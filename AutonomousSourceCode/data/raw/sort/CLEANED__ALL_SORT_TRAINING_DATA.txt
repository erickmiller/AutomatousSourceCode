import random


def getThird(*nums):
	after_sort = sorted(nums, reverse=True)
	print ('After sorting:', after_sort)
	return after_sort[2]

print (getThird(10, 5, 99, 1000, 22, 3, 2, 900, 1, 8))


import unittest


def sort(list):
    return sorted(list)


class Tester(unittest.TestCase):

    def setUp(self):
        self.x = 1

    def test_add(self):
        list = [5, 3, 1]
        list = sort(list)
        self.assertEqual(list[0], 1)


if __name__ == '__main__':
    unittest.main()


import random


def get_random_list(num=10):
    l = range(0, num)
    random.shuffle(l)
    return l


def is_sorted(l):
    for i in range(0, len(l) - 1):
        if l[i] > l[i + 1]:
            return False
    return True


def quick_sort(nums=[]):
    quick_sort.cnum = 0
    quick_sort.swaps = 0

    def swap(l, i, j):
        if i == j:
            return
        temp = l[i]
        l[i] = l[j]
        l[j] = temp
        quick_sort.swaps += 1

    def sublist_sort(nums, a, b):
        if a >= b:
            return
        pivot = nums[b]
        i = a
        j = b - 1
        while i <= j:
            while nums[i] < pivot:
                quick_sort.cnum += 1
                if i >= b:
                    break
                i += 1

            while nums[j] >= pivot:
                quick_sort.cnum += 1
                if j <= a:
                    break
                j -= 1
            if i < j:
                swap(nums, i, j)
                i += 1
                j -= 1
            else:
                break

        swap(nums, i, b)
        sublist_sort(nums, a, i - 1)
        sublist_sort(nums, i + 1, b)

    if len(nums) > 0:
        sublist_sort(nums, 0, len(nums) - 1)


def quick_sort2(nums=[]):
    if len(nums) == 0:
        return []
    else:
        return quick_sort2([x for x in nums[1:] if x < nums[0]]) + \
                           [nums[0]] + \
                               quick_sort2(
                                   [x for x in nums[1:] if x >= nums[0]])

if __name__ == '__main__':
    l = get_random_list(20)
    print l
    quick_sort(l)
    print l
    print "Sorted: % s,

"""
Created on Thu Jun 19 15:56:48 2014

@author: SBader
"""


def compose(f1, f2):
    return lambda *args, **kwargs: f1(f2(*args, **kwargs))


def float_sorted_items(dictionary):
    try:
        sorted_keys = sorted(dictionary.keys(), key=float)
    except:
        sorted_keys = dictionary.keys()
    sorted_values = [dictionary[key] for key in sorted_keys]
    return zip(sorted_keys, sorted_values)


def float_sorted(lst):
    try:
        print lst
        print "let's sort"
        print sorted(lst, key=float)
        return sorted(lst, key=float)
    except:
        return lst


def flatten_lol(lst):
    return [x for sublst in lst for x in sublst]
from lixian_plugins.api import task_filter


@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])


def value_sort(dict):
	return [dict[i] for i in sorted(dict.keys())]
print value_ + sort({'a': 1, 'b': 2, 'c': 3})
try:

    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:

    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
import re
import copy


def try_int_cast(value):
    """
    Attempts to cast value to an int. On failure, returns original value
    """
    try:
        return int(value)
    except:
        return value


def _natural_sort_key(value):
    """
    Used internally to get a tuple by which value is sorted.
    """
    return map(try_int_cast, re.findall(r'(\d+|\D+)', value))


def natural_sort_comparison(value1, value2):
    """
    Natural string comparison, case sensitive.
    """
    return cmp(_natural_sort_key(value1), _natural_sort_key(value2))


def natural_sort_case_insensitive_comparison(value1, value2):
    """
    Natural string comparison, ignores case.
    """
    return natural_sort_comparison(value1.lower(), value2.lower())


def natural_sort(sequence, comparison_callable=natural_sort_comparison):
    """
    In-place natural string sort.
    """
    sequence.sort(comparison_callable)


def natural_sorted(sequence, comparison_callable=natural_sort_comparison):
    """
    Returns a copy of seq, sorted by natural string sort.
    """
    temp = copy.copy(seq)
    natsort(temp, comparison_callable)
    return temp
from ds import arrays
import sys
from profile import profile


@profile
def sort(a):
    selection_sort(a, 0, len(a))


def selection_sort(a, start, length):
    for i in xrange(start + 1, start + length):
        key = a[i]
        j = i
        while(j > start and a[j - 1] > key):
            a[j] = a[j - 1]
            j -= 1
        a[j] = key


def main():
    a = arrays.make(sys.argv)
    sort(a)
    return a

if __name__ == "__main__":
    main()


def assert_sorted(a, from_index, length):
    selection_sort(a, from_index, length)
    for i in xrange(from_index, from_index + length - 1):
        assert a[i] <= a[i + 1]


def should_partially_sort():
    assert_sorted([30, 20, 10, 5, 3, 2, 4, 1, -4, -5], 3, 5)
    assert_sorted(arrays.array(50, False), 10, 20)


def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)


def counting_sort(A, k):
    C = [0] * k
    B = [None] * len(A)
    for a in A:
        C[a] += 1
    for i in range(1, len(C)):
        C[i] = C[i - 1] + C[i]
    for a in reversed(A):
        B[C[a] - 1] = a
        C[a] -= 1
    return B


if __name__ == "__main__":

    A = [2, 5, 3, 0, 2, 3, 0, 3]
    B = counting_sort(A, 6)
    print "Sorted %r" % B
from zope.viewlet.manager import ViewletManagerBase
from zope.traversing.browser import absoluteURL


class QreatureMenuVM(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)


class QreatureLeftSideBarVM(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)


class QreatureRightSideBarVM(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)
from lixian_plugins.api import task_filter


@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])


def swap(a, i, j):
    a[i], a[j] = a[j], a[i]


def insertionSort(a):
    l = len(a)
    for i in range(1, l):
        p = i
        while a[p - 1] > a[p] and p > 0:
            swap(a, p, p - 1)
            p -= 1
    return a

a = insertionSort([4, 78, 123, 87, 132, 5, 7, 1, 3, 8, 2, 8, 4, 1, 248])
print a
print "Sorted?: " + str(a == sorted(a))


def sorted_string(stringToSort):

    sortedList = list(stringToSort)
    sortedList.sort()

    result = ''.join(sortedList)

    return result

if __name__ == '__main__':

    string1 = 'hello'
    string2 = 'teststring'

    print sorted_string(string1)
    print sorted_string(string2)


def sort_ab(a, b):
    """Given already-sorted lists, `a` and `b`, return sorted list of both.

    You may not use sorted() or .sort().

    Check edge cases of empty lists:

        >>> sort_ab([], [])
        []

        >>> sort_ab([1, 2,3], [])
        [1, 2, 3]

        >>> sort_ab([], [1, 2, 3])
        [1, 2, 3]

    Check:

        >>> sort_ab([1, 3, 5, 7], [2, 6, 8, 10])
        [1, 2, 3, 5, 6, 7, 8, 10]
    """

    c = []

    while len(a) > 0 and len(b) > 0:
        if a[0] < b[0]:
            c.append(a[0])
            a.pop(0)
        else:
            c.append(b[0])
            b.pop(0)

    if len(a) > 0:
        c += a
    else:
        c += b

    return c


if __name__ == '__main__':
    import doctest
    if doctest.testmod().failed == 0:
        print "\n*** ALL TESTS PASSED. YOU'RE A MERGE CHAMPION!!\n"
try:

    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:

    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l


def sort_asc(str_):
    return int(''.join(sorted(list(str_), reverse=True)))
print(sort_asc('4721'))


def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict


def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k


def solution(A):
    len_a = len(A)
    if len_a < 3:
        return 0

    sort_a = sorted(A)
    for ind in xrange(0, len_a - 2):
        if (sort_a[ind] + sort_a[ind + 1]) > sort_a[ind + 2]:
            return 1
    return 0


def sort(arr):
    for idx in range(1, len(arr)):
        insert(arr, idx, arr[idx])
    return arr


def insert(arr, pos, val):
    i = pos - 1
    while i >= 0 and arr[i] > val:
        arr[i + 1] = arr[i]
        i = i - 1
    arr[i + 1] = val

if __name__ == '__main__':
    test_set = [7, 6, 2, 5, 4, 6, 1, 3, 10, 50, 3]
    print 'Sorting: {0}'.format(test_set)
    sorted_set = sort(test_set)
    print 'Sorted: {0}'.format(sorted_set)


def sorting_test_0():
    print "**** SORTING TEST 0 ****"
    numbers = [2, 1, 3, 4, -1]
    print "numbers before sort:\t\t", numbers
    sorted_numbers = sorted(numbers)
    print "sorted_ numbers:    \t\t", sorted_numbers
    print "numbers after sort:\t\t", numbers
    print


def sorting_test_0a():
    print "**** SORTING TEST 0a ****"
    numbers = [2, 1, 3, 4, -1];
    print "numbers before sort:\t\t", numbers
    numbers.sort();

    print "numbers after sort:\t\t", numbers
    print


def sorting_test_1():
    print "**** SORTING TEST 1 ****"
    numbers = [11, 2, 1, 22, 3, 4, -1]
    print "numbers before sort:\t\t", numbers
    numbers.sort();

    print "numbers after sort:\t\t", numbers
    print


def sorting_test_2():
    print "**** SORTING TEST 2 ****"
    str_numbers = ['2', '1', '3', '4', '-1']
    print "str_numbers before sort:\t\t", str_numbers
    sorted_str_numbers = sorted(str_numbers)
    print "sorted_str_numbers:     \t\t", sorted_str_numbers
    print "str_numbers after sort: \t\t", str_numbers
    print


def sorting_test_3():
    print "**** SORTING TEST 3 ****"
    str_numbers = ['11', '2', '1', '22', '3', '4', '-1']
    print "str_numbers before sort:\t\t", str_numbers
    sorted_str_numbers = sorted(str_numbers)
    print "sorted_str_numbers:     \t\t", sorted_str_numbers
    print "str_numbers after sort: \t\t", str_numbers
    print

sorting_test_0();
sorting_test_0a();
sorting_test_1();
sorting_test_2();
sorting_test_3();


from __future__ import unicode_literals
import pytest
from structures.radix_sort import radix_sort


@pytest.fixture
def sorted_list():
    return [i for i in xrange(10)]


@pytest.fixture
def equal_values_list():
    return [5, 9, 4, 2, 5, 0, 5, 2, 6, 4]


@pytest.fixture
def random_list():
    return [5, 9, 2, 4, 1, 6, 8, 7, 0, 3]


def test_sorted(sorted_list):
    radix_sort(sorted_list)
    assert sorted_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_average(random_list):
    radix_sort(random_list)
    assert random_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_equal_values(equal_values_list):
    radix_sort(equal_values_list)
    assert equal_values_list == [0, 2, 2, 4, 4, 5, 5, 5, 6, 9]

import operator


def sort_dict(data, reverse=False):
    if type(data) != dict:
        print 'Can only sort dicts'
        return data
    data_sorted = sorted(
    data.items(),
    key=operator.itemgetter(1),
     reverse=reverse)
    return data_sorted


def sort(dictList):

  return sorted(dictList, key=lambda x: -x['count'])def bubble_sort(l):
  is_sorted = False

  counter = 0
  while is_sorted == False:
    is_sorted = True

    for i in range(len(l) - 1):
      num1, num2 = l[i], l[i + 1]
      if num1 > num2:
        is_sorted = False
        l[i], l[i + 1] = num2, num1
  return l

print bubble_sort([6, 5, 3, 1, 8, 7, 2, 4])import operator


def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))


def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))


def bubble_sort(l):
    """
    Bubble Sort
    -----------
    Advantages:
        - stable
        - in-place
    Disadvantages:
        - slow for large data sets
    Time Complexity:
        - worst:   O(n^2)
        - average: O(n^2)
        - best:    O(n)
    Space Complexity:
        - O(1)
    """
    temp = l[:]
    size = len(temp)
    sorted_list = False;
    while not sorted_list:
        modified = False;
        for i in range(1, size):
            if temp[i - 1] > temp[i]:
                modified = True;
                temp[i], temp[i - 1] = temp[i - 1], temp[i]
        if not modified:
            sorted_list = True
    return temp

if __name__ == '__main__':

    help(bubble_sort)
    l = list(range(10, 0, -1))
    print('Unsorted list: ' + str(l));
    l = bubble_sort(l)
    print('Sorted list: ' + str(l))


def insertion_sort(input_list):
    if type(input_list) != 'list':
        input_list = list(input_list)

    sorted_list = []

    sorted_list.append(input_list[0])

    for item in input_list[1:]:

        if item >= sorted_list[-1]:
            sorted_list.append(item)

        else:
            for i in range(len(sorted_list)):
                if item < sorted_list[i]:
                    sorted_list.insert(i, item)
                    i += 1
                    break

    return sorted_list

l = [4, 5, 6, 19, 11, 2, 3]

s = ['cat', 'dog', 'bunny', 'apple']

t = (1, 5, 3, 2)

print insertion_sort(l)
print insertion_sort(s)
print insertion_sort(t)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict


def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k


def itemgetter(i):
    def getter(x): return x[i]
    return getter


def sorted(seq, key):
    aux = [(key(x), i, x) for i, x in enumerate(seq)]
    aux.sort()
    return [x for k, i, x in aux]


def sortNumber(n):
    list1 = []
    for i in xrange(len(str(n))):
        list1.append(str(n)[i])
    list1.sort()
    return "".join(list1)


def insert(n):
    sortedKey = sortNumber(n ** 3)
    if sortedKey in permDict:
        permDict[sortedKey].append(n)
    else:
        permDict[sortedKey] = [n]


def main():
    isFound = False
    counter = 1
    while not isFound:
        insert(counter)
        if len(permDict[sortNumber(counter ** 3)]) == 5:
            isFound = permDict[sortNumber(counter ** 3)][0] ** 3
        else:
            counter += 1
    print isFound

permDict = {}
main()
import unittest


def selection_sort(array):
    sorted_array, length = array[::], len(array)

    for i in range(length):
        min_idx = i
        for j in range(min_idx, length):
            if sorted_array[j] < sorted_array[min_idx]:
                min_idx = j
        sorted_array[i], sorted_array[
            min_idx] = sorted_array[min_idx], sorted_array[i]

    return sorted_array


class TestSelectionSort(unittest.TestCase):

    def test_selection_sort(self):
        self.assertEqual(range(1, 8), selection_sort([1, 2, 3, 4, 5, 6, 7]))
        self.assertEqual(range(1, 8), selection_sort([5, 1, 6, 3, 4, 2, 7]))
        self.assertEqual(range(1, 8), selection_sort([7, 6, 5, 4, 3, 2, 1]))
        self.assertEqual([], selection_sort([]))
        self.assertEqual([10], selection_sort([10]))

if __name__ == "__main__":
    unittest.main()_funcName = None
import random
from . import sort


def testAll():
	global _funcName
	funcArr = [_testMergeSort, _testMergeSortLarge]
	for i, func in enumerate(funcArr):
		for j in range(10):
			succ = func()
			_funcName = func.__name__
			_print("test " + str(j + 1) + " start")
			if succ:
				_print("test " + str(j + 1) + " pass")
			else:
				_print("test " + str(j + 1) + " failed")


def _testMergeSort():
	ar = [random.randint(-100, 100) for x in range(random.randint(1, 50))]
	_print(ar)
	arSorted = sort.mergeSort(ar[:])
	_print(arSorted)
	if arSorted == sorted(ar):
		return True
	else:
		return False


def _testMergeSortLarge():
	ar = [random.randint(-100, 100) for x in range(100000)]
	arSorted = sort.mergeSort(ar[:])
	if arSorted == sorted(ar):
		return True
	else:
		return False


def _print(msg):
	print(_funcName, end=": ")
	print(msg)

def insertion_sort_desc(A):
    n = len(A)
    for j in range(1, n):
        key = A[j]

        i = j - 1
        while (i >= 0) and (key > A[i]):
            A[i+1] = A[i]
            i = i - 1
        A[i+1] = key

    return Adef setify(items):
    result = []
    for item in items:
        if item not in result:
            result.append(item)
    return result

def second_largest(numbers):
    result = 0
    sorted_numbers = sorted(numbers)
    unique_sort_numbers = setify(sorted_numbers)
    pre_last_index = len(unique_sort_numbers) -2
    if len(unique_sort_numbers) < 2:
        return False
    result = unique_sort_numbers[pre_last_index]
    return result
a = [1,3,5,6,7,6,2,1,200, 800, 13]
b = [4,4]
c = [10,10,10,10,9]
print(second_largest(a))
print(second_largest(b))
print(second_largest(c))
def f(x):
 if len(x)==1: return x;
 for a in range(2,len(x)+1):
  i = a-1
  key = x[i]
  while i>0 and x[i-1] > key:
   x[i] = x[i-1]
   i-=1
  x[i] = key

 return x;
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)
def sort(a):
	dic={}
	l=[]
	for i in a:
		dic[''.join(sorted(i))].append(i)
	return sorted(dic.values())
def main():
	a=["nithin","jithin","athul","thaul"]
	print sort(a)
if __name__ == '__main__':
	main()
import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))


def quickSort(toSort):
	"""Default quick sort"""
	if len(toSort) <= 1:
		return toSort

	end = len(toSort) - 1
	pivot = toSort[end]

	low = []
	high = []

	for num in toSort[:end]:
		if num <= pivot:
			low.append(num)
		else:
			high.append(num)

	sortedList = quickSort(low)
	sortedList.append(pivot)
	sortedList.extend(quickSort(high))

	return sortedList

def main():
	array = [1, 6, 7, 2, 76, 45, 23, 4, 8, 12, 11]
	sortedList = quickSort(array)
	print sortedList

if __name__ == '__main__':
    main()



import datetime

def sort_list_into_keys(objects, copy_attr, sort_attr):
    """Sorts a given list of objects. Then creates a new list, which contains
    only a given attribute of each object.

    Arguments:
    copy_attr -- The attribute of each object to copy into the new list.
    sort_attr -- The attribute of each object to sort the list by.
    """
    sorted_list = sorted(objects, key = lambda x : getattr(x, sort_attr),
            reverse=True)
    sorted_keys = [ getattr(x, copy_attr) for x in sorted_list ]
    return sorted_keys

def timestamp():
    """Returns the current unix timestamp.
    """
    return datetime.datetime.now().timestamp()
def front_x(words):
    x_list =[]
    non_x_list = []
    sorted_list = []
    for str in words:
        if str[0].lower().startswith("x"):
            x_list.append(str)
        else:
            non_x_list.append(str)
    print x_list,
    print non_x_list
    print type(x_list)

    print sorted(x_list)
    print type(sorted(x_list))

    sorted_list = sorted(x_list)+sorted(non_x_list)


    return sorted_list








def sort_last(tuples):

    sort_by = []
    for item in tuples:
        sort_by.append(item[-1])
    sorted_index = sorted(sort_by)

    print sorted_index
    return sorted_index
import pytest
from random import randint, shuffle

from radix_sort import radix_sort

_RANGE = 100


@pytest.fixture
def make_random():
    return [randint(0, 100) for x in range(_RANGE)]


@pytest.fixture
def make_in_order():
    return [x for x in range(_RANGE)]


@pytest.fixture
def make_in_order_reverse():
    return [x for x in range(_RANGE)][::-1]


def test_radix_sort_random(make_random):
    to_sort = make_random
    assert to_sort != sorted(to_sort)
    assert radix_sort(to_sort) == sorted(to_sort)


def test_radix_sort_in_order(make_in_order):
    to_sort = make_in_order
    assert to_sort == sorted(to_sort)
    assert radix_sort(to_sort) == sorted(to_sort)


def test_radix_sort_reverse(make_in_order_reverse):
    to_sort = make_in_order_reverse
    assert to_sort != sorted(to_sort)
    assert to_sort == sorted(to_sort, reverse=True)
    assert radix_sort(to_sort) == sorted(to_sort)


def test_radix_sort_zero():
    to_sort = []
    assert radix_sort(to_sort) == []


def test_radix_sort_one():
    to_sort = [1]
    assert radix_sort(to_sort) == [1]


def test_radix_sort_small():
    to_sort = [1, 3, 2, 4, 5, 9, 8, 7, 6, 10]
    assert radix_sort(to_sort) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


def test_single_long_int_in_list():
    to_sort = [x for x in range(1000)] + [999999999999999999]
    shuffle(to_sort)
    assert to_sort != sorted(to_sort)
    assert radix_sort(to_sort) == sorted(to_sort)
from datetime import datetime
from itertools import groupby

def monthly(changeset):
    date = datetime.fromtimestamp(changeset.date()[0])
    return '%4d-%02d' % (date.year, date.month)

def group_by_month(changesets):
    sort = sorted(changesets, key=monthly)
    return groupby(sort, monthly)
import numpy as np
import random
R = random.sample(range(0,100000), 100000)
random.R = random.choice(R)


def sortwithloops():
    sortedInput = list(R)
    swap = True
    while(swap == True):
        swap = False
        for i in range(len(sortedInput)-1):
            if sortedInput[i] > sortedInput[i+1]:
                swap = True
                temp = sortedInput[i]
                sortedInput[i] = sortedInput[i+1]
                sortedInput[i+1] = temp
    return sortedInput


def numpySort():
    newR = list(R)
    return np.sort(newR)


def sortwithoutloops():
    newR2 = list(R)
    newR2.sort()
    return newR2


def searchwithloops():
    for i in range(len(R)):
        if random.R == R[i]:
            return True
    return False


def searchwithoutloops():
    return random.R in R



def numpySearch():
    return random.R in np.array(R)

'''
if you look at my results you see my numpy search is pretty significantly slower than my search without loops.
what would cause that?
'''



if __name__ == "__main__":
    import timeit as ti
    print "Using 100 iterations for each\n\n"

    print "Sort without loops: " + str(ti.timeit("sortwithoutloops()", setup="from __main__ import sortwithoutloops", number=100))
    print "Sort with numpy: " + str(ti.timeit("numpySort()", "from __main__ import numpySort", number=100))
    print "Search with loops: " + str(ti.timeit("searchwithloops()", setup="from __main__ import searchwithloops", number=100))
    print "Search without loops: " + str(ti.timeit("searchwithoutloops()", setup="from __main__ import searchwithoutloops", number=100))
    print "Search with numpy: " + str(ti.timeit("numpySearch()", setup="from __main__ import numpySearch", number=100))
class Solution:

    def twoSum(self, num, target):
        numSorted=[item for item in num]
        numSorted.sort()
        length=len(numSorted)
        left=0
        right=length-1
        while left<right:
            if numSorted[left]+numSorted[right]<target:
                left+=1
            elif numSorted[left]+numSorted[right]>target:
                right-=1
            else:
                break
        i=0
        j=0
        for i in range(length):
            if num[i]!=numSorted[left]:
                i+=1
            else:
                break
        for j in range(length):
            if num[j]!=numSorted[right]:
                j+=1
            elif j==i:
                continue
            else:
                break
        if i>j:
            return (j+1,i+1)
        return (i+1,j+1)

a=Solution()
b=a.twoSum([1,6,5,3,4],9)
print(b)









class Solution:


    def insertionSortList(self, head):
        if not head:
            return head
        dummy = ListNode(0)
        dummy.next = head
        lastSorted = head
        while lastSorted.next:
            if lastSorted.next.val < lastSorted.val:
                tmp = dummy
                while tmp.next.val < lastSorted.next.val:
                    tmp = tmp.next
                nextToSort = lastSorted.next
                lastSorted.next = nextToSort.next
                nextToSort.next = tmp.next
                tmp.next = nextToSort
            else:
                lastSorted = lastSorted.next
        return dummy.nextdef insertion_sort(list_to_sort):
    sorted_list = []
    unsorted_list = list_to_sort[:]
    while len(unsorted_list) > 0:
        selected = unsorted_list.pop()
        inserted = False
        if sorted_list == []:
            sorted_list.append(selected)
        else:
            for i in range(len(sorted_list)):
                if sorted_list[i] > selected:
                    sorted_list.insert(i, selected)
                    inserted = True
                    break
            if not inserted:
                sorted_list.append(selected)
    return sorted_list

if __name__ == '__main__':

    print insertion_sort([1, 2, 3, 4, 5, 6, 7, 8, 9])

    print insertion_sort([9, 8, 7, 6, 5, 4, 3, 2, 1])


import unittest


def bubble_sort(array):
    l = len(array)
    for i in xrange(l):
        sorted = False
        location = l
        for j in xrange(1, location - i):
            if array[j - 1] > array[j]:
                array[j - 1], array[j] = array[j], array[j - 1]
                sorted = True
                location = j
        if not sorted:
            break
    return array


class BubbleCase(unittest.TestCase):
    def setUp(self):
        pass

    def teatDown(self):
        pass

    def test_bubble(self):
        empty_array = []
        self.assertEqual(bubble_sort(empty_array), [])

        unsorted_array = [5, 1, 3, 6, 7]
        self.assertEqual(bubble_sort(unsorted_array), [1, 3, 5, 6, 7])

        unsorted_negative_array = [-5, 0, 6, -7]
        self.assertEqual(bubble_sort(unsorted_negative_array), [-7, -5, 0, 6])

        sorted_array = [1, 3, 5, 6, 7]
        self.assertEqual(bubble_sort(sorted_array), [1, 3, 5, 6, 7])

if __name__ == '__main__':
    unittest.main()
def sortStack(stack):
    sortedStack = []
    while stack:
        s = stack.pop()
        while sortedStack and s < sortedStack[-1]:
            stack.append(sortedStack.pop())
        sortedStack.append(s)
    return sortedStackdef break_words(stuff):
    """This function will break up words for us."""
    words = stuff.split()
    return words

def sort_words(words):
    """Sorts the words"""
    return sorted(words)

def print_first_word(words):
    word = words.pop(0)
    print word

def print_last_word(words):
    word = words.pop(-1)
    print word

def sort_sentence(sentence):
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)

def print_first_and_last_sorted(sentence):
    sorted_words = sort_sentence(sentence)
    print_first_word(sorted_words)
    print_last_word(sorted_words)
    __author__ = 'Lucian'
from const import values


def sort_high_to_low(shuffle_cards):
    sort_cards = []
    for value in values:
        for i, card in enumerate(shuffle_cards):
            if card[0] == value:
                sort_cards.append(shuffle_cards[i])
    return sort_cards


def type_color(card):
        return card[1]


def sort_by_color(shuffle_cards):
    sort_cards = sorted(shuffle_cards, key=type_color)
    return sort_cardsdef turboSort():
    inputValue = int(raw_input())
    sortedList = []
    for each in range(inputValue):
        number =  int(raw_input())
        lastIndex = len(sortedList) - 1
        if(lastIndex == -1 or (sortedList[lastIndex] <= number)):
            sortedList.append(number)
        elif(sortedList[0]>=number) :
            sortedList.insert(0,number)
        else:
            addToList(number,sortedList)
        print sortedList
    for each in sortedList:
        print each
def addToList(number,sortedList):
    print "add to list start"
    lower = 0
    higher = len(sortedList) - 1
    while(lower!=higher):
        mid = 0
        if((lower + higher)% 2 == 0 ):
            mid = (lower + higher)/2
        else:
            mid = (lower + higher)/2 + 1
        print lower, higher, mid
        if(sortedList[mid] == number):
            sortedList.insert(mid,number)
            return
        elif(sortedList[mid] < number):
            lower = mid+1
        else:
            higher = mid - 1
    print "while ends"
    print lower, higher
    sortedList.insert(higher,number)

turboSort()


class Playlist():


    @staticmethod
    def sort_by_filename(playlist):
        return sorted(playlist)


    @staticmethod
    def sort_by_title(playlist):
        return sorted(playlist, key=lambda tup: tup[1])


    @staticmethod
    def sort_by_genre(playlist):
        return sorted(playlist, key=lambda tup: tup[1])


    @staticmethod
    def sort_by_artist(playlist):
        return sorted(playlist, key=lambda tup: tup[1])


    @staticmethod
    def sort_by_year(playlist):
        try:
            return sorted(playlist, key=lambda tup: tup[1])
        except:
            return playlist




def valuesort(d):
	return [d[x] for x in sorted(d.keys())]

print valuesort({'x': 1, 'y': 2, 'a': 3})
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])


from operator import itemgetter

class Sorter(object):
	@staticmethod
	def sort_by_year(moviedata):
		sortedlist = sorted(moviedata, key=itemgetter('Year'))
		return sortedlist

import timeit

LIST     = [834, 29, 99, 473, 128, 43, 555, 3243, 666, 12, 0, 3223, 5533, 3214, 987, 4325, 87, 324, 45324, 980, 2343, 92, 23, 45, 433]
NB_ITERS = 500000



def withSort():
    l = [i for i in LIST]
    l.sort()
    return l




def withSorted():
    l = [i for i in LIST]
    return sorted(l)



t1 = timeit.Timer('withSort()',   'from __main__ import withSort')
t2 = timeit.Timer('withSorted()', 'from __main__ import withSorted')

print
print 'Sorting a list'
print ' * with an inplace sort() :', t1.timeit(NB_ITERS)
print ' * with a call to sorted():', t2.timeit(NB_ITERS)
__author__ = 'dihnatsyeu'

def bublesort (ListToSort):

    lenght = len(ListToSort)
    sorted = False
    for j in range(0, lenght-1):
        for i in range(0, lenght-j-1):
            if ListToSort[i] > ListToSort[i+1]:
               temp = ListToSort[i]
               ListToSort[i] = ListToSort[i+1]
               ListToSort[i+1] = temp
               sorted = True
            if sorted == False: break

    return ListToSort

print bublesort([24,1,34,3,72,5,21])def break_words(stuff) :
	""" This function will break up words for us. """
	words = stuff.split(' ')
	return words

def sort_words(words) :
	""" Sort the words """
	return sorted(words)

def print_first_word(words) :
	""" Prints the first word after popping it off. """
	word = words.pop(0)
	print(word)

def print_last_word(words) :
	word = words.pop(-1)
	print(word)

def sort_sentence(sentence) :
	""" Takes in a full sentence and returns the sorted words """
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)
def bubble_sort(nums):
	size = len(nums)
	for i in range(0,size-1):
		for j in range(0,size-i-1):
			if(nums[j] > nums[j+1]):
 				temp = nums[j]
				nums[j]=nums[j+1]
				nums[j+1]=temp
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = bubble_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)





def is_sorted(t):
	orig = t[:]
	t.sort()
	if t == orig:
		return True
	else:
		return False

t = [5,1,3,9]
print "Initial List : ",
print t

case = is_sorted(t)

if case == True:
	print "Yeah..!! That list is Sorted "
else:
	print "It's not sorted"
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)
import sort
import unittest
import random

class SortTestFunctions(unittest.TestCase):
    def setUp(self):
        self.ranges = [
            [],
            [1],
            [3, 2, 5, 2, 3, 7, 4, 7],
            [1, 1, 1, 1],
            [1, 1, 1, 2],
            [2, 1, 1, 1],
            [1, 2, 1, 2],
            [4, 3, 2, 1],
            [i for i in random.sample(xrange(0, 1000000000), 1000)],
            [1 for i in xrange(0, 1000)],
            [1 if i < 900 else 2 for i in xrange(0, 1000)],
            [2 if i < 100 else 1 for i in xrange(0, 1000)],
            [i if 1 < 50 else 2 for i in xrange(0, 100)] * 10,
            [i for i in xrange(1000, 0, -1)]
        ]

    def _isSorted(self, sequence):
        prev = None
        for item in sequence:
            if item < prev:
                return False
            prev = item
        return True

    @staticmethod
    def compareTupples(a, b):
        if a[0] == b[0]:
            return 0
        return -1 if a[0] < b[0] else 1

    def _test_sort(self, sort_func_name, *args):
        sort_func = getattr(sort, sort_func_name)
        for range in self.ranges:
            sort_func(range, None, *args)
            self.assertTrue(self._isSorted(range))
        self.assertRaises(TypeError, sort_func, (1, 2, 3), None, *args)
        self.assertRaises(TypeError, sort_func, 'hello', None, *args)
        self.assertRaises(TypeError, sort_func, [1, 2, 3], 'some_func', *args)


        sorted_ranges = [
            [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5)],
            [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)],
        ]
        for sorted_range in sorted_ranges:
            sort_func(sorted_range, self.compareTupples, *args)
            for i in xrange(len(sorted_range)):
                self.assertTrue(i == sorted_range[i][1])

    def test_bubble_sort(self):
        self._test_sort('bubble_sort')

    def test_selection_sort(self):
        self._test_sort('selection_sort')

    def test_coctail_sort(self):
        self._test_sort('coctail_sort')

    def test_insertion_sort(self):
        self._test_sort('insertion_sort')

    def test_shell_sort(self):
        self._test_sort('shell_sort')

    def test_shell_sort_shell_gap(self):
        self._test_sort('shell_sort', 'shell')

    def test_shell_sort_cuira_gap(self):
        self._test_sort('shell_sort', 'cuira')

    def test_comb_sort(self):
        self._test_sort('comb_sort')

    def test_merge_sort(self):
        self._test_sort('merge_sort')

    def test__get_sorted_sequences(self):
        ranges = (
            [],
            [1],
            [3, 2, 5, 2, 3, 7, 4, 7],
            [1, 1, 1, 1],
            [1, 1, 1, 2],
            [2, 1, 1, 1],
            [1, 2, 1, 2],
            [4, 3, 2, 1]
        )
        results = (
            [],
            [(0, 0)],
            [(0, 0), (1, 2), (3, 5), (6, 7)],
            [(0, 3)],
            [(0, 3)],
            [(0, 0), (1, 3)],
            [(0, 1), (2, 3)],
            [(0, 0), (1, 1), (2, 2), (3, 3)]
        )
        for i in xrange(0, len(ranges)):
            result = []
            for seq in sort._get_sorted_sequences(ranges[i], sort.compare):
                result.append(seq)
            self.assertEqual(result, results[i])
            self.assertRaises(TypeError, lambda: sort._get_sorted_sequences('hello', sort.compare).next())

    def test__merge(self):
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 2), (4, 5), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 3), (4, 6), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (-1, 3), (4, 5), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 0), (0, 0), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [], (0, 3), (4, 6), sort.compare)
        self.assertRaises(ValueError, sort._merge, [], [] * 6, (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, 'hello', [], (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], 'hello', (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], [], 'hello', (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], [], (0, 3), 'hello', sort.compare)
        self.assertRaises(TypeError, sort._merge, [0, 1], [None] * 2, (0, 0), (1, 1), 'hello')

        result = [None] * 7;
        sort._merge([0, 3, 4, 5, 1, 2, 6], result, (1, 3), (4, 5), sort.compare)
        self.assertEqual(result, [None, 1, 2, 3, 4, 5, None])

if __name__ == '__main__':
    unittest.main()
def bubble_sort(list):
	length = len(list) - 1
	sorted = False
	while not sorted:
		sorted = True
		for i in range(length):
			if list[i] > list[i+1]:
				(list[i], list[i+1]) = (list[i+1], list[i])

				sorted = False
		length -= 1
	return list

unsorted = [6, 5, 3, 1, 8, 7, 2, 4]
print bubble_sort(unsorted)

import random

def createList(length):
    l = []
    i = 0
    while length > i:
        l.append(random.randint(0,length))
        i +=1
    return l



def isSorted(l):
    i = 1
    while i < len(l):
        if l[i - 1] > l[i]:
            return False
        i += 1
    return True

a = [3,2,1]
b = [1,2,3]






def bubble(l):
    check = len(l) - 1
    while (check > 0):
        i = 0
        while i < check:
            if l[i] > l[i + 1]:
                l[i], l[i + 1] = l[i + 1], l[i]
            i += 1

        check -= 1
    return l

pre = createList(10)
print pre
post = bubble(pre)
print post
print isSorted(post)
a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))



class SelectionSort:
    """Implementation class for Selection sort."""

    @staticmethod
    def selectionSort( listToSort ):
        """Implementation of the algorithm.

        @param  listToSort  The list to sort.
        @return The sorted list
        """
        res = []
        ok = True
        while ok:
            if listToSort:
                minimum = min(listToSort)
                res.append( minimum )
                listToSort.remove( minimum )
            else:
                ok = False
        return res


def main():
    """Main-method, does testing."""
    import random
    l = []
    for i in range(20):
        l.append( random.randint( 0, 100))

    print( "List of random values: " + str(l) )
    print( "
    res = SelectionSort.selectionSort( l )
    print( "Sorted list: " + str(res) )


if __name__ == "__main__":
    main()

import numpy as np
from numba import jit
@jit
def bootstrap(data, num_samples, statistics):
  data_size = len(data)
  values = []
  for i in range(num_samples):
    values.append(statistics(data[np.random.randint(0, data_size,  data_size)]))
  return values

def interval(bootstrap_data, alfa):
    sorted_values = np.array(bootstrap_data)
    sorted_values.sort()
    return (sorted_values[alfa/2.0*len(sorted_values)],
            sorted_values[(1.0 - alfa/2.0)*len(sorted_values)])
import unittest

def insertion_sort(array):
    for i in range(1, len(array)):
        current = i
        while array[current] < array[current - 1] and current > 0:
            array[current], array[current - 1] = array[current - 1], array[current]
            current -= 1
    return array

class TestInsertionSort(unittest.TestCase):

    def test_empty_array(self):
        self.assertEqual(insertion_sort([]), [])

    def test_integers(self):
        self.assertEqual(insertion_sort([4, 7, 1, 8, 4, 2, 7, 2, 1, 0]), sorted([4, 7, 1, 8, 4, 2, 7, 2, 1, 0]))

    def test_strings(self):
        self.assertEqual(insertion_sort(['zebra', 'penguin', 'aardvark', 'basilisk']), sorted(['zebra', 'penguin', 'aardvark', 'basilisk']))

if __name__ == '__main__':
    unittest.main()
"""
David Schonberger
Hackerrank.com
Search - Lonely Integer
1/13/2015
"""

def mergeSort(lst, c):
    if len(lst) < 2:
        return lst
    m = len(lst) / 2
    return merge(mergeSort(lst[:m], c), mergeSort(lst[m:], c), c)

def merge(l, r, c):
    res = []
    while(l and r):
        if(l[0] <= r[0]):
            s = l
        else:
            s = r
        res.append(s.pop(0))
        if(s == r and not s == l):
            c[0] += len(l)

    res.extend(l if l else r)
    return res


N = input()
ar = raw_input()
ar = ar.split(' ')
ar = [int(t) for t in ar]

if(len(ar) == 1):
    print ar[0]
else:
    count = [0]
    ar_sorted = mergeSort(ar, count)
    found = False
    i = 0
    while(not found and i < len(ar_sorted) - 1):
        if(ar_sorted[i] != ar_sorted[i+1]):
            found = True
            res = ar_sorted[i]
        i += 2
    if(i == len(ar_sorted) - 1):
        res = ar_sorted[i]
    print res
"""
This module implements the bubble sort algorithim
"""



def bubble_sort(arr):
    """
    Perform a bubble sort on a given list. Return the sorted list.
    Example:

    >>> bubble_sort([1, 5, 7, 2, 3, 4, 1])
    [1, 1, 2, 3, 4, 5, 7]
    >>> bubble_sort(['a', 'd', 'b', 'c'])
    ['a', 'b', 'c', 'd']
    """
    pass
def sort_last(tuples):
	b = sorted(tuples, key = lambda x:x[-1])
	return b


print sort_last([(1, 3), (1, 7), (2, 2), (3, 4, 5)])



"""
Write a program to sort a stack in ascending order (with biggest item on top). You may use additional stacks to hold items, but you may not copy  the elements into
any other data structure (like array). The stack support the following operations push, pop, peek and is_empty.

"""


def sort_stack(stack):

    def peek(stack): return stack[-1]

    sorted_stack = []

    while stack:
        number = stack.pop()

        if stack and number > peek(stack):
            sorted_stack.append(number)
        else:
            while sorted_stack and peek(sorted_stack) > number:
                stack.append(sorted_stack.pop())

            sorted_stack.append(number)

    return sorted_stack


print(sort_stack([7, 73, 65, 23, 8, 77, 1, 24]))


def sort(A):


    def insert(A, num):
        if not A:
            A.append(num)
        else:
            if num < A[-1]:
                last_popped = A.pop()
                insert(A, num)
                insert(A, last_popped)
            else:
                A.append(num)

        return A

    if not A: return A

    num = A.pop()
    sort(A)
    insert(A, num)

    return A




A = [1,2,3,6,5,4]

print(sort(A))



class School(object):

	def __init__(self, schoolname):
		self._db = {}
		self.schoolname = schoolname

	def add(self, name, grade):
		if grade not in self._db.keys():
			self._db[grade] = set([name])
		else:
			self._db[grade].add(name)

	def grade(self, grade):
                if grade not in self._db:
                        return set()
		return self._db[grade]

	def sort(self):
		sorted_school = {}
		for grade in self._db:
			sorted_school[grade] = tuple(sorted(self._db[grade]))
		return sorted_school

	@property
	def db(self):
		return self._db

def is_increasing(seq):

	sort = sorted(seq)
	if seq == sort:
		return True
	else:
		return False

print is_increasing([1,2,3,4,5])
print is_increasing([5,6,-10])
import collections

def sort_fractions(fractions):
	numbers = {}
	result = []

	for fraction in fractions:
		numbers[fraction] = fraction[0] / fraction[1]
	result = sorted(numbers, key=lambda key: numbers[key])
	return result

try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
def insertion_sort(L):
	"""Returns a Sorted List.
	Usage:
	>>>insertion_sort([6,8,1,8,3])
	>>>[1, 3, 6, 8, 8]
	"""
	n = len(L)
	for j in range(1,n):
		 i = 0
		 while L[j] > L[i]:
		 	i += 1
		 m = L[j]
		 for k in range(0,j-i):
		 	L[j-k] = L[j-k-1]
		 L[i] = m
	return L

print insertion_sort([6,8,1,8,3])
def sort_array(value):
    return ''.join(sorted(value, key=lambda a: int(a)))

assert sort_array('12345') == '12345'
assert sort_array('54321') == '12345'
assert sort_array('34251') == '12345'
__author__ = 'Aristide'

def main():
    list_to_sort = raw_input("Enter the numbers to sort, e.g: 53784298 : ")
    print sort(map(lambda char: int(char)), list(list_to_sort))


def sort(unsorted_list):
    """
    sort splits any list with more than one element in two parts, calls itself on the sublists,
    and calls merge with the returned sorted lists. When the parameter is an empty list or a
    single element list, sort just returns the list as the output.

    Doctests:
    Test empty list
        >>> sort([])
        []

    Test single element list
        >>> sort([3])
        [3]

    Test all even length sublists list
        >>> sort([9,3,6,7,5,4,3,2])
        [2, 3, 3, 4, 5, 6, 7, 9]

    Test odd length list
        >>> sort([9,3,6,8,7,5,4,3,2])
        [2, 3, 3, 4, 5, 6, 7, 8, 9]

    """
    output = []

    if len(unsorted_list) <= 1:
        output = unsorted_list
    else:


        left_sorted_list = sort(unsorted_list[0:(len(unsorted_list)/2)])
        right_sorted_list = sort(unsorted_list[(len(unsorted_list)/2):])

        output = merge(left_sorted_list, right_sorted_list)

    return output


def merge(left_sorted_list, right_sorted_list):
    """
    merge traverses each sorted list comparing the front elements. The smaller of the two is the next element in the
    sorted merged list
    """
    merged_sorted_list = [None] * (len(left_sorted_list) + len(right_sorted_list))

    iLeft = 0
    iRight= 0

    iMerged = 0

    while iMerged < len(merged_sorted_list):
        if iLeft == len(left_sorted_list):
            merged_sorted_list[iMerged:] = right_sorted_list[iRight:]
            iMerged = len(merged_sorted_list)
        elif iRight == len(right_sorted_list):
            merged_sorted_list[iMerged:] = left_sorted_list[iLeft:]
            iMerged = len(merged_sorted_list)
        elif left_sorted_list[iLeft] < right_sorted_list[iRight]:
            merged_sorted_list[iMerged] = left_sorted_list[iLeft]
            iLeft += 1
            iMerged += 1
        else:
            merged_sorted_list[iMerged] = right_sorted_list[iRight]
            iRight +=1
            iMerged += 1

    return merged_sorted_list


if __name__ == "__main__":

    import doctest
    doctest.testmod(verbose=True)
__author__ = 'maxiee'
import Sort.utils as utils

class Base:
    data = []
    aux = []

    def __init__(self, data):
        self.data = data

    def sort(self):
        pass

    def less(self, i, j):
        return self.data[i] < self.data[j]

    def more(self, i, j):
        return self.data[i] > self.data[j]

    def exch(self, i, j):
        temp = self.data[i]
        self.data[i] = self.data[j]
        self.data[j] = temp

    def show(self):
        print(self.data)

    def is_sorted(self):
        for I in range(len(self.data) - 1):
            if self.less(I + 1, I):
                return False
        return True


class SelectSort(Base):
    def sort(self):

        return self.data


class InsertSort(Base):
    def sort(self):

        return self.data


class Shell(Base):
    def sort(self):

        return self.data


class Merge(Base):
    def __init__(self, data):
        super().__init__(data)
        self.aux = list(data)

    def sort(self):
        self.sort_sub(0, len(self.data) - 1)
        return self.data


    def sort_sub(self, lo, hi):

        pass


    def merge(self, lo, mid, hi):

        pass


class Quick(Base):
    def sort(self):
        self.sort_sub(0, len(self.data) -1)
        return self.data


    def sort_sub(self, lo, hi):

        pass


    def partition(self, lo, hi):

        pass


def sort_and_test(name, cls, l):
    c = cls(list(l))
    c.sort()
    print(name, c.is_sorted())

if __name__ == "__main__":
    length = 1000
    l = utils.gen_string_list(length)
    sort_and_test("", SelectSort, l)
    sort_and_test("", InsertSort, l)
    sort_and_test("", Shell, l)
    sort_and_test("", Merge, l)
    sort_and_test("", Quick, l)import zope.viewlet.manager


class SortingViewletManager(zope.viewlet.manager.ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)
def is_sorted(l):
    if len(l) == 1:
        return True
    for i in xrange(1,len(l)):
        if l[i]<l[i-1]:
            return False
    return True


def insertion_sort(l):

    for i in xrange(1, len(l)):
        j = i - 1
        key = l[i]

        while (j >= 0) and (l[j] > key):
           l[j+1] = l[j]
           j -= 1
        l[j+1] = key



m = input()
ar = [int(i) for i in raw_input().strip().split()]
insertion_sort(ar)
print " ".join(map(str,ar))

"""
Created on Mon Sep 21 10:38:13 2015

@author: MDeyell
"""


def sort_a_list(invar):
    "takes a list and return the list sorted in the descending order"
    outvar = sorted(invar, reverse=True)
    return outvar


grades = [[37, 'Jeanette Wafer'], [6, 'Joshua Tran'], [85, 'Susan Maddox']]


def sort_by_mark(grades):
    "take a list and returns it sorted by mark in the descending order"
    def getKey(item):
        return item[0]

    outvar = sorted(grades, key=getKey, reverse=True)
    return outvar


def sort_by_name(input):
    "take a list and returns it sorted by name in the ascending order"
    def getKey(item):
        return item[1]

    outvar = sorted(input, key=getKey)
    return outvar

def comparator(a, b):
    if a[0] / float(a[1]) > b[0] / float(b[1]):
        return 1
    elif a[0] / float(a[1]) == b[0] / float(b[1]):
        if a[0] > b[0]:
            return 1
        elif a[0] == b[0]:
            return 0
        else:
            return -1
    return -1


def sort_fractions(fractions):
    return sorted(fractions, comparator)




import Stack as stk

def sortTheStack(stack1):
	if (stack1.isEmpty()):
		print "Stack is empty. Nothing to sort."
		return None
	sortedStack = stk.Stack()
	while (not stack1.isEmpty()):
		count = 0
		temp = stack1.pop()
		if(sortedStack.isEmpty()):
			sortedStack.push(temp)
		else:
			if(temp < sortedStack.peek()):
				sortedStack.push(temp)
			else:
				while ( (not sortedStack.isEmpty()) and (temp > sortedStack.peek()) ):
					stack1.push(sortedStack.pop())
					count = count + 1
				sortedStack.push(temp)
				for i in range(0,count):
					sortedStack.push(stack1.pop())
	while( not sortedStack.isEmpty()):
		stack1.push(sortedStack.pop())
	return 	stack1










def main():
	unSortedStack = stk.Stack()
	unSortedStack.push(5)
	unSortedStack.push(3)
	unSortedStack.push(2)
	unSortedStack.push(4)
	unSortedStack.push(1)
	print "Before Sorting: "
	unSortedStack.printStack()
	sorted = sortTheStack(unSortedStack)
	if (sorted != None):
		print "After Sorting: "
		sorted.printStack()





if __name__ == "__main__":
	main()

def is_unique_characters_brute_force(str_):

    for i, c in enumerate(str_):
        if c in str_[i+1:]:
            return False
    return True


def is_unique_characters_by_sort(str_):

    str_sorted = ''.join(sorted(str_))

    for i in range(len(str_sorted) - 1):
        if str_sorted[i] == str_sorted[i+1]:
            return False
    return True


def is_unique_characters(str_):
    flags = [0] * 128

    for c in str_:
        if flags[ord(c)] == 1:
            return False
        else:
            flags[ord(c)] = 1
    return True

if __name__ == '__main__':
    print(is_unique_characters_brute_force('abcdefg'))
    print(is_unique_characters_brute_force('abcdefga'))
    print(is_unique_characters_by_sort('abcdefg'))
    print(is_unique_characters_by_sort('abcdefga'))
    print(is_unique_characters('abcdefg'))
    print(is_unique_characters('abcdefga'))
'''
group the anagrams together

cat tea tac  eat rat act tar ball
'''
'''
return the lexicalgraphical order sorted string
'''
def lexicalSort(string):
    return ''.join(sorted(string))


def groupAnagram(arr):
    groups = {}
    for string in arr:
        try: groups[lexicalSort(string)]+=[string]
        except: groups[lexicalSort(string)] = [string]

    return groups

print groupAnagram(['cat', 'tea', 'tac',  'eat', 'rat', 'act', 'tar' ,'ball'])



def quickSort (arr):
    """ Quicksort a list

    :type arr: list
    :param arr: List to sort
    :returns: list -- Sorted list
    """
    if not arr:
        return []

    pivots = [x for x in arr if x == arr[0]]
    lesser = quickSort([x for x in arr if x < arr[0]])
    greater = quickSort([x for x in arr if x > arr[0]])

    return lesser  + pivots + greater

test_array = [1 ,4,5,7,8,9,90,3,2,3,4]
sorted_array = quickSort (test_array)
print sorted_array
def sort_a_list(L):
    V = sorted(L, reverse=True)
    return(V)


from operator import itemgetter


def sort_by_mark(Y):
    P = sorted(Y, key=itemgetter(0), reverse=True)
    return(P)


def sort_by_name(B):
    S = sorted(B, key=itemgetter(1))
    return(S)
def seg_word(sent1):
	list1 = sent1.split(' ')
	return list1

def sort_word(list1):
	return sorted(list1)

def print_first(list1):
	item1 = list1.pop(0)
	print item1

def print_last(list1):
	item1 = list1.pop(-1)
	print item1

def sort_sent(sent1):
	list1 = seg_word(sent1)
	return sort_word(list1)

def print_first_last(sent1):
	list1 = seg_word(sent1)
	print_first(list1)
	print_last(list1)

def print_first_last_sort(sent1):
	list1 = sort_sent(sent1)
	print_first(list1)
	print_last(list1)


"""
Created on Sat Jun  1 13:46:19 2013

@author: lars
"""

def exch(lst, a, b):
    lst[a], lst[b] = lst[b], lst[a]





def sort(lst):
    sorted_end_idx = 0
    while sorted_end_idx < len(lst):
        smallest_idx = sorted_end_idx
        i = sorted_end_idx
        while sorted_end_idx < len(lst):
            if lst[i] < lst[smallest_idx]:
                smallest_idx = i
            i+=1
        exch(lst, sorted_end_idx, smallest_idx)
        sorted_end_idx += 1
    return lst

__author__ = 'maxiee'
import Sort.utils as utils

class Base:
    data = []
    aux = []

    def __init__(self, data):
        self.data = data

    def sort(self):
        pass

    def less(self, i, j):
        return self.data[i] < self.data[j]

    def more(self, i, j):
        return self.data[i] > self.data[j]

    def exch(self, i, j):
        temp = self.data[i]
        self.data[i] = self.data[j]
        self.data[j] = temp

    def show(self):
        print(self.data)

    def is_sorted(self):
        for I in range(len(self.data) - 1):
            if self.less(I + 1, I):
                return False
        return True


class SelectSort(Base):
    def sort(self):

        return self.data


class InsertSort(Base):
    def sort(self):

        return self.data


class Shell(Base):
    def sort(self):

        return self.data


class Merge(Base):
    def __init__(self, data):
        super().__init__(data)
        self.aux = list(data)

    def sort(self):
        self.sort_sub(0, len(self.data) - 1)
        return self.data


    def sort_sub(self, lo, hi):

        pass


    def merge(self, lo, mid, hi):

        pass


class Quick(Base):
    def sort(self):
        self.sort_sub(0, len(self.data) -1)
        return self.data


    def sort_sub(self, lo, hi):

        pass


    def partition(self, lo, hi):

        pass


def sort_and_test(name, cls, l):
    c = cls(list(l))
    c.sort()
    print(name, c.is_sorted())

if __name__ == "__main__":
    length = 1000
    l = utils.gen_string_list(length)
    sort_and_test("", SelectSort, l)
    sort_and_test("", InsertSort, l)
    sort_and_test("", Shell, l)
    sort_and_test("", Merge, l)
    sort_and_test("", Quick, l)
"""
Simple insertion sort
"""
import random

def swap_positions(index, li):
    while index > 0 and li[index] < li[index-1]:
        li[index-1], li[index] = li[index], li[index-1]
        index -= 1


def insertion_sort(dark_list):
    index_sorted_upto = 0
    for index, value in enumerate(dark_list):
        if value < dark_list[index_sorted_upto]:
            swap_positions(index, dark_list)
        index_sorted_upto = index
    return dark_list


def check_list_sorted(ar1):
    """
    checks if an array/list is sorted
    """
    return all(ar1[i] >= ar1[i-1] for i in range(1, len(ar1)))


def main():
    array_size = 1000
    numbers_range = 10000
    foo_ar = random.sample(range(0, numbers_range), array_size)

    print("before insertion_sort, is list sorted: {0}".format(check_list_sorted(foo_ar)))
    foo_ar = insertion_sort(foo_ar)
    print("after insertion_sort, is list sorted: {0}".format(check_list_sorted(foo_ar)))


if __name__ == '__main__':
	main()try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l



def lensort(x):
    return sorted(x,key=len)




print lensort(['python', 'perl', 'java', 'c', 'haskell', 'ruby'])


def alternateSort(ar):
	sorted(ar)
	for i in range(1,len(ar),2):
		if i!=len(ar)-1:
			temp = ar[i]
			ar[i]=ar[i+1]
			ar[i+1]=temp
	return ar

print alternateSort([1,2,3,4,5,6,7])
l = [1, 3, 2, 5]

print(l)
print(sorted(l))
l.sort()
print(l)
print(l == sorted(l))

print(sorted(l, key=lambda x: -x))
l.sort(key=lambda x: -x)
print(l)
print(l == sorted(l, key=lambda x: -x))

print(sorted(l, key=lambda x: -x, reverse=True))
l.sort(key=lambda x: -x, reverse=True)
print(l)
print(l == sorted(l, key=lambda x: -x, reverse=True))

print(sorted(l, reverse=True))
l.sort(reverse=True)
print(l)
print(l == sorted(l, reverse=True))

print(sorted(l, reverse=False))
l.sort(reverse=False)
print(l)
print(l == sorted(l, reverse=False))


l = list(range(2000))
l.sort()
print(l[0], l[-1])
l.sort(reverse=True)
print(l[0], l[-1])


class A:
    def __init__(self, x):
        self.x = x
    def __lt__(self, other):
        return self.x > other.x
    def __repr__(self):
        return str(self.x)
l = [A(5), A(2), A(1), A(3), A(4)]
print(l)
l.sort()
print(l)
l.sort(reverse=True)
print(l)
def insert(elem, list):
    """Return a copy of LIST with ELEM sorted in"""
    if len(list) == 0:
        return [elem]

    head = list[0]
    tail = list[1:]
    if elem <= head:
        return list + [elem]

    return [head] + insert(elem, tail)

def sort(list):
    """Return a sorted copy of LIST"""
    if len(list) <= 1:
        return list

    head = list[0]
    tail = list[1:]
    return insert(head, sort(tail))
def swap(x1,x2):return x2,x1

def cocktailSort(lst):
	correctlySorted = False
	while not correctlySorted:
		correctlySorted = True
		for idx in range(len(lst) - 1):
			if lst[idx] > lst[idx + 1]: correctlySorted = False ; lst[idx],lst[idx + 1] = swap(lst[idx], lst[idx + 1])

		for idx in range(len(lst))[::-1][:-1]:
			if lst[idx] < lst[idx - 1]: correctlySorted = False ; lst[idx],lst[idx - 1] = swap(lst[idx], lst[idx - 1])

	return lst

print cocktailSort([4,2,3,1])



import sys

def main():
	T = int(sys.stdin.readline().strip())
	while T > 0:
		line = sys.stdin.readline().rstrip('\n')
		sort = sorted(line.strip().split(' '))
		g = gcd(int(sort[1]), int(sort[0]))
		val = (int(sort[0]) * int(sort[1])) / (g * g)
		print val
		T -= 1

def gcd (x, y):
	while y:
		x, y = y, x % y
	return x

if __name__ == '__main__':
	main()
import json;
import os.path

def sortLetters(word):
	return ''.join(sorted(word))

def firstLetters(word):
	currFirstThreeLetters = sortedWord[: min(3,len(word))]
	return currFirstThreeLetters

def solve(scrambledWord):
	sortedWord = sortLetters(scrambledWord)
	firstThree = firstLetters(sortedWord)
	filePath = "./processed_scrambles/" + firstLetters + ".json"

	if os.path.isfile(filePath):
		with open(filePath, "r") as infile:
			solutionsDict = json.loads(infile.read())
			if sortedWord in solutionsDict:
				return solutionsDict[sortedWord]
			else:
				return "NOT IN FILE"
	else:
		return "FILE DOES NOT EXIST"

import sys

for line in sys.stdin:
    print line
    solve(line)def break_words(stuff):
	words = stuff.split(' ')
	return words

def sort_words(words):
	return sorted(words)


def print_first_word(words):
	word = words.pop(0)
	print word

def print_last_word(words):
	word = words.pop(-1)
	print word

def sort_sentence(sentence):
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)def sort(values):
    sorted = False
    while not sorted:
        sorted = True
        for x in range(len(values)-1):
            if values[x] > values[x+1]:
                sorted = False
                values[x], values[x+1] = values[x+1], values[x]

    return values
def alternateSort(ar):
	sorted(ar)
	for i in range(1,len(ar),2):
		if i!=len(ar)-1:
			temp = ar[i]
			ar[i]=ar[i+1]
			ar[i+1]=temp
	return ar

print alternateSort([1,2,3,4,5,6,7])
def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst)/2
    lst_a = merge_sort(lst[0:mid])
    lst_b = merge_sort(lst[mid:])

    sorted_list = []

    while len(lst_a) > 0 and len(lst_b) > 0:
        if lst_a[0] > lst_b[0]:
            sorted_list.append(lst_b.pop(0))
        else:
            sorted_list.append(lst_a.pop(0))

    sorted_list.extend(lst_a)
    sorted_list.extend(lst_b)

    return sorted_list


def bubble_sort(lst):
    sorted = False

    while not sorted:
        sorted = True
        for i in range(len(lst) - 1):
            if lst[i] > lst[i + 1]:
                temp = lst[i]
                lst[i] = lst[i + 1]
                lst[i + 1] = temp
                sorted = False


def insertion_sort(lst):
    for i in range(1, len(lst)):

        left_item_index = i - 1
        current_item = lst[i]

        while left_item_index >= 0 and current_item < lst[left_item_index]:
            lst[left_item_index + 1] = lst[left_item_index]
            lst[left_item_index] = current_item
            left_item_index = left_item_index - 1


def main():
    pass

if __name__ == "__main__":
    main()def sorted(q):
	q.sort()
	return q

print sorted([8,2,0,3,4])
def selection_sort(a):
	i=0;j=1;temp=0
	while i<len(a):
		j=i
		while j<len(a):
			if a[i] > a[j]:
				temp=a[j]
				a[j]=a[i]
				a[i]=temp
			j=j+1
		i=i+1
	return a



if __name__=="__main__":
	a=[5,3,7,4,2]
	for i in range(0,len(a)):
		sorted_list=selection_sort(a)
	print "The sorted list is: ",sorted_list



__author__ = 'Leonardo Oliveira (leonardo.ribeirooliv@rackspace.com)'

import re

def tryint(s):
    try:
        return int(s)
    except:
        return s

def alphanum_key(s):
    """ Turn a string into a list of string and number chunks.
        "z23a" -> ["z", 23, "a"]
    """
    return [ tryint(c) for c in re.split('([0-9]+)', s) ]

def sort_nicely(l):
    """ Sort the given list in the way that humans expect.
    """
    return sorted(l, key=alphanum_key)

def sort_nicely_reverse(l):
    """ Sort the given list in the way that humans expect.
    """
    return sorted(l, key=alphanum_key, reverse=True)class Sorter():
	def mergeSort(self, x):

		n = len(x)
		if n == 1:
			return x
		else:
			a = self.mergeSort(x[0:int(n/2)])
			b = self.mergeSort(x[int(n/2):])
			return self.mergeSortedList(a, b)

	def mergeSortedList(self, a, b):

		c = []
		while len(a) or len(b):
			if len(a) == 0:
				return c + b
			if len(b) == 0:
				return c + a

			if a[0] < b[0]:
				c.append(a[0])
				a.pop(0)
			elif b[0] < a[0]:
				c.append(b[0])
				b.pop(0)
			elif a[0] == b[0]:
				c.append(a[0])
				c.append(b[0])
				a.pop(0)
				b.pop(0)
		return c





def is_sorted(t):
	orig = t[:]
	t.sort()
	if t == orig:
		return True
	else:
		return False

t = [5,1,3,9]
print "Initial List : ",
print t

case = is_sorted(t)

if case == True:
	print "Yeah..!! That list is Sorted "
else:
	print "It's not sorted"
'''
Coursera: Stanford Algotithm Part I
Programming Question 1: Merge Sort and Count Number Inversions
Author: Jihong
Date: March 2015
'''


def loadData(filename):
    with open(filename) as f:
        lines = [x.split() for x in f]
    f.close()

    tempList =  zip(*lines)
    tempList = list(tempList[0])
    A = map(int,tempList)

    return A


def mergeSort(A):
    if len(A) == 1:
        sortedA = A
    elif len(A)>1:
        LH = A[:len(A)//2]
        sortedLH = mergeSort(LH)
        RH = A[len(A)//2:]
        sortedRH = mergeSort(RH)
        sortedA = [0]*len(A)

        i = 0
        j = 0
        k = 0

        while i<len(sortedLH) and j<len(sortedRH):
            if sortedLH[i]<sortedRH[j]:
                sortedA[k]=sortedLH[i]
                i=i+1
            else:
                sortedA[k]=sortedRH[j]
                j=j+1
            k=k+1

        while i<len(sortedLH):
            sortedA[k]=sortedLH[i]
            i=i+1
            k=k+1

        while j<len(sortedRH):
            sortedA[k]=sortedRH[j]
            j=j+1
            k=k+1

    return sortedA


def CountSplitInv(A,n):
    if len(A) <= 1:
        sortedA = A
        numInv = 0
    else:
        LH = A[:len(A)//2]
        sortedLH = mergeSort(LH)
        RH = A[len(A)//2:]
        sortedRH = mergeSort(RH)
        sortedA = [None]*len(A)

        i = 0
        j = 0
        k = 0
        numInv = 0
        while i<len(sortedLH) and j<len(sortedRH):
            if sortedLH[i]<=sortedRH[j]:
                sortedA[k]=sortedLH[i]
                i=i+1
            elif sortedLH[i]>sortedRH[j]:
                sortedA[k]=sortedRH[j]
                j=j+1
                numInv = numInv + len(sortedLH)-i
            k=k+1


        while i<len(sortedLH):
            sortedA[k]=sortedLH[i]
            i=i+1
            k=k+1

        while j<len(sortedRH):
            sortedA[k]=sortedRH[j]
            j=j+1
            k=k+1

    return (sortedA, numInv)


def Count(A, n):
    if n==1:
        return (A,0)
    elif n>1:
        LH = A[:n//2]
        RH = A[n//2:]
        (B,x) = Count(LH,len(LH))
        (C,y) = Count(RH,len(RH))
        (D,z) = CountSplitInv(A,n)
        return (D,x+y+z)


def main():






    A = loadData('IntegerArray.txt')
    (A,numInv) = Count(A, len(A))
    print 'Number inversions: %d' % numInv



if __name__ == "__main__":
	  main()
def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)




from common.helpers import default_compare

def sort(array, compare=default_compare):
  sorted = False
  while not sorted:
    sorted = inner_sort(array, 1, compare)
    sorted = sorted and inner_sort(array, 0, compare)
  return array

def inner_sort(array, start_i, compare):
  sorted = True
  for i in range(start_i, len(array) - 1, 2):
    if compare(array[i], array[i + 1]) > 0:
      array[i], array[i + 1] = array[i + 1], array[i]
      sorted = False
  return sorted


import random


def bubble_sort(alist):
    sorted = False
    while not sorted:
        sorted = True
        for idx in range(len(alist)-1):
            if alist[idx] > alist[idx+1]:
                alist[idx], alist[idx+1] = alist[idx+1], alist[idx]
                sorted = False
    return alist


def selection_sort(alist):
    for pos in range(len(alist)-1):
        min_pos = pos
        for idx in range(pos, len(alist)):
            if alist[min_pos] > alist[idx]:
                min_pos = idx
        alist[pos], alist[min_pos] = alist[min_pos], alist[pos]
    return alist


def heap_sort(alist):
    raise(NotImplementedError)


def insertion_sort(alist):
    raise(NotImplementedError)


def shell_sort(alist):
    raise(NotImplementedError)


def merge_sort(alist):
    raise(NotImplementedError)


def quick_sort(alist):
    if len(alist) <= 1:
        return alist
    pivot = alist[0]
    greater = []
    lesser = []
    for element in alist:
        if element <= pivot:
            lesser.append(element)
        else:
            greater.append(element)
    return quick_sort(lesser) + [pivot] + quick_sort(greater)

"""
Bubble Sort
wiki: https://en.wikipedia.org/wiki/Bubble_sort
input: list of sortable objects
returns: new sorted array
"""
def bubble_sort(input):

    sorted = list(input)

    input_length = len(input)

    swap = True

    while swap:
        swap = False
        for i in range(input_length-1):

            if sorted[i] > sorted[i+1]:
                temp = sorted[i]
                sorted[i] = sorted[i+1]
                sorted[i+1] = temp
                swap = True
    return sorted

"""
Selection Sort
wiki: https://en.wikipedia.org/wiki/Selection_sort
input: list of sortable objects
returns: new sorted array
"""
def selection_sort(input):

    sorted = list(input)

    input_length = len(input)

    for i in range(input_length):

        min_index = i

        for j in range(i,input_length):

            if sorted[min_index] > sorted[j]:
                min_index = j

        if min_index != i:
            temp = sorted[i]
            sorted[i] = sorted[min_index]
            sorted[min_index] = temp
    return sorteda = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

def selection_sort(l):
    sorted = []
    while l:
        sorted.append(min(l))
        l.remove(l)
    return sorted

def evaluate_fraction(fraction):
    return fraction[0] / fraction[1]


def sort_fractions(fractions):
    return(sorted(fractions, key=evaluate_fraction))
def sort_fractions(fractions):
	return sorted(fractions, key = lambda x: x[0]/x[1])
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]


__author__ = 'Leonardo Oliveira (leonardo.ribeirooliv@rackspace.com)'

import re

def tryint(s):
    try:
        return int(s)
    except:
        return s

def alphanum_key(s):
    """ Turn a string into a list of string and number chunks.
        "z23a" -> ["z", 23, "a"]
    """
    return [ tryint(c) for c in re.split('([0-9]+)', s) ]

def sort_nicely(l):
    """ Sort the given list in the way that humans expect.
    """
    return sorted(l, key=alphanum_key)

def sort_nicely_reverse(l):
    """ Sort the given list in the way that humans expect.
    """
    return sorted(l, key=alphanum_key, reverse=True)from nocassa.cassandra.genbisect import insort


class SortedDict(dict):
    def __init__(self, *args, **kwargs):
        sup = super(SortedDict, self)
        sup.__init__(*args, **kwargs)
        self.sorted_keys = sup.keys()
        self.sort_keys()

    def sort_keys(self):
        self.sorted_keys.sort(cmp=self.compare)

    def insort(self, key):
        insort(self.sorted_keys, key, compare=self.compare)

    def remove_key(self, key):
        self.sorted_keys.remove(key)

    compare = staticmethod(cmp)

    def __delitem__(self, key):
        super(SortedDict, self).__delitem__(key)
        self.remove_key(key)

    def __eq__(self, other):
        if not super(SortedDict, self).__eq__(other):
            return False
        if isinstance(other, SortedDict):
            return other.sorted_keys == self.sorted_keys
        return True

    def __iter__(self):
        for k in self.sorted_keys:
            yield k

    def __ne__(self, other):
        return not self.__eq__(other)

    def __setitem__(self, key, value):
        if key not in self:
            self.insort(key)
        super(SortedDict, self).__setitem__(key, value)

    def __repr__(self):
        r = ', '.join(': '.join(map(repr, item)) for item in self.iteritems())
        r = '%s({%s})' % (self.__class__.__name__, r)
        return r

    def clear(self):
        self.sorted_keys[:] = []
        super(SortedDict, self).clear()

    def copy(self):
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, S, v=None):
        return cls(super(SortedDict, cls).fromkeys(S, v))

    def iteritems(self):
        for k in self:
            yield (k, self[k])

    iterkeys = __iter__

    def itervalues(self):
        for k in self:
            yield self[k]

    def keys(self):
        return list(self.sorted_keys)

    def items(self):
        return list(self.iteritems())

    def pop(self, *args):
        pop = super(SortedDict, self).pop
        if len(args) not in [1, 2]:
            pop(*args)

        if len(args) == 1:
            k, = args
            value = pop(k)
            self.remove_key(k)
            return value

        k, d = args
        if k in self:
            self.remove_key(k)

        return pop(k, d)

    def values(self):
        return list(self.itervalues())





def is_sorted(a):
  b = len(a)
  if b == 1 :
    return 1
  for i in range(b-1):
    if a[i] > a[i+1] :
      return 0
  return 1




assert(is_sorted((10, 20, 30, 32, 33)))

assert(is_sorted((1,)))

assert(is_sorted((1,2)))

assert(not is_sorted((2, 1)))

assert(not is_sorted((1, 4, 7, 8, 6)))

assert(not is_sorted((10, 20, 30, 25, 34, 45, 67)))


'''
Created on Oct 10, 2013

@author: av
'''



def _find_a_place_for_first_element(list_to_sort, start, end):
    lower_pointer = start
    upper_pointer = end
    while lower_pointer < upper_pointer:
        while lower_pointer < upper_pointer:
            upper_pointer += -1
            if list_to_sort[upper_pointer] < list_to_sort[lower_pointer]:
                list_to_sort[upper_pointer], list_to_sort[lower_pointer] = list_to_sort[lower_pointer], list_to_sort[upper_pointer]
                break
        while lower_pointer < upper_pointer:
            lower_pointer += +1
            if list_to_sort[lower_pointer] > list_to_sort[upper_pointer]:
                list_to_sort[upper_pointer], list_to_sort[lower_pointer] = list_to_sort[lower_pointer], list_to_sort[upper_pointer]
                break
    return list_to_sort, lower_pointer



def my_quick_sort(list_to_sort, start=None, end=None):
    if start == None:
        start = 0
    if end == None:
        end = len(list_to_sort)
    if end-start < 2:
        return list_to_sort
    list_to_sort, first_element_new_position = _find_a_place_for_first_element( list_to_sort, start, end )
    list_to_sort = my_quick_sort(list_to_sort, start, first_element_new_position)
    list_to_sort = my_quick_sort(list_to_sort, first_element_new_position+1, end)
    return list_to_sort

def is_sorted_asc(vector):
    if len(vector) < 2:
        return True
    return vector[0] <= vector[1] and is_sorted_asc(vector[1:])

if __name__ == '__main__':
    list_to_sort = [13,20,10,10,28,9]
    sorted_list = my_quick_sort(list_to_sort)
    print( sorted_list )
    print( 'Is it sorted ascending?', is_sorted_asc(sorted_list) )

from operator import attrgetter

class Sort():
    def sort(self, results):
        raise NotImplementedError("You have not implemented the sort method")

class RatingSort(Sort):

    def sort(self, results):
        return sorted(results, key=attrgetter('rating'), reverse=True)

class AvailabilitySort(Sort):

    def sort(self, results):
        return sorted(results, key=attrgetter('availability'))
'''
In this module we implement counting sort

'''


def counting_sort(arr):
    '''
    Sort array using counting sort

    '''
    count = [0] * (max(arr)+1)
    sorted_list = [0]*len(arr)
    for i in arr:
        count[i] += 1
    for i in range(1,len(count)):
        count[i] += count[i-1]
    for i in arr:
        sorted_list[count[i] - 1] = i
        count[i] -= 1
    return sorted_list    def sort_fractions(fractions):
	d = {}
	for i in fractions:
		key = i[0] / i[1]
		d[key] = i
	final = []
	for key in sorted(d):
		final.append(d[key])
	return final

def main():
	print(sort_fractions([(2, 3), (1, 2)]))
	print(sort_fractions([(2, 3), (1, 2), (1, 3)]))
	print(sort_fractions([(5, 6), (22, 78), (22, 7), (7, 8), (9, 6), (15, 32)]))


if __name__ == '__main__':
	main()def main(list_to_sort):
  sublist1, sublist2 = split_list(list_to_sort)
  if len(sublist1) > 2:
    main(sublist1)
  if len(sublist2) > 2:


def split_list(list_to_sort):
  list_halfway_point = len(list_to_sort)/2
  sublist1 = list_to_sort[0:list_halfway_point]
  sublist2 = list_to_sort[list_halfway_point:]
  if len(sublist1) > 1:
    split_list(sublist1)
  if len(sublist2) > 1:
    split_list(sublist2)
  return sublist1, sublist2


def reconstruction(list1, list2):
  sorted_list = []
  for item1 in list1:
    for item2 in list2:
      if item1 < item2:
        sorted_list.append(item1)
      else:
        sorted_list.append(item2)






def single_item_comparison(small_list):
  if num2 < num1:
    return [num2, num1]
  else:
    return [num1, num2]
"""
This module implements the heapsort algorithm
"""

def heap_sort(arr):
    """
    Perform a heap sort on a given list. Return the sorted list.
    """
    pass
import copy

def my_min(l):
  if l == []:
      raise 'this is an empty list'
  else:
      min_elem  = l[0]
      for i in l:
          if min_elem > i:
              min_elem = i
  return min_elem


def my_reverse(l):
    if len(l) == 0:
        raise 999
    else:
        return l[::-1]


def select_sort(list):
    l = copy.deepcopy(list)
    if len(l) == 0:
        raise 999
    else:
        my_sorted = []
        for i in range(len(l)):
            my_sorted.append(my_min(l))
            l.remove(my_min(l))
    return my_sorted


def insert_sort(l):
    if len(l) == 0:
        raise 999
    else:
        my_sorted = [l[0]]
        for i in range(1, len(l)):
            for j in range(len(my_sorted)):
                if my_sorted[j] >= l[i]:
                    my_sorted.insert(j, l[i])
                    break
                elif j == len(my_sorted) - 1:
                    my_sorted.append(l[i])
    return my_sorted


def tear_list(sorted1, sorted2):
    ret_sort = []
    i = j = 0
    while i < len(sorted1) and j < len(sorted2):
        if sorted1[i] < sorted2[j]:
            ret_sort.append(sorted1[i])
            i += 1
        else:
            ret_sort.append(sorted2[j])
            j += 1
    while i < len(sorted1):
        ret_sort.append(sorted1[i])
        i += 1
    while j < len(sorted2):
        ret_sort.append(sorted2[j])
        j += 1
    return ret_sort



def add_up_sort(l):
    if len(l) == 0:
        raise  999
    elif len(l) == 1:
        return l
    else:
        sorted1 = add_up_sort(l[: len(l) / 2])
        sorted2 = add_up_sort(l[len(l) / 2 :])
    return tear_list(sorted1, sorted2)


l = [1, 5, 36, 67, 4, 7, 78, 100]
add_up_sort(l)


def bubble_sort(mylist):
	length=len(mylist)
	for i in range(length-1):
		if (mylist[i]>mylist[i+1]):
			temp=mylist[i]
			temp2=mylist[i+1]
			mylist[i]=temp2
			mylist[i+1]=temp
			bubble_sort(mylist)

	return mylist

print (bubble_sort([5,19,4,1,36,99,2]))

assert bubble_sort([5,19,4,1,36,99,2]) == sorted([5,19,4,1,36,99,2])
assert bubble_sort(["Greg", "Armen", "Ken"]) == sorted(["Greg", "Armen", "Ken"])
def sort_a_list(L):
    M = sorted(L, reverse=True)
    return(M)

import operator


def sort_by_mark(myclass):
    myclass = sorted(myclass, key=operator.itemgetter(0), reverse=True)
    return(myclass)


def sort_by_name(myclass):
    myclass = sorted(myclass, key=operator.itemgetter(1))
    return(myclass)
"""
Median of Two Sorted Arrays
There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
"""
class Solution:

    def findMedianSortedArrays(self, A, B):
        C = A
        C.extend(B)
        C.sort()
        length = len(C)
        if len(C)%2 == 1:
            return C[len(C)/2]
        else:
            return float(C[length/2]+C[length/2-1])/2
def select_sort(nums):
	size = len(nums)
	for i in range(0,size-1):
		min_element = i
		for j in range(i+1,size):
		  if(nums[j]<nums[min_element]):
		        min_element = j
	        temp = nums[min_element]
                nums[min_element] = nums[i]
	        nums[i] = temp
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = select_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)

import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))



def testSort(lst):
    if lst: return testSort([elem for elem in lst[1:] if elem<lst[0]]) + lst[0:1] + testSort([elem for elem in lst[1:] if elem>=lst[0]])
    return []

func = testSort

lst = [1, 2, 33, 3, 4, 6, 7, 788, 9, 5, 33, 222]

sortedList = func(lst)
print sortedListfrom operator import itemgetter, attrgetter


def sort_a_list(l):
    a = (sorted(l, reverse=True))
    return(a)


def sort_by_mark(my_class):
    b = (sorted(my_class, reverse=True))
    return(b)


def sort_by_name(my_class):
    getcount = itemgetter(1)
    c = (sorted(my_class, key=getcount))
    return(c)
from Rnaseq import *

class sort_by_significance(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k14 -r ${inputs[0]} > ${ID}.sorted.sig
        '''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.sig']



def break_words(stuff):
    """This function will break up words for us"""
    return stuff.split(' ')

def sort_words(words):
    """Sort the words"""
    return sorted(words)

def print_first_word(words):
    """Prints the first word after popping it off"""
    print words.pop(0)

def print_last_word(words):
    """Prints the last word after popping it off"""
    print words.pop(-1)

def sort_sentence(sentence):
    """Takes in a full sentence and returns the sorted words"""
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    """Prints the 1st and last words of the sentence"""
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)

def print_first_and_last_sorted(sentence):
    """Sorts the words then prints the first and last one"""
    sorted_words = sort_sentence(sentence)
    print_first_word(sorted_words)
    print_last_word(sorted_words)


class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))

def bubble_sort(nums):
	size = len(nums)
	for i in range(0,size-1):
		for j in range(0,size-i-1):
			if(nums[j] > nums[j+1]):
 				temp = nums[j]
				nums[j]=nums[j+1]
				nums[j+1]=temp
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = bubble_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)

from datetime import datetime
import calendar
from collections import OrderedDict

def by_date(changes):
    sorted = OrderedDict()
    for repo in changes:
        for commit in changes[repo]:
            _, _, date, _, _ = commit
            epoch = calendar.timegm(datetime.strptime(date, '%Y-%m-%d').utctimetuple())
            if epoch in sorted:
                sorted[epoch] += commit
            else:
                sorted[epoch] = [commit]
    return sorted

def by_author(changes):
    sorted = OrderedDict()
    for repo in changes:
        for commit in changes[repo]:
            _, author, _, _, _ = commit
            if author in sorted:
                sorted[author] += commit
            else:
                sorted[author] = [commit]
    return sorted

def by_directory(changes):
    sorted = OrderedDict()
    for repo in changes:
        if repo in sorted:
            sorted[repo] = changes[repo]
        else:
            sorted[repo] = changes[repo]
    return sorted

SORT = {
    'date': by_date,
    'author': by_author,
    'directory': by_directory
}


def valuesort(d):
   return [d[x] for x in sorted(d.keys())]
print valuesort({'x': 1, 'y': 2, 'a': 3})

'''
Given an array of strings, return all groups of strings that are anagrams.
Note: All inputs will be in lower-case.

For example:
Input:  ["tea","and","ate","eat","dan", "xyz"]
Output: ['and', 'dan', 'tea', 'ate', 'eat']
'''

class Solution:


    def anagrams(self, strs):
        def sort_str(string):
            l = list(string)
            l.sort()
            sorted_str = ""
            for c in l:
                sorted_str = sorted_str + c
            return sorted_str

        m = {}
        for string in strs:
            sorted_string = sort_str(string)
            if sorted_string in m:
                m[sorted_string].append(string)
            else:
                m[sorted_string] = [string]

        result = []
        for k in m:
            if len(m[k]) > 1:
                result = result + m[k]
        return result

if __name__ == "__main__":
    s = Solution()
    print s.anagrams(["tea","and","ate","eat","dan", "xyz"])


import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))
from random import shuffle


def sort(values):
    while sorted(values) != values:
        shuffle(values)

    return values
from Rnaseq import *

class bowtie2bam(Step):
    def usage(self, context):
        usage='''
$${programs}/samtools view -b -h -S -u $${ID}.bowtie.sam | $${programs}/samtools sort - $${ID}.sorted
'''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.bam']

__author__ = "Antony Cherepanov"


def merge_sort(t_input):
    length = len(t_input)
    if 2 < length:
        half_length = length // 2
        left_half = t_input[:half_length]
        right_half = t_input[half_length:]
        sorted_left = merge_sort(left_half)
        sorted_right = merge_sort(right_half)
        i = 0
        j = 0
        result = list()
        for k in range(length):
            if len(sorted_left) <= i:
                result.extend(sorted_right[j:])
                break

            if len(sorted_right) <= j:
                result.extend(sorted_left[i:])
                break

            if sorted_left[i] < sorted_right[j]:
                result.append(sorted_left[i])
                i += 1
            else:
                result.append(sorted_right[j])
                j += 1

        return result

    else:
        if 1 == length:
            return t_input
        elif 2 == length:
            first = t_input[0]
            second = t_input[1]
            if first < second:
                return [first, second]
            else:
                return [second, first]from collections import defaultdict

class School(object):

  def __init__(self, schoolName):
    self.schoolName = schoolName
    self._db = defaultdict(set)

  @property
  def db(self):
    return self._db

  def add(self, name, grade):
    self.db[grade].add(name)

  def grade(self, grade):
    return self.db[grade]

  def sort(self):
    return [(grade, tuple(sorted(self.db[grade]))) for grade in sorted(self.db)]


def sayHi(Name):
    print "Hi,", Name

def printList(List):
    print List

def sort(List):
    return sorted(List)
""" Write a function extsort to sort a list of files based on extension.
"""

def extsort(x):
	return sorted(x, key = lambda i: i.split('.')[1])
print extsort(['a.c', 'a.py', 'b.py', 'bar.txt', 'foo.txt', 'x.c'])

def sort_word(word):
	"""Sorted"""
	print word
	return sorted(word)

word = raw_input("Enter the value")
from django.shortcuts import render
from __init__ import pyro


def get_test():
    print library.test()


def home(request, by_what='tytul'):
    """ Strona glowna. Parametr 'by_what' mowi nam po czym sortujemy liste. """

    sort = by_what

    book_list = pyro.library.getBook_list(20)
    sorted_list = pyro.library.getBook_sort(by_what, 'ASC', 20)

    template = "index.html"
    context = {'book_list':book_list, 'sorted_list':sorted_list, 'sort':sort}

    return render(request, template, context)



import random
import math

from benchmark import timethese

SAMPLE_SIZE             = 40 * 1000
BENCHMARK_ITERATIONS    = 100


def main():
    print "Generating sample data..."
    points = generatate_points(SAMPLE_SIZE)

    timethese(BENCHMARK_ITERATIONS,
        (
            ("classic",     lambda : sort_classic(points)),
            ("key",         lambda : sort_key(points)),
            ("OM",          lambda : sort_om(points)),
            ("ST",          lambda : sort_st(points)),
        )
    )


def generatate_points(N):
    DISTANCE = 10
    a = []

    for x in xrange(N):
        a.append(
            (random.randint(0, DISTANCE), random.randint(0, DISTANCE))
        )
    return a


def veclen(point):
    return math.sqrt( point[0] ** 2 + point[1] ** 2)


def sort_classic(data):

    def cmp_distances(a, b):
        return int(veclen(a) - veclen(b))

    return sorted(data, cmp=cmp_distances)


def sort_key(data):
    return sorted(data, key=veclen)


def sort_om(data):
    cache = dict()

    def cmp_cached(a, b):
        if a not in cache:
            cache[a] = veclen(a)
        if b not in cache:
            cache[b] = veclen(b)

        return int(cache[a] - cache[b])

    return sorted(data, cmp=cmp_cached)


def sort_st(data):
    return [ p for vl, p in sorted([(veclen(p), p) for p in data]) ]


if __name__ == '__main__':
    main()
"""
Write a program that sorts its command line arguments.
"""

import sys

def sortThis(lis):
	lis.sort()
	return lis

argLis = sys.argv[1:]
fmt = ("%20s: %s")
print(fmt % ("Arguments", argLis))

sortedArgs = sortThis(argLis)
print(fmt % ("Sorted arguments:", sortedArgs))
from sys import argv

scriptname, filename = argv[0], argv[1]

def create_dictionary(filename):

    input_file = open(filename)

    dictionary = {}

    for line in input_file:
        line = line.rstrip().split(':')
        key, value = line[0], int(line[1])
        dictionary[key] = value

    return dictionary

def sort_dictionary_keys(dictionary):
    sorted_keys = sorted(dictionary.keys())
    return sorted_keys

def print_sorted_dictionary(dictionary, sorted_keys):
    for key in sorted_keys:
        print "Restaurant %r is rated at %d." % (key, dictionary[key])

def main():
    dictionary = create_dictionary(filename)
    sorted_keys = sort_dictionary_keys(dictionary)
    print_sorted_dictionary(dictionary, sorted_keys)


if __name__ == '__main__':
    main()"""
    Look through the list.  Find the smallest element.  Swap it to the front.
    Repeat.
"""
l = [1,3,5,2,8,7,9,6]

def swapItems(local_list, index1, index2):
    index1
    index2
    hold = local_list[index1]
    local_list[index1] = local_list[index2]
    local_list[index2] = hold
    return local_list

def sortList(org_list):

    sorted_list = org_list

    for i in range(0, len(sorted_list)):
        for j in range(i+1, len(sorted_list)):
            if sorted_list[j] < sorted_list[i]:
                swapItems(sorted_list, j, i)

    return sorted_list

print(sortList(l))
import json

def sort_by_name(item):
	return item[0]

with open("data-hold/domestic-jobcount.json") as f:
	data = json.loads(f.read())

sorted_data = sorted(data, key=sort_by_name)

for d in sorted_data:
	if d[1] < 100:
		print("%s, %s" %(d[0], d[1]))



from time import sleep
from threading import Timer

def sleepsort(values):
    sleepsort.result = []
    def add1(x):
        sleepsort.result.append(x)
    mx = values[0]
    for v in values:
        if mx < v: mx = v
        Timer(v, add1, [v]).start()
    sleep(mx+1)
    return sleepsort.result

if __name__ == '__main__':
    x = [3,2,4,7,3,6,9,1]
    if sleepsort(x) == sorted(x):
        print('sleep sort worked for:',x)
        print('sorted array is:',sorted(x))
    else:
        print('sleep sort FAILED for:',x)
def bubble_sort(array):
    n = len(array)
    for i in range(n):
        for j in range(i):
            if array[j] > array[i]:
                array[i], array[j] = array[j], array[i]
    return array
array = [1,4,5,2,7,4,7,9,3,2]
print bubble_sort(array) == sorted(array)
def insertion_sort(seq):
	for i in range(1,len(seq)):
		j=i
		while j>0 and seq[j-1]>seq[j]:
			seq[j-1],seq[j]=seq[j],seq[j-1]
			j-=1
	return seq
seq=[3,5,2,6,8,1,0,3,5,6,2]

assert(insertion_sort(seq)==sorted(seq))
import operator


def sortFirst(L):
    return sorted(L,key=operator.itemgetter(0))

def sortThird(L):
    return sorted(L,key=operator.itemgetter(2))

def sortSecondDescend(L):
    return sorted(L,key=operator.itemgetter(1),reverse=True)

if __name__ == '__main__':
    L = [(1,2,3),(4,1,5),(0,0,6)]
    print(sortFirst(L))
    print(sortThird(L))
    print(sortSecondDescend(L))

import unittest


class Bubbler(object):
    def __init__(self, sample):
        ''' sample is the list to sort
        '''
        self.sample = sample

    @property
    def sorter(self):
        ''' implement bubble sort here
        '''
        pass

    def __repr__(self):
        return 'Bubbler({})'.format(self.sample)


class BubblerTestCases(unittest.TestCase):

    def test_simple(self):
        x1 = [1, 2, 3, 4, 5]
        b = Bubbler(x1)
        self.assertEquals(b.sorter, sorted(b.sample))

    def test_negatives(self):
        x2 = [4, 5, 23, 5, 6, 1, 6, -1, 0.3]
        b = Bubbler(x2)
        self.assertEquals(b.sorter, sorted(b.sample))

    def test_all_negatives(self):
        x3 = [-1, -4, -3, -2, -5]
        b = Bubbler(x3)
        self.assertEquals(b.sorter, sorted(b.sample))

    def test_decimals(self):
        x4 = [0.3, 0.2, 0.1, 0.4, -0.5, -0.3]
        b = Bubbler(x4)
        self.assertEquals(b.sorter, sorted(b.sample))


if __name__ == '__main__':
    unittest.main()
def insertion_sort(the_list, sorted_length = 0):
    if len(the_list) <= sorted_length:
        return the_list
    current = the_list.pop()
    if sorted_length == 0:
        the_list.insert(0,current)
    else:
        for x in range(sorted_length):
            if the_list[x] >= current:
                the_list.insert(x, current)
                return insertion_sort(the_list, sorted_length + 1)
        the_list.insert(sorted_length,current)
    return insertion_sort(the_list, sorted_length + 1)


a = [3,2,4,5,19,20,2,30,1000,1]
print a
insertion_sort(a)
print a
a.sort()
print a
def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]
def cardSort(values):
    sortedList=[]
    for i in range(min(values),max(values)+1):
        if i in values:
            for card in values:
                if card==i:
                    sortedList.append(card)
                    del card

    return sortedList
from Selection_sort import sort
import random
import os


def checker():
    sorted_elems = []
    result = []
    for i in range(10000):
        result.append(random.randint(0, 150000))

    sorted_elems = sort(result)
    length = len(sorted_elems)
    for i in range(length - 1):
        if sorted_elems[i] > sorted_elems[i + 1]:
            return False
    return True

print(checker())
def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist
def getKey(item):
    return item[0] / item[1]


def sort_fractions(fractions):
    return sorted(fractions, key=getKey)


print(sort_fractions([(5, 6), (22, 78), (22, 7), (7, 8), (9, 6), (15, 32)]))

def swap_lis(lis, i):
	lis[i], lis[i + 1] = lis[i + 1], lis[i]
      	return 0

def sort(lis, limit):
	for i in range(limit):
		[swap_lis(lis, j) if lis[j] > lis[j + 1] for j in range(limit)]
	return lis


lis = input("enter the list\n")
limit = len(lis) - 1
lis_sorted = sort(lis, limit)
print "the sorted list is %r"%(lis_sorted)


import timeit

def test_sorted(filename):
    f_in = open(filename, 'r')
    unsorted_list = ' '.join(f_in).split()
    sorted_list = sorted(unsorted_list)
    f_in.close()
    return sorted_list

def test_sort(filename):
    f_in = open(filename, 'r')
    unsorted_list = ' '.join(f_in).split()
    unsorted_list.sort()
    f_in.close()
    return unsorted_list

def print_fastest(time1, name1, time2, name2):
    if (time1 < time2):
        amount_faster = time2 - time1
        print("The function using the {0} method executed {1:8f} seconds faster"
              .format(name1,amount_faster))
    else:
        amount_faster = time1 - time2
        print("The function using the {0} method executed {1:8f} seconds faster"
              .format(name2,amount_faster))

file = 'E:\\Python34\\Scripts\\unsorted_fruits.txt'

sorted_timer = timeit.Timer(stmt="test_sorted(file)",
                             setup="from __main__ import test_sorted, file")
sort_timer = timeit.Timer(stmt="test_sort(file)",
                          setup="from __main__ import test_sort, file")

min_sorted_result = min(sorted_timer.repeat(3,100))
min_sort_result = min(sort_timer.repeat(3,100))

print("The argument for these functions during this test was '{0}'.\n"
      .format(file))
print('sorted: {0:8f}'.format(min_sorted_result))
print('sort: {0:8f}'.format(min_sort_result))


print_fastest(min_sorted_result, 'sorted', min_sort_result, 'sort')

from Rnaseq import *

class sort_by_sample(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k5,6 ${inputs[0]} > ${ID}.sorted.sample
        '''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.sample']

try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
def sort_fractions(fractions):
    return sorted(fractions, key=getKey)


def getKey(item):
    return item[0]/item[1]
from operator import itemgetter

__author__ = 'george'


l1=[9,10,0,-5,111,2,4,3,5,2,8]

print l1.sort()
print l1

l1=[9,10,0,-5,111,2,4,3,5,2,8]

print sorted(l1)
print l1
print sorted(l1,reverse=True)

tup= (1,5,32,6,0,-12)
print sorted(tup)

def keyfunc(A):
    return A[0]

A=[[1,2],[5,3],[0,1],[-10,3]]
A.sort(key=keyfunc)
print A
A.sort(key=keyfunc,reverse=True)
print A



student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
sorted(student_tuples, key=itemgetter(1,2))def selection_list_sort(xs):
  unsorted_l = xs
  sorted_l = []
  min_idx = 0

  while unsorted_l:
    for i in range(len(unsorted_l)):
      if unsorted_l[i] < unsorted_l[min_idx]:
        min_idx = i
    sorted_l.append(unsorted_l[min_idx])
    del unsorted_l[min_idx]
    min_idx = 0

  return sorted_l

def selection_dict_sort(d):
  unsorted = d
  sorted_l = []
  min_key_val = None, None

  while unsorted:
    for k in unsorted:
      if not min_key_val[0] or unsorted[k] < min_key_val[1]:
        min_key_val = k, unsorted[k]
    sorted_l.append(min_key_val)
    del unsorted[min_key_val[0]]
    min_key_val = None, None

  return sorted_l

l = [12,12,15,2,7,2,12]
print selection_list_sort(l)

d = {"the": 10, "and": 11, "hello": 15, "goodbye": 11}
print selection_dict_sort(d)
def merge_sort(input_array):
    length_of_input = len(input_array)
    if length_of_input == 1:
        return input_array
    else:
        first_sorted_half = merge_sort(input_array[0 : int(length_of_input / 2)])
        second_sorted_half = merge_sort(input_array[int(length_of_input / 2): ])
        sorted_array = merge(first_sorted_half, second_sorted_half)
        return sorted_array

def merge(first_sorted_array, second_sorted_array):
    length_1 = len(first_sorted_array)
    length_2 = len(second_sorted_array)
    total_length = length_1 + length_2

    i = 0
    j = 0
    merged_array = []

    for idx in range(total_length):

        if first_sorted_array[i] > second_sorted_array[j]:
            merged_array.append(second_sorted_array[j])
            j += 1
        else:
            merged_array.append(first_sorted_array[i])
            i += 1

        if i == length_1:
            merged_array += second_sorted_array[j : ]
            return merged_array
        elif j == length_2:
            merged_array += first_sorted_array[i : ]
            return merged_array
def read_in_file():
    filename = 'IntegerArray.txt'
    f = open(filename, 'r')
    numbers = []
    for entry in f:
        numbers.append(int(entry))
    f.close()
    return numbers


def use_example():
    return [8, 4, 3, 2, 3, 5, 1, 0, 10]


def sort_and_count(ar):
    if len(ar) == 1:
        return 0, ar
    else:
        ct_left, left = sort_and_count(ar[0:len(ar) / 2])
        ct_right, right = sort_and_count(ar[len(ar) / 2::])

        ar_sorted, ct_split = count_split(left, right)


        return ct_left + ct_right + ct_split, ar_sorted


def count_split(left, right):
    ar_sorted = []
    i = j = 0
    count = 0
    while i < len(left) and j < len(right):
        if(left[i] > right[j]):
            count += len(left) - i
            ar_sorted.append(right[j])
            j += 1
        else:
            ar_sorted.append(left[i])
            i += 1

    if j == len(right):
        ar_sorted += left[i:]
    else:
        ar_sorted += right[j:]

    return ar_sorted, count


if __name__ == "__main__":
    result, _ = sort_and_count(read_in_file())
    print result
import urllib
import urllib2

from basesort import BaseSort


class HerokuSort(BaseSort):

    def exec_request(self):

        data = urllib.urlencode({'css': self.original})
        ua = 'Sublime Text 2 - CSScomb'
        req = urllib2.Request("http://csscomb.herokuapp.com/sort.php", data, headers={'User-Agent': ua})
        file = urllib2.urlopen(req, timeout=10)

        sorted_css = file.read()

        if len(sorted_css) > 0:
            return sorted_css
        else:
            return None


def break_words(stuff):
	"""This is a sample help statement"""
	words = stuff.split(' ')
	return words

def sort_words(words):
	return sorted(words)

def print_first_word(words):
	word = words.pop(0)
	print word

def print_last_word(words):
	word = words.pop(-1)
	print word

def sort_sentence(sentence):
	words = break_words(sentence)
	return sort_words(words)
__author__ = 'instancetype'


class SimpleList:
    def __init__(self, items):
        self._items = list(items)

    def add(self, item):
        self._items.append(item)

    def __getitem__(self, index):
        return self._items[index]

    def sort(self):
        self._items.sort()

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return 'SimpleList({!r})'.format(self._items)


class SortedList(SimpleList):
    def __init__(self, items=()):
        super().__init__(items)
        self.sort()

    def add(self, item):
        super().add(item)
        self.sort()

    def __repr__(self):
        return 'SortedList({!r})'.format(list(self))


class IntList(SimpleList):
    def __init__(self, items=()):
        for x in items: self._validate(x)
        super().__init__(items)

    @staticmethod
    def _validate(x):
        if not isinstance(x, int):
            raise TypeError('IntList only supports integers')

    def add(self, item):
        self._validate(item)
        super().add(item)

    def __repr__(self):
        return 'IntList({!r})'.format(list(self))


class SortedIntList(IntList, SortedList):
    def __repr__(self):
        return 'SortedIntList({!r})'.format(list(self))def bubble_sort(mylist):
	length=len(mylist)
	for i in range(length-1):
		if (mylist[i]>mylist[i+1]):
			temp=mylist[i]
			temp2=mylist[i+1]
			mylist[i]=temp2
			mylist[i+1]=temp
			bubble_sort(mylist)

	return mylist

print (bubble_sort([5,19,4,1,36,99,2]))

assert bubble_sort([5,19,4,1,36,99,2]) == sorted([5,19,4,1,36,99,2])
assert bubble_sort(["Greg", "Armen", "Ken"]) == sorted(["Greg", "Armen", "Ken"])
def quick_sort(list, size):

    print 'Sorting list of size', size

    list_left  = []
    count_left = 0
    list_right = []
    count_right = 0
    pivot = [list[0]]
    sorted_list = []
    for i in range(1,len(list)):
        if (list[i]) > pivot[0]:
            list_right.append(list[i])
            count_right += 1
        elif (list[i] < pivot[0]):
            list_left.append(list[i])
            count_left += 1
        else:
            pivot = pivot + [list[i]]

    if count_left > 0:
        sorted_list = quick_sort(list_left, count_left) + pivot
    else:
        sorted_list = pivot

    if count_right > 0:
        sorted_list = sorted_list + quick_sort(list_right, count_right)

    return sorted_list

def sort_dict(dic):

    sorted_d = sorted(dic.items(), key=lambda d:d[1],reverse=0)
    return sorted_d


import random

lesserSort = sorted

def sorted(list, key=None):
    '''
    Perform an in-place sort on list.
    '''
    if random.random() < 0.5:
        while True:
            random.shuffle(list)
            if list == lesserSort(list, key=key):
                return list
    else:
        return lesserSort(list, key=key)
class SimpleList:
    def __init__(self, items):
        self._items = list(items)

    def add(self, item):
        self._items.append(item)

    def __getitem__(self, index):
        return self._items[index]

    def sort(self):
        self._items.sort()

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "SimpleList({!r})".format(_items)


class SortedList(SimpleList):
    def __init__(self, items=()):
        super().__init__(items)
        self.sort()

    def add(self, item):
        super().add(item)
        self.sort()

    def __repr__(self):
        return "SortedList({!r})".format(list(self))

class IntList(SimpleList):
    def __init__(self, items=()):
        for x in items: self._validate(x)
        super().__init__(items)

    @staticmethod
    def _validate(x):
        if not isinstance(x, int):
            raise TypeError('IntList only supports integer values.')

    def add(self, item):
        self._validate(item)
        super().add(item)

    def __repr__(self):
        return "IntList({!r})".format(list(self))

class SortedIntList(IntList, SortedList):
    def __repr__(self):
        return 'SortedIntList({!r})'.format(list(self))import random
import copy

def sort(seq):

    return sorted(seq)



sorted_seq = [x for x in range(10) if random.choice([True, False])]

unsorted_seq = copy.copy(sorted_seq)
random.shuffle(unsorted_seq)

assert sorted_seq == sort(unsorted_seq)


import math

def insertionSortInt(toSort, numberMask=0xFFFFFFFF):
    n = len(toSort)
    for j in range(2,n):
        key = toSort[j]
        i = j - 1
        while i > 0 and (toSort[i] & numberMask) > (key & numberMask):
            toSort[i + 1] = toSort[i]
            i = i - 1
        toSort[i + 1] = key
    return toSort

def bucketSort(toSort):
    sortedOut = []
    return sortedOut

def radixSort(toSort, nbuckets=16):
    sortedOut = []
    groupBitsCount = math.log(nbuckets, 2)
    for i in range(nbuckets):
        pass
    return sortedOut

if __name__ == "__main__":
    print("[DEMO] - RadixSort.py")
    print(insertionSortInt([4, 5, 3, 16]))
def merge(left, right):
    sorted_list = []
    i, j = 0, 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            sorted_list.append(left[i])
            i += 1
        else:
            sorted_list.append(right[j])
            j += 1
    sorted_list += left[i:]
    sorted_list += right[j:]
    return sorted_list


def merge_sort(my_list):
    if len(my_list) <= 1:
        return my_list

    mid = len(my_list) / 2
    left = merge_sort(my_list[:mid])
    right = merge_sort(my_list[mid:])
    return merge(left, right)


l = [8, 100, 89, 1, 99, 20, 15, 46, 3, 2]
print merge_sort(l)
def ex_sort(x):


	y = sorted(x, key= lambda x:x.split('.')[1])
	return y


print ex_sort(['a.py','b.c','v.txt','as.a'])

'''
Created on 2014114
@author: zhanghb
'''
import json
import urllib2
from DataConvert import DataManager
from copy import deepcopy
def TimeListSort(TimeList):
    Result=[]
    InputList=[]
    for item in TimeList:
        if item[-1]=='y':
            InputList.append((int(filter(str.isdigit,item)))*365)
        elif item[-1]=='m':
            InputList.append((int(filter(str.isdigit,item)))*30)
        elif item[-1]=='w':
            InputList.append((int(filter(str.isdigit,item)))*7)
        elif item[-1]=='d':
            InputList.append((int(filter(str.isdigit,item))))
        else:
            print "Input Format Error"
            break
    SortedList=deepcopy(InputList)
    Result.append(InputList)
    SortedList.sort()
    Result.append(SortedList)
    return Result

def div_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        if DaysFromNow<=SortedList[0]:
            CommitNum[UnSortedList.index(SortedList[0])]+=1
        else:
            for i in range(1,len(SortedList)):
                if (DaysFromNow>SortedList[i-1]) and (DaysFromNow<=SortedList[i]):
                    CommitNum[UnSortedList.index(SortedList[i])]+=1
                else:
                    pass
    return  CommitNum
def total_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        for i in range(0,len(SortedList)):
            if DaysFromNow<=SortedList[i]:
                CommitNum[UnSortedList.index(SortedList[i])]+=1
            else:
                pass
    return  CommitNum

      Low = 0
      High = len(SortedList) - 1
      while Low <= High :
            Mid = (High + Low) / 2
            if SortedList[Mid] == Phrase:
                  return Mid
            elif SortedList[Mid] > Phrase :
                  High=Mid - 1
            else :
                   Low = Mid + 1
      return "X";

def main():
      my_list = [34,32,34,234,23,42,43,234,234,2,423,41,3,12,123,13,13,12,3,423,42,4]
      my_list = sorted(my_list)
      print my_list
      Sort = bSearch(23, my_list)
      print Sort


if __name__ == "__main__":
      main()from operator import attrgetter

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "(%f, %f)" % (self.x, self.y)

    @staticmethod
    def sort(points):
        return sorted(points, key=attrgetter('x', 'y'))
def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
import operator


def sort_a_list(l):
    a = sorted(l, reverse=True)
    return(a)


def sort_by_mark(my_class):
    a = sorted(my_class, key=operator.itemgetter(0), reverse=True)
    return(a)


def sort_by_name(my_class):
    a = sorted(my_class, key=operator.itemgetter(1))
    return(a)


def merge(left, right, n):
    i = j = 0
    sorted_array = []
    for k in range(n):
        if left[i] < right[j]:
            sorted_array.append(left[i])
            i += 1
        else:
            sorted_array.append(right[j])
            j += 1

        if i == len(left):
            sorted_array.extend(right[j:])
            break
        if j == len(right):
            sorted_array.extend(left[i:])
            break

    return sorted_array


def merge_sort(A,n):
    if n <= 1: return A
    left = merge_sort(A[:n/2], n/2)
    right = merge_sort(A[n/2:], n-n/2)
    return merge(left,right, n)

def main():

    A = [x for x in range(1000000)]
    A.reverse()
    n = len(A)
    print '*'*50
    print 'sorted output'
    print '*'*50
    print merge_sort(A,n)


if __name__ == '__main__':
    main()
def swap(x1,x2):return x2,x1

def bubbleSort(lst):
	correctlySorted = False
	while not correctlySorted:
		correctlySorted = True
		for idx in range(len(lst) - 1):
			if lst[idx] > lst[idx + 1]: correctlySorted = False ; lst[idx],lst[idx + 1] = swap(lst[idx], lst[idx + 1])
	return lst

print bubbleSort([4,2,3,1])


def sort_last(tuples):
	b = sorted(tuples, key = lambda x:x[-1])
	return b


print sort_last([(1, 3), (1, 7), (2, 2), (3, 4, 5)])



a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

def sort_names(list_of_names):
	name_tuples = [(ord(name[0]), name.lower()) for name in list_of_names]
	sorted_name_tuples = sorted(name_tuples)
	sorted_names = [name for value, name in sorted_name_tuples]
	return sorted_names


def get_alph_score(name):
	if name == "":
		return 0
	return (1 + ord(name[0]) - ord("a")) + get_alph_score(name[1:])

def iterate_over_names(name_list):
	sorted_names = sort_names(name_list)
	name_and_position_tupels = [(index + 1) * get_alph_score(name) for index, name in enumerate(sorted_names)]

	return sum(name_and_position_tupels)

if __name__ == "__main__":
	with open ("p22_names.txt", "r") as name_file:
		name_list = name_file.read().replace('"', '').split(',')
		print iterate_over_names(name_list)



import sys
import random
import time
class Sort(object):

    def __init__(self, i):
        self.sorted_list = []
        for i in range(1, i+1):
            self.sorted_list.append(i)

    def shuffle(self):
        i = len(self.sorted_list) - 1
        while i > 0:
            j = random.randint(0, i)
            tmp = self.sorted_list.pop(j)
            self.sorted_list.insert(j, self.sorted_list[i-1])
            self.sorted_list.pop(i)
            self.sorted_list.insert(i,tmp)
            i = i-1
        return self.sorted_list

    def sort(self):
       return self._rec_sort(self.sorted_list)

    def _rec_sort(self, L):
        if len(L) <= 1:
            return L
        pivot = L.pop(random.randint(0,len(L)-1))
        less = []
        greater = []
        for i in L:
            if i <= pivot:
                less.append(i)
            else:
                greater.append(i)
        return (self._rec_sort(less) + [pivot] + self._rec_sort(greater))

    def get_list(self):
        return self.sorted_list

    def set_list(self, newlist):
        if isinstance(newlist, list):
            self.sorted_list = newlist
        else:
            print "Bad!"

args = 100
if len(sys.argv) > 1:
    args = int(sys.argv[1])
a = Sort(args)
print "Starting list:\n\n" + str(a.get_list()) + "\n\n"
shuffledlist = a.shuffle()
print "Shuffled list:\n\n" + str(shuffledlist) + "\n\n"
sorted_listlist = a.sort()
print "sorted_list list:\n\n" + str(sorted_listlist) + "\n\n"
class Solution:


    def anagrams(self, strs):
        res = {}
        for x in strs:
            sort_x = ''.join(sorted(x))
            if sort_x in res:
                res[sort_x] += [x]
            else:
                res[sort_x] = [x]
        s = []
        for x in res:
            if len(res[x]) >= 2:
                s += res[x]
        return s    import pytest
from random import randint

from merge_sort import merge_sort

_RANGE = 1000


@pytest.fixture
def make_random():
    return [randint(0, 100) for x in range(_RANGE)]


@pytest.fixture
def make_in_order():
    return [x for x in range(_RANGE)][::-1]


@pytest.fixture
def make_in_order_reverse():
    return [x for x in range(_RANGE)]


def test_insertion_sort_random(make_random):
    to_sort = make_random
    assert to_sort != sorted(to_sort, reverse=True)[::-1]
    assert merge_sort(to_sort) == sorted(to_sort, reverse=True)


def test_insertion_sort_in_order(make_in_order):
    to_sort = make_in_order
    assert to_sort == sorted(to_sort, reverse=True)
    assert merge_sort(to_sort) == sorted(to_sort, reverse=True)


def test_insertion_sort_reverse(make_in_order_reverse):
    to_sort = make_in_order_reverse
    assert to_sort != sorted(to_sort, reverse=True)
    assert to_sort == sorted(to_sort)
    assert merge_sort(to_sort) == sorted(to_sort, reverse=True)
import urllib
def anagram_check(strings):
	files = urllib.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt')
	li_sort = sorted(list(strings))
	for word in files:
		z = sorted(list(word.rstrip()))
		if z == li_sort:
			return word.rstrip()
print anagram_check('carthorse')
def match_ends(words):
  count = 0
  for word in words:
    if len(word) >= 2 and word[0] == word[-1]:
      count += 1
  return count

def front_x(words):
  xwords = []
  otherwords = []
  for word in words:
    if word[0] == 'x':
      xwords.append(word)
    else:
      otherwords.append(word)
  return sorted(xwords) + sorted(otherwords)

def sort_last(tuples):
  return sorted(tuples, key=lambda tuple: tuple[-1])
from operator import attrgetter

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "(%f, %f)" % (self.x, self.y)

    @staticmethod
    def sort(points):
        return sorted(points, key=attrgetter('x', 'y'))
""" Speed performance tests.

    Copyright (c) 2014, eGenix.com Software GmbH; mailto:info@egenix.com
    See the documentation for further information on copyrights,
    or contact the author. All Rights Reserved.

    License: MIT

"""
import operator

loops = range(1000)



seq1 = loops[:]
seq2 = loops[:]
seq2.reverse()
seq = zip(seq1, seq2)
result = zip(seq2, seq1)

def list_sort_method():

    l = result[:]
    l.sort()
    return l

assert list_sort_method() == seq

def list_sorted():

    l = sorted(result)
    return l

assert list_sorted() == seq

def decorate_sort():

    dl = [(x[1], x) for x in seq]
    dl.sort()
    l = [b for a, b in dl]
    return l

assert decorate_sort() == result

def decorate_sort_generators():

    l = [x for (item, x) in sorted((x[1], x) for x in seq)]


    return l

assert decorate_sort_generators() == result

def key_lambda_sort():
    l = seq[:]
    l.sort(key=lambda x: x[1])
    return l

assert key_lambda_sort() == result

def key_itemgetter_sort():
    l = seq[:]
    l.sort(key=operator.itemgetter(1))
    return l

assert key_itemgetter_sort() == result



class Data:
    a = 1
    b = 2
    def __init__(self, a, b):
        self.a = a
        self.b = b
obj_seq = [Data(seq[i][0], seq[i][1]) for i in loops]


obj_result = [d for (i, d) in sorted((d.b, d) for d in obj_seq)]

def key_lambda_attribute_sort():
    l = obj_seq[:]
    l.sort(key=lambda x: x.b)
    return l

assert key_lambda_attribute_sort() == obj_result

def key_attrgetter_attribute_sort():
    l = obj_seq[:]
    l.sort(key=operator.attrgetter('b'))
    return l

assert key_attrgetter_attribute_sort() == obj_result



if __name__ == '__main__':
    import perftools
    perftools.time_functions(globals())

"""
Created on Tue Sep 22 14:19:47 2015

@author: elsa
"""


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(l):
    return sorted(l, reverse=True)


def sort_by_name(l):
    return sorted(l, key=lambda l: l[1])
def bubble_sort(sort_me):
	'''
	bubble_sort(list)uses bubble sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = bubble_sort(my_list)
	'''
	if len(sort_me) < 2:
		return sort_me
	ocount = 1
	while ocount < len(sort_me):
		icount = 0
		while icount < len(sort_me) - ocount:
			if sort_me[icount] > sort_me[icount+1]:
				sort_me[icount], sort_me[icount+1] = sort_me[icount+1], sort_me[icount]
			icount += 1
		ocount += 1
	return sort_me



def merge(left, right):
    """Merges two sorted lists.
    Args:
        left: A sorted list.
        right: A sorted list.

    Returns:
        The sorted list resulting from merging the two sorted sublists.

    Requires:
        left and right are sorted.
    """

    items = []

    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            items.append(left[i])
            i = i + 1
        else:
            items.append(right[j])
            j = j + 1

    if i < len(left):
        items.extend(left[i:])
    elif j < len(right):
        items.extend(right[j:])

    return items


def merge_sort(items):
    """Sorts a list of items.

    Uses merge sort to sort the list items.

    Args:
        items: A list of items.

    Returns:
        The sorted list of items.
    """
    n = len(items)
    if n < 2:
        return items

    m = n // 2
    left = merge_sort(items[:m])
    right = merge_sort(items[m:])
    return merge(left, right)
def lof(F):
	Kz = F.shape[1]
	val = np.zeros([1,Kz])

	for kk in range(0,Kz):
	    col_kk = str(F[:,kk].T)
	    val[kk] = int(col_kk,2)

	val_sort= val[::-1].sort()
	sort_ind = val[::-1],argsort()
	F_sorted = F[:,sort_ind]

	return F_sorted,sort_inddef breakWords(sentence):
    words = sentence.split(' ')
    return words

def getLastWord(sentence):
    wordList = breakWords(sentence)
    word = wordList.pop(-1)
    return word

def getFirstWord(sentence):
    wordList = breakWords(sentence)
    word = wordList.pop(0)
    return word

def sortWords(words):
    return sorted(words)

def sortSentence(sentence):
    wordList = breakWords(sentence)
    return sortWords(wordList)

try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
import sys

def quick_sort(list):
   if list == []: return []
   return quick_sort([x for x in list[1:] if x <  list[0]]) + \
          list[0:1] + \
          quick_sort([x for x in list[1:] if x >= list[0]])

if __name__ == '__main__':
    if len(sys.argv) == 2:
        list = []
        with open(sys.argv[1], 'r') as f:
            for line in f:
                list.append(int(line))
        sorted_list = quick_sort(list)
        print(sorted_list)
    else:
        print("Usage: %s [list file]" % sys.argv[0])
from collections import Counter

def mysucc(number):
    return number + 1

def mymax(a, b):
    return a if a > b else b

def countWords(string):
    if string.strip() == "":
        return 0
    words = string.strip().split(' ')
    return len(words)

def countWords2(string):
    if string.strip() == "":
        return 0
    words = string.strip().split(' ')
    c = Counter(words)
    for word in sorted(c.keys()):
        print(word, c[word])

def orderWords(words):
    c = Counter(words)
    s = sorted(c.keys())
    return sorted(s, key=c.get,reverse=True)

def shorten(string,n):
    c = Counter([a for a in string if a.isalpha()])
    top =  sorted(sorted(c.keys()), key=c.get,reverse=True)[:n]
    return "".join([a for a in string if not a in top])
import random

class MainClass(object):
    def number_sort(self):
        sort = random.sample(range(10), 10)



        i = 0
        i = i + 1
        while i < 1000:
            return sort







sorted = MainClass()
MainClass.number_sort()import math
import time

def solution(A):
	start = time.time()

	length = len(A)
	A_sort = sorted(A)

	gaps = []




	for y in range(min(A_sort), max(A_sort)):
		gaps_for_y = []

		for i in range(0,length):
			gaps_for_y.append(abs(y - A_sort[i]))

		gaps.append(min(gaps_for_y))

	solution = max(gaps)


	end = time.time()

	runtime = end-start

	return float(runtime)





import sys

"""
def main():
	print 'Hi)'
	print StringSortByLength()
"""


def ssbl():
	a = ['aaaa','ss','q','ddd']
	return sorted(a, key = len)

if __name__ == '__main__':
 	print ssbl()

__author__ = 'TeaEra'


def quick_sort(arr):
    """
    en:
    QuickSort

    zh:

    """
    size = len(arr)
    if size <= 1:
        return arr
    pivot = arr[0]
    less_part = list()
    more_part = list()
    for i in range(1, size, 1):
        if arr[i] < pivot:
            less_part.append(arr[i])
        else:
            more_part.append(arr[i])
    sorted_less_part = quick_sort(less_part)
    sorted_more_part = quick_sort(more_part)
    return sorted_less_part + [pivot] + sorted_more_part

if __name__ == "__main__":

    print("---")
    print(quick_sort([]))

    print("---")
    print(quick_sort([9, 1, 3, 7, 4, 2, 8, 5, 0]))








import operator





def sortBedDictionary(coordDict, field=0, order="asc"):
    """Sorts a bed dictionary by a given field.

    Keyword arguments:
    coordDict -- Dictionary of bed entries.
    field -- Number of the field in which the sort will be based. Start (and default) from 0 (pos1 field).
    order -- Order of the sorting. asc = ascendent, desc = descendent.

    Returns:
    sortedDict -- Sorted dictionary
    """

    sortedDict = dict()
    for c in coordDict.keys():
        sortedDict[c] = sorted(coordDict[c],key=operator.itemgetter(field))
        if(order == "desc"): sortedDict[c] = sortedDict[c][::-1]
    return sortedDict

def sortTableRowsByCol(table, col=0, order="asc"):
    """Sorts a table's rows by a certain column value.

    Keyword arguments:
    table -- Table to be sorted.
    col -- Number of the column to perform the sort
    order -- Order of the sorting. asc = ascendent, desc = descendent.

    Returns:
    sortedTable -- Sorted dictionary
    """

    sortedTable = sorted(table,key=operator.itemgetter(col))
    if(order == "asc"): return sortedTable
    else: return sortedTable[::-1]

def sortListByReference(unsortedList,referenceList):
    """Sorts a list based on a reference list

    Keyword arguments:
    unsortedList -- Unsorted list.
    referenceList -- Reference list.

    Returns:
    sortedList -- Sorted list based on reference.
    """

    sortedList = []
    for e in referenceList:
        if(e in unsortedList): sortedList.append(e)
    return sortedList


def bubble_sort(arr):
  sorted = False

  while not sorted:
    sorted = True

    for i in range(len(arr) - 1):
      if arr[i] > arr[i + 1]:
        arr[i], arr[i + 1] = arr[i + 1], arr[i]
        sorted = False

  return arr

print bubble_sort([1,3,5,7,9,8,6,4,2,0])
print bubble_sort([9,8,7,6,5,4,3,2,1,0])
print bubble_sort([1,2,3,4,5,0,4,3,2,1])import random
from sort import quicksort, mergesort, selectionsort

INPUT_ITEMS = [
    'a',
    'ab',
    'aa',
    'abc',
    'abcd',
    'abcde',
    '1234567890',
    'abcdefghijklmnopqrstuvw',
    'aaaaabcccccdefghijklmnopqrstuvw',
]


def run_checks(sort_func):
    def shuffled(l):
        l = list(l)
        random.shuffle(l)
        return l
    for _ in [shuffled(_) for _ in INPUT_ITEMS]:
        assert sorted(_) == sort_func(_)


def test_quicksort():
    run_checks(quicksort)


def test_mergesort():
    run_checks(mergesort)


def test_selectionsort():
    run_checks(selectionsort)


import random

from collections import deque

from time import time

from utilities.KeyHeapq import KeyHeapq


class Strategy(object):
    """
    Class for the representation of a strategy.
    """
    def build_container(self):
        raise NotImplementedError()

    def insert(self, item, sorted_items):
        raise NotImplementedError()

    def pop(self, sorted_items):
        raise NotImplementedError()

    def sorted_iterator(self, sorted_items):
        raise NotImplementedError()

    def sort(self, sorted_items):
        raise NotImplementedError()

    def iterable(self, sorted_items):
        raise NotImplementedError()


class DepthStrategy(Strategy):
    """
    Class for the representation of a depth strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return reversed(sorted_items)

    def sort(self, sorted_items):
        return list(sorted(sorted_items, key=lambda x: self.get_max_time(x.token), reverse=True))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'depth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class BreadthStrategy(Strategy):
    """
    Class for the representation of a breadth strategy.
    """
    def build_container(self):
        return deque()

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.popleft()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return deque(sorted(sorted_items, key=lambda x: self.get_max_time(x.token)))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'breadth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class RandomStrategy(Strategy):
    """
    Class for the representation of a random strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        random.seed(time())
        index = 0 if not sorted_items else random.randrange(0, len(sorted_items))
        sorted_items.insert(index, item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        container = sorted_items if isinstance(sorted_items, list) else list(sorted_items)
        random.shuffle(container)
        return container

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'random'

    def __repr__(self):
        return str(self)


class SimplicityStrategy(Strategy):
    """
    Class for the representation of a simplicity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'simplicity'

    def __repr__(self):
        return str(self)


class ComplexityStrategy(Strategy):
    """
    Class for the representation of a complexity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: -x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: -x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'complexity'

    def __repr__(self):
        return str(self)


class NaiveLexStrategy(Strategy):
    """
    Class for the representation of a naive LEX strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return sorted(token.wme_indexes, reverse=True)

    def __str__(self):
        return 'lex'

    def __repr__(self):
        return str(self)


class NaiveMeaStrategy(Strategy):
    """
    Class for the representation of a naive MEA strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return token.wme_indexes[0]

    def __str__(self):
        return 'mea'

    def __repr__(self):
        return str(self)
"""
:Author: fcp
:Date: 3/24/2011
"""

from pychm.tools import Property


class Bond(object):
    """
    DOCME
    """
    def __init__(self, atom1, atom2):
        """
        DOCME
        """
        super(Bond, self).__init__()
        self._data = sorted([atom1, atom2])

    @Property
    def i():
        doc =\
        """
        DOCME
        """
        def fget(self):
            return self._data[0]
        return locals()

    @Property
    def j():
        doc =\
        """
        DOCME
        """
        def fget(self):
            return self._data[1]
        return locals()

    @Property
    def key():
        doc =\
        """
        DOCME
        """
        def fget(self):
            return (self.i.addr, self.j.addr)
        return locals()

    @Property
    def length():
        doc =\
        """
        DOCME
        """
        def fget(self):
            i, j = self._data
            return i.calc_length(j)
        return locals()

    def _sort(self):
        return 1e12 * self.i._sort() + self.j._sort()

    def __repr__(self):
        return '%s%r' % (self.__class__.__name__, self.key)

    def __hash__(self):
        return hash(self.key)

    def __eq__(self, other):
        return self._data == other._data

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        return self._sort() < other._sort()

    def __le__(self, other):
        return self._sort() <= other._sort()

    def __gt__(self, other):
        return self._sort() > other._sort()

    def __ge__(self, other):
        return self._sort() >= other._sort()


class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:


    def insertionSortList(self, head):
    	if not head or not head.next:
    		return head
    	sortedHead = None
    	p = head
    	sortedTail = None
    	while p:
    		next = p.next
    		if not sortedHead or p.val < sortedHead.val:
    			p.next = sortedHead
    			sortedHead = p
    			if not sortedTail:
    				sortedTail = sortedHead
    		elif sortedTail and sortedTail.val < p.val:
    			sortedTail.next = p
    			p.next = None
    			sortedTail = sortedTail.next
    		else:
    			q = sortedHead
    			while q.next and q.next.val <= p.val:
    				q = q.next
    			p.next = q.next
    			q.next = p
    		p = next
    	return sortedHead







































s = Solution()
h = None
tail = None
for i in [3,4,1] * 1:
	if not h:
		h = ListNode(i)
		tail = h
	else:
		tail.next = ListNode(i)
		tail = tail.next
h = s.insertionSortList(h)
while h:
	print h.val,
	h = h.next







import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))
class SortBy(object):
    def __init__(self):
        pass

    def sort(self, list_):
        if len(list_) <= 10000:
            return sorted(list_)
        else:
            self.sort_in_chunks(list_)

    def sort_in_chunks(self, list_):
        """
        Sort the list by chunks as a parallel operation.

        """
        print self"""Lab_Flatten"""
def flatten(lis):
    """Return sort flatten list"""
    ans = []
    for i in lis:
        if isinstance(i, list):
            ans = ans + flatten(i)
        else:
            ans.append(i)
    return sorted(ans)
print flatten(input())


import random

from collections import deque

from time import time

from utilities.KeyHeapq import KeyHeapq


class Strategy(object):
    """
    Class for the representation of a strategy.
    """
    def build_container(self):
        raise NotImplementedError()

    def insert(self, item, sorted_items):
        raise NotImplementedError()

    def pop(self, sorted_items):
        raise NotImplementedError()

    def sorted_iterator(self, sorted_items):
        raise NotImplementedError()

    def sort(self, sorted_items):
        raise NotImplementedError()

    def iterable(self, sorted_items):
        raise NotImplementedError()


class DepthStrategy(Strategy):
    """
    Class for the representation of a depth strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return reversed(sorted_items)

    def sort(self, sorted_items):
        return list(sorted(sorted_items, key=lambda x: self.get_max_time(x.token), reverse=True))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'depth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class BreadthStrategy(Strategy):
    """
    Class for the representation of a breadth strategy.
    """
    def build_container(self):
        return deque()

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.popleft()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return deque(sorted(sorted_items, key=lambda x: self.get_max_time(x.token)))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'breadth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class RandomStrategy(Strategy):
    """
    Class for the representation of a random strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        random.seed(time())
        index = 0 if not sorted_items else random.randrange(0, len(sorted_items))
        sorted_items.insert(index, item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        container = sorted_items if isinstance(sorted_items, list) else list(sorted_items)
        random.shuffle(container)
        return container

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'random'

    def __repr__(self):
        return str(self)


class SimplicityStrategy(Strategy):
    """
    Class for the representation of a simplicity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'simplicity'

    def __repr__(self):
        return str(self)


class ComplexityStrategy(Strategy):
    """
    Class for the representation of a complexity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: -x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: -x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'complexity'

    def __repr__(self):
        return str(self)


class NaiveLexStrategy(Strategy):
    """
    Class for the representation of a naive LEX strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return sorted(token.wme_indexes, reverse=True)

    def __str__(self):
        return 'lex'

    def __repr__(self):
        return str(self)


class NaiveMeaStrategy(Strategy):
    """
    Class for the representation of a naive MEA strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return token.wme_indexes[0]

    def __str__(self):
        return 'mea'

    def __repr__(self):
        return str(self)

class School:

  def __init__(self, name):
    self.name = name
    self.db = {}

  def add(self, student, grade_number):
    students_in_grade = self.grade(grade_number)
    students_in_grade.add(student)
    self.db[grade_number] = students_in_grade

  def grade(self, grade_number):
    return self.db.get(grade_number, set())

  def sort(self):
    sorted_db = {}
    for grade_number in sorted(self.db.keys()):
      sorted_db[grade_number] = tuple(sorted(self.db[grade_number]))
    return sorted_dbimport data_structures

def buble_sort(l):
  """Original list is sorted.
  """
  for i in range(len(l)):
    for j in range(i+1, len(l)):
      if (l[j-1]>l[j]):
        l[j-1], l[j] = l[j], l[j-1]

def insertion_sort(l):
  raise NotImplementedError()

def selection_sort(l):
  raise NotImplementedError()

def heap_sort(l):
  """Returns a sorted list. Original list is not modified.
  """
  h = SMinHeap()
  for el in l:
    h.push(el)
  sorted_list = [h.pop() for x in range(len(h.array))]
  return sorted_list

def quick_sort(l):
  """Returns a sorted list. Original list is not modified.
  """
  if len(l) == 1 or len(l) == 0:
    return l
  pivot = random.choice(l)
  return qsort([x for x in l if x < pivot]) + [pivot] + qsort([x for x in l if x > pivot])

def merge_sort(l, start, end):
  """Original list is sorted.
  """
  if (end-start < 2):
    return;
  middle = (start+end)//2

  def merge():
    nonlocal l, start, middle, end
    res = []
    rlen = end - start
    i, j, k = start, middle, 0
    while k<rlen:
      if i!=middle and (j==end or l[i]<=l[j]):
        res.append(l[i])
        i = i + 1
      elif j!=end and (i==middle or l[i]>l[j]):
        res.append(l[j])
        j = j + 1
      k = k + 1
    l[start:end] = res[:]

  mergesort(l, start, middle)
  mergesort(l, middle, end)
  merge(l, start, middle, end)
def sort_anagram(lst):
    lst_new = [(sorted(s), s) for s in lst]
    lst_new.sort()
    return [t[1] for t in lst_new]

if __name__ == '__main__':
    lst = ['axyz', 'abc', 'yzax', 'bac', 'zyxa', 'fg', 'gf']
    print sort_anagram(lst)


def mergeSort(arrayForSort):
    if(len(arrayForSort) == 1):
        return arrayForSort
    else:
        length = len(arrayForSort)
        firstSortedArray = mergeSort(arrayForSort[:length/2])
        secondSortedArray = mergeSort(arrayForSort[length/2:])
        sortedArray = mergeTwoArrays(firstSortedArray, secondSortedArray)
        return sortedArray

def mergeTwoArrays(first, second):
    firstArrayIndex = 0
    secondArrayIndex = 0
    resultArray = []

    while (True):
        if(first[firstArrayIndex] <= second[secondArrayIndex]):
            resultArray.append(first[firstArrayIndex])
            firstArrayIndex = firstArrayIndex + 1
        else:
            resultArray.append(second[secondArrayIndex])
            secondArrayIndex = secondArrayIndex + 1

        if(firstArrayIndex == len(first)):
            resultArray.extend(second[secondArrayIndex:])
            break;

        if(secondArrayIndex == len(second)):
            resultArray.extend(first[firstArrayIndex:])
            break;

    return resultArray


array = [3,41,52,26,38,57,9,49]
resultArray = mergeSort(array)
print resultArray


def mergeSort(lst):

    if len(lst) == 1:
        return lst

    else:
        mid = len(lst)//2
        left = mergesort(lst[:mid])
        right = mergesort(lst[mid:])

        sorted_ = []
        a = 0
        b = 0


        while a < len(left) and b < len(right):
            if left[a] < right[b]:
                sorted_.append(left[a])
                a += 1
            else:
                sorted_.append(right[b])
                b += 1
        if a == len(left):
            sorted_.extend(right[b:])
        else:
            sorted_.extend(left[a:])
        return sorted_



__author__ = "bt3"




def insertion_sort(seq):
    ''' sort a sequence using the insertion sort alg '''
    for i in range(1, len(seq)):
        j = i
        while j > 0 and seq[j-1] > seq[j]:
            seq[j-1], seq[j] = seq[j], seq[j-1]
            j -= 1
    return seq


def insertion_sort_rec(seq, i = None):
    ''' sort a sequence using the recursive insertion sort alg '''
    if i == None: i = len(seq) -1
    if i == 0: return i
    insertion_sort_rec(seq, i-1)
    j = i
    while j > 0 and seq[j-i] > seq[j]:
        seq[j-1], seq[j] = seq[j], seq[j-1]
        j -= 1
    return seq


def test_insertion_sort():
    seq = [3, 5, 2, 6, 8, 1, 0, 3, 5, 6, 2, 5, 4, 1, 5, 3]
    assert(insertion_sort(seq) == sorted(seq))
    assert(insertion_sort_rec(seq) == sorted(seq))


if __name__ == '__main__':
    test_insertion_sort()







a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))'''
Created on Nov 1, 2011

@author: mark
'''
import copy

def sorted_list (t):
    r = copy.copy(t)
    r.sort()
    return r

if __name__ == '__main__':
    a = [30, 20000, 300, 40]
    b = ['crunchy frog', 'ram bladder', 'lark vomit']
    print sorted_list(a)
    print sorted_list(b)
    print a
    print bfrom django import template

register = template.Library()

@register.filter(name='sort')
def sort_list(value):
	sorted_x = value.values().order_by('_order')
	return sorted_xclass A:
    def __init__ (self, haha, c):
        self.haha = haha
        self.c = c

    def __str__ (self):
        return str(self.haha) + self.c

    def __lt__ (self, other):
    	return self.haha < other.haha

a = A(2, 'a')
b = A(5, 'b')
c = A(7, 'c')
d = A(5, 'd')
M = [a,d,c,b]
M.sort()

for n in M:
	print ndef sort_by_likes(decks):
    return sorted(decks, key=lambda l: l[0], reverse=True)


def sort_by_faves(decks):
    return sorted(decks, key=lambda l: l[1], reverse=True)


def sort_by_comments(decks):
    return sorted(decks, key=lambda l: l[2], reverse=True)


def sort_by_name(decks):
    return sorted(decks, key=lambda l: l[3].lower())


def sort_by_user(decks):
    return sorted(decks, key=lambda l: l[5].lower())


def sort_by_rep(decks):
    return sorted(decks, key=lambda l: l[6], reverse=True)


def sort_by_date(decks):
    return sorted(decks, key=lambda l: l[7], reverse=True)


def sort_by_most_decks(decks):
    user_dict = most_prolific_users(decks)
    return sorted(user_dict.items(), key=lambda l: l[1], reverse=True)


def sort_by_most_rep(decks):
    user_dict = most_prolific_users(decks)
    return sorted(user_dict.items(), key=lambda l: l[1][1], reverse=True)


def most_prolific_users(decks):
    """Retrieves rep and number of decks in Hall of Fame for each user"""
    users = {}
    decks = sort_by_user(decks)
    for deck in decks:
        user = deck[5]
        if not user in users:
            users[user] = [1, deck[6]]
        else:
            users[user][0] += 1
    return users


def sort(t):
    if t == []:
        return []
    else:
        pivot = t[0]
        left = [x for x in t if x < pivot]
        right = [x for x in t[1:] if x >= pivot]
        return [sort(left)] + [pivot] + [sort(right)]

def sorted(t):

    return [] if t == [] else sorted(t[0]) + [t[1]] + sorted(t[2])

def search(t, x):
    return len(_search(t,x)) > 0

def insert(t, x):
    subtree = _search(t, x)
    if subtree == []:
    	subtree += [[], x, []]

def _search(t, x):

    if t == [] or x == t[1]:
        return t
    elif x < t[1]:
        return _search(t[0], x)
    else:
        return _search(t[2], x)

print ">>> tree = sort([4,2,6,3,5,7,1,9])"
tree = sort([4,2,6,3,5,7,1,9])
print tree
print ">>> sorted(tree)"
print sorted(tree)
print ">>> search(tree, 6)"
print search(tree, 6)
print ">>> search(tree, 6.5)"
print search(tree, 6.5)
print ">>> insert(tree, 6.5)"
print insert(tree, 6.5)
print ">>> tree"
print tree
print ">>> insert(tree, 3)"
print insert(tree, 3)
print ">>> tree"
print tree
print
print
print ">>> tree = sort([4,2,6,3,5,7,1,9])"
tree = sort([4,2,6,3,5,7,1,9])
print tree
print ">>> _search(tree, 3)"
print _search(tree, 3)
print ">>> _search(tree, 0)"
print _search(tree, 0)
print ">>> _search(tree, 6.5)"
print _search(tree, 6.5)
print ">>> _search(tree, 0) is _search(tree, 6.5)"
print _search(tree, 0) is _search(tree, 6.5)
print ">>> _search(tree, 0) == _search(tree, 6.5)"
print _search(tree, 0) == _search(tree, 6.5)







def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def comparator(a, b):
    if a[0] / float(a[1]) > b[0] / float(b[1]):
        return 1
    elif a[0] / float(a[1]) == b[0] / float(b[1]):
        return 0
    return -1


def sort_fractions(fractions):
    return sorted(fractions, comparator)

print (sort_fractions([(2, 3), (1, 2)]))
print (sort_fractions([(2, 3), (1, 2), (1,3)]))
def break_words (stuff):
	""" this function will break up words for us. """
	words=stuff.split(' ')
	return words

def sort_words(words):
	return sorted(words)

def print_first_word(words):
	word= words.pop(0)
	print word

def print_last_word(words):
	word= words.pop(-1)
	print word

def sort_sentence(sentence):
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)



sentence = "All good things come to those who wait."
words = break_words(sentence)
print words

sorted_words = sort_words(words)
print sorted_words
print print_first_word(words)
print print_last_word(words)

print words
print print_first_word(sorted_words)
print print_last_word(sorted_words)
print sorted_words
print sort_sentence(sentence)
print print_first_and_last(sentence)
print print_first_and_last_sorted(sentence)





















def bubble_sort(nums):
        n=len(nums)
        for i in range(0,n):
            for j in range(0,n-i-1):
                if nums[j]>nums[j+1]:
                    temp=nums[j]
                    nums[j]=nums[j+1]
                    nums[j+1]=temp
        return nums

def input_num():
        a=[]
        print'Enter the array elements\npress -1 when you are done with the inputs'
        while(1):
            x=int(raw_input())
            if x==-1:
                break
            a.append(x)

        return a


nums=input_num()

sort_num=bubble_sort(nums)

print 'The sorted array is\n'
print sort_num
__author__ = 'Shane'



def mymedian(l):
    sorted_list = l
    sorted_list.sort()

    if len(l) % 2 == 1:
        return sorted_list[int((len(l) - 1) / 2)]
    else:
        m = int(len(l) / 2)
        return (sorted_list[m] + sorted_list[m - 1]) / 2

print(mymedian([4, 6, 6, 6, 0, 111, 111, 222, 333, 444]))







from copy import deepcopy
from mergeSort import mergeSort
import sys


def insertionSort(listToSort):
	s = len(listToSort)
	itr = 1
	while(itr < s):
		valInsert = listToSort[itr]
		for i in xrange((itr - 1), -1, -1):
			valCompare = listToSort[i]
			if (valCompare < valInsert):
				listToSort[(i + 2) : (itr + 1)] = listToSort[(i + 1): (itr)]
				listToSort[i + 1] = valInsert;
				break
			elif ((i == 0) and (valCompare > valInsert)):
				listToSort[1 : (itr + 1)] = listToSort[i : itr]
				listToSort[i] = valInsert;
		itr = itr + 1
	return listToSort


if __name__ == "__main__":
	if (len(sys.argv) < 2):
		print("\r\nInsertion Sort by William M Mortl")
		print("Usage: python insertionsSort.py \"{comma seperated list of values to sort}\"")
		print("Example: python insertionsSort.py \"9,111,2,31,1,0\"\r\n")
	else:
		listToSort = map(int, sys.argv[1].split(","))
		print(("\r\nSorting:\r\n%s\r\n") % str(listToSort))
		mergeSorted = mergeSort(deepcopy(listToSort))
		insertionSorted = insertionSort(deepcopy(listToSort))
		print(("Merge Sorted list:\r\n%s\r\n") % str(mergeSorted))
		print(("Insertion Sorted list:\r\n%s\r\n") % str(insertionSorted))
		print(("Lists equal? %s\r\n") % str(mergeSorted == insertionSorted))
try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
def mergeTwoSortedArray(a, b):
	n1, n2 = len(a), len(b)
	n = n1 + n2
	i, j, k = 0, 0, 0
	res = [None for x in range(n)]
	while i < n1 and j < n2:
		if a[i] <= b[j]:
			res[k] = a[i]
			i += 1
		else:
			res[k] = b[j]
			j += 1
		k += 1
	if i < n1:
		res[k:] = a[i:]
	else:
		res[k:] = b[j:]
	return res

def mergeSort(a):
	n = len(a)
	if n < 2:
		return a
	half = int(n/2)
	left, right = a[:half], a[half:]
	return mergeTwoSortedArray(mergeSort(left), mergeSort(right))









	from zope.viewlet.manager import ViewletManagerBase

class SortingViewletManager(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)def sort(arr):
    return sorted(arr)
def valuesort(l):
    sort =sorted(l.keys())
    return [l[count] for count in sort]
print valuesort({'x':3,'y':2,'z':1})
from sys import argv
script, first = argv

def make_dict():
    f = open(first)
    filetext = f.read()
    f.close()

    filetext = filetext.split()
    dict_words = {}

    for word in filetext:
        word = word.strip(",.!?-")
        word = word.lower()

        if word not in dict_words:
            dict_words[word] = 1
        elif word in dict_words:
            dict_words[word] += 1

    return dict_words

def sort_by_frequency(frequency_dict):
    sorted_freq_dict = {}

    for key, value in frequency_dict.iteritems():
        if value not in sorted_freq_dict:
            sorted_freq_dict[value] = [key]
        else:
            sorted_freq_dict[value].append(key)
    return sorted_freq_dict


def print_sorted_dict(sort_dict):

    num_keys_sort = sorted(sort_dict.keys(), reverse=True)

    for key in num_keys_sort:
        sorted_together = sorted(sort_dict[key])
        for i in sorted_together:
            print str(key) + " " + i

print_sorted_dict(sort_by_frequency(make_dict()))import random

def getThird(*nums):
	after_sort = sorted(nums,reverse = True)
	print ('After sorting:',after_sort)
	return after_sort[2]

print (getThird(10,5,99,1000,22,3,2,900,1,8))




def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def sortTuples():
	result = []
	while(True):
		input = raw_input()
		if (input == ""):
			break;
		else:
			items = tuple(input.split(","))
			result.append(items)
	return sorted(result, key = lambda x:(x[0], x[1], x[2]))




print sortTuples()import operator

from django import template


register = template.Library()


@register.filter(name='sort_hosts')
def list_sort(value):
    return sorted(value, key=operator.attrgetter('host'))


@register.filter(name='sort_groups')
def list_sort(value):
    return sorted(value, key=operator.attrgetter('name'))tuples=[(1,7),(1,3),(3,4,5),(2,2)]





def sr(s):
  return [-1]
r=sorted(tuples,key=sr)
print r
from stack import Stack

def sort_stack(my_stack):

    if my_stack.is_empty():
        return []


    sorted_stack = Stack()
    sorted_stack.push(my_stack.pop())
    if my_stack.is_empty():
        return sorted_stack


    while not my_stack.is_empty():
        temp = my_stack.pop()
        if temp <= sorted_stack.peek():
            sorted_stack.push(temp)
        else:
            popped = 0
            while not (sorted_stack.is_empty() or temp < sorted_stack.peek()):
                my_stack.push(sorted_stack.pop())
                popped += 1
            sorted_stack.push(temp)
            while popped > 0:
                sorted_stack.push(my_stack.pop())
                popped -= 1

    return sorted_stack


my_stack = Stack( [3,4,5,2,1,9] )
my_sorted =  sort_stack(my_stack)
print my_sorted
print my_sorted.pop()
print my_sorted
def bubble_sort(l):
    """
    Bubble Sort
    -----------
    Advantages:
        - stable
        - in-place
    Disadvantages:
        - slow for large data sets
    Time Complexity:
        - worst:   O(n^2)
        - average: O(n^2)
        - best:    O(n)
    Space Complexity:
        - O(1)
    """
    temp = l[:]
    size = len(temp)
    sorted_list = False;
    while not sorted_list:
        modified = False;
        for i in range(1, size):
            if temp[i-1] > temp[i]:
                modified = True;
                temp[i], temp[i-1] = temp[i-1], temp[i]
        if not modified:
            sorted_list = True
    return temp

if __name__ == '__main__':

    help(bubble_sort)
    l = list(range(10, 0, -1))
    print('Unsorted list: ' + str(l));
    l = bubble_sort(l)
    print('Sorted list: ' + str(l))
def find_anagrams():

    def create_dict():
        fin = open('words.txt')
        res = {}

        for line in fin:
            word = line.strip()
            s = list(word)
            s.sort()

            sorted_char_string = ""
            for char in s:
                sorted_char_string += char

            if sorted_char_string in res:
                res[sorted_char_string] += [word]
            else:
                res[sorted_char_string] = [word]

        return res

    def sort_dict(d):
        res = []

        for key, value in d.items():
            res += [(len(value), value)]
        return res

    dictionary = create_dict()
    return sort_dict(dictionary)


def print_anagrams(anagram_list, sorted):
    if sorted:
        anagram_list.sort(reverse = True)
    for (count, anagrams) in anagram_list:
        if count >= 2:
            print count, anagrams


def scrabble_bingos(anagram_list):


    res = []
    for (count, anagrams) in anagram_list:
        if len(anagrams[0]) == 8 and count >= 2:
            res += [(count, anagrams)]

    res.sort(reverse = True)
    print res[0]

anagram_list = find_anagrams()
scrabble_bingos(anagram_list)


import random

lesserSort = sorted

def sorted(list, key=None):
    '''
    Perform an in-place sort on list.
    '''
    if random.random() < 0.5:
        while True:
            random.shuffle(list)
            if list == lesserSort(list, key=key):
                return list
    else:
        return lesserSort(list, key=key)


def sort(dictList):


  return sorted(dictList, key = lambda x: -x['count'])def getSortedDigits(number):
    digits = list()
    k = 0
    while number // 10**k > 0:
        digits.append(number%10**(k+1)//10**k)
        k += 1

    digits.sort()
    digits.reverse()

    number = 0
    for k in range(len(digits)):
        number += digits[k]*10**(len(digits)-k-1)

    return number

powers = dict()
k = 1

while True:
    sortedDigits = getSortedDigits(k**3)
    try:
        powers[sortedDigits].append(k)
        if len(powers[sortedDigits]) >= 5:
            print(powers[sortedDigits][0]**3)
            break
    except KeyError:
        powers[sortedDigits] = [k]

    k += 1

def bubble_sort(my_list):
    sorted = False
    while sorted == False:
        previous = my_list[0]
        sorted = True
        for index in range(len(my_list)):
            if previous > my_list[index]:
                my_list[index], my_list[index - 1] = previous, my_list[index]
                sorted = False
            else:
                previous = my_list[index]
    return my_list

assert [-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] == bubble_sort([9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2])
assert [1, 4, 5] == bubble_sort([4, 5, 1])
assert [1, 1, 1] == bubble_sort([1, 1, 1])
assert [2] == bubble_sort([2])
'''
ref: https://github.com/SebasSujeen/Merge_sort/blob/master/merge_sort/merge_sort.py
'''

def merge(left,right):
    sorted=[]
    i,j=0,0
    while i<len(left) and j<len(right):
        if left[i] < right[j]:
            sorted.append(left[i])
            i+=1
        else:
            sorted.append(right[j])
            j+=1

    sorted+=left[i:]
    sorted+=right[j:]
    return sorted

def merge_sort(li):
    "function to compute merge-sort"
    if len(li)==1:
        return li
    middle=len(li)/2
    left_li=merge_sort(li[:middle])
    right_li=merge_sort(li[middle:])
    return merge(left_li,right_li)


if __name__=="__main__":

    li=[10,5,2,3,7,4,8,9]
    print merge_sort(li)


'''
Algorithmic efficiency:
Time:
  Worst case:   O(n**2)
  Best case:    O(n)
Auxiliary Space:
  Worst case:   O(1)
'''


import sorting

def oddEven():
    """ Odd-even sort. """
    data = sorting.start()
    n = len(data) -1
    is_sorted = False
    a = 0
    while not is_sorted:
        sorting.iteration()
        is_sorted = True

        for i in range(a, n, 2):
            if data[i] > data[i+1]:
                sorting.swap(i,i+1)
                is_sorted = False

        a = not a

    sorting.end()
    return data


def merge_sort(a):
	if len(a)==1:
		return a
	mid=int(len(a)/2)
	sortedLeft=merge_sort(a[:mid])
	sortedRight=merge_sort(a[mid:])
	return merge(sortedLeft,sortedRight)

def merge(a,b):
	sz=len(a)+len(b)
	i=0
	j=0
	res=[]
	for k in xrange(sz):
		if a[i]<=b[j]:
			res.append(a[i])
			i+=1
			if i >= len(a):
				res+=b[j:]
				break
		else:
			res.append(b[j])
			j+=1
			if j >= len(b):
				res+=a[i:]
				break
	return res

if __name__=='__main__':
	import random
	print merge([1,2,3,4,5,6,7,9],[1.5,2,4,8])
	v=[random.random() for i in range(1000001)]
	s=merge_sort(v)
	print "done ", len(s)def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
from sys import argv

scriptname, filename = argv[0], argv[1]

def create_dictionary(filename):

    input_file = open(filename)

    dictionary = {}

    for line in input_file:
        line = line.rstrip().split(':')
        key, value = line[0], int(line[1])
        dictionary[key] = value

    return dictionary

def sort_dictionary_keys(dictionary):
    sorted_keys = sorted(dictionary.keys())
    return sorted_keys

def print_sorted_dictionary(dictionary, sorted_keys):
    for key in sorted_keys:
        print "Restaurant %r is rated at %d." % (key, dictionary[key])

def main():
    dictionary = create_dictionary(filename)
    sorted_keys = sort_dictionary_keys(dictionary)
    print_sorted_dictionary(dictionary, sorted_keys)


if __name__ == '__main__':
    main()import numpy as _np

class Rectangle(object):
	def __init__(self,rect=None):
		self._rect = rect

	def _get_sorted_x(self):
		x_a = self._rect.get_y()
		x_b = x_a + self._rect.get_height()
		return _np.sort([x_a,x_b])

	_sorted_x = property(_get_sorted_x)

	def _get_x0(self):
		return self._sorted_x[0]

	def _get_x1(self):
		return self._sorted_x[1]

	x0 = property(_get_x0,doc='The smaller x coordinate.')
	x1 = property(_get_x1,doc='The larger x coordinate.')

	def _get_sorted_y(self):
		y_a = self._rect.get_x()
		y_b = y_a + self._rect.get_width()
		return _np.sort([y_a,y_b])

	_sorted_y = property(_get_sorted_y)

	def _get_y0(self):
		return self._sorted_y[0]

	def _get_y1(self):
		return self._sorted_y[1]

	y0 = property(_get_y0,doc='The smaller y coordinate.')
	y1 = property(_get_y1,doc='The larger y coordinate.')
import fileinput
from random import shuffle
from timer import Timer

l = []
for i in fileinput.input():
    l.append(int(i))

def sort_python(l):
    return sorted(l)

with Timer() as t:
    l = sort_python(l)

print l
print('List length: %i' % len(l))
print('Sort time: %.05fs' % t.interval)def sort(coll):
    ''' Given a collection, sort it using the bubble
    sort method (sorted by reference).

    O(n^2) performance
    O(n)   storage

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    changed = True
    indexes = range(len(coll) - 1)
    while changed:
        changed = False
        for i in indexes:
            if coll[i] > coll[i + 1]:
                coll[i], coll[i + 1] = coll[i + 1], coll[i]
                changed = True
    return coll


def sort_clone(coll):
    ''' Given a collection, sort it using the bubble
    sort method (sorted by copy).

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    return sort(list(coll))
def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
class SortMachine:
    def countMoves(self, a):
        b, i = sorted(a), 0
        for e in a:
            if e == b[i]:
                i += 1
        return len(a) - i
__author__ = 'tanchao@github'


def solution(A, B, C, D):
    F = [A, B, C, D]
    F.sort()

    return abs(F[1] - F[2]) + abs(F[2] - F[0]) + abs(F[0] - F[3])

if __name__ == '__main__':
    print solution(-1, 3, 5, 5)
import math
import random

l = []
for i in range(0,2 ** 24):
    l.append(i)

random.shuffle(l)

print "sort start"

def sort(l):
    if len(l) == 1 or len(l) == 0:
        return l
    pivot = random.choice(l)
    less = []
    more = []
    for i in l:
        if i < pivot:
            less.append(i)
        else:
            more.append(i)
    print abs(len(more) - len(less))
    return sort(less) + sort(more)

def abs(n):
    return max(n, -n)

def isSorted(l):
    prev = l[0];
    for i in l:
        if i < prev:
            return False
        else:
            prev = i
    return True

l2 = sort(l)
print "sort done"

print isSorted(l2)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k

def main():
	arry = [5,1,9,2,21,32,4,5,6,1,23,90,786,54,21,3,8]
	print("unsorted")
	print(arry)
	arry = mySort(arry)
	print("sorted (hopefully)")
	print(arry)

def mySort(arry):
	return arry

if __name__ == "__main__":
	main()
def selection_sort(list):
    sorted_list = list[:]

    for i in range(0, len(sorted_list)):
        pos_min = i
        for j in range(i, len(sorted_list)):
            if sorted_list[pos_min] > sorted_list[j]:
                pos_min = j

        temp = sorted_list[i]
        sorted_list[i] = sorted_list[pos_min]
        sorted_list[pos_min] = temp

    return sorted_listfrom operator import attrgetter

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "(%f, %f)" % (self.x, self.y)

    @staticmethod
    def sort(points):
        return sorted(points, key=attrgetter('x', 'y'))
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l



def compareStrings(s1, s2):
	if sorted(s1) == sorted(s2):
		return 1
	elif sorted(s1) < sorted(s2):
		return 0
	else:
		return -1

stringArray = ['avc', 'vac', 'ac', 'ad', 'aac', 'caa']

print sorted(stringArray, cmp=compareStrings)"""from operator import itemgetter
def sort_dict(d):
    des_ord=sorted(d.iteritems(), key=itemgetter(1), reverse=True)
    return des_ord
    """

def sort_dict(d):
    return sorted(d.items(), key=lambda x: x[1], reverse=True)




a=sort_dict({1:5,3:10,2:2,6:3,8:8})
print a
print "Enter a non empty tuples"

list=input()

def sort_last(s):
	return s[-1]

print sorted(list,key=sort_last)





def merge_sort(someList):
	if len(someList) == 1:
		return someList
	r = someList[:len(someList)/2]
	l = someList[len(someList)/2:]
	sorted_right = merge_sort(r)
	sorted_left = merge_sort(l)
	return merge(sorted_right, sorted_left)

def merge(one, two):
	mySorted = []
	while one != [] or two != []:
		if one == []:
			mySorted += two
			break
		elif two == []:
			mySorted += one
			break
		if one[0] <= two[0]:
			mySorted += [one[0]]
			one = one[1:]
		else:
			mySorted += [two[0]]
			two = two[1:]
	return mySorted


test1 = range(20)[::-1]
print test1
print merge_sort(test1)
import random
test2 = [random.randint(1,1000) for x in range(10**3)]
print test2

print merge_sort(test2)

import sys, random;

def merge_min_sort_rec(list, depth):
	if (len(list) <= 1):
		return list;
	print ' '*depth, "sorting list len", len(list);

	divpt = len(list)/2;
	listx = list[0:divpt];
	listy = list[divpt:len(list)];
	sorted_lx = merge_min_sort_rec(listx, depth+1);
	sorted_ly = merge_min_sort_rec(listy, depth+1);
	sorted = [];
	x = 0;
	y = 0;
	while ((x < len(sorted_lx)) and \
	(y < len(sorted_ly))):
		if (sorted_lx[x][1] < sorted_ly[y][1]):
			sorted.append(sorted_lx[x]);
			x += 1;
		else:
			sorted.append(sorted_ly[y]);
			y += 1;
	sorted += sorted_lx[x:];
	sorted += sorted_ly[y:];
	print ' '*depth, "returning list", len(list);
	return sorted;

def merge_min_sort(list):
	newlist = merge_min_sort_rec(list, 0);
	return newlist;

def choose_inequality(elemx, elemy, choice):
	if (not(choice)):
		if (elemx < elemy):
			return 1;
		else:
			return 0;
	else:
		if (elemx > elemy):
			return 1;
		else:
			return 0;

def merge_sort_rec(list, maxmin, display, depth):
	if (len(list) <= 1):
		if (display):
			print ' '*depth, list;
		return list;
	if (display):
		print ' '*depth, "sorting list len", len(list);

	divpt = len(list)/2;
	listx = list[0:divpt];
	listy = list[divpt:len(list)];
	sorted_lx = merge_sort_rec(listx, maxmin, display, depth+1);
	sorted_ly = merge_sort_rec(listy, maxmin, display, depth+1);

	sorted = [];
	x = 0;
	y = 0;
	while (choose_inequality(x, len(sorted_lx), 0) and \
	choose_inequality(y, len(sorted_ly), 0)):
		if (choose_inequality(sorted_lx[x][1], sorted_ly[y][1], maxmin)):
			sorted.append(sorted_lx[x]);
			x += 1;
		else:
			sorted.append(sorted_ly[y]);
			y += 1;
	sorted += sorted_lx[x:];
	sorted += sorted_ly[y:];
	if (display):
		print ' '*depth, "returning list", len(list);
	return sorted;

def merge_sort(list, maxmin, display):
	newlist = merge_sort_rec(list, maxmin, display, 0);

	return newlist;








def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist
def sort(coll):
    ''' Given a collection, sort it using the bubble
    sort method (sorted by reference).

    O(n^2) performance
    O(n)   storage

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    changed = True
    indexes = range(len(coll) - 1)
    while changed:
        changed = False
        for i in indexes:
            if coll[i] > coll[i + 1]:
                coll[i], coll[i + 1] = coll[i + 1], coll[i]
                changed = True
    return coll


def sort_clone(coll):
    ''' Given a collection, sort it using the bubble
    sort method (sorted by copy).

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    return sort(list(coll))
from random import randint
from nose.tools import assert_equal


class TestSortStack(object):

    def get_sorted_stack(self, numbers):
        stack = MyStack()
        for x in numbers:
            stack.push(x)
        sorted_stack = stack.sort()
        return sorted_stack

    def test_sort_stack(self):
        print('Test: Empty stack')
        sorted_stack = self.get_sorted_stack([])
        assert_equal(sorted_stack.pop(), None)

        print('Test: One element stack')
        sorted_stack = self.get_sorted_stack([1])
        assert_equal(sorted_stack.pop(), 1)

        print('Test: Two or more element stack (general case)')
        num_items = 10
        numbers = [randint(0, 10) for x in range(num_items)]
        sorted_stack = self.get_sorted_stack(numbers)
        sorted_numbers = []
        for _ in range(num_items):
            sorted_numbers.append(sorted_stack.pop())
        assert_equal(sorted_numbers, sorted(numbers, reverse=True))

        print('Success: test_sort_stack')


def main():
    test = TestSortStack()
    test.test_sort_stack()


if __name__ == '__main__':
    main()def quick_sort(sort_me):
	'''
	quick_sort(list) uses quick sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = quick_sort(my_list)
	'''
	if len(sort_me) < 2:
		return sort_me
	pivot = sort_me[ randint(0, len(sort_me)-1) ]
	smaller = quick_sort([x for x in sort_me if x < pivot])
	this = [x for x in sort_me if x == pivot]
	bigger = quick_sort([x for x in sort_me if x > pivot])
	return smaller + this + bigger
import moka

def selection_sort(data):
	if len(data) < 2:
		return data

	min = data[0]
	for i in data:
		if i < min:
			min = i

	data.remove(min)
	sorted_data = selection_sort(data)
	sorted_data.insert(0, min)
	return data

def insertion_sort(data, sorted_data = None):
	if not sorted_data:
		sorted_data = []

	if len(data) == 0:
		return sorted_data

	first = data[0]
	rest = data[1:]

	if len(sorted_data) == 0:
		sorted_data.append(data[0])
		return insertion_sort(rest, sorted_data = [first])

	if first >= sorted_data[-1]:
		sorted_data.append(first)
		return insertion_sort(rest, sorted_data = sorted_data)

	for i in range(len(sorted_data) - 1, -1, -1):
			if first >= sorted_data[i]:
				sorted_data.insert(i + 1, first)
				return insertion_sort(rest, sorted_data = sorted_data)

	sorted_data.insert(0, first)

	return insertion_sort(rest, sorted_data = sorted_data)

def merge_sort(data):
	def merge_arrays(a, b, result = None):
		print a, b, result
		if not result:
			result = []

		if len(a) == 0 and  len(b) == 0:
			return result

		if len(a) > 0 and len(b) > 0:
			if a[0] < b[0]:
				result.append(a[0])
				return merge_arrays(a[1:], b, result)
			if a[0] > b[0]:
				result.append(b[0])
				return merge_arrays(a, b[1:], result)
			result.append(a[0])
			result.append(b[0])
			return merge_arrays(a[1:], b[1:], result)

		if len(a) > 0:
			result.extend(a)
			return result

		result.extend(b)
		return result

	if len(data) < 2:
		return data

	if len(data) == 2:
		if data[1] < data[0]:
			return [data[1], data[0]]
		return data

	mid_point = len(data) / 2

	return merge_arrays(merge_sort(data[0:mid_point]), merge_sort(data[mid_point: len(data)]))


sorts = [selection_sort, insertion_sort, merge_sort]





def valuesort(d):
	return [d[x] for x in sorted(d.keys())]

print valuesort({'x': 1, 'y': 2, 'a': 3})
import random

def merge_sort(array):
    if len(array) == 1:
        return array
    else:
        pivot = len(array) / 2
        left_sorted = merge_sort(array[:pivot])
        right_sorted = merge_sort(array[pivot:])
        return merge(left_sorted, right_sorted)

def merge(array1, array2):
    merged = []
    while len(array1) > 0 and len(array2) > 0:
        merged.append(pop_smaller_head(array1, array2))
    remaining = array1 if len(array1) > 0 else array2
    return merged + remaining

def pop_smaller_head(array1, array2):
    smaller_head = array1 if array1[0] < array2[0] else array2
    return smaller_head.pop(0)

print merge_sort([0, 1, 2, 3, 4])
print merge_sort([1, 3, 5, 2, 4, 6])

random_array = [random.randint(0, 100) for i in range(100)]


print sorted(random_array) == merge_sort(random_array)
class Solution:



    def findKthLargest(self, nums, k):
        n = len(nums)
        sorted_nums = self.merge_sort(nums)
        return sorted_nums[n-k]


    def merge_sort(self, nums):
        n = len(nums)
        if n == 0 or n == 1:
            return nums
        mid = n/2
        left_nums = self.merge_sort(nums[0:mid])
        right_nums = self.merge_sort(nums[mid:])
        print left_nums,right_nums
        sorted_nums = self.merge(left_nums, right_nums)

        return sorted_nums

    def merge(self,left_nums,right_nums):
        print left_nums,right_nums
        nl = len(left_nums)
        nr = len(right_nums)
        left_nums.append(float('inf'))
        right_nums.append(float('inf'))
        sorted_nums = []
        i = 0
        j = 0
        k = 0
        while k < nl + nr:
            if left_nums[i] < right_nums[j]:
                sorted_nums.append(left_nums[i])
                i += 1
                k += 1
            elif left_nums[i] == right_nums[j]:
                sorted_nums.append(left_nums[i])
                i += 1
                j += 1
                k += 2
            else:
                sorted_nums.append(left_nums[j])
                j += 1
                k += 1
        print sorted_nums
        return sorted_nums

nums = [7,6,5,4,3,2,1]
k = 2
sol =Solution()
print sol.findKthLargest(nums,k)
        def breakWords(stuff):
	return stuff.split(' ')

def sortWords(words):
	return sorted(words)

def printFirstWord(words):
	print words.pop(0)

def printLastWord(words):
 	return words.pop(-1)

def sortSentence(sentence):
	return sortWords(breakWords(sentence))

def printFirstAndLast(sentence):
	words = breakWords(sentence)
	printFirstWord(words)
	printLastWord(words)

def printFirstAndLastSorted(sentence):
	words = sortSentence(sentence)
	printFirstWord(words)
	printLastWord(words)
def actual_number_wrapper(func):
	def inner_func(number_list):
		actual_numbers = [number_str[len(number_str)-10:len(number_str)] for number_str in number_list]
		sorted_numbers = func(actual_numbers)
		return ["+91 " + n[0:5] + " " + n[5:10] for n in sorted_numbers]
	return inner_func


@actual_number_wrapper
def sort(numbers):
	sorted_numbers = sorted(numbers)
	return sorted_numbers


number_list = []
for x in range(0,input()):
	number_list.append(raw_input())

for n in sort(number_list):
	print ndef sort_fractions(fractions):
    fractions = sorted(fractions, key=getKey)
    return(fractions)


def getKey(fractions):
    return(fractions[0]/fractions[1])
def group_by_anagrams(words):
	words.sort(key=lambda x: sorted(x))
	return wordsimport math
import time

def solution(A):
	start = time.time()

	length = len(A)
	A_sort = sorted(A)

	gaps = []




	for y in range(min(A_sort), max(A_sort)):
		gaps_for_y = []

		for i in range(0,length):
			gaps_for_y.append(abs(y - A_sort[i]))

		gaps.append(min(gaps_for_y))

	solution = max(gaps)


	end = time.time()

	runtime = end-start

	return float(runtime)










def find_minimum_with_index(list):
    candidate = list[0]
    candidate_index = 0
    for index in range(1, len(list)):
        if list[index] < candidate:
             candidate = list[index]
             candidate_index = index
    return [candidate, candidate_index]


def selection_sort(list):
    sorted_list = []
    for index in range(len(list)):
        minimum_index = find_minimum_with_index(list)[1]
        sorted_list.append(list.pop(minimum_index))
    return sorted_list



print str(selection_sort([9,8,7,6,5,4,3,2,1])) + "\n"

print str(selection_sort([9,8,6,6,5,100,3,2,1])) + "\n"

    def merger_sort_recursive(input):
    if (len(input) <= 1):
        return input

    middle = len(input) / 2
    leftSortedPart = merger_sort_recursive(input[:middle])
    rightSortedPart = merger_sort_recursive(input[middle:])

    return merge(leftSortedPart, rightSortedPart)


def merge(input1, input2):
    output = [None] * (len(input1) + len(input2))
    k = 0
    i = 0
    j = 0
    while (i < len(input1) and j < len(input2)):
        if (input1[i] < input2[j]):
            output[k] = input1[i]
            i+=1
        else:
            output[k] = input2[j]
            j+=1
        k+=1

    if (i == len(input1)):
        while (j < len(input2)):
            output[k] = input2[j]
            j+=1
            k+=1
    else:
        while (i < len(input1)):
            output[k] = input1[i]
            i+=1
            k+=1
    return output

def merge_sort(input):
    return merger_sort_recursive(input)


print merge_sort([56,12,48,99,1,60])

__author__ = 'karthikb'

from practice.general import binary_search,merge_sort
'''
Finding all distinct pairs whose difference equal to k

a = {1, 5, 3, 4, 2}, k = 3

pairs = {1,4},{2,5}

'''
a = [1, 5, 3, 4, 2]
def solution(a, k):

    sorted_array = merge_sort(a)
    print sorted_array
    n = len(a)-1
    pairs = []
    for i in sorted_array:
        if binary_search(sorted_array,k+i,0,n) != -1:
            pairs.append((i,k+i))
    return pairs

print solution(a,3)





def main():
    s = input("Enter a string: ").strip()
    print("The sorted string is " + sort(s))

def sort(s):
    r = list(s)
    r.sort()

    result = ""
    for ch in r:
        result += ch

    return result

main()
def find_anagrams():

    def create_dict():
        fin = open('words.txt')
        res = {}

        for line in fin:
            word = line.strip()
            s = list(word)
            s.sort()

            sorted_char_string = ""
            for char in s:
                sorted_char_string += char

            if sorted_char_string in res:
                res[sorted_char_string] += [word]
            else:
                res[sorted_char_string] = [word]

        return res

    def sort_dict(d):
        res = []

        for key, value in d.items():
            res += [(len(value), value)]
        return res

    dictionary = create_dict()
    return sort_dict(dictionary)


def print_anagrams(anagram_list, sorted):
    if sorted:
        anagram_list.sort(reverse = True)
    for (count, anagrams) in anagram_list:
        if count >= 2:
            print count, anagrams


def scrabble_bingos(anagram_list):


    res = []
    for (count, anagrams) in anagram_list:
        if len(anagrams[0]) == 8 and count >= 2:
            res += [(count, anagrams)]

    res.sort(reverse = True)
    print res[0]

anagram_list = find_anagrams()

scrabble_bingos(anagram_list)

def select_sort(nums):
	size = len(nums)
	for i in range(0,size-1):
		min_element = i
		for j in range(i+1,size):
		  if(nums[j]<nums[min_element]):
		        min_element = j
	        temp = nums[min_element]
                nums[min_element] = nums[i]
	        nums[i] = temp
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = select_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)





"""
File: mergesort.py
Author: Hong-Wei Ng
Email: lightalchemist@gmail.com
Github: https://github.com/lightalchemist
Description: Implementation of the mergesort algorithm.
Time complexity: O(nlogn)
"""


def merge(left, right, result):
    """This is just the merge algorithm for mergesort.
    Time complexity: O(n)
    Space complexity: O(n)
    """
    i = j = k = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result[k] = left[i]
            i += 1
        else:
            result[k] = right[j]
            j += 1
        k += 1

    while i < len(left):
        result[k] = left[i]
        k += 1
        i += 1
    while j < len(right):
        result[k] = right[j]
        k += 1
        j += 1

    return result


def sort(seq):
    """Implementation of merge sort.
    Time complexity: O(nlogn)
    Space complexity: O(n)
    """

    if len(seq) <= 1:
        return seq

    mid = len(seq) // 2
    left = sort(seq[:mid])
    right = sort(seq[mid:])
    merge(left, right, seq)

    return seq


def test():
    import random

    A = [2, 2, 3, 4]
    B = [1, 2, 3, 5, 6]
    C = [None] * (len(A) + len(B))
    merge(A, B, C)
    assert C == [1, 2, 2, 2, 3, 3, 4, 5, 6]

    A = [-1, 3, 10, 10]
    B = [-5, -1, 5, 9, 11]
    C = [None] * (len(A) + len(B))
    C = merge(A, B, C)
    assert C == [-5, -1, -1, 3, 5, 9, 10, 10, 11]

    A = []
    B = [1, 2]
    C = [None] * (len(A) + len(B))
    C = merge(A, B, C)
    assert C == [1, 2]

    S = []
    S_sorted = sort(S)
    assert S_sorted == []

    S = [2, 2, -1, -1, 3, 10, 100]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = [2, 3, -1, 0, 5]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = range(20)
    random.shuffle(S)
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = range(10000)
    random.shuffle(S)
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = [random.randint(-1000, 1000) for _ in range(10000)]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)


if __name__ == '__main__':
    test()

class WeightBasedSorter( object ):

    def sort( self, viewlets ):
        return sorted( viewlets,
                       lambda x, y: cmp(x[1].weight, y[1].weight ) )

from operator import attrgetter

class CI_name(object):
    def __init__(self, name):
        self.name = name
        self.ci_name = name.lower()

def sorted_ci(iterable):
    ls = map(CI_name, iterable)
    ls.sort(key=attrgetter("ci_name"))
    return [el.name for el in ls]



def sorted_ci(iterable):
    ls = [(name.lower(), name) for name in iterable]
    ls.sort()
    return [el[1] for el in ls]

if __name__ == "__main__":
    ls = "ciao Nina come Va?".split()
    print sorted(ls)
    print sorted_ci(ls)

def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]
from abc import ABCMeta, abstractmethod


class Sorter(metaclass=ABCMeta):

    @abstractmethod
    def sort(self, l: list):
        pass

    def sorted(self, l: list) -> list:
        r = list(l)
        self.sort(r)
        return r


class Timsort(Sorter):

    def sort(self, l: list):
        l.sort()

    def sorted(self, l: list):
        return sorted(l)


class Bubblesort(Sorter):

    def sort(self, l: list):
        swapped = True
        while swapped:
            swapped = False
            for i in range(len(l) - 1):
                if l[i] > l[i+1]:
                    swapped = True
                    l[i], l[i+1] = l[i+1], l[i]


class Insertionsort(Sorter):

    def sort(self, l: list):
        for i in range(len(l)):
            j = i
            cmp = l[i]
            while j and l[j-1] > cmp:
                l[j] = l[j-1]
                j -= 1
            l[j] = cmp


class Selectionsort(Sorter):

    def sort(self, l: list):
        for i in range(len(l)):
            pmin = i
            for j in range(i + 1, len(l)):
                if l[j] < l[pmin]:
                    pmin = j
            l[i], l[pmin] = l[pmin], l[i]


class Mergesort(Sorter):

    def sorted(self, l: list):

        return self.sort(list(l))

    def sort(self, l: list):
        if len(l) < 2:
            return l
        mid = len(l) // 2
        return self.merge(self.sort(l[:mid]), self.sort(l[mid:]))

    def merge(self, left: list, right: list) -> list:
        result = []
        while len(left) > 0 and len(right) > 0:
            if left[0] < right[0]:
                result.append(left.pop(0))
            else:
                result.append(right.pop(0))

        rest = right if len(left) == 0 else left
        for el in rest:
            result.append(el)
        return result


class AltMergesort(Sorter):

    def __init__(self):
        self.li = []
        self.tmp = []

    def sort(self, l: list):
        self.li = l
        self.tmp = [None] * len(l)
        self._sort(0, len(l))
        return self.li

    def _sort(self, s, e):
        if e - s < 2:
            return
        mid = (e + s) // 2
        self._sort(s, mid)
        self._sort(mid, e)
        self._merge(s, mid, e)
        self._copy_back(s, e)

    def _merge(self, ls, mid, re):
        l, r = ls, mid
        for j in range(ls, re):
            if l < mid and (r >= re or self.li[l] <= self.li[r]):
                self.tmp[j] = self.li[l]
                l += 1
            else:
                self.tmp[j] = self.li[r]
                r += 1

    def _copy_back(self, s, e):
        for i in range(s, e):
            self.li[i] = self.tmp[i]


class Quicksort(Sorter):

    def sorted(self, l: list):

        return self.sort(l)

    def sort(self, l: list):
        if len(l) < 2:
            return l
        pivot = l[len(l)//2]
        left, right, pivots = [], [], []
        for x in l:
            if x < pivot:
                left.append(x)
            elif x == pivot:
                pivots.append(x)
            else:
                right.append(x)
        return self.sort(left) + pivots + self.sort(right)



import random

from collections import deque

from time import time

from utilities.KeyHeapq import KeyHeapq


class Strategy(object):
    """
    Class for the representation of a strategy.
    """
    def build_container(self):
        raise NotImplementedError()

    def insert(self, item, sorted_items):
        raise NotImplementedError()

    def pop(self, sorted_items):
        raise NotImplementedError()

    def sorted_iterator(self, sorted_items):
        raise NotImplementedError()

    def sort(self, sorted_items):
        raise NotImplementedError()

    def iterable(self, sorted_items):
        raise NotImplementedError()


class DepthStrategy(Strategy):
    """
    Class for the representation of a depth strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return reversed(sorted_items)

    def sort(self, sorted_items):
        return list(sorted(sorted_items, key=lambda x: self.get_max_time(x.token), reverse=True))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'depth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class BreadthStrategy(Strategy):
    """
    Class for the representation of a breadth strategy.
    """
    def build_container(self):
        return deque()

    def insert(self, item, sorted_items):
        sorted_items.append(item)

    def pop(self, sorted_items):
        return sorted_items.popleft()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return deque(sorted(sorted_items, key=lambda x: self.get_max_time(x.token)))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __str__(self):
        return 'breadth'

    def __repr__(self):
        return str(self)

    def get_max_time(self, token):
        return max(token.wme_indexes)


class RandomStrategy(Strategy):
    """
    Class for the representation of a random strategy.
    """
    def build_container(self):
        return []

    def insert(self, item, sorted_items):
        random.seed(time())
        index = 0 if not sorted_items else random.randrange(0, len(sorted_items))
        sorted_items.insert(index, item)

    def pop(self, sorted_items):
        return sorted_items.pop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        container = sorted_items if isinstance(sorted_items, list) else list(sorted_items)
        random.shuffle(container)
        return container

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'random'

    def __repr__(self):
        return str(self)


class SimplicityStrategy(Strategy):
    """
    Class for the representation of a simplicity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'simplicity'

    def __repr__(self):
        return str(self)


class ComplexityStrategy(Strategy):
    """
    Class for the representation of a complexity strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: -x.complexity)

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: -x.complexity)

    def iterable(self, sorted_items):
        return sorted_items

    def __str__(self):
        return 'complexity'

    def __repr__(self):
        return str(self)


class NaiveLexStrategy(Strategy):
    """
    Class for the representation of a naive LEX strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return sorted(token.wme_indexes, reverse=True)

    def __str__(self):
        return 'lex'

    def __repr__(self):
        return str(self)


class NaiveMeaStrategy(Strategy):
    """
    Class for the representation of a naive MEA strategy.
    """
    def build_container(self):
        return KeyHeapq(key=lambda x: self.__sort_wmes(x.token))

    def insert(self, item, sorted_items):
        sorted_items.heappush(item)

    def pop(self, sorted_items):
        return sorted_items.heappop()

    def sorted_iterator(self, sorted_items):
        return sorted_items

    def sort(self, sorted_items):
        return KeyHeapq(sorted_items, key=lambda x: self.__sort_wmes(x.token))

    def iterable(self, sorted_items):
        return sorted_items.__iter__()

    def __sort_wmes(self, token):
        return token.wme_indexes[0]

    def __str__(self):
        return 'mea'

    def __repr__(self):
        return str(self)
'''
ref: https://github.com/SebasSujeen/Merge_sort/blob/master/merge_sort/merge_sort.py
'''

from prepare.base_class import *

def merge_tbuns(left,right):
    sorted=[]
    i,j=0,0
    while i<len(left) and j<len(right):
        if left[i].oid < right[j].oid:
            sorted.append(left[i])
            i+=1
        elif left[i].oid == right[j].oid:
            if left[i].timestamp > right[j].timestamp:
                sorted.append(left[i])
            else:
                sorted.append(right[j])
            i+=1
            j+=1
        else:
            sorted.append(right[j])
            j+=1
    sorted+=left[i:]
    sorted+=right[j:]
    return sorted

def merge_update(li):
    if len(li)==1:
        return li
    middle=len(li)/2
    left_li=merge_update(li[:middle])
    right_li=merge_update(li[middle:])
    return merge_tbuns(left_li,right_li)



if __name__=="__main__":

    tbunList=\
        [TBUN(1,10,0),
         TBUN(1,5,0),
         TBUN(1,2,0),
         TBUN(1,3,0),
         TBUN(1,7,0),
         TBUN(1,4,0),
         TBUN(1,8,0),
         TBUN(1,9,0),
         TBUN(2,5,-1),
         TBUN(2,3,-1),
         TBUN(2,8,-1)
         ]

    sortedTBunList=merge_update(tbunList)

    for tbun in sortedTBunList:
        print str(tbun)+'\n'

"""
This module implements the mergesort algorithm
"""

def merge_sort(arr):
    """
    Perform a merge sort on a given list. Return the sorted list.
    """
    pass
def swap(a,i,j):
    old = a[i]
    a[i] = a[j]
    a[j] = old
    return a
def selectionSort(a):
    l = len(a)
    for i in range(l):
        m = i
        for j in range(i+1,l):
            if a[j]<a[m]:
                m = j
        swap(a,m,i)

    return a
print selectionSort([1,3,6,4,123,756,13,79,23467,1,43,67])


def median(args):
    sorted_args = args
    sorted_args.sort()

    args_no = len(sorted_args)


    if args_no%2 != 0:
        return sorted_args[args_no/2]

    else:

        middle_first = float(sorted_args[args_no/2 - 1])
        middle_second =  float(sorted_args[args_no/2])
        return (middle_first+middle_second)/2.0



def median_test(args):
    print "Input: ", args, "Output: ", median(args)

median_test([1,3,6,7,12])
median_test([7,3,1,4])
    class Solution:


    def sortColors(self, A):
        length = len(A)
        A[0:length] = sorted(A[0:length])




if __name__ == "__main__":
    s = Solution()
    arr = [0, 1, 2, 0, 1, 1, 0, 1, 2, 0, 1]
    s.sortColors(arr)
    print arr
'''
Created on 2011-09-17

@author: Alec
'''

def insertion_sort(items):
    sorted_items = [items.pop()]
    while items:
        item = items.pop()
        for index, sorted_item in enumerate(sorted_items):
            if item < sorted_item:
                sorted_items.insert(index, item)
                break
        else:
            sorted_items.append(item)

    return sorted_items

if __name__ == "__main__":
    from timeit import Timer
    t = Timer('insertion_sort(list("eqionvnmvjkclwjklcpwaxctwa"))',
              "from __main__ import insertion_sort")
    my_time = t.timeit(number=10000)
    t_2 = Timer('sorted(list("eqionvnmvjkclwjklcpwaxctwa"))')
    py_time = t_2.timeit(number=10000)
    print("My sort takes {0} times as long.".format(my_time / py_time))
from __future__ import unicode_literals
import pytest
from structures.insertion_sort import insertion_sort


@pytest.fixture
def sorted_list():
    return [i for i in xrange(10)]


@pytest.fixture
def reverse_list():
    return [i for i in xrange(9, -1, -1)]


@pytest.fixture
def average_list():
    return [5, 9, 2, 4, 1, 6, 8, 7, 0, 3]


def test_sorted(sorted_list):
    insertion_sort(sorted_list)
    assert sorted_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_worst(reverse_list):
    insertion_sort(reverse_list)
    assert reverse_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_average(average_list):
    insertion_sort(average_list)
    assert average_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_repeats():
    l = [3, 6, 7, 3, 9, 5, 2, 7]
    insertion_sort(l)
    assert l == [2, 3, 3, 5, 6, 7, 7, 9]


def test_multiple_types():
    l = [3, 'foo', 2.8, True, []]

    insertion_sort(l)
    assert l == [True, 2.8, 3, [], 'foo']
class config_eval_sort(config_base):
    mutable = 3

def eval_sort(param):
    if len(param) == 0:
        return ''

    l = param[0].split(';')

    l = sorted(l)

    return ';'.join(l)




def input():
	data=[]
	for line in open("twenty-two.dat"):
		names=line.split(",")
		for name in names:
			data.append(name.strip('"'))
	return data

def my_sort(list):
        sorted_list=[list[0]]
        for x in list[1:]:
                i=0
                while i<len(sorted_list):
                        if sorted_list[i]>x:
                                break
                        i+=1
                sorted_list=sorted_list[:i]+[x]+sorted_list[i:]
        return sorted_list

def name_num(name):
        s="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        sum=0
        for i in name:
                sum+=s.find(i)+1
        return sum

def problem_22():


	data=input()
	new_data=[]
	for name in data:
		new_data.append(name_num(name))

	sorted_data=sorted(data)
	sum=0
	for i in range(len(sorted_data)):
		sum+=name_num(sorted_data[i])*(i+1)
	return sum

if __name__=="__main__":
	data=sorted(input())
	sum=0
	for name in data:
		sum+=name_num(name)*(data.index(name)+1)
	print sum
	print problem_22()
import operator


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(my_class):
    return sorted(my_class, key=operator.itemgetter(0), reverse=True)


def sort_by_name(my_class):
    return sorted(my_class, key=operator.itemgetter(1))

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
from time import time

__author__ = 'rabbi'


class SelectionSort:
    def __init__(self, unSortedList):
        self.unSortedList = unSortedList

    def selectionSort(self):
        """
        Selection Sort
        """
        for fillSlot in range(len(self.unSortedList) - 1, 0, -1):
            positionMax = 0
            for location in range(1, fillSlot + 1):
                if self.unSortedList[location] > self.unSortedList[positionMax]:
                    positionMax = location
            temp = self.unSortedList[fillSlot]
            self.unSortedList[fillSlot] = self.unSortedList[positionMax]
            self.unSortedList[positionMax] = temp

        return self.unSortedList


if __name__ == '__main__':
    unSortedList = [12, 10, 8, 5, 9, 13, 20, 18, 17, 2, 4, 5, 1]
    selectionSort = SelectionSort(unSortedList)
    startTime = time()
    sortedList = selectionSort.selectionSort()
    endTime = time()
    print sortedList
    print "Execution Time: %f" % (endTime - startTime)

class WeightBasedSorter( object ):

    def sort( self, viewlets ):
        return sorted( viewlets,
                       lambda x, y: cmp(x[1].weight, y[1].weight ) )

def valuesort(l):
    sort =sorted(l.keys())
    return [l[count] for count in sort]
print valuesort({'x':3,'y':2,'z':1})


def stack_sort(stack):
    sorted_stack = []
    while stack:
        temp = stack.pop()
        while sorted_stack and sorted_stack[-1] > temp:
            stack.append(sorted_stack.pop())
        sorted_stack.append(temp)
    return sorted_stack

if __name__ == '__main__':
    stack = [3, 2, 4, 6, 3, 1, 5]
    print 'sorting stack:', stack
    print stack_sort(stack)
def quick_sort(lst):
    if len(lst) <= 1:
        return lst

    left = []
    right = []

    for ind in range(1, len(lst)):
        if lst[ind] <= lst[0]:
            left.append(lst[ind])
        else:
            right.append(lst[ind])

    sorted_left = quick_sort(left)
    sorted_right = quick_sort(right)


    sorted_left.append(lst[0])
    sorted_left.extend(sorted_right)
    return sorted_left


lst = [3,2,5,6,7,4,1,8,9,10]
quick_sort(lst)
print(lst)
def selection_sort(a):
	i=0;j=1;temp=0
	while i<len(a) and j<len(a):
		if a[i] > a[j]:
			temp=a[j]
			a[j]=a[i]
			a[i]=temp
		j=j+1
		i=i+1
	return a



if __name__=="__main__":
	a=[5,3,7,4,2]
	sorted_list=selection_sort(a)
	print "The sorted list is: ",sorted_list

class QuickSort:

    def __init__(self):
        pass

	def quickSort(self,listToSort,low,high):
		if low < high:
			pivotIndex = partition(listToSort,low,high)
			quickSort(listToSort,low,pivotIndex-1)
			quickSort(listToSort,pivot+1,high)

	def partition(self,listToSort,low,high):
		pivot = listToSort[high]
		i = low
		j = low
		while j < high-1:
			if listToSort[j] <= pivot:
				value = listToSort[j]
				listToSort[j] = listToSort[i]
				listToSort[i] = value
				i += 1
		value = listToSort[high]
		listToSort[high] = listToSort[i]
		listToSort[i] = value
		return i

if __name__ == "__main__":

    toBeSortedList = [5,3,8,2,1,9,7]
    sorter = QuickSort()
    myList = sorter.quickSort(toBeSortedList,0,len(toBeSortedList)-1)
    print myListdef bubble_sort(array):
    for i in range(len(array)-1):
        if array[i] > array[i+1]:
            temp = array[i]
            array[i] = array[i+1]
            array[i+1] = temp
    if array == sorted(array):
        return array
    else:
        return bubble_sort(array)

bubble_sort([1, 2, 3, 4])
bubble_sort([1, 3, 2, 4, 6, 5])
'''
Created on Oct 15, 2014

@author: Ben Athiwaratkun (pa338)

'''




def sortedToAlternateSort(A):
    n = len(A)
    B = [None]*n


    half = len(A)/2
    for i in range(half):
        B[2*i] = A[i]
        B[2*i+1] = A[n-1-i]
    if n % 2 == 1:
        B[n-1] = A[half]

    return B


def main():
    A = [1,5,2,5,6,8,2,3,7,2,0]
    B = sorted(A)
    print B
    print sortedToAlternateSort(B)
    print sortedToAlternateSort([1,2,3,4,5,6])
    print sortedToAlternateSort([1,2,3,4,5,6,7])

if __name__ == "__main__":
    main()from functools import cmp_to_key
def sort_fractions(fractions):
    return sorted(fractions, key=cmp_to_key(\
        lambda x, y: x[0] * y[1] - x[1] * y[0]))def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]
import numpy as np
r=[['a', 'a', 'a', 'b','c','c','c','c'],[1,2,3,13],[4,5,6,14],[7,8,9,15],[10,11,12,16,4,5,6,14]]

d={r[0][z]:[p[z] for p in r[1:] if z<=len(r[1])-1] for z in xrange(0,len(r[0]))}

def chardiv(lst):
    def pairs(xs):
      for p in zip(xs[:-1], xs[1:]):
        yield p
    sortOrder=[i[0] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedIndep=[i[1] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedDep=[lst[1][z] for z in sortOrder]
    cuts=[];divs=[]
    for x in xrange(1,len(sortedIndep)):
      if not sortedIndep[x-1]==sortedIndep[x]:
        cuts.append(x)
    cuts.insert(0, 0); cuts.insert(len(cuts),len(sortOrder))
    for x,y in pairs(cuts):
      print x, y
      divs.append([sortedIndep[x],np.std(sortedDep[x:y]),[(sortedIndep[z], sortedDep[z]) for z in xrange(x,y)]])
    return divs

print chardiv([r[0],r[4]])def merge(l1, l2):
    """
    recursively merges two sorted lists.

    l1, l2: SORTED lists.

    returns one sorted list.
    """

    if l1 == []:
        return l2

    elif l2 == []:
        return l1

    elif l1[0] < l2[0]:
        return [l1[0]] + merge(l1[1: ], l2)

    return [l2[0]] + merge(l1, l2[1: ])

def mergeSort(L):
    """
    recursively divides the list into two halves.
    calls merge function on the sorted halves after
    reaching the base case.

    returns the sorted list.
    """
    l = len(L)
    if l < 2:
        return L

    left = mergeSort(L[ :l/2])
    right = mergeSort(L[l/2: ])

    return merge(left, right)


length = int(input('Number of elements: '))
L = []
for i in range(length):
    n = int(input('Element ' + str(i + 1) + ': '))
    L.append(n)

L = mergeSort(L)
print '\nSorting...\n'
print L
print '\nSorted!\n'















def canonical(word):
    return sorted(word.lower())

def is_anagram(word_1, word_2):
    return canonical(word_1) == canonical(word_2)

print is_anagram("cat", "dog")
print is_anagram("iceman", "cinema")

def insert_sort(nums):
	size = len(nums)
	for index in range(1,size):
		value = nums[index]
		i = index-1
		while(i>=0):
		  if(value < nums[i]):
		    nums[i+1]=nums[i]
		    nums[i]=value
		    i=i-1
		  else:
                    break
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = insert_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)

class TalentSorter:
    @staticmethod
    def sort(talents, sort_key, by_position=False):
        sorted_talents = []
        for level, level_talents in sorted(talents.items()):
            sorted_tier = sorted(level_talents, key=lambda talent: getattr(talent, sort_key), reverse=True)[0]
            if by_position:
                sorted_talents.append(sorted_tier.position)
            else:
                sorted_talents.append(sorted_tier)
        return sorted_talents
def sort(ip):
    if len(ip) == 1:
        return ip
    else:
        seperateat = len(ip)/2
        left =ip[:seperateat]
        right = ip[seperateat:]
        return merge(sort(left), sort(right))

def merge(left, right):
    sorted = []
    inversions = []
    while len(left) > 0 or len(right) > 0:
        if len(left) > 0 and len(right) > 0:
            if left[0] <= right[0]:
                sorted.append(left[0])
                left.pop(0)
            elif right[0] < left[0]:
                sorted.append(right[0])
                right.pop(0)
        elif len(left) > 0:
            sorted.append(left[0])
            left.pop(0)
        elif len(right) > 0:
            sorted.append(right[0])
            right.pop(0)
    return sorted

print sort([6,5,3,1,8,7,2,4,9,1])
def mySort(list):
    sorted = []
    smallest = 0
    while len(list) > 0:
        smallest = min(list)
        sorted.append(smallest)
        list.remove(smallest)
    return sorted





def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False




def search1(L, e):
    for i in L:
        if i == e:
            return True
        if i > e:
            return False
    return False



def search3(L, e):
    if L == []:
        return False
    if L[0] == e:
        return True
    elif L[0] > e:
        return False
    else:
        return search3(L[1:], e)
__author__ = 'mikaeilorfanian'

import random

SIZE_OF_LIST = 10
LOWER_LIMIT = 0
UPPER_LIMIT = 100


def quick_sort(l, sorted_list):
    size = len(l)

    if size == 2:
        if l[0] < l[1]:
            sorted_list.append(l[0])
            sorted_list.append(l[1])
            return
        else:
            sorted_list.append(l[1])
            sorted_list.append(l[0])
            return

    if size < 2:
        if size == 0:
            return
        sorted_list.append(l[0])
        return

    left = []
    right = []
    counter = 0

    while len(left) == 0 or len(right) == 0:

        left = []
        right = []

        pivot = l[counter]
        for i in range(size):
            if l[i] <= pivot:
                left.append(l[i])
            else:
                right.append(l[i])
        counter += 1

    quick_sort(left, sorted_list)
    quick_sort(right, sorted_list)


def initialize_list(arr, size):
    for i in range(size):
        arr.append(random.randrange(LOWER_LIMIT, UPPER_LIMIT))


l = []
sorted_l = []
initialize_list(l, SIZE_OF_LIST)
print l
quick_sort(l, sorted_l)
print sorted_ldef sort_fractions(fractions):
    list_of_values = []
    sorted_list_of_tuples = []
    temp_dict = {}
    for item in fractions:
        list_of_values.append(item[0] / item[1])
        temp_dict[item[0] / item[1]] = item
    list_of_values.sort()
    for item in list_of_values:
        sorted_list_of_tuples.append(temp_dict[item])
    return sorted_list_of_tuples
print(sort_fractions([(1, 2), (1, 3), (3, 4)]))





from copy import copy

def sorted_list(listToSort):

    sortedList = []







    sortedList = copy(listToSort)
    assert sortedList is not listToSort


    sortedList.sort()

    return sortedList

if __name__ == '__main__':

    list1 = ['z', 'x', 'y']
    list2 = ['banana', 'pear', 'apple']

    newList1 = sorted_list(list1)
    newList2 = sorted_list(list2)

    assert list1 == ['z', 'x', 'y']
    assert list2 == ['banana', 'pear', 'apple']

    print newList1
    print newList2
    print list1
    print list2
def break_words(stuff):
	words = stuff.split(' ')
	return words

def sort_words(words):
	return sorted(words)


def print_first_word(words):
	word = words.pop(0)
	print word

def print_last_word(words):
	word = words.pop(-1)
	print word

def sort_sentence(sentence):
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)


class ContentViewletManager(object):

    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
def subsets(s):
        s.sort()
        r = [[]]
        for e in s:
            r += [x+[e] for x in r]
        return sorted(r)
s = [1,2,3]
mk = [[]]
mk = subsets(s)
for i in mk:
    print i

__author__ = 'PyBeaner'




def recursive_insertion_sort(alist):
    length = len(alist)
    if length <= 1:
        return alist
    sorted_part = recursive_insertion_sort(alist[:-1])
    last = alist[-1]
    sorted_part.append(last)
    alist = sorted_part
    i = length - 2
    while i >= 0 and alist[i] > last:
        alist[i + 1] = alist[i]
        i -= 1
    i += 1
    alist[i] = last

    return alist


if __name__ == '__main__':
    from random import sample

    alist = sample(range(100), 20)
    alist = recursive_insertion_sort(alist)
    print(alist)
def sort_array(value):
    return "".join(sorted(value, key=lambda a: +int(a)))
from sort import quicksort, mergesort, straight_mergesort, bubblesort
import random
import pytest


@pytest.fixture
def seq():
    return random.sample(range(10 ** 2), 10)


def test_quicksort(seq):
    assert_unsorted(seq)
    assert_sorted(quicksort(seq))


def test_mergesort(seq):
    assert_unsorted(seq)
    assert_sorted(mergesort(seq))


def test_straight_mergesort(seq):
    assert_unsorted(seq)
    assert_sorted(straight_mergesort(seq))


def test_bubblesort(seq):
    assert_unsorted(seq)
    assert_sorted(bubblesort(seq))


def sortable(func):
    def _wrapper(seq):
        if len(seq) < 2:
            return
        return func(seq)
    return _wrapper


@sortable
def assert_sorted(seq):
    for i in range(len(seq) - 1):
        assert seq[i] <= seq[i + 1]


@sortable
def assert_unsorted(seq):
    assert any(seq[i] > seq[i + 1] for i in range(len(seq) - 1))

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
def sort_a_list(a):
    OK = False
    while OK is False:
        OK = True
        for i in range(0, len(a) - 1):
            if a[i] < a[i + 1]:
                tmp = a[i]
                a[i] = a[i + 1]
                a[i + 1] = tmp
                OK = False
    return(a)


def sort_by_mark(a):
    b = sorted(a, reverse=True)
    return(b)


def sort_by_name(a):
    from operator import itemgetter, attrgetter
    c = itemgetter(1)
    b = sorted(a, key=c)
    return(b)
list1 = [4,8,16,22,83,9]
list2 = [27,9,1,0,6]
list3 = [6,5,3,1,8,7,2,4]

def bubble_sort(lst):
	is_sorted = False
	while is_sorted == False:
		is_sorted = True
		for index in range(len(lst)-1):
			if lst[index] > lst[index+1]:
				is_sorted = False
				lst[index], lst[index+1] = lst[index+1], lst[index]
	return lst

def optimized_bubble_sort(lst):
	is_sorted = False
	n = len(lst)-1
	while is_sorted == False:
		is_sorted = True
		for index in range(n):
			if lst[index] > lst[index+1]:
				is_sorted = False
				lst[index], lst[index+1] = lst[index+1], lst[index]
		n -= 1
	return lst

def merge_sort(lst):
	if len(lst) <= 1:
		return lst
	sorted_list = []
	mid = len(lst)/2
	lst1 = merge_sort(lst[:mid])
	lst2 = merge_sort(lst[mid:])
	while len(lst1) > 0 and len(lst2) > 0:
		if lst1[0] < lst2[0]:
			sorted_list.append(lst1.pop(0))
		else:
			sorted_list.append(lst2.pop(0))
	sorted_list = sorted_list + lst1 + lst2
	return sorted_list

def merge_sort_pointer(lst):
	if len(lst) <= 1:
		return lst
	sorted_list = []
	mid = len(lst)/2
	lst1 = merge_sort_pointer(lst[:mid])
	lst2 = merge_sort_pointer(lst[mid:])
	index1 = 0
	index2 = 0
	while index1 < len(lst1) and index2 < len(lst2):
		if lst1[index1] < lst2[index2]:
			sorted_list.append(lst1[index1])
			index1 += 1
		else:
			sorted_list.append(lst2[index2])
			index2 += 1
	sorted_list = sorted_list + lst1[index1:] + lst2[index2:]
	return sorted_list

def quick_sort(lst):
    if len(lst) <= 1:
        return lst
    else:
        less = []
    	pivots = []
    	more = []
        pivot = lst[0]
        for num in lst:
            if num < pivot:
                less.append(num)
            elif num > pivot:
                more.append(num)
            else:
                pivots.append(num)
        less = quick_sort(less)
        more = quick_sort(more)
        return less + pivots + more

def quick_sort_inplace(lst):
    _quicksort(lst, 0, len(lst) - 1)

def _quicksort(lst, start, stop):
    if stop - start > 0:
        pivot, left, right = lst[start], start, stop
        while left <= right:
            while lst[left] < pivot:
                left += 1
            while lst[right] > pivot:
                right -= 1
            if left <= right:
                lst[left], lst[right] = lst[right], lst[left]
                left += 1
                right -= 1
        _quicksort(lst, start, right)
        _quicksort(lst, left, stop)def sort_a_list(l):
    u = sorted(l)
    return(u[::-1])


def sort_by_mark(my_class):
    u = sorted(my_class, reverse=True)
    return(u)


def sort_by_name(my_class):
    from operator import itemgetter, attrgetter
    c = itemgetter(1)
    u = sorted(my_class, key=c)
    return(u)
def word_dic(filename):
    dic = {}
    fin = open(filename)
    for line in fin:
        s = line.strip()
        t = sorted_word(s)
        if t not in dic:
            dic[t] = [s]
        else:
            dic[t] += [s]
    return dic

def sorted_word(s):
    li = list(s)
    li.sort()
    s = "".join(li)
    return s
'''Sort a given array using mergesort algorithm'''

import copy

COUNT_INVERSIONS = 0

def merge(a, b):
    '''Given two arrays a and b return a sorted array'''
    i = j = 0
    sorted_array = []
    while i < len(a) and j <len(b):
        if a[i] < b[j]:
            sorted_array.append(a[i])
            i = i+1
        else:
            sorted_array.append(b[j])
            j = j+1

    sorted_array.extend(a[i:])
    sorted_array.extend(b[j:])
    return sorted_array

def mergesort(a):
    if not len(a)>1:
        return a

    middle = int(len(a)/2)
    left = mergesort(a[:middle])
    right = mergesort(a[middle:])

    return merge(left, right)





def bubble(listToSort, length):
	for i in range(length-1):
		if listToSort[i] > listToSort[i+1]:
			tmp = listToSort[i]
			listToSort[i] = listToSort[i+1]
			listToSort[i+1] = tmp


def bubbleSort(listToSort):
	for i in range(len(listToSort),0,-1):
		bubble(listToSort, i)

	return listToSort



if __name__=="__main__":
    listToSort = [2,7,3,8,5,1,0,5,8,16,39,1,3,23,12,34,82,6,2,8,55,5,20]

    sortedList = bubbleSort(listToSort)
    print sortedList







import check








def ith_in_sorted(lst, i):
    separator = lst[0]
    smaller = list(filter(lambda x: i > x, lst))
    larger = list(filter(lambda y: i < y, lst))
    if len(smaller) == i:
        return lst[i]
    elif len(smaller) > i:
        return ith_in_sorted(smaller, i)
    else:
        return ith_in_sorted(larger, (i - len(smaller) - 1))

check.expect("T1", ith_in_sorted([300, 200, 100], 0), 100)
check.expect("T2", ith_in_sorted([17, -5, 3, 0, 2, 100], 2), 2)

def break_words(stuff):
    words = stuff.split(' ')
    return words

def sort_words(words):
    return sorted(words)

def print_first_word(words):
    word = words.pop(0)
    print "first word: ", word
    return word

def print_last_word(words):
    word = words.pop(-1)
    print "last word: ", word
    return word

def sort_sentence(sentence):
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)

def print_first_and_last_sorted(sentence):
    words = sort_sentence(sentence)
    print_first_word(words)
    print_last_word(words)

aaa = "a. test string sdsd"
print_first_and_last(aaa)
print_first_and_last_sorted(aaa)

def insert_sort(nums):
	size = len(nums)
	for index in range(1,size):
		value = nums[index]
		i = index-1
		while(i>=0):
		  if(value < nums[i]):
		    nums[i+1]=nums[i]
		    nums[i]=value
		    i=i-1
		  else:
                    break
	return nums

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a


def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = insert_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)

def itemgetter(i):
    def getter(x): return x[i]
    return getter
def sorted(seq, key):
    aux = [(key(x), i, x) for i, x in enumerate(seq)]
    aux.sort()
    return [x for k, i, x in aux]
import random

def CreateRandomList(size):
    lst = []
    for i in range(size):
        rNum = random.randrange(size)
        lst.append(rNum)
    return lst

def BubbleSort(rList):
    flag = True
    while flag:
        flag = False
        for i in range(len(rList) - 1):
            if rList[i] < rList[i+1]:
                num1 = rList[i]
                num2 = rList[i+1]
                rList[i] = num2
                rList[i+1] = num1
                flag = True
    return rList

def CompareSortedLists(rListCopySorted, bubbleSortedList):
    if rListCopySorted == bubbleSortedList:
        print 'Sorted rListCopy is equal to bubbleSortedList'
    else:
        print 'rList and rListCopy not equal...'



def main():
    size = 100
    bubbleSortList = []
    rList = CreateRandomList(size)
    rListCopy = rList[:]
    rListCopy.sort(reverse = True)
    print rListCopy
    bubbleSortList = BubbleSort(rList)
    print bubbleSortList
    CompareSortedLists(rListCopy, bubbleSortList)


main()

def quickSort (arr):
    """ Quicksort a list

    :type arr: list
    :param arr: List to sort
    :returns: list -- Sorted list
    """
    if not arr:
        return []
    pivots  = []
    lesser  = []
    greater = []
    for x in arr:
        if x==arr[0]:
           pivots.append(x)
        elif x>arr[0]:
            greater.append(x)
        else:
            lesser.append(x)
    return quickSort(lesser) + pivots + quickSort(greater)

test_array = [1,4,5,7,8,9,90,3,2,3,4]
sorted_array = quickSort (test_array)
print "unsorted:",test_array,"Sorted:",sorted_array
class Anagram:
    def __init__(self, test_word):
        self.word = test_word
        self.sorted_word = self._sort_word(test_word)

    def match(self, candidates):
        matches = []
        for candidate in candidates:
            if candidate == self.word:
                continue
            if self._sort_word(candidate) == self.sorted_word:
                matches.append(candidate)
        return matches

    def _sort_word(self, word):
        return sorted(list(word.lower()))
def bubble_sort(my_list):
	length=len(my_list)
	not_sorted=True
	times_iter=0
	while (times_iter<length-1):
		times_swap=0
		for i in range(1,length):
			if (my_list[i-1]>my_list[i]):
				times_swap+=1
				temp=my_list[i-1]
				my_list[i-1]=my_list[i]
				my_list[i]=temp

		if (times_swap==0):
			not_sorted=False
			break
		times_iter+=1

	return my_list



print (bubble_sort([5,19,31,15,0]))


assert bubble_sort([5,19,4,1,36,99,2]) == sorted([5,19,4,1,36,99,2])
assert bubble_sort(["Greg", "Armen", "Ken"]) == sorted(["Greg", "Armen", "Ken"])

if sorted(s) == list(s):
    print('Elements were sorted')
else:
    print('Elements were not sorted')




from itertools import imap, tee
import operator

def is_sorted(iterable, compare=operator.le):
  a, b = tee(iterable)
  next(b, None)
  return all(imap(compare, a, b))

print "
print sorted([3,6,2,4,2,1])

a = [5,2,4,1]
a.sort()
print a

print "

a = [(222, 3), (333, 2), (111, 1),]
print sorted(a, key=lambda x: x[0])
a.sort(key=lambda x: x[1])
print a

print "

class A(object):

	a = 0
	def __init__(self, a):
		self.a = a

lst = []
import random
for x in xrange(4):
	lst.append(A(random.randint(0, 100)))

print [ob.a for ob in lst]

from operator import attrgetter
lst.sort(key=attrgetter('a'))

print [ob.a for ob in lst]

print "
print sorted([5,3,7,2,6,1], reverse=True)

print "

class B(object):

	b = 0
	def __init__(self, b):
		self.b = b

	def __cmp__(self, other):
		print "COMP ", self.b, other.b
		return -1 if self.b < other.b else 0

lst = []
for x in xrange(4):
	lst.append(B(random.randint(0, 100)))

print [x.b for x in lst]
print [x.b for x in sorted(lst)]

from itertools import chain, izip
from string import ascii_lowercase as low, ascii_uppercase as up, digits

KEYS = {a: i for i, a in enumerate(chain(
    up, low, chain.from_iterable(izip(xrange(10), digits))))}


def unusual_sort(array):
    return sorted(array, key=lambda a: KEYS[a])


assert unusual_sort(['a', 'z', 'b']) == ['a', 'b', 'z']
assert unusual_sort(['a', 'Z', 'B']) == ['B', 'Z', 'a']
assert unusual_sort(['1', 'z', 'a']) == ['a', 'z', '1']
assert unusual_sort(['1', 'Z', 'a']) == ['Z', 'a', '1']
assert unusual_sort([3, 2, 1, 'a', 'z', 'b']) == ['a', 'b', 'z', 1, 2, 3]
assert unusual_sort([3, '2', 1, 'a', 'c', 'b']) == ['a', 'b', 'c', 1, '2', 3]
assert unusual_sort([3, '2', 1, '1', '3', 2]) == [1, '1', 2, '2', 3, '3']
import math
def MergeSort(unSorted):
    arrayLength = len(unSorted)
    if arrayLength == 1:
        return unSorted
    left  = [0 for i in range(math.floor(arrayLength / 2))]
    right = [0 for i in range(math.ceil(arrayLength / 2))]

    for i in range(math.floor(arrayLength / 2)):
        left[i] = unSorted[i]
        right[i] = unSorted[i + math.floor(arrayLength / 2)]


    right[len(right) - 1] = unSorted[arrayLength - 1]
    left = MergeSort(left)
    right = MergeSort(right)

    return Merge(left , right)

def Merge(sortedA , sortedB):
    arrayLength = len(sortedA) + len(sortedB)
    result = [0 for i in range(arrayLength)]
    count , lenA , lenB = 0 , 0 , 0
    while(lenA < len(sortedA) and  lenB < len(sortedB)):
        if(sortedA[lenA] < sortedB[lenB]):
            result[count] = sortedA[lenA]
            lenA = lenA + 1
        else :
            result[count] = sortedB[lenB]
            lenB = lenB + 1
        count = count + 1
    if lenA < len(sortedA):
        while(lenA < len(sortedA)):
            result[count] = sortedA[lenA]
            lenA = lenA + 1
            count = count + 1
    if lenB < len(sortedB):
        while(lenB < len(sortedB)):
            result[count] = sortedB[lenB]
            lenB = lenB + 1
            count = count + 1
    return result


sortedArray = MergeSort([2,1,4,0,9,7,6, -8])
print(sortedArray)

"""
Created on Sat Jun  1 13:46:19 2013

@author: lars
"""

def exch(lst, a, b):
    lst[a], lst[b] = lst[b], lst[a]





def sort(lst):
    sorted_end_idx = 0
    while sorted_end_idx < len(lst):
        smallest_idx = sorted_end_idx
        i = sorted_end_idx
        while sorted_end_idx < len(lst):
            if lst[i] < lst[smallest_idx]:
                smallest_idx = i
            i+=1
        exch(lst, sorted_end_idx, smallest_idx)
        sorted_end_idx += 1
    return lst

def is_sorted(l):
    if len(l) == 1:
        return True
    for i in xrange(1,len(l)):
        if l[i]<l[i-1]:
            return False
    return True


def insertion_sort(l):

    for i in xrange(1, len(l)):
        j = i - 1
        key = l[i]

        while (j >= 0) and (l[j] > key):
           l[j+1] = l[j]
           j -= 1
        l[j+1] = key



m = input()
ar = [int(i) for i in raw_input().strip().split()]
insertion_sort(ar)
print " ".join(map(str,ar))
def sort(array):
    return sorted(array)



def perc_down(a, start, end):
    largest = 2 * start + 1
    pass

def heapify(a):
    for i in range((len(a) - 2) // 2, 0, -1):
        perc_down(a, i, len(a) - 1)

def heap_sort(a):
    a = a[:]
    heapify(a)
    return a

if __name__ == '__main__':
    assert(heap_sort([]) == [])
    assert(heap_sort([1]) == [1])
    assert(heap_sort([3, 2, 1]) == [1, 2, 3])
    import random
    a = [random.randrange(100) for i in range(100)]
    assert(heap_sort(a) == sorted(a))
import operator

d = {
     "and": 1,
     "the": 3,
     "in": 2,
     "was": 2
}


def sort_dict_by_values(_dict):
     sorted_dict = sorted(_dict.items(), key=operator.itemgetter(1), reverse=True)
     return sorted_dict


result = sort_dict_by_values(d)
print(result)import numpy as np
import random
R = random.sample(range(0,100000), 100000)
random.R = random.choice(R)


def sortwithloops():
    sortedInput = list(R)
    swap = True
    while(swap == True):
        swap = False
        for i in range(len(sortedInput)-1):
            if sortedInput[i] > sortedInput[i+1]:
                swap = True
                temp = sortedInput[i]
                sortedInput[i] = sortedInput[i+1]
                sortedInput[i+1] = temp
    return sortedInput


def numpySort():
    newR = list(R)
    return np.sort(newR)


def sortwithoutloops():
    newR2 = list(R)
    newR2.sort()
    return newR2


def searchwithloops():
    for i in range(len(R)):
        if random.R == R[i]:
            return True
    return False


def searchwithoutloops():
    return random.R in R



def numpySearch():
    return random.R in np.array(R)

'''
if you look at my results you see my numpy search is pretty significantly slower than my search without loops.
what would cause that?
'''



if __name__ == "__main__":
    import timeit as ti
    print "Using 100 iterations for each\n\n"

    print "Sort without loops: " + str(ti.timeit("sortwithoutloops()", setup="from __main__ import sortwithoutloops", number=100))
    print "Sort with numpy: " + str(ti.timeit("numpySort()", "from __main__ import numpySort", number=100))
    print "Search with loops: " + str(ti.timeit("searchwithloops()", setup="from __main__ import searchwithloops", number=100))
    print "Search without loops: " + str(ti.timeit("searchwithoutloops()", setup="from __main__ import searchwithoutloops", number=100))
    print "Search with numpy: " + str(ti.timeit("numpySearch()", setup="from __main__ import numpySearch", number=100))
def median(seq):
    sort = sorted(seq[:])

    size = len(seq)
    half = size // 2

    result = 0
    if size % 2 == 0:
        result = (sort[half-1] + sort[half]) / 2.0
    else:
        result = sort[half]
    return result


print median([5,2,4,7,4,9])
print median([6, 8, 12, 2, 23])
def mergeSort(toSort):
	if len(toSort) <= 1:
           return toSort

	mIndex = len(toSort) / 2
	left = mergeSort(toSort[:mIndex])
        right = mergeSort(toSort[mIndex:])

	result = []
	while len(left) > 0 and len(right) > 0:
	    if left[0] > right[0]:
	        result.append(right.pop(0))
	    else:
		result.append(left.pop(0))

	if len(left) > 0:
	    result.extend(mergeSort(left))
	else:
	    result.extend(mergeSort(right))

	return result
def main():
	l = [1, 6, 7, 2, 76, 45, 23, 4, 8, 12, 11]
	sortedList = mergeSort(l)
	print sortedList
if __name__ == '__main__':
	main()
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
import unittest, random, string
from sorts import merge_sort, insertion_sort

red='\x1b[0;31m'
green='\x1b[0;32m'
teal='\x1b[0;36m'
NC='\x1b[0m'

class TestSorts(unittest.TestCase):
    '''
    These are some really messy tests to throw a bunch of random strings at us and test if they are sorted via our two algorithms.
    '''

    def setUp(self):
        self.test_data = [self.randomword() for i in range(10)]

    def test_merge_sort(self):

        for test_line in self.test_data:
            merge_sorted = merge_sort(list(test_line))
            tim_sorted = sorted(test_line)
            self.assertEqual(merge_sorted, tim_sorted, '\n\nFailed to be sorted! The input was:\n{}\n\nmerge_sort returned:\n{}\n\nand it should be:\n{}\n'.format(teal + test_line + NC, red + ''.join(merge_sorted) + NC, green + ''.join(tim_sorted) + NC))


    def test_insertion_sort(self):

        for test_line in self.test_data:
            insertion_sorted = insertion_sort(list(test_line))
            tim_sorted = sorted(test_line)
            self.assertEqual(insertion_sorted, tim_sorted, '\n\nFailed to be sorted! The input was:\n{}\n\ninsertion_sort returned:\n{}\n\nand it should be:\n{}\n'.format(teal + test_line + NC, red + ''.join(insertion_sorted) + NC, green + ''.join(tim_sorted) + NC))


    def randomword(self):
        return ''.join(random.choice(string.lowercase) for i in range(50))


if __name__ == '__main__':
    unittest.main()

import random
import time
import numpy
import sys

import quickSort
import selectionSort
import bubbleSort
import optBubbleSort
import insertionSort
import inplaceQuickSort
import utils
import heapSort
import inplaceSimpleQuickSort
import inplaceMidPivotQuickSort

def measureInline(sortObj):
	inputArr = utils.createInputArray(1000);
	startTime = time.time()
	outputArr = sortObj.sortList(inputArr)
	endTime = time.time()
	unsortedTime = (endTime - startTime)

	startTime = time.time()
	outputArr = sortObj.sortList(outputArr)
	endTime = time.time()
	sortedTime = endTime - startTime

	return (unsortedTime, sortedTime)

def measure(funcName, sortObj, count=10):
	unsortedTime = 0
	sortedTime = 0
	unsortedTimeArray = list()
	sortedTimeArray = list()
	for i in range(count):
		(unsortedTime, sortedTime) = measureInline(sortObj)
		unsortedTimeArray.append(unsortedTime)
		sortedTimeArray.append(sortedTime)
	averageUnsortTime = numpy.mean(unsortedTimeArray)
	averageSortTime = numpy.mean(sortedTimeArray)
	sortObj.setTime(averageUnsortTime, averageSortTime)
	print "Average Time taken by %s for unsorted is %2.3g" \
		%(funcName, averageUnsortTime)
	print "Average Time taken by %s for sorted is %2.3g" \
		%(funcName, averageSortTime)

sortClassList = {
	"InplaceMidPivotQuickSort" : inplaceMidPivotQuickSort.InplaceMidPivotQuickSort(),
	"InplaceSimpleQuickSort" : inplaceSimpleQuickSort.InplaceSimpleQuickSort(),
	"heapSort" : heapSort.HeapSort(),
	"InsertionSort": insertionSort.InsertionSort(),
	"BubbleSort": bubbleSort.BubbleSort(),
	"OptBubbleSort": optBubbleSort.OptBubbleSort(),
	"SimpleQuicksort": quickSort.QuickSort(),
	"InplaceQuicksort": inplaceQuickSort.InplaceQuickSort(),
	"selectionSort": selectionSort.SelectionSort()
}

def main():
	sys.setrecursionlimit(10000)
	for name in sortClassList:
		measure(name, sortClassList[name])

main()def insenstiveSort(stringList):
    return sorted(stringList, key=str.lower)

def insenstiveSort(stringList):
    """ For both str and unicode"""
    return sorted(stringList, key=lambda x: x.lower())

print(insenstiveSort(['a', 'B', 'c']))
class QuickSort:

    def quick_sort(self, array):
        if len(array) < 1:
            return array
        else:
            less, more, equal = [], [], []
            pivot = array[0]
            for i in array:
                if i < pivot:
                    less.append(i)
                elif i > pivot:
                    more.append(i)
                else:
                    equal.append(i)
            less_sorted = self.quick_sort(less)
            more_sorted = self.quick_sort(more)
            return less_sorted + equal + more_sorted

if __name__ == '__main__':
    qs = QuickSort()
    array = [4, 65, 2, -31, 0, 99, 83, 782, 1]
    print(qs.quick_sort(array))def get_array(file):
    return file.readline().split()


def bubble_sort(list):
    swaps = 0
    passes = 0
    sorted = False
    while sorted is False:
        sorted = True
        for i in range(0, (len(list)-1)):
            if list[i] > list[i+1]:
                list[i], list[i+1] = list[i+1], list[i]
                swaps += 1
                sorted = False
        passes += 1
    return passes, swaps


file = open('data.txt', 'r')
size = int(file.readline())
print(bubble_sort([int(i) for i in get_array(file)]))
from zen.isIterable import isIterable

def sortBy(*args,**keywords):

	sorted=[]
	sel=[]

	if len(args)==1:
		if isIterable(args[0]) and len(args[0])>1:
			sorted=list(args[0][-1])
			sel=list(args[0][0])
			inputType=type(args[0][0]).__name__
		else:
			return
	elif len(args)>1:
		sorted=list(args[-1])
		sel=list(args[0])
		inputType=type(args[0]).__name__

	l=sorted[:]
	for s in l:
		if s not in sel:
			sorted.remove(s)

	unsorted=sel[0:0]

	for s in sel:
		if s not in sorted:
			unsorted=unsorted+[s]

	if inputType=='str' or inputType=='unicode':
		unsorted=''.join(unsorted)
		sorted=''.join(sorted)
	elif inputType=='dict':
		sorted=list(sorted)
		unsorted=list(unsorted)
	else:
		exec('sorted='+inputType+'(sorted)')
		exec('unsorted='+inputType+'(unsorted)')

	return(sorted+unsorted)
def sort(coll):
    ''' Given a collection, sort it using the insertion
    sort method (sorted by reference).

    O(n^2) performance
    O(n)   storage

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    for j in range(1, len(coll)):
        k = coll[j]
        i = j - 1
        while i > 0 and coll[i] > k:
            coll[i + 1] = coll[i]
            i = i - 1
        coll[i + 1] = k
    return coll


def sort_clone(coll):
    ''' Given a collection, sort it using the insertion
    sort method (sorted by copy).

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    return sort(list(coll))
def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
__author__ = 'cwang'
from bisect import bisect_left


def binary_search(sorted_arr, target):
    pos = bisect_left(sorted_arr, target)
    return pos if pos < len(sorted_arr) and sorted_arr[pos] == target else -1

def my_binary_search(sorted_arr, target, lo, hi):
    if lo == hi:
        return lo
    mid = (lo + hi) // 2
    if target < sorted_arr[mid]:
        return my_binary_search(sorted_arr, target, lo, mid)
    elif target > sorted_arr[mid]:
        return my_binary_search(sorted_arr, target, mid + 1, hi)
    else:
        return mid

if __name__ == '__main__':
    arr = [1, 3, 5, 2, 4, 0]
    arr.sort()
    target = 1
    print(binary_search(arr, target))
    print(my_binary_search(arr, target, 0, len(arr)))
from Rnaseq import *

class sort_by_significance(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k14 -r ${inputs[0]} > ${ID}.sorted.sig
        '''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.sig']

import merge
def merge_sort(alist):
	""" (list of number) -> (list of number sorted)

	Return a list of number sorted use O(nlogn) time

	>>> merge_sort([1, 3 ,2, 7, 4, 6])
	[1, 2, 3, 4, 6, 7]
	"""

	n = len(alist)

	if n == 0 or n == 1:
		return alist
	else:
		leftList = alist[:n/2]
		rightList = alist[n/2:]

		leftSorted = merge_sort(leftList)
		rightSorted = merge_sort(rightList)

		return merge.merge(leftSorted, rightSorted)





class Host(object):
    def __init__(self, state, name, address, files=[], users=[]):
        self.name = name
        self.address = address
        self.files = sorted(files)
        self.files = sorted(users)
        state.hosts[name] = self

    def addfile(self, file):
        self.files.append(file)
        self.files.sort()

    def removefile(self, file):
        self.files.remove(file)

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.name)
def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])
def keynat(string):
    r'''A natural sort helper function for sort() and sorted()
    without using regular expression.

    >>> items = ('Z', 'a', '10', '1', '9')
    >>> sorted(items)
    ['1', '10', '9', 'Z', 'a']
    >>> sorted(items, key=keynat)
    ['1', '9', '10', 'Z', 'a']
    '''
    r = []
    for c in string:
        try:
            c = int(c)
            try: r[-1] = r[-1] * 10 + c
            except: r.append(c)
        except:
            r.append(c)
    return r   from sys import argv

scriptname, filename = argv[0], argv[1]

def create_dictionary(filename):

    input_file = open(filename)

    dictionary = {}

    for line in input_file:
        line = line.rstrip().split(':')
        key, value = line[0], int(line[1])
        dictionary[key] = value

    return dictionary

def sort_dictionary_keys(dictionary):
    sorted_keys = sorted(dictionary.keys())
    return sorted_keys

def print_sorted_dictionary(dictionary, sorted_keys):
    for key in sorted_keys:
        print "Restaurant %r is rated at %d." % (key, dictionary[key])

def main():
    dictionary = create_dictionary(filename)
    sorted_keys = sort_dictionary_keys(dictionary)
    print_sorted_dictionary(dictionary, sorted_keys)


if __name__ == '__main__':
    main()def partition(a, l, r):
    p = a[l]
    i = l + 1
    for j in xrange(l + 1, r):
        if a[j] > p: continue
        a[j], a[i] = a[i], a[j]
        i += 1
    a[l], a[i - 1] = a[i - 1], a[l]
    return i - 1

def choosePivot(a, l, r):

    if 2 == (l - r): return l
    first = a[l]
    final = a[r - 1]
    if 0 == ((r - l) % 2): i = ((r - l) / 2) - 1
    else: i = (r - l) / 2
    mid = a[l + i]
    if (first < mid < final) or (final < mid < first): return l + i
    elif (mid < first < final) or (final < first < mid): return l
    else: return r - 1

def qSort(a, l, r):
    if r - l <= 1: return 0
    p = choosePivot(a, l, r)
    a[l], a[p] = a[p], a[l]
    tot = r - l - 1
    i = partition(a, l, r)
    tot += qSort(a, l, i)
    tot += qSort(a, i + 1, r)
    return tot

if "__main__" == __name__:
    a = []
    with open('QuickSort.txt', 'r') as f:
        for line in f:
            a.append(int(line))
    tot = qSort(a, 0, len(a))
    sorted = True
    for i in range(1, len(a)):
        if a[i - 1] > a[i]:
            sorted = False
            break
    print 'Comparisons: %d' % tot
    if sorted: print 'Sorted'
    else: print 'Incorrectly sorted!'"""	sort values of a dictionary based on the key	"""


def value_sort(d):
    return [d[x] for x in sorted(d.keys())]

print value_sort({'x': 1, 'y': 2, 'a': 3})

from Mafiastats.mafiaStats.models import  Game, Team, Category,Player
from django.db.models.query import QuerySet


def attrSort(items,attr,reverse,category=None):
	print str(reverse)
	return sorted(items,(lambda x,y: cmp(getattr(x,attr),getattr(y,attr))),reverse=reverse)


def sortQuery(query,sortMethod,reverse,category):
	"""Returns a sorted queryset Will use sort_by if sortMethod is a string 	Will pass a sequence pulled from query if sortMethod is callable"""
	if(type(sortMethod) is str):
		if type(query) is QuerySet:
			if reverse:
				sortMethod = '-'+sortMethod
			return query.order_by(sortMethod)
		else:
			return attrSort(query,sortMethod,reverse)
	items = query.all() if type(query) is QuerySet else query
	if(hasattr(sortMethod,'__call__')):
		return sortMethod(items,reverse,category)


def playersByWins(players,reverse,category=None):
	return sorted(players,(lambda x,y:cmp(x.wins(category),y.wins(category))),reverse=reverse)

def playersByLosses(players,reverse,category=None):
	return sorted(players,(lambda x,y:cmp(x.losses(category),y.losses(category))),reverse=reverse)

def playersByWinPct(players,reverse,category=None):
	return sorted(players,(lambda x,y:cmp(x.winPct(category),y.winPct(category))),reverse=reverse)

def playersByModerated(players,reverse,category=None):
	return sorted(players,(lambda x,y:cmp(x.modded(),y.modded())),reverse=reverse)

def modsByLargestGame(mods,reverse,category=None):
	return sorted(mods,(lambda x,y:cmp(x.largestModdedCount(),y.largestModdedCount())),reverse=reverse)

def gamesByLength(games,reverse,category=None):
	return sorted(games,(lambda x,y:cmp(x.length(),y.length())),reverse=reverse)

def gamesByPlayers(games,reverse,category=None):
	return sorted(games,(lambda x,y:cmp(x.num_players(),y.num_players())),reverse=reverse)
def teamsByGame(teams,reverse,category=None):
	return sorted(teams,(lambda x,y:cmp(x.game.title,y.game.title)),reverse=reverse)
def teamsByLength(teams,reverse,category=None):
	return sorted(teams,(lambda x,y:cmp(x.game.length(),y.game.length())),reverse=reverse)
def sequenceByElmnt(elNumb):
	def sortFunc(sequence,reverse,category=None):
		return sorted(sequence,(lambda x,y:cmp(x[elNumb],y[elNumb])),reverse=reverse)
	return sortFunc
def insertion_sort(the_list, sorted_length = 0):
    if len(the_list) <= sorted_length:
        return the_list
    current = the_list.pop()
    if sorted_length == 0:
        the_list.insert(0,current)
    else:
        for x in range(sorted_length):
            if the_list[x] >= current:
                the_list.insert(x, current)
                return insertion_sort(the_list, sorted_length + 1)
        the_list.insert(sorted_length,current)
    return insertion_sort(the_list, sorted_length + 1)


a = [3,2,4,5,19,20,2,30,1000,1]
print a
insertion_sort(a)
print a
a.sort()
print a
def sort_a_list(list):
    for i in range(len(list)):
        return(sorted(list, reverse=True))
def break_words(stuff):
	return stuff.split(' ')

def sort_words(words):
	return sorted(words)

def print_first_word(words):
	print words.pop(0)

def print_last_word(words):
	print words.pop(-1)

def sort_sentence(sentence):
	return sort_words(break_words(sentence))

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)
import functools

from flask import request
from sqlalchemy import desc

from ._compat import httplib
from .request_utils import error_abort


def sort_query(query, allowed_fields=(), default=None):
    allowed_fields = set(allowed_fields)
    sort_param = request.args.get("sort", None)
    if sort_param:
        sort_fields = sort_param.split(",")

        for sort_field in sort_fields:
            descending = sort_field.startswith("-")
            if descending:
                sort_field = sort_field[1:]

            if sort_field not in allowed_fields:
                error_abort(httplib.BAD_REQUEST, "Cannot sort by field {0!r}".format(sort_field))
            query = query.order_by(desc(sort_field) if descending else sort_field)
    elif default is not None:
        query = query.order_by(default)

    return query


def sorted_view(func=None, **sort_kwargs):
    if func is None:
        return functools.partial(sorted_view, **sort_kwargs)

    @functools.wraps(func)
    def new_func(*args, **kwargs):
        returned = func(*args, **kwargs)
        return sort_query(returned, **sort_kwargs)

    return new_func
class Solution:
    """
    @param A: sorted integer array A which has m elements,
              but size of A is m+n
    @param B: sorted integer array B which has n elements
    @return: void
    """
    def mergeSortedArray(self, A, m, B, n):

        j=0
        for i in range(m,m+n):
            A[i]=B[j]
            j+=1
            if j==n:
                break
        A.sort()
        return A
'''
ref: https://github.com/SebasSujeen/Merge_sort/blob/master/merge_sort/merge_sort.py
'''

from prepare.base_class import *

def merge_tbuns(left,right):
    sorted=[]
    i,j=0,0
    while i<len(left) and j<len(right):
        if left[i].oid < right[j].oid:
            sorted.append(left[i])
            i+=1
        elif left[i].oid == right[j].oid:
            if left[i].timestamp > right[j].timestamp:
                sorted.append(left[i])
            else:
                sorted.append(right[j])
            i+=1
            j+=1
        else:
            sorted.append(right[j])
            j+=1
    sorted+=left[i:]
    sorted+=right[j:]
    return sorted

def merge_update(li):
    if len(li)==1:
        return li
    middle=len(li)/2
    left_li=merge_update(li[:middle])
    right_li=merge_update(li[middle:])
    return merge_tbuns(left_li,right_li)



if __name__=="__main__":

    tbunList=\
        [TBUN(1,10,0),
         TBUN(1,5,0),
         TBUN(1,2,0),
         TBUN(1,3,0),
         TBUN(1,7,0),
         TBUN(1,4,0),
         TBUN(1,8,0),
         TBUN(1,9,0),
         TBUN(2,5,-1),
         TBUN(2,3,-1),
         TBUN(2,8,-1)
         ]

    sortedTBunList=merge_update(tbunList)

    for tbun in sortedTBunList:
        print str(tbun)+'\n'

__author__ = 'dihnatsyeu'

def bublesort (ListToSort):

    lenght = len(ListToSort)
    sorted = False
    for j in range(0, lenght-1):
        for i in range(0, lenght-j-1):
            if ListToSort[i] > ListToSort[i+1]:
               temp = ListToSort[i]
               ListToSort[i] = ListToSort[i+1]
               ListToSort[i+1] = temp
               sorted = True
            if sorted == False: break

    return ListToSort

print bublesort([24,1,34,3,72,5,21])class BearSlowlySorts:
	def minMoves(self, w):
		if self.sorted(w):
			return 0
		w1 = list(w)
		w1 = self.sortFront(w1)
		if self.sorted(w1):
			return 1
		w2 = list(w)
		w2 = self.sortEnd(w2)
		if self.sorted(w2):
			return 1

		w1 = self.sortEnd(w1)
		if self.sorted(w1):
			return 2
		w2 = self.sortFront(w2)
		if self.sorted(w2):
			return 2
		return 3

	def sorted(self, w):
		prev = 0
		for v in w:
			if v < prev:
				return False
			prev = v
		return True

	def sortFront(self, w):
		front = list(w[:-1])
		front.sort()
		front.append(w[-1])
		return front

	def sortEnd(self, w):
		end = list(w[1:])
		end.sort()
		ret = [w[0]]
		ret += end
		return ret
def sort_dict(d):
  'return a sorted list of tuples from the dictionary'
  return sorted(d.items(), key = lambda x : x[1], reverse=True)def sort_by(field, articles, reverse=False):
    return sorted(articles, reverse=reverse, key=lambda p: p.meta[field])
__author__ = 'kyu'

def sort(A):
    m=len(A)
    if len(A)<=1: return A
    else:
        L=A[:m]
        R=A[m:]


def merge(A,B):
    res=[]
    ia=0
    ib=0
    while ia<len(A) and ib <len(B):
        if A[ia] <= B[ib]:
            res.append(A[ia])
            ia+=1
        else:
            res.append(B[ib])
            ib+=1
    return res+A[ia:]+B[ib:]


def msort(A):
    if len(A) <= 1: return A
    else:
        m=len(A)/2
        return merge(msort(A[:m],msort(A[m:])))






def msortBasic(A):
    if len(A) <= 1: return A
    else:
        m=len(A)/2
        L=A[:m]
        R=A[m:]
        sortedL=msort(L)
        sortedR=msort(R)
        return merge(sortedL,sortedR)






def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l


list = [9, 1, 2, 5, 5, 8, 4, 2, 3, 6]


def sort_a_list(x):
    print(sorted(x, reverse=True))
    return

sort_a_list(list)



listComplex = [
    [37, 'Jeanette Wafer'], [6, 'Joshua Tran'], [85, 'Susan Maddox']]


def sort_by_mark(y):
    print(sorted(y, reverse=True))
    return

sort_by_mark(listComplex)
from random import randint
def bozosort(list):
    toSort = list
    sorted = False
    runs = 0
    while sorted == False:
        sorted = True
        for i in range(0, len(toSort)-1):
            if toSort[i] > toSort[i+1]:
                sorted = False;
        if sorted == False:
            rand1 = randint(0, len(toSort)-1)
            rand2 = randint(0, len(toSort)-1)
            while rand1 == rand2:
                rand1 = randint(0, len(toSort)-1)
                rand2 = randint(0, len(toSort)-1)
            old_toSort1 = toSort[rand1]
            toSort[rand1] = toSort[rand2]
            toSort[rand2] = old_toSort1
            runs += 1
    return runs


import random
import math

from benchmark import timethese

SAMPLE_SIZE             = 40 * 1000
BENCHMARK_ITERATIONS    = 100


def main():
    print "Generating sample data..."
    points = generatate_points(SAMPLE_SIZE)

    timethese(BENCHMARK_ITERATIONS,
        (
            ("classic",     lambda : sort_classic(points)),
            ("key",         lambda : sort_key(points)),
            ("OM",          lambda : sort_om(points)),
            ("ST",          lambda : sort_st(points)),
        )
    )


def generatate_points(N):
    DISTANCE = 10
    a = []

    for x in xrange(N):
        a.append(
            (random.uniform(-DISTANCE, DISTANCE), random.uniform(-DISTANCE, DISTANCE))
        )
    return a


def veclen(point):
    return math.sqrt( point[0] ** 2 + point[1] ** 2)


def sort_classic(data):

    def cmp_distances(a, b):
        return int(veclen(a) - veclen(b))

    return sorted(data, cmp=cmp_distances)


def sort_key(data):
    return sorted(data, key=veclen)


def sort_om(data):
    cache = dict()

    def cmp_cached(a, b):
        if a not in cache:
            cache[a] = veclen(a)
        if b not in cache:
            cache[b] = veclen(b)

        return int(cache[a] - cache[b])

    return sorted(data, cmp=cmp_cached)


def sort_st(data):
    return [ p for vl, p in sorted([(veclen(p), p) for p in data]) ]


if __name__ == '__main__':
    main()
def keynat(string):
    r'''A natural sort helper function for sort() and sorted()
    without using regular expression.

    >>> items = ('Z', 'a', '10', '1', '9')
    >>> sorted(items)
    ['1', '10', '9', 'Z', 'a']
    >>> sorted(items, key=keynat)
    ['1', '9', '10', 'Z', 'a']
    '''
    r = []
    for c in string:
        try:
            c = int(c)
            try: r[-1] = r[-1] * 10 + c
            except: r.append(c)
        except:
            r.append(c)
    return r   import unittest
import logging
import math
import pdb

def merge(A, p, q, r):

    left = [A[i] for i in range(p, q + 1)]

    right = [A[i] for i in range(q + 1, r + 1)]
    left.append(float("inf"))
    right.append(float("inf"))

    i = 0
    j = 0
    for k in range(p, r + 1):
        if left[i] <= right [j]:
            A[k] = left[i]
            i += 1
        else:
            A[k] = right[j]
            j += 1

def merge_sort(A, p, r):
    if p < r:
        middle = int(math.floor((p + r) / 2.))
        merge_sort(A, p, middle)
        merge_sort(A, middle + 1, r)
        merge(A, p, middle, r)

def sort(l):

    sorted_list = list(l)
    merge_sort(sorted_list, 0, len(l) - 1)
    return sorted_list

class TestSorted(unittest.TestCase):

    def setUp(self):
        self.lists = (
                [1,],
                [2, 3],
                [4, 3, 2, 2, 6, 7],
                [0, 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10],
                [12, 34, 32, 34, 32, 34, 65, 34, 1, 4, 3, 5],
                [3, 5, 6, 3, 5, 6, 7, 3, 5, 6, 3, 5, 3, 123])

    def test_sorted(self):
        for original_list in self.lists:
            sorted_list = sort(original_list)
            self.assertListEqual(sorted_list, sorted(original_list))

if __name__ == '__main__':
    pdb.run('sort([4, 3, 2, 2, 6, 7])')
    unittest.main()





A = [31, 41, 59, 26, 41, 58]


def bubble_sort(L):
    '''This is the bubble sort algorithm'''
    sorted = False
    while not sorted:
        sorted = True
        for i in range(len(L) - 1):
            if L[i] > L[i+1]:
                sorted = False
                L[i], L[i+1] = L[i+1], L[i]
    return L




A = np.array([31, 41, 59, 26, 41, 58])

A.sort()
A.sort(kind='mergesort')
__author__ = 'VGN'


def merge(a, b):
    """
    Merge subroutine to merge the sorted lists a and b
    :param a: sorted subarray a
    :param b: sorted subarray b
    :return: new list merging the sorted list a and b
    """
    c = list()
    i = 0
    j = 0

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i = i+1
        elif b[j] < a[i]:
            c.append(b[j])
            j = j+1
    if i < len(a):
        for k in range(i, len(a)):
            c.append(a[k])
    if j < len(b):
        for k in range(j, len(b)):
            c.append(b[k])
    return c


def merge_sort(input):
    length = len(input)
    if length <= 1:
        return input
    a = merge_sort(input[0:length/2])
    b = merge_sort(input[length/2:])
    return merge(a, b)

def median(lst):

    sorted_lst = sorted(lst)

    lst_length = len(sorted_lst)


    if lst_length % 2 == 0:
        index_1 = lst_length / 2
        index_2 = index_1 - 1
        median = (sorted_lst[index_1] + sorted_lst[index_2]) / 2.0
        return median

    elif lst_length % 2 == 1:
        median = 0
        index = lst_length / 2
        median = sorted_lst[index]
        return medianimport operator


def sort_a_list(l):
    a = sorted(l, reverse=True)
    return(a)


def sort_by_mark(my_class):
    a = sorted(my_class, key=operator.itemgetter(0), reverse=True)
    return(a)


def sort_by_name(my_class):
    a = sorted(my_class, key=operator.itemgetter(1))
    return(a)


def anagram_method1(string1, string2):
    return histogram(string1) == histogram(string2)

def histogram(string):
    res = {}
    for letter in string:
        if letter in res:
            res[letter] = res[letter] + 1
        else:
            res[letter] = 1
    return res

def anagram_method2(string1, string2):
    return sort(string1) == sort(string2)

def sort(string):
    return ''.join(sorted(string))
from random import shuffle

def is_sorted(list):
	for e in range(0, len(list)-1):
		if list[e] > list[e+1]:
			return False
	return True

def bogo_sort(sort_me):
	'''
	bogo_sort(list) uses bogo sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = bogo_sort(my_list)
	'''
	while not is_sorted(sort_me):
		shuffle(sort_me)
	return sort_me
a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

def break_words(stuff):
	"""This function will break up words for us"""
	words = stuff.split(' ')
	return words

def sort_words(words):
	"""Sorts the words"""
	return sorted(words)

def print_first_word(words):
	"""Prints the first word after popping it off."""
	word = words.pop(0)
	print word

def print_last_word(words):
	"""Prints the last word after popping it off."""
	word = words.pop(-1)
	print word

def sort_sentence(sentence):
	"""Takes in a full sentence and returns the sorted words"""
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	"""Prints the first and last words of the sentence"""
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	"""Sorts the words then prints the first and last one."""
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)

sentence = "All good things come to those who wait."
words = break_words(sentence)
print words

sorted_words = sort_words(words)
print sorted_words

print_first_word(words)

print_last_word(words)

print words

print_first_word(sorted_words)
print_last_word(sorted_words)

print sorted_words

sorted_words = sort_sentence(sentence)
print sorted_words

print_first_and_last(sentence)

print_first_and_last_sorted(sentence)def bubble_sort(mylist):
	length=len(mylist)
	for i in range(length-1):
		if (mylist[i]>mylist[i+1]):
			temp=mylist[i]
			temp2=mylist[i+1]
			mylist[i]=temp2
			mylist[i+1]=temp
			bubble_sort(mylist)

	return mylist

print (bubble_sort([5,19,4,1,36,99,2]))

assert bubble_sort([5,19,4,1,36,99,2]) == sorted([5,19,4,1,36,99,2])
assert bubble_sort(["Greg", "Armen", "Ken"]) == sorted(["Greg", "Armen", "Ken"])
class Solution:

    def findMedianSortedArrays(self, A, B):
        A.extend(B)
        A.sort()
        length = len(A)
        if length%2 ==0:
            return (A[length/2-1]+A[length/2])/2.0
        else:
            return A[length/2]

if __name__ == '__main__':
    s = Solution()
    print s.findMedianSortedArrays([1,2,5],[3,4,6])


    raw_input()def sort(unsorted):
    """Takes an unsorted list as input and returns 2 lenght n/2 unstored lists in a tuple."""
    if len(unsorted) < 2:
        return unsorted


    mid = len(unsorted) / 2
    left = unsorted[:mid]
    right = unsorted[mid:]


    left = sort(left)
    right = sort(right)

    return merge(left, right)


def merge(left, right):
    """Takes 2 unsorted lists and returns 1 sorted list."""
    sorted = []

    i = 0
    j = 0
    for k in xrange(len(left) + len(right)):

        if i == len(left):
            sorted.extend(right[j:])
            break
        elif j == len(right):
            sorted.extend(left[i:])
            break


        if left[i] < right[j]:
            sorted.append(left[i])
            i = i + 1
        else:
            sorted.append(right[j])
            j = j + 1

    return sorted


def mergesort(unsorted):
    """Takes an unsorted list as imput and return a sorted list."""

    if len(unsorted) <= 1:
        return unsorted

    return sort(unsorted)
try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
import typ

@typ.typ(items=[int])
def count_sort(items):
  """
  >>> count_sort([])
  []
  >>> count_sort([1])
  [1]
  >>> count_sort([2,1])
  [1, 2]
  >>> count_sort([1,2])
  [1, 2]
  >>> count_sort([1,2,2])
  [1, 2, 2]
  """
  if items == []:
    return []
  counts = {}
  for num in items:
    if num in counts:
      counts[num] += 1
    else:
      counts[num] = 1

  sorted_list = []
  for num in xrange(min(items), max(items) + 1):
    if num in counts:
      for j in xrange(counts[num]):
        sorted_list.append(num)

  return sorted_list

def merge(xs1, xs2):
    i = 0
    j = 0
    sorted_xs = []
    inversions = 0
    for k in range(len(xs1) + len(xs2)):
        if xs1[i] < xs2[j]:
            sorted_xs.append(xs1[i])
            i += 1
            if i == len(xs1):
                sorted_xs += (xs2[j:])
                return sorted_xs, inversions
        else:
            sorted_xs.append(xs2[j])
            j += 1
            inversions += len(xs1) - i
            if j == len(xs2):
                sorted_xs += (xs1[i:])
                return sorted_xs, inversions
    return sorted_xs, inversions


def sort_count_inversions(xs):
    if len(xs) == 1:
        return xs, 0
    mid = len(xs) / 2
    xs1 = xs[0:mid]
    xs2 = xs[mid:len(xs)]
    sorted_xs1, inversions1 = sort_count_inversions(xs1)
    sorted_xs2, inversions2 = sort_count_inversions(xs2)
    sorted_xs, inversions_merged = merge(sorted_xs1, sorted_xs2)
    return sorted_xs, inversions1 + inversions2 + inversions_merged


contents = file.read(file('integerArray.txt'))
numbers = contents.split('\r\n')
del numbers[-1]
numbers = map(lambda x: int(x), numbers)
print sort_count_inversions(numbers)[1]data = [1,3,9,4,111,150]

def InsertSort(data):
	for j in range(1,(len(data)-1)):
		key = data[j]
		i = j-1
		while(i>=0 and data[i]>key):
			data[i+1] = data[i]
			i = i-1
		data[i+1] = key
	return data

def main():
	print data
	SortedData = InsertSort(data)
	print SortedData

main()



def merge_sort(in_list):

    l_len = len(in_list)

    if l_len == 1:
        return in_list

    h_len = len(in_list)/2
    h1 = merge_sort(in_list[:h_len])
    h2 = merge_sort(in_list[h_len:])


    sorted_list = []

    while (len(h1) + len(h2)) != 0:
        if h1 == []:
            return sorted_list + h2
        elif h2 == []:
            return sorted_list + h1
        elif h1[0] < h2[0]:
            sorted_list.append(h1.pop(0))
        else:
            sorted_list.append(h2.pop(0))

    return sorted_list

in_list = [33,6,43,32,63,66,3,45,8,201,98,78,98,23,43,12,36,72,17,1]

print merge_sort(in_list)


def sortByCrime(atms):
    sortedAtms = sorted(atms, key=lambda atm: atm['crimes'])
    print sortedAtms
    return sortedAtms



def insert(array, splitIndex, value):
	"""
	insert value into array before item at splitIndex
	"""
	arr1 = array[0:splitIndex]
	arr2 = array[splitIndex:]
	return arr1 + [value] + arr2


def index(x, sorted_a):
	"""
	returns splitIndex
	"""
	for elem in sorted_a:
		if x <= elem:
			return sorted_a.index(elem)
	else:
		return len(sorted_a)

def insertSort(array):
	sorted_arr = [array[0]]
	for x in array[1:]:
		sorted_arr = insert(sorted_arr, index(x, sorted_arr), x)

	return sorted_arr


if __name__ == '__main__':
	print insert([0,1,2,3,4,5], 2, 10)
	print insertSort([1,0,5,19,3,-16])def selectionSort(L):
    sorted = []
    remaining = L
    while len(remaining) > 0:
        lowest = remaining[0]
        for x in remaining:
            if x < lowest:
                lowest = x
        sorted.append(lowest)
        remaining.remove(lowest)
    return sorted


list1 = [65, 23, 74, 87, 9, 34, 143]
print list1
print selectionSort(list1)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
'''
Created on 24/11/2012

@author: Pavel
'''

def sort_dict_value(dicto, decrease = True):
    import operator
    return  sorted(dicto.iteritems(), key=operator.itemgetter(1),reverse=decrease)

def sort_dict_key(dicto, decrease = True):
    import operator
    return  sorted(dicto.iteritems(), key=operator.itemgetter(0), reverse = decrease)
    from random import randint

def randArray():
    array = []

    for i in range(0, 10):
        randnum = randint(1, 100)
        array.append(randnum)
    return array

def insertionSort(array):

    for key in range(1, len(array)):
        current = array[key]
        indx = key - 1
        while indx >= 0 and array[indx] > current:
            array[indx+1] = array[indx]
            indx -= 1
        array[indx+1] = current
    return array

array = randArray()
print(array)

sorted = insertionSort(array)
print("sorted")
print(sorted)

numbers = [25, 72, -35, 10, -34, -91, 2, -2]
print(numbers)
print(sorted(numbers))
print(sorted(numbers, key = abs))
print(sorted(numbers, key = lambda x: x % 10))

words = ['bob', 'Haha', 'WTO', 'Lily', 'isRight', 'P']
print(words)
print(sorted(words))
print(sorted(words, reverse = True))
print(sorted(words, reverse = True, key = str.lower))

record = [('Bob', 75), ('Lily', 93), ('dike', 88), ('Lisa', 82)]
def sortByName(rec):
    return rec[0].lower()
print(sorted(record, key = sortByName))
from operator import itemgetter
print(sorted(record, key = itemgetter(0)))
print(sorted(record, key = lambda record:record[1], reverse = True))

myArray = [ 1, 50, 3, 17, 5, 3, 2, 99, 4 ]

def quickSort(arrayToSort):
  upper = []
  lower = []
  if len(arrayToSort) <= 1:
    return arrayToSort
  pivot = arrayToSort.pop()
  for elem in arrayToSort:
    if elem <= pivot:
      lower.append(elem)
    else:
      upper.append(elem)
  sortedArray = quickSort(lower)
  sortedArray.append(pivot)
  sortedArray.extend(quickSort(upper))
  return sortedArray

if __name__ == "__main__":
   print myArray
   print quickSort(myArray)
def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])
def groupAnagrams(strs):
        result=[]
        d={}
        while strs:
            word=strs.pop()
	    print sorted(word)
            if d.has_key(sorted(word)):
                d[sorted(word)]=d[sorted(word)].append(word)
            else:
                d[sorted(word)]=[word]
        for item in d.values():
            if len(item)>1:
                item.sort()
	return d.values()

strs=["and","dan"]
print strs
print groupAnagrams(strs)
l = [1, 3, 2, 5]

print(l)
print(sorted(l))
l.sort()
print(l)
print(l == sorted(l))

print(sorted(l, key=lambda x: -x))
l.sort(key=lambda x: -x)
print(l)
print(l == sorted(l, key=lambda x: -x))

print(sorted(l, key=lambda x: -x, reverse=True))
l.sort(key=lambda x: -x, reverse=True)
print(l)
print(l == sorted(l, key=lambda x: -x, reverse=True))

print(sorted(l, reverse=True))
l.sort(reverse=True)
print(l)
print(l == sorted(l, reverse=True))

print(sorted(l, reverse=False))
l.sort(reverse=False)
print(l)
print(l == sorted(l, reverse=False))


l = list(range(2000))
l.sort()
print(l[0], l[-1])
l.sort(reverse=True)
print(l[0], l[-1])


class A:
    def __init__(self, x):
        self.x = x
    def __lt__(self, other):
        return self.x > other.x
    def __repr__(self):
        return str(self.x)
l = [A(5), A(2), A(1), A(3), A(4)]
print(l)
l.sort()
print(l)
l.sort(reverse=True)
print(l)

seq = [7, 13, 2, -1, -1, 16]

def selection_sort(sequence):
    seqLen = len(sequence)
    sortedSeq = sequence[:]

    for i in range(0, seqLen-1):
        minIdx=i
        for k in range(i+1, seqLen):
            if sortedSeq[k] < sortedSeq[minIdx]:
                minIdx = k
        sortedSeq[i], sortedSeq[minIdx] = sortedSeq[minIdx], sortedSeq[i]

    return sortedSeq

print selection_sort(seq)



def odd_even_sort(in_array):
    is_sorted = False
    length=len(in_array)-1
    (even_loop, odd_loop) = (range(1,length, 2), range(0, length, 2))

    while not is_sorted:
        is_sorted = True
        if not sorted_loop(even_loop, in_array):
            is_sorted = False
        if not sorted_loop(odd_loop, in_array):
            is_sorted = False
    return in_array

def sorted_loop(loop, in_array):
    is_sorted = True
    for i in loop:
        if in_array[i] > in_array[i+1]:
            in_array[i], in_array[i+1] = in_array[i+1], in_array[i]
            is_sorted = False
    return is_sorted





def sort(arr):

	arr.sort()
	return arrclass SortedList:
   def __init__(self):
       self.values = []

   def append(self, value):
       self.values.append(value)

   def __getitem__(self, index):
       self.values.sort()
       return self.values[index]

   def __len__(self):
       return len(self.values)


store = []


def sort_by_last_letter(strings):
    def last_letter(s):
        return s[-1]

    store.append(last_letter)
    print(last_letter)
    return sorted(strings, key=last_letter)

def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]


'''
Created on 2012-11-17

@author: CaiKnife
'''


def sort_by_attr(seq, attr):
    intermed = [(getattr(x, attr), i, x) for i, x in enumerate(seq)]
    intermed.sort()
    return [x[-1] for x in intermed]

def sort_by_attr_inplace(lst, attr):
    lst[:] = sort_by_attr(lst, attr)



import operator
def sort_by_attr_new(seq, attr):
    return sorted(sq, key=operator.attrgetter(attr))

def sort_by_attr_inplace_new(lst, attr):
    lst.sort(key=operator.attrgetter(attr))

__author__ = 'Brian Sargent'

class SortTupleList:
    tupleSortIndex = 0
    reverseOrder = False

    def __init__(self,tupleIndex,isReversed=False):
        self.tupleSortIndex = tupleIndex
        self.reverseOrder = isReversed

    def doSort(self,aList):
        """Sort a list of tuples. Tuple tupleSortIndex is used to select the tuple member used."""
        sortedList = sorted(aList,key=self.SortSelect,reverse = self.reverseOrder)
        return sortedList

    def SortSelect(self,tuple):
        return tuple[self.tupleSortIndex]





import random


def insertion_sort(ls):
    for i in xrange(1, len(ls)):
        key = ls[i]
        j = i - 1
        while j >= 0 and ls[j] > key:
            ls[j + 1] = ls[j]
            j -= 1
        ls[j + 1] = key


def is_sorted(ls):
    return ls == sorted(ls)


def random_ls(len, frm, to):
    return [random.randint(frm, to) for _ in xrange(len)]


def test_insertion_sort_simple():
    ls = [5, 2, 4, 6, 1, 3]
    insertion_sort(ls)
    assert ls == [1, 2, 3, 4, 5, 6]


def test_insertion_sort_random():
    for i in [10, 100, 1000]:
        ls = random_ls(i, 0, i//2)
        insertion_sort(ls)
        assert is_sorted(ls)


def test_insertion_sort_trivial():
    for i in [10, 100, 1000]:
        ls = range(i)
        insertion_sort(ls)
        assert is_sorted(ls)

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])

class WeightBasedSorter( object ):

    def sort( self, viewlets ):
        return sorted( viewlets,
                       lambda x, y: cmp(x[1].weight, y[1].weight ) )

def insertionSort(ar):
    sorted = 0
    i = len(ar) - 2
    val = ar[len(ar)-1]
    while not sorted:
        if i < 0:
            ar[0] = val
            sorted = 1
        elif (ar[i] > val):
            ar[i+1] = ar[i]
            i -= 1
        else:
            ar[i+1] = val
            sorted = 1
        print str(ar).strip('[]').replace(",", "")
    return ""

m = input()
ar = [int(i) for i in raw_input().strip().split()]
insertionSort(ar)


def merge(left, right):
    """Merges two sorted lists.
    Args:
        left: A sorted list.
        right: A sorted list.

    Returns:
        The sorted list resulting from merging the two sorted sublists.

    Requires:
        left and right are sorted.
    """

    items = []

    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            items.append(left[i])
            i = i + 1
        else:
            items.append(right[j])
            j = j + 1

    if i < len(left):
        items.extend(left[i:])
    elif j < len(right):
        items.extend(right[j:])

    return items


def merge_sort(items):
    """Sorts a list of items.

    Uses merge sort to sort the list items.

    Args:
        items: A list of items.

    Returns:
        The sorted list of items.
    """
    n = len(items)
    if n < 2:
        return items

    m = n // 2
    left = merge_sort(items[:m])
    right = merge_sort(items[m:])
    return merge(left, right)


def is_sorted(sequence, reverse=False):
    return (sorted(sequence, reverse=reverse) == sequence)

def insertion_sort(sequence):
    """Returns a sorted list from a sequence."""


    sequence = list(sequence)

    for i in range(1, len(sequence)):
        current_value = sequence[i]
        j = i
        while (j > 0 and current_value < sequence[j-1]):
            j -= 1
        sequence.insert(j, sequence.pop(i))

    return sequence

def insertion_sort_nonincreasing(sequence):
    """Returns a sorted list from a sequence."""
    sequence = list(sequence)

    for i in range(1, len(sequence)):
        current_value = sequence[i]
        j = i
        while (j > 0 and current_value > sequence[j-1]):
            j -= 1
        sequence.insert(j, sequence.pop(i))

    return sequence

if __name__ == "__main__":
    l = [3, 4, 19, 2, 10, 7, 1, 5, 8]

    sorted_list = insertion_sort(l)
    assert is_sorted(sorted_list)
    print "%s became %s" % (l, sorted_list)

    sorted_nonincreasing_list = insertion_sort_nonincreasing(l)
    assert is_sorted(sorted_nonincreasing_list, reverse=True)
    print "%s became %s" % (l, sorted_nonincreasing_list)
def min_elem(nums):
    min_index = 0

    index = 0
    for item in nums:
        if item < nums[min_index]:
            min_index = index

        index +=1

    return min_index

print(min_elem([3,-7,1,-4]))

def basic_sort (nums):
    sorted_nums = []

    while len(nums) != 0:
            min_index = min_elem(nums)
            sorted_nums = sorted_nums+ [nums[min_index]]
            del nums[min_index]

    return sorted_nums

print(basic_sort([2,3,0]))



def sort(arr):

	sorted = False
	while not sorted:
		sorted = True
		for i in range(0, len(arr)-1):
			if arr[i] > arr[i+1]:
				temp = arr[i]
				arr[i] = arr[i+1]
				arr[i+1] = temp
				sorted = False
	print arr
	return arr
def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist
import operator

d = {
     "and": 1,
     "the": 3,
     "in": 2,
     "was": 2
}


def sort_dict_by_values(_dict):
     sorted_dict = sorted(_dict.items(), key=operator.itemgetter(1), reverse=True)
     return sorted_dict


result = sort_dict_by_values(d)
print(result)def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist
def read_in_file():
    filename = 'IntegerArray.txt'
    f = open(filename, 'r')
    numbers = []
    for entry in f:
        numbers.append(int(entry))
    f.close()
    return numbers


def use_example():
    return [8, 4, 3, 2, 3, 5, 1, 0, 10]


def sort_and_count(ar):
    if len(ar) == 1:
        return 0, ar
    else:
        ct_left, left = sort_and_count(ar[0:len(ar) / 2])
        ct_right, right = sort_and_count(ar[len(ar) / 2::])

        ar_sorted, ct_split = count_split(left, right)


        return ct_left + ct_right + ct_split, ar_sorted


def count_split(left, right):
    ar_sorted = []
    i = j = 0
    count = 0
    while i < len(left) and j < len(right):
        if(left[i] > right[j]):
            count += len(left) - i
            ar_sorted.append(right[j])
            j += 1
        else:
            ar_sorted.append(left[i])
            i += 1

    if j == len(right):
        ar_sorted += left[i:]
    else:
        ar_sorted += right[j:]

    return ar_sorted, count


if __name__ == "__main__":
    result, _ = sort_and_count(read_in_file())
    print result





import os
import sys
sys.path.append(os.path.join('..'))
import dubious_sort as D
import random
import string

def generate_random_list(n):
    while True:
        mess = [random.choice(string.ascii_lowercase) for i in range(n)]


        if len(set(mess)) > 1:
            return mess

def test_n_10():
    lst = generate_random_list(10)
    assert D.sort(lst) == sorted(lst)





def test_n_100():
    for i in range(100):
        lst = generate_random_list(100)
        assert D.sort(lst) == sorted(lst)

def test_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst) == sorted(lst)

def test_broken_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst, broken=True) != sorted(lst)

def test_broken_n_2():
    for i in range(100):
        lst = generate_random_list(2)
        assert D.sort(lst, broken=True) != sorted(lst)
__author__ = 'alex'


def task_7(arg):
    def unique_disordered(arg):
        z = set(arg)
        return list(z)

    print 'Not sorted ' + str(arg) + ' == ' + str(unique_disordered(arg))

    def unique_ordered(arg):
        x = set(arg)
        z = list(x)
        z.sort()
        return z

    print 'Sorted ' + str(arg) + ' == ' + str(unique_ordered(arg))


m = ["a", 5, 2, 5, (1, "a"), "a"]
task_7(m)

"""
Created on Wed Sep 23 09:39:40 2015

@author: simonfredon
"""


from operator import *


def sort_a_list(lista):
    a = sorted(lista, reverse=True)
    return a


def sort_by_mark(mycl):
    b = sorted(mycl, key=itemgetter(0), reverse=True)
    return b


def sort_by_name(mclass):
    c = sorted(mclass, key=itemgetter(1))
    return c
def itemgetter(i):
    def getter(x): return x[i]
    return getter
def sorted(seq, key):
    aux = [(key(x), i, x) for i, x in enumerate(seq)]
    aux.sort()
    return [x for k, i, x in aux]


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
import numpy as np
r=[['a', 'a', 'a', 'b','c','c','c','c'],[1,2,3,13],[4,5,6,14],[7,8,9,15],[10,11,12,16,4,5,6,14]]

d={r[0][z]:[p[z] for p in r[1:] if z<=len(r[1])-1] for z in xrange(0,len(r[0]))}

def chardiv(lst):
    def pairs(xs):
      for p in zip(xs[:-1], xs[1:]):
        yield p
    sortOrder=[i[0] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedIndep=[i[1] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedDep=[lst[1][z] for z in sortOrder]
    cuts=[];divs=[]
    for x in xrange(1,len(sortedIndep)):
      if not sortedIndep[x-1]==sortedIndep[x]:
        cuts.append(x)
    cuts.insert(0, 0); cuts.insert(len(cuts),len(sortOrder))
    for x,y in pairs(cuts):
      print x, y
      divs.append([sortedIndep[x],np.std(sortedDep[x:y]),[(sortedIndep[z], sortedDep[z]) for z in xrange(x,y)]])
    return divs

print chardiv([r[0],r[4]])l = [1, 3, 2, 5]

print(l)
print(sorted(l))
l.sort()
print(l)
print(l == sorted(l))

print(sorted(l, key=lambda x: -x))
l.sort(key=lambda x: -x)
print(l)
print(l == sorted(l, key=lambda x: -x))

print(sorted(l, key=lambda x: -x, reverse=True))
l.sort(key=lambda x: -x, reverse=True)
print(l)
print(l == sorted(l, key=lambda x: -x, reverse=True))

print(sorted(l, reverse=True))
l.sort(reverse=True)
print(l)
print(l == sorted(l, reverse=True))

print(sorted(l, reverse=False))
l.sort(reverse=False)
print(l)
print(l == sorted(l, reverse=False))


l = list(range(2000))
l.sort()
print(l[0], l[-1])
l.sort(reverse=True)
print(l[0], l[-1])


class A:
    def __init__(self, x):
        self.x = x
    def __lt__(self, other):
        return self.x > other.x
    def __repr__(self):
        return str(self.x)
l = [A(5), A(2), A(1), A(3), A(4)]
print(l)
l.sort()
print(l)
l.sort(reverse=True)
print(l)

class WeightBasedSorter( object ):

    def sort( self, viewlets ):
        return sorted( viewlets,
                       lambda x, y: cmp(x[1].weight, y[1].weight ) )


"""
Given list l, sort it in reverse order
ie: 10, 9, 8, 7, 6
"""
l = [5,2,1,5,9,10,11]
l2 = [4, 8]

def merge_sort(my_list):
    if len(my_list) <= 1:
        return my_list
    elif len(my_list) == 2:
        temp_list = []
        if my_list[0] > my_list[1]:
            temp_list.append(my_list[0])
            temp_list.append(my_list[1])
        else:
            temp_list.append(my_list[1])
            temp_list.append(my_list[0])
        return temp_list
    else:
        temp_list = []
        list1 = my_list[:(len(my_list)-1)/2]
        list2 = my_list[(len(my_list)-1)/2:]
        sorted_list1 = merge_sort(list1)
        sorted_list2 = merge_sort(list2)
        while len(sorted_list1) != 0 and len(sorted_list2) != 0:
            if sorted_list1[0] > sorted_list2[0]:
                temp_list.append(sorted_list1.pop(0))
            else:
                temp_list.append(sorted_list2.pop(0))
        if len(sorted_list1) == 1 and len(sorted_list2) == 0:
            temp_list.append(sorted_list1.pop(0))
        elif len(sorted_list1) == 0 and len(sorted_list2) == 1:
            temp_list.append(sorted_list2.pop(0))
        return temp_list




sorted_l = merge_sort(l)
print sorted_l


import random as rd

def merge_sort(x):
    '''
    x: unsorted list
    '''
    if len(x) == 1:
        return x

    left = x[:len(x)/2]
    right = x[len(x)/2:]

    left_sorted = merge_sort(left)
    right_sorted = merge_sort(right)


    Y = []
    left_k = 0
    right_k = 0
    for k in range(len(x)):
        if left_sorted[left_k] < right_sorted[right_k]:
            Y.append(left_sorted[left_k])
            left_k += 1
        else:
            Y.append(right_sorted[right_k])
            right_k += 1


        if left_k == len(left_sorted):
            Y.extend(right_sorted[right_k:])
            return Y
        if right_k == len(right_sorted):
            Y.extend(left_sorted[left_k:])
            return Y
    return Y

def partition(Y,p):
    '''
    partitions the list using pivot, p
    '''
    left = []
    right = []
    pivots = []
    for k in range(len(Y)):
        if Y[k] < p:
            left.append(Y[k])
        elif Y[k] > p:
            right.append(Y[k])
        elif Y[k] == p:
            pivots.append(Y[k])
    return left,right,pivots

def quick_sort(X):
    '''
    quick sort
    '''

    if len(X) <= 1:
        return X

    pivot = X[0]
    left,right,pivots =  partition(X,pivot)
    left_sorted = quick_sort(left)
    right_sorted = quick_sort(right)
    left_sorted.extend(pivots)
    left_sorted.extend(right_sorted)
    return left_sorted


def quick_select(X,n):
    '''
    smartly finds n_th element in a list
    uses quickselection technique
    '''


    if len(X) == 1:
        return X[0]

    pivot = X[0]
    left,right,pivots = partition(X,pivot)








    if len(left) > n:
        return quick_select(left,n)


    elif len(left)+len(pivots) > n:
        return pivot


    else:
        return quick_select(right,n-len(left)-len(pivots))



import unittest

class mergeSort:

    def sort(self, arr):
        return self.merge_sort(arr)


    def merge_sort(self, arr):
        if len(arr) < 2:
            return arr
        mid = int(len(arr) / 2)
        x = self.merge_sort(arr[:mid])
        y = self.merge_sort(arr[mid:])
        z = self.merge(x, y)
        return z


    def merge(self, y, z):
        self.isSorted(z)
        self.isSorted(y)
        result = list()
        while (len(y) > 0) and (len(z) > 0):
            if y[0] < z[0]:
                result.append(y[0])
                y.pop(0)
            else:
                result.append(z[0])
                z.pop(0)
        result += y
        result += z
        return result


    def isSorted(self, arr):
        try:
            for i in range(len(arr)-1):
                assert (arr[i] <= arr[i+1])
        except AssertionError, e:
            print arr
            print str(e)
            raise RuntimeError("damar")


if __name__ == '__main__':
    ms = mergeSort()
    print ms.sort([3, 6, 5, 1, 4, 2])
def merge_sort(a,b):
	"""merge_sort two sorted lists"""
	out = []
	i = 0
	j = 0

	while i < len(a) and j < len(b):
		if a[i] < b[j]:
			out.append(a[i])
			i += 1
		elif b[j] < a[i]:
			out.append(b[j])
			j += 1
		elif a[i] == b[j]:
			out.append(a[i])
			out.append(b[j])
			i += 1
			j += 1

	if i < len(a):
		out.extend(a[i:])
	if j < len(b):
		out.extend(b[j:])

	return out






def sort_merge_rec(lst):
	"""sort an unsorted list using merge sort. takes in list, returns that list, sorted"""

	if len(lst) > 1:
		left = sort_merge_rec(lst[:len(lst)/2])
		right = sort_merge_rec(lst[len(lst)/2:])
		return merge_sort(left, right)
	else:
		return lst

if __name__=='__main__':
    from timeit import Timer

    t = Timer("sort_merge_rec", "from __main__ import sort_merge_rec")
    print sort_merge_rec([2, 5, 3, 7, 6, 1])
    print t.timeit()







def mySortFunction(a,b):
    return a[1]-b[1]


myListofLists=[[8,9,3],[1,1,5],[4,5,0],[3,4,9],[6,3,1]]


print sorted(myListofLists)

print sorted(myListofLists,cmp=mySortFunction)from tempfile import NamedTemporaryFile
import subprocess

def report_diff(correct_report_path, test_report_path):

    sorted_correct = NamedTemporaryFile()
    presort_correct = open(correct_report_path)
    for line in sorted(presort_correct):
        sorted_correct.file.write(line)
    sorted_correct.file.flush()


    sorted_test = NamedTemporaryFile()
    presort_test = open(test_report_path)
    for line in sorted(presort_test):
        sorted_test.file.write(line)
    sorted_test.file.flush()

    result = subprocess.Popen(["diff", "-b", sorted_correct.name, sorted_test.name],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result.wait()
    return "".join(result.stdout)import random
import copy


def inorder(x):
    i = 0
    j = len(x)
    while i + 1 < j:
        if x[i] > x[i + 1]:
            return False
        i += 1
    return True


def sort(x):

    random.shuffle(x)
    return x




sorted_seq = [x for x in range(10) if random.choice([True, False])]

unsorted_seq = copy.copy(sorted_seq)
random.shuffle(unsorted_seq)

assert sorted_seq == sort(unsorted_seq)
def centered_average(nums):
    sort_nums = sorted(nums)
    length = len(nums)
    if length % 2 == 0:
        return (sort_nums[length / 2 -1] + sort_nums[length / 2]) / 2
    else:
        return sort_nums[length / 2]
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
'''
Created on Jun 22, 2013

@author: Yubin Bai

All rights reserved.
'''
from collections import deque


def topoSort(graph):
    def topoVisit(u):
        visited[u] = 1
        for v in graph[u]:
            if (visited[v] == 0):
                topoVisit(v)
        topoSorted.appendleft(u)
    visited = {}
    for v in graph:
        visited[v] = 0
    topoSorted = deque()
    for v in graph:
        if visited[v] == 0:
            topoVisit(v)
    return topoSorted

if __name__ == '__main__':
    graph = {0: [1], 1: [3], 2: [1], 3: [2, 4], 4: [5], 5: [7], 6: [4], 7: [6]}
    print topoSort(graph)
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(my_class):
    return sorted(my_class, reverse=True)


from operator import itemgetter


def sort_by_name(my_class):
    return sorted(my_class, key=itemgetter(1))





def merge(left,right):
    sorted=[]
    i,j=0,0
    while i<len(left) and j<len(right):
        if left[i] < right[j]:
            sorted.append(left[i])
            i+=1
        else:
            sorted.append(right[j])
            j+=1

    sorted+=left[i:]
    sorted+=right[j:]
    return sorted

def merge_sort(li):
    "function to compute merge-sort"
    if len(li)==1:
        return li
    middle=len(li)/2
    left_li=merge_sort(li[:middle])
    right_li=merge_sort(li[middle:])
    return merge(left_li,right_li)


if __name__=="__main__":

    li=[10,5,2,3,7,4,8,9]
    print merge_sort(li)

def merge(a, p, r, q):
	sorted_a = []

	i = p
	j = r+1

	while i <= r and j <= q:
		if a[i] < a[j]:
			sorted_a.append(a[i])
			i += 1
		else:
			sorted_a.append(a[j])
			j += 1

	if i <= r:
		sorted_a.extend(a[i:r+1])
	elif j <= q:
		sorted_a.extend(a[j:q+1])

	a[p:q+1] = sorted_a

def merge_sort(a, p, q):
	if p != q:
		r = (p+q) // 2
		merge_sort(a, p, r)
		merge_sort(a, r+1, q)
		merge(a, p, r, q)

def binary_search(a, v, start, end):
	while start <= end:
		m = (start+end) // 2
		if a[m] == v:
			return m
		elif a[m] > v:
			end = m-1
		else:
			start = m+1

	return -1

def has_summands(a, x):
	merge_sort(a, 0, len(a)-1)
	for i in range(len(a)-1):
		s1 = a[i]
		s2 = x - s1
		if binary_search(a, s2, i+1, len(a)-1) > -1:
			return s1, s2

	return None

a = [7, 1, 2, 3, 0, 1]
for i in [0, 9, 5, 3, 2]:
	print "%d = %s" % (i, has_summands(a, i))
from random import randint
from nose.tools import assert_equal


class TestSortStack(object):

    def get_sorted_stack(self, numbers):
        stack = MyStack()
        for x in numbers:
            stack.push(x)
        sorted_stack = stack.sort()
        return sorted_stack

    def test_sort_stack(self):
        print('Test: Empty stack')
        sorted_stack = self.get_sorted_stack([])
        assert_equal(sorted_stack.pop(), None)

        print('Test: One element stack')
        sorted_stack = self.get_sorted_stack([1])
        assert_equal(sorted_stack.pop(), 1)

        print('Test: Two or more element stack (general case)')
        num_items = 10
        numbers = [randint(0, 10) for x in range(num_items)]
        sorted_stack = self.get_sorted_stack(numbers)
        sorted_numbers = []
        for _ in range(num_items):
            sorted_numbers.append(sorted_stack.pop())
        assert_equal(sorted_numbers, sorted(numbers, reverse=True))

        print('Success: test_sort_stack')


def main():
    test = TestSortStack()
    test.test_sort_stack()


if __name__ == '__main__':
    main()'''
Created on Nov 10, 2015

@author: st.becker
'''
import math

class Scorer(object):
    '''
    classdocs
    '''


    def __init__(self):
        '''
        Constructor
        '''

    def sort(self, setToSort, board):
        def sortKey(word):
            weight = 0
            for value in range(10):
                weight += board.countOverlapForValue(value, word) * math.pow(10, -value)
            return weight

        return sorted(setToSort,key=sortKey,reverse=True)import random

def sorted_(list_):
    return all(list_[i] <= list_[i+1] for i in xrange(len(list_) - 1))
def generate_(n = 10, k = 10):
    return [random.randrange(0, k) for _ in range(0, n)]
def swap(list_, left, right):
    temp = list_[left]
    list_[left] = list_[right]
    list_[right] = temp
def run_algorithm(list_, sort_function):
    for i in list_:
        sort_function(list_)
        if not sorted_(list_): return False
    return True
def is_sorted(ser):
    ser1=ser[:]
    ser.sort()
    if ser==ser1:
        return True
    else:
        return False

s=['a','t','c']
print(is_sorted(s))
__author__ = 'kud'
def break_words(stuff):
    words = stuff.split(" ")
    return words

def sort_words(words):
    return sorted(words)

def print_first_word(words):
    word = words.pop(0)
    return word

def print_last_word(words):
    word = words.pop(-1)
    return word

def sort_sentence(sentence):
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    words = break_words(sentence)
    return print_first_word(words) +"\n"+ print_last_word(words)


def print_first_and_last_sorted(sentence):
    words = sort_sentence(sentence)
    return print_first_word(words) + "\n" + print_last_word(words)


s = "This is test sentence."

w = break_words(s)
sorted_words = sort_words(w)
print w
print sorted_words
print print_first_word(w)
print print_last_word(w)
print sort_sentence(s)
print print_first_and_last(s)
print print_first_and_last_sorted(s)
def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]




def insertionSort(l):
    """
    Returns "s" as a sorted list in worst case O(n**2) runtime.
    """
    for i in range(len(l)):
        j = i
        while j > 0 and l[j] < l[j-1]:
            l[j], l[j-1] = l[j-1], l[j]
            j -= 1
    return l
def bubble_sort(mylist):
	length=len(mylist)
	for i in range(length-1):
		if (mylist[i]>mylist[i+1]):
			temp=mylist[i]
			temp2=mylist[i+1]
			mylist[i]=temp2
			mylist[i+1]=temp
			bubble_sort(mylist)

	return mylist

print (bubble_sort([5,19,4,1,36,99,2]))

assert bubble_sort([5,19,4,1,36,99,2]) == sorted([5,19,4,1,36,99,2])
assert bubble_sort(["Greg", "Armen", "Ken"]) == sorted(["Greg", "Armen", "Ken"])
from mDist import mDist

def DistSort(p,C):
	dists=[ (mDist(p,c),c) for c in C]
	return [p for d,p in sorted(dists,key=lambda x: x[0])]
def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])


print(sort_fractions([(2, 3), (1, 2)]))
print(sort_fractions([(2, 3), (1, 2), (1, 3)]))
print(sort_fractions([(5, 6), (22, 78), (22, 7), (7, 8), (9, 6), (15, 32)]))
from itertools import count

def sortView(n):
	""" Returns character-sorted string representation of input value """
	return ''.join(sorted(list(str(n))))

for n in count(1):
	if sortView(n) == sortView(2*n) == sortView(3*n) == sortView(4*n) == sortView(5*n) == sortView(6*n):
		break

print "Solution found at n = %d " % n



def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
class Solution:



    def isAnagram(self, s, t):
        s_list, t_list = list(s), list(t)
        s_list.sort()
        t_list.sort()
        sorted_s = ''.join(s_list)
        sorted_t = ''.join(t_list)
        return sorted_s == sorted_t


import random

def is_sorted(sequence):
	for i, j in zip(sequence, sequence[1:]):
		if j < i:
			return False
	return True


def swap(sequence, i, j):
	sequence[i], sequence[j] = sequence[j], sequence[i]


def shuffle(sequence):
	for i in range(1, len(sequence)):
		swap(sequence, i, random.randrange(i + 1))


def partition(sequence, i, j):
	pivot = i
	i += 1
	j -= 1
	while i < j:
		while i < j and sequence[i] < sequence[pivot]:
			i += 1
		while i < j and sequence[j] > sequence[pivot]:
			j -= 1
		swap(sequence, i, j)

	if sequence[i] >= sequence[pivot]:
		i -= 1

	swap(sequence, pivot, i)

	return i


def actual_sort(sequence, i, j):
	if (j - i) <= 1:
		return
	pivot = partition(sequence, i, j)
	actual_sort(sequence, i, pivot)
	actual_sort(sequence, pivot + 1, j)
	assert is_sorted(sequence[i:j])


def sort(sequence):
	shuffle(sequence)
	actual_sort(sequence, 0, len(sequence))


def main():
	l = [1, 4, 5, 3, 20, -1, 7, 2, 0]
	sort(l)
	print(l)

if __name__ == '__main__':
	main()

import os
import sys

def merge(left, right):
    sorted_list = []
    left_index = 0
    right_index = 0

    while (left_index < len(left)) and (right_index < len(right)):
        if left[left_index] < right[right_index]:
            sorted_list.append(left[left_index])
            left_index += 1
        else:
            sorted_list.append(right[right_index])
            right_index += 1

    if left:
        sorted_list.extend(left[left_index:])
    if right:
        sorted_list.extend(right[right_index:])

    return sorted_list

def merge_sort(l):
    if len(l) <= 1:
        return l

    mid = len(l) / 2
    left  = l[mid:]
    right = l[:mid]

    left = merge_sort(left)
    right = merge_sort(right)

    return merge(left, right)

if __name__ == "__main__":
    from random import shuffle
    l = [1,2,3,4,5,6,7,8,9]
    shuffle(l)
    assert merge_sort(l) == [1,2,3,4,5,6,7,8,9]
def string_length_sort(strings):
	items_counted = {}
	for item in strings:
	    items_counted.setdefault(item, len(item))

	sorted_by_count = sorted([(value, key) for (key,value) in items_counted.items()])
	return [i[1] for i in sorted_by_count]


def sort_by_key(item_list, key):
    return sorted(item_list, key=lambda k: k[key])

class Solution:

	def findMedianSortedArrays(self, A, B):
		c = A + B
		c.sort()
		ln = len(c)
		if ln % 2 == 0:
			return (c[ln / 2 - 1] + c[ln / 2]) / 2.0
		else:
			return c[ln / 2]
import random

def sort(array):

    print(array)
    print('using built in sort to check if array is sorted ')
    print(sorted(array))

    return array

def initArray(array):



    return array


def main():
    array = [0, 5, 1]
    print(array)
    array = initArray(array)
    print(array)
    array = sort(array)
    print(array)


main()
__author__ = 'bruno'
import algorithms.sort.selectionSort as SelectionSort


def search(array, k):
    sorted_array = SelectionSort.sort(array)
    return sorted_array[k]def insertion_sort(unsorted_list):
  sorted_list = []

  for idx1, val1 in enumerate(unsorted_list):
    current = unsorted_list[idx1]
    inserted = False

    if idx1 == 0:
      sorted_list.append(current)
    else:
      for idx2, val2 in enumerate(sorted_list):

        if val2 > val1 and not inserted:
          sorted_list.insert(idx2, val1)
          inserted = True
      if not inserted:
        sorted_list.append(val1)

  return sorted_listfrom helper import *


def insert_sort(head):
    sorted_head = head
    if not head or not head.next:
        return sorted_head

    head = head.next
    if head.val < sorted_head.val:
        sorted_head.next = head.next
        head.next = sorted_head
        sorted_head, head = head, sorted_head

    while head:
        pre = sorted_head
        cur = sorted_head.next
        while cur and head.val >= cur.val:
            cur = cur.next
            pre = pre.next
        else:
            if not cur:
                break
            pre.next = cur.next
            cur.next = pre
        head = head.next
    return sorted_head


if __name__ == '__main__':
    head = build_llist([29, 23, 82, 11])
    print_llist(head)

    pro_head = insert_sort(head)
    print_llist(pro_head)
import pytest
from gossip.exceptions import CannotResolveDependencies
from gossip.utils import _topological_sort


def test_topological_sort(indices, graph, expected):
    sorted = _topological_sort(indices, set(graph))
    assert len(sorted) == len(indices)
    assert set(sorted) == set(indices)
    assert sorted == expected


def test_cycles():
    with pytest.raises(CannotResolveDependencies):
        _topological_sort([0, 1, 2, 3], set([(0, 1), (1, 2), (2, 0)]))


@pytest.fixture(params=[
    (set([(0, 1), (1, 2)]), [0, 1, 2, 3, 4]),
    (set([(4, 0), (2, 4), (3, 2)]), [1, 3, 2, 4, 0]),
    (set([(4, 0), (2, 4), (3, 1), (3, 2)]), [3, 2, 4, 0, 1]),
    ])
def graph_expected(request):
    return request.param

@pytest.fixture
def graph(graph_expected):
    return graph_expected[0]

@pytest.fixture
def expected(graph_expected):
    return graph_expected[1]


@pytest.fixture
def indices():
    return list(range(5))
def sort_a_list(a):
    b = sorted(a, reverse=True)
    return(b)


def sort_by_mark(a):
    d = sorted(a, reverse=True, key=lambda colonne: colonne[0])
    return(d)


def sort_by_name(a):
    d = sorted(a, key=lambda colonne: colonne[1])
    return(d)
__author__ = 'olya'

from random import randint


def quick_sort(s):
    info = {
        'comparisons': 0
    }

    def _quick_sort(sample):
        less = []
        greater = []
        equal = []
        if len(sample) < 2:
            return sample
        pivot = sample[randint(0, len(sample) - 1)]
        for x in sample:
            if x < pivot:
                info['comparisons'] += 1
                less.append(x)
            elif x > pivot:
                info['comparisons'] += 1
                greater.append(x)
            else:
                info['comparisons'] += 1
                equal.append(x)
        return _quick_sort(less) + equal + _quick_sort(greater)

    info['sorted'] = _quick_sort(s)
    return info['comparisons'], info['sorted']


def real_quick_sort(s, first, last):
    info = {
        'comparisons': 0
    }


    def _real_quick_sort(sample, p, r):
        info['comparisons'] += 1
        if p < r:
            q = partition(sample, p, r)
            i, j = get_corners(sample, p, r, q)
            _real_quick_sort(sample, p, i)
            _real_quick_sort(sample, j, r)


    def partition(sample, p, r):
        x = sample[r]
        i = p - 1
        for j in range(p, r):
            info['comparisons'] += 1
            if sample[j] < x:
                i += 1
                sample[i], sample[j] = sample[j], sample[i]
        sample[i + 1], sample[r] = sample[r], sample[i + 1]
        return i + 1


    def get_corners(sample, p, r, q):
        i, j = q - 1, q + 1
        while i > p and sample[i] == sample[q]:
            info['comparisons'] += 1
            i -= 1
        while j < r and sample[j] == sample[q]:
            info['comparisons'] += 1
            j += 1
        return i, j

    _real_quick_sort(s, first, last)
    info['sorted'] = s
    return info['comparisons'], info['sorted']import pytest
from random import randint

from insertion_sort import insertion_sort

_RANGE = 1000


@pytest.fixture
def make_random():
    return [randint(0, 100) for x in range(_RANGE)]


@pytest.fixture
def make_in_order():
    return [x for x in range(_RANGE)]


@pytest.fixture
def make_in_order_reverse():
    return [x for x in range(_RANGE)][::-1]


def test_insertion_sort_random(make_random):
    to_sort = make_random
    assert to_sort != sorted(to_sort)
    assert insertion_sort(to_sort) == sorted(to_sort)


def test_insertion_sort_in_order(make_in_order):
    to_sort = make_in_order
    assert to_sort == sorted(to_sort)
    assert insertion_sort(to_sort) == sorted(to_sort)


def test_insertion_sort_reverse(make_in_order_reverse):
    to_sort = make_in_order_reverse
    assert to_sort != sorted(to_sort)
    assert to_sort == sorted(to_sort)[::-1]
    assert insertion_sort(to_sort) == sorted(to_sort)





import os
import sys
sys.path.append(os.path.join('..'))
import dubious_sort as D
import random
import string

def generate_random_list(n):
    while True:
        mess = [random.choice(string.ascii_lowercase) for i in range(n)]


        if len(set(mess)) > 1:
            return mess

def test_n_10():
    lst = generate_random_list(10)
    assert D.sort(lst) == sorted(lst)





def test_n_100():
    for i in range(100):
        lst = generate_random_list(100)
        assert D.sort(lst) == sorted(lst)

def test_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst) == sorted(lst)

def test_broken_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst, broken=True) != sorted(lst)

def test_broken_n_2():
    for i in range(100):
        lst = generate_random_list(2)
        assert D.sort(lst, broken=True) != sorted(lst)







def merge_sort(a, b):
  if not a: return b
  if not b: return a
  if a[0] > b[0]: return [b[0]] + merge_sort(a, b[1:])
  else:           return [a[0]] + merge_sort(a[1:], b)

if __name__ == '__main__':
  a = [1, 3, 5, 7, 9]
  b = [2, 4, 6, 8, 10]
  print merge_sort(a, b)

def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist

import sys
import random

class InsertSort():
    N = []

    def __init__(self,arr):
        self.N = arr

    def exchange(self, x, y):
        tmp = self.N[x]
        self.N[x] = self.N[y]
        self.N[y] = tmp

    def isSorted(self):
        return self.checkSorted(0,len(self.N)-1)

    def lessThan(self, i, j):
        if self.N[i] < self.N[j]:
            return -1

        if self.N[i] > self.N[j]:
            return 1

        return 0

    def checkSorted(self,low,high):
        if low>= high:
            return True

        for k in range(low,high):
            if self.N[k] > self.N[k+1]:
                print "array not sorted!"
                for kk in range(low,high+1):
                    print self.N[kk]
                return False

        return True

    def Sort(self):
        num = len(self.N)

        for i in range(1,num):
            for j in range(i,0,-1):

                if self.lessThan(j,j-1) < 0:
                    self.exchange(j,j-1)
                else:
                    break

    def printN(self):
        print self.N

class ShellSort(InsertSort):
    def __init__(self,arr):
        InsertSort.__init__(self,arr)
        self.hSort = []
        i = 1
        while i < len(self.N):
            self.hSort.append()
            i = 3 * i + 1
        self.hSort.reverse()
        print "distance serial:",self.distance

    def Sort(self):


        num = len(self.N)

        for h in self.hSort:
            for i in range(1,num,h):
                for j in range(i,0,(-1) * h):

                    if self.lessThan(j, j-h) < 0:
                        self.exchange(j, j-h)
                    else:
                        break

def CallSortAlg(func,arg=None):
    import time
    t1 = time.time()
    func()
    t2 = time.time()
    print '%s took %0.3f ms' % (func.func_name, (t2-t1)*1000.0)

def InsertSortUnitTest():
    arrayN = []
    random.seed(10000000)

    for i in range(0,4000):
        arrayN.append(random.randint(1, 100000))

    print arrayN
    m = InsertSort(arrayN)
    res = CallSortAlg(m.Sort)
    m.printN()
    assert(m.isSorted())

InsertSortUnitTest()
class Stack:
 def __init__(self):
  self.elements = []

 def pop(self):
  return self.elements.pop()

 def push(self, x):
  self.elements.append(x)

 def isEmpty(self):
  return self.elements == []

 def peek(self):
  return self.elements[-1]

def sort(a):
 if a.isEmpty():
  return a
 b = Stack()
 sorted = False
 while not sorted:
  sorted = True
  while not a.isEmpty():
   x = a.pop()
   if a.isEmpty():
    b.push(x)
    continue
   if x > a.peek():
    sorted = False
    b.push(a.pop())
    a.push(x)
   else:
    b.push(x)
  while not b.isEmpty():
   a.push(b.pop())
 return a

a = Stack()
a.push(3)
a.push(1)
a.push(4)
a.push(2)
a = sort(a)
while not a.isEmpty():
 print a.pop()

from operator import itemgetter


def sort_dict(d):
    return sorted(d.items(), key=itemgetter(1), reverse=True)

assert sort_dict({3: 1, 2: 2, 1: 3}) == [(1, 3), (2, 2), (3, 1)]
assert sort_dict({1: 2, 2: 4, 3: 6}) == [(3, 6), (2, 4), (1, 2)]
assert sort_dict({1: 2, 2: 4, 3: 6}) == [(3, 6), (2, 4), (1, 2)]
assert sort_dict({1: 5, 3: 10, 2: 2, 6: 3, 8: 8}) == \
    [(3, 10), (8, 8), (1, 5), (6, 3), (2, 2)]



def MostlySortedList(n):
	A = CreateRandomList(N)
	A.sort()
	A[0], A[-1] = A[-1], A[0]
	return A



import sys

def alphaSort(s):
    l = list(set(sorted(s)))
    return ''.join(sorted(l))

def isPermute(x):

    num = set()

    num.add(alphaSort(str(x)))

    if(     alphaSort(str(2*x)) in num
            and alphaSort(str(3*x)) in num
            and alphaSort(str(4*x)) in num
            and alphaSort(str(5*x)) in num
            and alphaSort(str(6*x)) in num):
        return True
    else:
        return False

def solve():

    i = 1
    while True:
        if isPermute(i):
            return i
        i = i + 1

print solve()
def ex_sort(x):


	y = sorted(x, key= lambda x:x.split('.')[1])
	return y


print ex_sort(['a.py','b.c','v.txt','as.a'])
import unittest


def bubble_sort(array):
    sorted_array = array[::]
    is_sorted = False

    while not is_sorted:
        is_sorted = True
        for i in range(1, len(sorted_array)):
            if sorted_array[i - 1] > sorted_array[i]:
                sorted_array[i - 1], sorted_array[i] = sorted_array[i], sorted_array[i - 1]
                is_sorted = False

    return sorted_array


class TestBubbleSort(unittest.TestCase):
    def test_bubble_sort(self):
        self.assertEqual(range(1, 8), bubble_sort([1, 2, 3, 4, 5, 6, 7]))
        self.assertEqual(range(1, 8), bubble_sort([5, 1, 6, 3, 4, 2, 7]))
        self.assertEqual(range(1, 8), bubble_sort([7, 6, 5, 4, 3, 2, 1]))


if __name__ == "__main__":
    unittest.main()import operator


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(l):
    return sorted(list(l), reverse=True)


def sort_by_name(l):
    return sorted(list(l), key=operator.itemgetter(1), reverse=False)
import operator

def attributeSort(seq, attr):
    """
    """
    return sorted(seq, key=operator.attrgetter(attr))
from django import template
from catalog.additions import SORTED_PRODUCT_OPTION
register = template.Library()

@register.inclusion_tag('templatetags/categ_sort.html')
def categ_sort(selected):
    return {
        'sorted_options': SORTED_PRODUCT_OPTION,
        'selected': selected
    }
from __future__ import absolute_import
import collections

import funcfinder.questions.dict as q
from funcfinder.utils import *
sortedcontainers = try_import("sortedcontainers")


@solves(q.group_by_key_func)
def group_by_key_func(iterable, key_func):
    result = collections.defaultdict(list)
    for item in iterable:
        result[key_func(item)].append(item)
    return result


@solves(q.sort_dict_by_key)
def ordered_dict_sorted_by_key(d):
    return collections.OrderedDict(sorted(d.items()))


@solves(q.sort_dict_by_key, q.always_sorted_dict_by_key)
def sorted_dict(d):
    return sortedcontainers.SortedDict(d)


@solves(q.sort_dict_by_value)
def ordered_dict_sorted_by_value(d):
    return collections.OrderedDict(sorted(d.items(), key=lambda item: item[1]))


@solves(q.copy_dict)
def copy_dict(d):
    return d.copy()


import db

def inter_operation():
    op = input('Enter operation: insert/out/search power/search model/edit car/delete car/move car: ')
    return op

def incorrect_operation():
    print('Error! Incorrect operation.')

def out_cars():
    data,is_empty = db.load_from_pickle()

    if is_empty == False:
        data_sorted = data[:]
        data_sorted.sort(key=lambda i:i['model'])
        for i in range (len(data_sorted)):
            print(data_sorted[i]['model'],data_sorted[i]['power'],data_sorted[i]['sign'],data_sorted[i]['x'],data_sorted[i]['y'],data_sorted[i]['d'])

def insertion_sort(list):
    sorted_list = list[:]

    for index in range(0, len(list)):
        current_value = sorted_list[index]
        position = index

        while position > 0 and current_value < sorted_list[position - 1]:
            sorted_list[position] = sorted_list[position - 1]
            position -= 1

        sorted_list[position] = current_value

    return sorted_listdef case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
import unittest
import bubble_sort

class BubbleSortTest(unittest.TestCase):

    def is_list_sorted(lst):
        return all([lst[i] <= lst[i+1] for i in xrange(len(lst)-1)])

    def test_bubble_sort():
        lists = (
            [0,5,2,-1],
            []
            [-10,-3,0.1,3])




def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k






import random
import time


def build_random_list(upper_limit):
    rand_list = list(range(1, upper_limit))
    random.shuffle(rand_list)

    return rand_list


def merge_sort(rand_list):
    if len(rand_list) == 1:
        return rand_list

    half_len = int(len(rand_list) / 2)
    sec_half = len(rand_list) - half_len

    left_list = rand_list[:half_len]
    right_list = rand_list[half_len:]

    left_sorted = merge_sort(left_list)
    right_sorted = merge_sort(right_list)


    sorted_list = list()
    i = 0
    j = 0
    for k in range(len(rand_list)):
        if i == len(left_sorted):
            while j < len(right_sorted):
                sorted_list.append(right_sorted[j])
                j += 1
            break

        if j == len(right_sorted):
            while i < len(left_sorted):
                sorted_list.append(left_sorted[i])
                i += 1
            break


        if left_sorted[i] <= right_sorted[j]:
            sorted_list.append(left_sorted[i])
            i += 1
        else:
            sorted_list.append(right_sorted[j])
            j += 1

    return sorted_list


def calc_running_time(MS=False, upper_limit=1E3, num_trials=1E3):

    time_start = time.time()

    for i in range(num_trials):
        rand_list = build_random_list(upper_limit)


        if MS:
            sorted_list = merge_sort(rand_list)


        else:
            rand_list.sort()


    time_end = time.time()

    time_spent = time_end - time_start

    return time_spent


def test_merge_sort():
    error_count = 0
    upper_limit = int(1E2)

    for i in range(1000):
        rand_list = build_random_list(upper_limit)


        sorted_list = merge_sort(rand_list)


        rand_list.sort()
        if sorted_list != rand_list:


            error_count += 1

    print('Number of errors in merge sort is ', error_count)






for i in range(2, 10):
    upper_limit = int(10**i)
    print('Size of list: ', upper_limit)
    num_trials = 1000

    regular_RT = calc_running_time(False, upper_limit, num_trials)
    print('Python sort running time: ', regular_RT)

    MS_RT = calc_running_time(True, upper_limit, num_trials)
    print('Merge sort running time: ',MS_RT)

quit()



Size of list:  100
Python sort running time:  0.08988785743713379
Merge sort running time:  0.5029749870300293
Size of list:  1000
Python sort running time:  0.9489920139312744
Merge sort running time:  6.389283895492554
Size of list:  10000
Python sort running time:  10.525191068649292
Merge sort running time:  79.75374698638916
def isGreaterThan(valA, valB):
    return valA > valB

def sort_dict(d):
    sortedList = []
    for key in d:
        valueA = d[key]
        index = 0
        for (keyB, valueB) in sortedList:
            if isGreaterThan(valueA, valueB):
                break
            index = index + 1
        sortedList.insert(index, (key, valueA))
    return sortedList

if __name__ == "__main__":
    dictA = {3:1,2:2,1:3}
    expectedA = [(1,3),(2,2),(3,1)]
    print expectedA == sort_dict(dictA)

    dictB = {1:5,3:10,2:2,6:3,8:8}
    expectedB = [(3,10),(8,8),(1,5),(6,3),(2,2)]
    print expectedB == sort_dict(dictB)
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)



print sorted([2,134,5,657,78,34])

def reversed_cmp(x, y):
	if x > y:
		return -1
	elif x < y:
		return 1
	return 0
print sorted([21,332,23,62,1,34,11,123], reversed_cmp)



print sorted(['alice','Jacob','Bob','chenlina'])

def cmp_ignore_case(s1, s2):
	u1 = s1.upper()
	u2 = s2.upper()
	if u1 > u2:
		return 1
	elif u1 < u2:
		return -1
	return 0
print sorted(['alice','Jacob','Bob','chenlina'], cmp_ignore_case)








def SelectionSort(L):
	unsorted_list = L
	sorted_list = []
	while unsorted_list != []:
		least = unsorted_list[0]
		for e in unsorted_list:
			if e < least:
				least = e
		unsorted_list.remove(least)
		sorted_list.append(least)
	return sorted_list




def Inplace_SelectionSort(L):
	for i in range(len(L)):
		l = i
		for j in range(i+1, len(L)):
			if L[j] < L[l]:
				l = j

		L[l], L[i] = L[i], L[l]



def main():
	L1 = [1, 4, 3, 5, 6, 2]
	print "SelectionSort: ", SelectionSort(L1)

	L2 = [1, 4, 3, 5, 6, 2]
	Inplace_SelectionSort(L2)
	print "Inplace SelectionSort: ", L2

if __name__ == '__main__':
	main()
"""
Exercise 5A - Write a function sorted_string that takes one string
  argument and returns a string with the same characters but sorted in
  lexical (alphabetic) order.  You may use the list sort method, but
  you may NOT use the built-in library function 'sorted' in your
  solution.  Write your function in a module also named sorted_string
  that defines at least two test strings.  In your module, call your
  function on each of these strings and print the results.
"""
s = 'supercalifragilisticexpealidocius'
t = 'antidisestablishmentarianism'
def sorted_string(s):
    "sorted_string(s), s a string.  Returns a sorted string."


    s_list=list(s)

    if len(s) > 1:
        s_list.sort()

    return ''.join(s_list)

def test_sorted_string(s=s,t=t):
    print sorted_string(s)
    print sorted_string(t)
    return None

if __name__ == "__main__":

    import sys
    if len(sys.argv) == 3:
        test_sorted_string(s=sys.argv[1], t=sys.argv[2])
    else:
        test_sorted_string()
else:

    test_sorted_string()
def insertion_sort(input_list):
    if type(input_list) != 'list':
        input_list = list(input_list)

    sorted_list = []

    sorted_list.append(input_list[0])

    for item in input_list[1:]:

        if item >= sorted_list[-1]:
            sorted_list.append(item)

        else:
            for i in range(len(sorted_list)):
                if item < sorted_list[i]:
                    sorted_list.insert(i, item)
                    i +=1
                    break

    return sorted_list

l = [4, 5, 6, 19, 11, 2, 3]

s = ['cat', 'dog', 'bunny', 'apple']

t = (1, 5, 3, 2)

print insertion_sort(l)
print insertion_sort(s)
print insertion_sort(t)from operator import itemgetter, attrgetter, methodcaller


def sort_by_end(l):
    return sorted(l, key=itemgetter(1))


def pred(sorted_jobs, j):
    begin_time = sorted_jobs[j-1][0]
    i = j-1
    while sorted_jobs[i][1] > begin_time:
        if i < 0:
            break
        i -= 1

    if i < 0:
        return 0

    return i+1

def was(sorted_jobs):
    dp = [0 for _ in range(0,n_jobs+1)]

    for i in range(1, n_jobs+1):
        dp[i] = max(sorted_jobs[i-1][2] + dp[pred(sorted_jobs, i)], dp[i-1])

    return dp[n_jobs]


if __name__ == "__main__":
    T = int(input())

    for _ in range(T):
        n_jobs = int(input())

        jobs = []

        for _ in range(n_jobs):
            inp = list(map(int, input().split()))

            jobs.append([inp[0], inp[1], inp[2]])


        sorted_jobs = sort_by_end(jobs)

        res = was(sorted_jobs)

        print(res)

class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
def break_w(words) :
	return words.split(' ')

def get_first(words) :
	return words.pop(0)

def get_last(words) :
	return words.pop(-1)

def sort(words) :
	"""Sorts the words"""
	return sorted(words)

def sort_sentence(words) :
	"""sorts sentence"""
	break_words = break_w(words)
	return sort(break_words)

def print_first_last(sentence) :
	"""prints first and last word from sorted sentence"""
	sw = sort_sentence(sentence)
	print get_first(sw), get_last(sw)


print_first_last("ovo je proba i testiram nesto")



def bubble_sort(A):
	n = len(A)
	while True:
		newn = 0
		i = 1
		while i <= (n - 1):
			if A[i - 1] > A[i]:
				A[i - 1], A[i] = A[i], A[i - 1]
				newn = i
			i += 1
		n = newn
		if n == 0:
			break

	return A

def main():
	arr = [8, 6, 7, 5, 3, 0, 9]
	sorted = [0, 3, 5, 6, 7, 8, 9]

	print("Output:", bubble_sort(arr))
	print("Expected:", sorted)

if __name__ == "__main__":
	main()import imfeat


class SortedHistogram(imfeat.Histogram):

    def __init__(self, *args, **kw):
        super(SortedHistogram, self).__init__(*args, **kw)

    def __call__(self, image):
        out = super(SortedHistogram, self).__call__(image)
        out.sort()
        return out


class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
def insertionSort(ar):
    v = ar[-1]
    pos = len(ar) - 2

    if(-1 == pos):
      print " ".join(map(str, ar))
      return ""

    sorted = False
    while(not sorted):
      if(-1 == pos):
        ar[0] = v
        sorted = True

      elif(v <= ar[pos]):
        ar[pos+1] = ar[pos]
        pos -= 1

      elif(ar[pos] < v):
        ar[pos+1] = v
        sorted = True

      print " ".join(map(str, ar))

    return ""








def bubble(listToSort, length):
	for i in range(length-1):
		if listToSort[i] > listToSort[i+1]:
			tmp = listToSort[i]
			listToSort[i] = listToSort[i+1]
			listToSort[i+1] = tmp


def bubbleSort(listToSort):
	for i in range(len(listToSort),0,-1):
		bubble(listToSort, i)

	return listToSort



if __name__=="__main__":
    listToSort = [2,7,3,8,5,1,0,5,8,16,39,1,3,23,12,34,82,6,2,8,55,5,20]

    sortedList = bubbleSort(listToSort)
    print sortedListdef sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)

"""
Created on Mon Sep 21 18:56:59 2015

@author: pippo
"""
from operator import *


def sort_a_list(lista):
    stampa = sorted(lista, reverse=True)
    return stampa


def sort_by_mark(mycl):
    stampi = sorted(mycl, key=itemgetter(0), reverse=True)
    return stampi


def sort_by_name(mclass):
    stampo = sorted(mclass, key=itemgetter(1))
    return stampo


import unittest

def condense_meeting_ranges(meeting_ranges):
    sorted_meeting_ranges = sort_meetings(meeting_ranges)
    return sorted_meeting_ranges

def sort_meetings(meeting_ranges):
    return sorted(meeting_ranges)


class MergingRanges(unittest.TestCase):
    def test_condense_meeting_ranges(self):
        meeting_ranges = [(0,1), (3,5), (4,8), (10,12), (9,10)]
        condensed_ranges = [(0,1), (3,8), (9,12)]
        self.assertEquals(condense_meeting_ranges(meeting_ranges), condensed_ranges)

    def test_sort_meetings(self):
        meeting_ranges = [(3,5), (0,1),(4,8), (10,12), (9,10)]
        sorted_meeting_ranges = [(0,1), (3,5), (4,8), (9,10), (10,12)]
        self.assertEquals(sort_meetings(meeting_ranges), sorted_meeting_ranges)
class MyDict:
    def __init__(self, d = {}):
        self.dict = d

    def keys(self):
        """
        >>> a = MyDict({'a': 1, 'b': 2, 'c': 3})
        >>> a.keys()
        ['a', 'b', 'c']
        """
        sorted_keys = self.dict.keys()
        sorted_keys.sort()
        return sorted_keys

    def values(self):
        """
        >>> a = MyDict({'a': 1, 'b': 2, 'c': 3})
        >>> a.values()
        [1, 2, 3]
        """
        sorted_values = self.dict.values()
        sorted_values.sort()
        return sorted_values



def main():
    d = MyDict({'a' : 1, 'b' : 2, 'c' : 3})
    print( d.keys() )
    print( d.values() )

if __name__ == "__main__":
    import doctest
    doctest.testmod()
    main()
import sys


class MergeSort:

    def __init__(self, array):
        self.array      = array
        self.inversions = 0

    def get_inversions(self):
        return self.inversions

    def sort(self):
        return self.merge_sort(self.array)

    def merge_sort(self, array):
        length = len(array)

        if length < 2:
            return array
        else:
            split_length = int(length / 2)
            array_x      = self.merge_sort(array[:split_length])
            array_y      = self.merge_sort(array[split_length:])
            sorted       = []

            length_x = len(array_x)
            index_x, index_y = 0, 0
            while len(sorted) < length:

                if array_x[index_x] > array_y[index_y]:
                    sorted.append(array_y[index_y])
                    index_y += 1
                    self.inversions += length_x - index_x
                else:
                    sorted.append(array_x[index_x])
                    index_x += 1

                if index_x == len(array_x):
                    sorted.extend(array_y[index_y:])

                if index_y == len(array_y):
                    sorted.extend(array_x[index_x:])

            return sorted


def main(argv):
    file = open(argv[0])
    unsorted_list = [int(element) for element in file.readlines()]
    file.close()

    sorter      = MergeSort(unsorted_list)
    sorted_list = sorter.sort()
    inversion   = sorter.get_inversions()
    print "file \'%s\' contained %s elements and was sorted with %s inversions" % (argv[0], len(sorted_list), inversions)


if __name__ == "__main__":
    main(sys.argv[1:])
def anagram(dict):
  output = []
  map = {}

  for word in dict:
    sorted_word = sortchars(word)
    if sorted_word not in map:
      map[sorted_word] = [word]
    else:
      map[sorted_word].append(word)

  for k in map.keys():
    if (len(map[k])) > 1:
      output.append(map[k])

  return output

def sortchars(word):
  l = list(word)
  l.sort()
  return ''.join(l)

result = anagram(("algorithm", "dog", "cat", "god", "tac", "test"))
print result

songs = open("songs.txt").readlines()

def sort(file):
	sortedList = []
	for i in range(len(file)):
		currentLowest = ord(file[0][0])
		for song in file[:i]:
			if ord(song[0]) < currentLowest:
				currentLowesst = ord(song[0])
				sortedList.append(song)
	return sortedList











class Solution:




    def mergeSortedArray(self, A, B):
        if len(A) == 0:
            return B
        if len(B) == 0:
            return A

        result = []
        i,j = 0,0
        while (i < len(A)) and (j < len(B)):
            if A[i] < B[j]:
                result.append(A[i])
                i += 1
            else:
                result.append(B[j])
                j += 1

        if i == len(A):
            result += B[j:]
        if j == len(B):
            result += A[i:]

        return result




    def mergeSortedArray(self, A, B):
        C = A + B
        C.sort()
        return C
"""Lab_Flatten"""
def flatten(lis):
    """Return sort flatten list"""
    ans = []
    for i in lis:
        if isinstance(i, list):
            ans = ans + flatten(i)
        else:
            ans.append(i)
    return sorted(ans)
print flatten(input())


from heapq import heappush, heappop


def heapSort(array):
    """
    Running Time
    ------------
    :rtype : object
    :param array:
    Average: O(n*log(n))
    Best: O(n*log(n))
    Worst: O(n*log(n))
    """



    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]







    return sortedArray

if __name__ == '__main__':
    import random
    array = [random.randint(1, 2 ** 32) for f in xrange(10000)]
    sortedArray = heap_sort(array)
    print sortedArray
    print max(sortedArray)
    print min(sortedArray)
from time import time

__author__ = 'rabbi'


class BubbleSort:
    def __init__(self, unSortedList):
        self.unSortedList = unSortedList

    def bubbleSort(self):
        """
        Bubble sort
        """
        for passedNumber in range(len(self.unSortedList) - 1, 0, -1):
            for i in range(passedNumber):
                if self.unSortedList[i] > self.unSortedList[i + 1]:
                    self.unSortedList[i], self.unSortedList[i + 1] = self.unSortedList[i + 1], self.unSortedList[i]
        return self.unSortedList


if __name__ == '__main__':
    unSortedList = [12, 10, 8, 5, 9, 13, 20, 18, 17, 2, 4, 5, 1]
    bubbleSort = BubbleSort(unSortedList)
    startTime = time()
    sortedList = bubbleSort.bubbleSort()
    endTime = time()
    print sortedList
    print "Execution Time: %f" % (endTime - startTime)



from random import randrange

def merge(lst1, lst2):
    """
    input 2 unsorted lists
    output a sorted list in ascending order
    """

    idx = 0
    jdx = 0


    sorted_lst = []



    while idx != len(lst1) and jdx != len(lst2):




        if lst1[idx] < lst2[jdx]:
            sorted_lst.append(lst1[idx])
            idx += 1
        else:
            sorted_lst.append(lst2[jdx])
            jdx += 1



    sorted_lst.extend(lst1[idx:])
    sorted_lst.extend(lst2[jdx:])

    return sorted_lst

def merge_sort(lst):
    """
    a recursive method to sort a list into ascending order
    """


    if len(lst) < 2:
        return lst

    else:
        half1 = lst[:len(lst)//2]
        half2 = lst[len(lst)//2:]

        sorted_1 = merge_sort(half1)
        sorted_2 = merge_sort(half2)

        return merge(sorted_1, sorted_2)



def merge_sort_test():
    """
    function to test merge_sort with random numbers
    """
    failed = 0
    for trial in range(100):
        length = randrange(1, 10)
        idx = 0
        lst = []
        for item in range(length):
            lst.append(randrange(1, 999))


        sorted_lst = merge_sort(lst)
        if sorted_lst != sorted(lst):
            failed += 1

    if failed > 0:
        print "test failed for ", str(failed), " of cases."
    else:
        print "test passed!! :)"

merge_sort_test()
sort_dict({3:1,2:2,1:3}) == [(1,3),(2,2),(3,1)]
sort_dict({1:2,2:4,3:6}) == [(3,6),(2,4),(1,2)]



def sort_dict(d):
    'return a sorted list of tuples from the dictionary'
    return sorted(zip(d.keys, d.values()), key=lambda t: t[1], reverse=True)


def sort_dict(d):
    return sorted(d.items(), key=lambda t: t[1], reverse=True)

from operator import itemgetter
def sort_dict(d):
    return sorted(d.items(), key=itemgetter(1), reverse=True)
class Solution:



    def isAnagram(self, s, t):
        s_list, t_list = list(s), list(t)
        s_list.sort()
        t_list.sort()
        sorted_s = ''.join(s_list)
        sorted_t = ''.join(t_list)
        return sorted_s == sorted_tdef sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist


def sort_last(x):
    return sorted(x, key=lambda x:x[-1])

print sort_last([[1, 3], [3, 2], [2, 1]])
print sort_last([[2, 3], [1, 2], [3, 1]])
print sort_last([[1, 7], [1, 3], [3, 4, 5], [2, 2]])from operator import attrgetter

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "(%f, %f)" % (self.x, self.y)

    @staticmethod
    def sort(points):
        return sorted(points, key=attrgetter('x', 'y'))
''' implement merge sort
'''

''' merge two sorted arrays A and B into C
'''
import sys
def merge(A,B):
    a_len = len(A)
    b_len = len(B)
    C=[]
    A.append(sys.maxint)
    B.append(sys.maxint)
    i=j=0
    while i < a_len and j < b_len:
        if A[i] < B[j]:
            C.append(A[i])
            i+=1
        else:
            C.append(B[j])
            j+=1
    return C


''' return a sorted array of A
'''
def merge_sort(A):
    if (len(A)==1):
        return A
    first_half = merge_sort(A[:len(A)/2])
    second_half = merge_sort(A[len(A)/2:])
    return merge(first_half, second_half)


if __name__=='__main__':
    print merge_sort([3,9,7,6,2,5,1,4])

def quickSort(toSort):
	"""Default quick sort"""
	if len(toSort) <= 1:
		return toSort

	end = len(toSort) - 1
	pivot = toSort[end]

	low = []
	high = []

	for num in toSort[:end]:
		if num <= pivot:
			low.append(num)
		else:
			high.append(num)

	sortedList = quickSort(low)
	sortedList.append(pivot)
	sortedList.extend(quickSort(high))

	return sortedList

def main():
	array = [1, 6, 7, 2, 76, 45, 23, 4, 8, 12, 11]
	sortedList = quickSort(array)
	print sortedList

if __name__ == '__main__':
    main()

def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]
def checkio(data):
    sort  = sorted(data)
    length = len(data)
    find_median = float((sort[length/2] + sort[-(length+1)/2]))/2
    print find_median
    return find_median



if __name__ == '__main__':
    assert checkio([1, 2, 3, 4, 5]) == 3, "Sorted list"
    assert checkio([3, 1, 2, 5, 3]) == 3, "Not sorted list"
    assert checkio([1, 300, 2, 200, 1]) == 2, "It's not an average"
    assert checkio([3, 6, 20, 99, 10, 15]) == 12.5, "Even length"
import sys

def sort_word(word):
    return "".join(sorted(word))


def is_match(word, sortedWord):
    return sortWord(word.lower()) == sortedWord.lower()


def append_results(words, sorted_input):
    results = []
    for key, value in words.items():
        if value.lower() == sorted_input.lower():
            results.append(key)
    return results


def main(word_input = ""):
    dictionary = open("dict").read().splitlines()
    sorted_input = sort_word(word_input.lower())

    words = {}

    for line in dictionary:
        words[line.lower()] = sort_word(line).lower()

    results = append_results(words, sorted_input)

    for result in results:
        print result


if __name__ == "__main__":
    main(sys.argv[1])

class WeightBasedSorter( object ):

    def sort( self, viewlets ):
        return sorted( viewlets,
                       lambda x, y: cmp(x[1].weight, y[1].weight ) )
def main():
    s = input("Enter a string: ").strip()
    print("The sorted string is " + sort(s))

def sort(s):
    r = list(s)
    r.sort()

    result = ""
    for ch in r:
        result += ch

    return result

main()

def merge(a, b):
	"""Merging subroutine. Meant to merge two sorted lists into a combined, sorted list."""
	n = len(a) + len(b)
	d = [0 for i in range(n)]
	i = 0
	j = 0
	for k in range(n):
		if a[i] < b[j]:
			d[k] = a[i]
			if i+1 > len(a)-1:
				for l in b[j:]:
					d[k+1] = b[j]
					k += 1
					j += 1
				return d
			i += 1
		elif a[i] > b[j]:
			d[k] = b[j]
			if j+1 > len(b)-1:
				for l in a[i:]:
					d[k+1] = a[i]
					k+=1
					i+=1
				return d
			j += 1

def merge_sort(c):
	"""Recursive merge sort. Takes non-repeating list and returns sorted version of the list."""
	if len(c) == 1:
		return c
	else:
		a = merge_sort(c[:int(len(c)/2)])
		b = merge_sort(c[int(len(c)/2):])
		return merge(a,b)

try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
''' implement merge sort
'''

''' merge two sorted arrays A and B into C
'''
import sys
def merge(A,B):
    a_len = len(A)
    b_len = len(B)
    C=[]
    A.append(sys.maxint)
    B.append(sys.maxint)
    i=j=0
    while i < a_len and j < b_len:
        if A[i] < B[j]:
            C.append(A[i])
            i+=1
        else:
            C.append(B[j])
            j+=1
    return C


''' return a sorted array of A
'''
def merge_sort(A):
    if (len(A)==1):
        return A
    first_half = merge_sort(A[:len(A)/2])
    second_half = merge_sort(A[len(A)/2:])
    return merge(first_half, second_half)


if __name__=='__main__':
    print merge_sort([3,9,7,6,2,5,1,4])

def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def break_words(stuff):
	""" Blah blah blah"""
	words = stuff.split(' ')
	return words

def sort_words(words):
	"Sort sort Sort"
	return sorted(words)

def print_first_word(words):
	""" First First First"""
	word = words.pop(0)
	print word

def print_last_word(words):
	""" Last Last Last"""
	word = words.pop(-1)
	print word

def sorted_sentence(sentence):
	"""Sorts the words in the sentence"""
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	"""First and Last of sentence"""
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	""" a b c"""
	words = sorted_sentence(sentence)
	print_first_word(words)
	print_last_word(words)

from django import template
from django.utils.datastructures import SortedDict

register = template.Library()

@register.filter(name='sort')
def listsort(value):
    if isinstance(value, dict):
        new_dict = SortedDict()
        key_list = sorted(value.keys())
        for key in key_list:
            new_dict[key] = value[key]
        return new_dict
    elif isinstance(value, list):
        return sorted(value)
    else:
        return value
    listsort.is_safe = True
import typ

@typ.typ(items=[int])
def strand_sort(items):
  """
  >>> strand_sort([])
  []
  >>> strand_sort([1])
  [1]
  >>> strand_sort([2,1])
  [1, 2]
  >>> strand_sort([1,2])
  [1, 2]
  >>> strand_sort([1,2,2])
  [1, 2, 2]
  """
  nitems = len(items)
  sortedBins = []
  while( len(items) > 0 ):
      highest = float("-inf")
      newBin = []
      i = 0
      while( i < len(items) ):
          if( items[i] >= highest ):
              highest = items.pop(i)
              newBin.append( highest )
          else:
              i=i+1
      sortedBins.append(newBin)

  sorted = []
  while( len(sorted) < nitems ):
      lowBin = 0
      for j in range( 0, len(sortedBins) ):
          if( sortedBins[j][0] < sortedBins[lowBin][0] ):
              lowBin = j
      sorted.append( sortedBins[lowBin].pop(0) )
      if( len(sortedBins[lowBin]) == 0 ):
          del sortedBins[lowBin]
  return sorted


"""
Created on Wed Sep 23 09:39:40 2015

@author: simonfredon
"""


from operator import *


def sort_a_list(lista):
    a = sorted(lista, reverse=True)
    return a


def sort_by_mark(mycl):
    b = sorted(mycl, key=itemgetter(0), reverse=True)
    return b


def sort_by_name(mclass):
    c = sorted(mclass, key=itemgetter(1))
    return c
""" Write a function lensort to sort a list of strings based on length.
"""

def lensort(lists):
	return sorted(lists, key = lambda x:len(x))
print lensort(['python', 'java', 'c', 'ruby', 'lisp', 'haskall'])
import random

def quick_sort(sortlist):
	left = []
	right = []
	solution = []
	if len(sortlist) <= 1:
		return sortlist
	pivot = sortlist[len(sortlist)/2]
	sortlist.remove(pivot)
	for each in sortlist:
		if each <= pivot:
			left.append(each)
		elif each > pivot:
			right.append(each)
	left_sorted = quick_sort(left)
	right_sorted = quick_sort(right)
	solution.append(left_sorted)
	solution.append(pivot)
	solution.append(right_sorted)
	return solution

list_to_sort = random.sample(range(1,100),10)

print quick_sort(list_to_sort)
def insertion_sort(unsorted_list):
  sorted_list = []

  for idx1, val1 in enumerate(unsorted_list):
    current = unsorted_list[idx1]
    inserted = False

    if idx1 == 0:
      sorted_list.append(current)
    else:
      for idx2, val2 in enumerate(sorted_list):

        if val2 > val1 and not inserted:
          sorted_list.insert(idx2, val1)
          inserted = True
      if not inserted:
        sorted_list.append(val1)

  return sorted_list__author__ = 'Brian Sargent'

class SortTupleList:
    tupleSortIndex = 0
    reverseOrder = False

    def __init__(self,tupleIndex,isReversed=False):
        self.tupleSortIndex = tupleIndex
        self.reverseOrder = isReversed

    def doSort(self,aList):
        """Sort a list of tuples. Tuple tupleSortIndex is used to select the tuple member used."""
        sortedList = sorted(aList,key=self.SortSelect,reverse = self.reverseOrder)
        return sortedList

    def SortSelect(self,tuple):
        return tuple[self.tupleSortIndex]








def sortedDictValue(adict):
    keys = adict.keys()
    keys.sort()
    return [(key,adict[key]) for key in keys]

def test_sortedDictValue():
    adict = { 'a':1,
              'c':22,
              'b':5 }

    print adict
    print sortedDictValue(adict)


def case_insensitive(string_list):
    auxiliary_list = [ (x.lower(), x) for x in string_list ]
    auxiliary_list.sort()
    return [ x[1] for x in auxiliary_list ]


def test_case_insensitive():
    sample_list = ['natsuko',
                   'SATOSHI',
                   'YOHKO',
                   'masahito']

    print sample_list
    print case_insensitive(sample_list)


    print sorted(sample_list, key=str.lower)

def main():
    test_sortedDictValue()
    test_case_insensitive()

if __name__ == '__main__':
    main()
from flask import render_template_string, url_for, request
from flask_jinjahelpers import header_sort_url
from tests import TemplateHelperTestCase


class TestHeaderSorter(TemplateHelperTestCase):
    def setup_views(self):
        @self.app.route('/')
        def index():
            sorted_fields = request.args.getlist('sort')
            return render_template_string(
                """
                {% from "_tablehelpers.html" import render_header_link %}
                {{
                render_header_link('name', 'Name', sorted_fields)
                }}
                """,
                sorted_fields=sorted_fields
            )

    def test_sort_by_empty_string(self):
        assert header_sort_url('') == (
            '/'
        )

    def test_with_consecutive_calls(self):
        assert header_sort_url('age') == (
            '/?sort=age'
        )
        assert header_sort_url('name') == (
            '/?sort=name'
        )

    def test_with_empty_string_in_sorted_fields(self):
        assert header_sort_url('name', ['']) == (
            '/?sort=name'
        )

    def test_with_hyphen_in_sorted_fields(self):
        assert header_sort_url('name', ['-']) == (
            '/?sort=name'
        )

    def test_sorted_fields_supports_string_as_parameter(self):
        assert header_sort_url('age', 'age') == (
            '/?sort=-age'
        )

    def test_sort_by_single_header(self):
        assert header_sort_url('age', ['name'], max_sorted_fields=2) == (
            '/?sort=age&sort=name'
        )
        assert header_sort_url('name') == '/?sort=name'
        assert header_sort_url('name', ['-name']) == '/?sort=name'
        assert header_sort_url('name', ['name']) == '/?sort=-name'

    def test_with_multiple_sorted_fields(self):
        assert header_sort_url(
            'name', ['name', 'age'], max_sorted_fields=2
        ) == (
            '/?sort=-name&sort=age'
        )

        assert header_sort_url(
            'age', ['name', 'age'], max_sorted_fields=2
        ) == (
            '/?sort=-age&sort=name'
        )

        assert header_sort_url(
            'age', ['name', '-age'], max_sorted_fields=2
        ) == (
            '/?sort=age&sort=name'
        )

        assert header_sort_url(
            'age', ['-age', 'name'], max_sorted_fields=2
        ) == (
            '/?sort=age&sort=name'
        )

    def test_max_number_of_sorted_fields(self):
        assert header_sort_url(
            'name', ['name', 'age'], max_sorted_fields=1
        ) == (
            '/?sort=-name'
        )

    def test_render_header_link(self):
        response = self.client.get(url_for('.index', sort=['name']))

        assert  '<th class="table-sort-asc">' in response.data
        assert '<a href="/?sort=-name">Name</a>' in response.data
        assert '</th>' in response.data

        response = self.client.get(url_for('.index', sort=['-name']))
        assert  '<th class="table-sort-desc">' in response.data
        assert '<a href="/?sort=name">Name</a>' in response.data
        assert '</th>' in response.data

        response = self.client.get(url_for('.index', sort=['name', 'age']))
        assert response.data.count('</th>') == 1
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)

def sort_word(w):
    """
    given a string, returns another string with the same letter but sorted alphabetically
    """
    return ''.join(sorted(w))

def detect_anagrams(word, words):
    sorted_word = sort_word(word.lower())
    word_dict = {}
    for w in words:
        if w.lower() != word.lower():
            word_dict.setdefault(sort_word(w.lower()), []).append(w)
    return word_dict.get(sorted_word, [])
import re
import sys
import requests

from . import FeedUtil
from . import ServerUtil
from . import Feed_TwitchTv

class Feeds_TwitchTv_GSL(object):
    @property
    def league(self):
        return "gsl"

    def sortGslVideosByLeague(self, videos):
        ServerUtil.info('Sort Videos by League')
        leagues = {}
        for i in videos:
            try:
                league = i['title'].split(',')[1].split('.')[0].strip()
                if league not in leagues:
                    leagues[league] = []
                leagues[league].append (i)
            except:
                pass
        return leagues

    def sortGslLeagueVideosByCode(self, videos):
        ServerUtil.info('Sort League by Code A/S')
        sorted = {'CodeS': [], 'CodeA': []}
        codeKeys = ['Code S', 'Code A']
        for video in videos:
            for code in codeKeys:
                if code in video['title']:
                    sorted[FeedUtil.restfiyString(code)].append(video)
        return sorted

    def sortGslVideosByGroup(self, videos):
        ServerUtil.info('Sort League Code Round by Group')
        sorted = {}
        for i in videos:
            try:

                if 'Ro4' in i['title']:
                    group = 'SemiFinal'
                    if group not in sorted:
                        sorted[group] = []
                    sorted[group].append(i)
                elif 'Ro8' in i['title']:
                    group = 'QuarterFinal'
                    if group not in sorted:
                        sorted[group] = []
                    sorted[group].append(i)
                else:
                    group = re.search('Group [a-zA-Z]', i['title'])
                    if group is None:
                        group = re.search('Final', i['title'])
                    group = group.group()
                    if group not in sorted:
                        sorted[group] = []
                    sorted[group].append(i)
            except:
                pass
        return sorted

    def sortGslVideosByRound(self, videos):
        ServerUtil.info('Sort League Code by Rounds')
        sorted = {}
        for i in videos:
            try:
                round = re.search('Ro[0-9][0-9]', i['title'])
                if round is None:
                    round = re.search('Ro[0-9]', i['title'])
                    if round is None:
                        round = re.search('Final', i['title'])
                round = round.group()
                if round not in sorted:
                    sorted[round] = []
                sorted[round].append(i)
            except:
                pass
        return sorted

    def sortGslVideosByMatch(self, videos):
        ServerUtil.info('Sort Round by Matches')
        sorted = {}
        for i in videos:
            try:
                match = re.search('Match.[0-9]', i['title'])
                if match is None:
                    match = re.search('Match[0-9]', i['title'])
                    if match is None:
                        match = re.search('Final', i['title'])
                match = match.group()
                if not match in sorted:
                    sorted[match] = []
                sorted[match].append(i)
            except:
                pass
        return sorted

    def sortGslCodeAVideos(self, videos):
        sortedByGroup = self.sortGslVideosByGroup(videos)
        groupKeys = list(sortedByGroup.keys())
        groupKeys.sort()
        sortedByGroup['_type'] = 'dir'
        sortedByGroup['_keys'] = groupKeys
        for i in groupKeys:
            sortedByGroup[i] = self.sortGslVideosByMatch(sortedByGroup[i])
            listKeys = list(sortedByGroup[i].keys())
            listKeys.sort()
            sortedByGroup[i]['_type'] = 'list'
            sortedByGroup[i]['_keys'] = listKeys
        return sortedByGroup

    def sortGslCodeSVideos(self, videos):
        sortedByRound = self.sortGslVideosByRound(videos)
        roundKeys = list(sortedByRound.keys())
        roundKeys.sort()
        sortedByRound['_type'] = 'dir'
        sortedByRound['_keys'] = roundKeys
        for i in roundKeys:
            sortedByRound[i] = self.sortGslVideosByGroup(sortedByRound[i])
            groupKeys = list(sortedByRound[i].keys())
            groupKeys.sort()
            sortedByRound[i]['_type'] = 'dir'
            sortedByRound[i]['_keys'] = groupKeys
            for j in groupKeys:
                sortedByRound[i][j] = self.sortGslVideosByMatch(sortedByRound[i][j])
                listKeys = list(sortedByRound[i][j].keys())
                listKeys.sort()
                sortedByRound[i][j]['_type'] = 'list'
                sortedByRound[i][j]['_keys'] = listKeys
        return sortedByRound

    def getSortedGslBroadcasts(self, videos):
        allGslLeagues = self.sortGslVideosByLeague(videos)
        gslLeaguesSorted = {}
        for i in allGslLeagues.keys():
            league = FeedUtil.restfiyString(i)
            gslLeaguesSorted[league] = self.sortGslLeagueVideosByCode(allGslLeagues[i])
            codeKeys = list(gslLeaguesSorted[league].keys())
            gslLeaguesSorted[league]['_type'] = 'dir'
            gslLeaguesSorted[league]['_keys'] = codeKeys
            gslLeaguesSorted[league]['CodeA'] = self.sortGslCodeAVideos(gslLeaguesSorted[league]['CodeA'])
            gslLeaguesSorted[league]['CodeS'] = self.sortGslCodeSVideos(gslLeaguesSorted[league]['CodeS'])
        return gslLeaguesSorted

    @FeedUtil.CacheResult(timer=50)
    def getGslVideos(self):
        videos = Feed_TwitchTv.getChannelVideos('gsl', broadcasts=True)
        sorted = self.getSortedGslBroadcasts(videos)
        return sorted

    @FeedUtil.Feed(key='league/gsl', timer=60)
    def Feed_getGslChannelInfo(self):
        return Feed_TwitchTv.getChannelObject('gsl')

    @FeedUtil.Feed(key='league/gsl/events', timer=60)
    def Feed_getGSLEvents(self):
        gsl = self.getGslVideos()
        events = []
        for i in gsl.keys():
            events.append(FeedUtil.restfiyString(i))
        events.sort()
        return {'keys': events}

    @FeedUtil.Feed(base='league/gsl/event/%s', timer=60)
    def Feed_getGSLEventVideos(self):
        gsl = self.getGslVideos()
        leagues = {}
        for i in gsl.keys():
            leagues[i] = {FeedUtil.restfiyString(i): gsl[i]}
        return leagues
import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))
def sort_me(lst):
    lst.sort(key=lambda a: str(a)[-1])
    return lst



assert sort_me(['acvd', 'bcc']) == ['bcc', 'acvd']
assert sort_me(['asdf', 14, '13', 'asdf']) == ['13', 14, 'asdf', 'asdf']
from random import Random

class BogoSort(object):
	def sort(self, list):
		while not self.isSorted(list):
			self.shuffle(list)
		return list

	def isSorted(self, list):
		return sorted(list) == list

	def shuffle(self, list):
		Random().shuffle(list)
		return listdef _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]



from __future__ import print_function

import sys





"Return a list of all edges (v0, w) in E starting at v0. Used by topsort."
def _allEdgesFrom(v0, E):
    resEdges = []
    for v, w in E:
        if v0 == v:
            resEdges.append((v, w))
    return resEdges


"Recursive topsort function."
def _topSort(v, E, visited, sorted, sortedIndices):


    visited[v] = 1
    for v, w in _allEdgesFrom(v, E):

        if not visited[w]:
            _topSort(w, E, visited, sorted, sortedIndices)
        else:
            if not sorted[w]:
                print('Cyclic dependency in links.')
                sys.exit(0)
    sorted[v] = 1
    sortedIndices.insert(0, v)


"""
Topological sort.

V = list of vertex names
E = list of 0-indexed edge pairs between vertices

Result is a list of sorted vertex names

Based on Topsort by Nathan Wallace, Matthias Urlichs
Hans Nowak, Snippet 302, Dinu C. Gherman
http://www.faqts.com/knowledge_base/view.phtml/aid/4491

Example of use:

import topsort

pairs = [('a', 'b'), ('b', 'c'), ('a', 'd'), ('b', 'd')]
print pairs

(V, E) = topsort.pairsToVertexEdgeGraph(pairs)
print
print V
print E

result = topsort.topSort(V, E)
print
print result
"""
def topSort(V, E):
    n = len(V)
    visited = [0] * n
    sorted  = [0] * n
    sortedIndices = []

    for v in range(n):
        if not visited[v]:
            _topSort(v, E, visited, sorted, sortedIndices)


    sortedElements = [V[i] for i in sortedIndices]

    return sortedElements


""" For use in preparing input for topsort.
Input is a dictionary whose values are the vertices connected to its keys.
Output is a list of pairs for pairsToVertexEdgeGraph
"""
def dictionaryToPairs(dict):
    pairs = [];
    for k in dict:
        for v in dict[k]:
            pairs.append( (k, v) )

    return pairs



"""Convert an element pairs list into (verticesList, edgeIndexList)
   for topSort.

   e.g. wrap( [('a','b'), ('b','c'), ('c','a')] )
         -> (['a','b','c'], [(0,1), (1,2), (2,0)])

   Returns Vertices, (indexed) Edges
"""
def pairsToVertexEdgeGraph(pairs):
    V = set()


    for x, y in pairs:
        V.add(x)
        V.add(y)


    V = [v for v in V]


    indexOf = {}
    i = 0
    for v in V:
        indexOf[v] = i
        i += 1


    E = [(indexOf[x], indexOf[y]) for x, y in pairs]

    return V, E



def sort_two_by_two(ul):

    for index in range(len(ul)):
        try:
            el1 = ul[index]
            el2 = ul[index + 1]
            if el1 > el2:
                ul[index] = el2
                ul[index +1] = el1
        except IndexError:
            return ul


def bubble(ul):

    sorted_list = ul
    copyed_list = []
    while copyed_list != sorted_list:
        copyed_list = sorted_list[:]
        sorted_list = sort_two_by_two(sorted_list)
    return sorted_list
import logging
import logging.handlers


logging.basicConfig(
    level=logging.DEBUG,
    format='LINE %(lineno)-4d  %(levelname)-8s %(message)s',
    datefmt='%m-%d %H:%M',
    filename="tree" + ".log",
    filemode='w')


def quick_sort(array, p, r):
    logging.info(array)
    if p < r:
        q = partition(array, p, r)
        quick_sort(array, p, q - 1)
        quick_sort(array, q + 1, r)


def partition(be_sorted, pivot, last_element):
    x = be_sorted[last_element]
    i = pivot - 1
    for j in range(pivot, last_element):
        print(be_sorted)
        if be_sorted[j] < x:
            i += 1
            be_sorted[j], be_sorted[i] = be_sorted[i], be_sorted[j]
    i += 1
    be_sorted[i], be_sorted[last_element] = be_sorted[last_element], be_sorted[i]
    return i


if __name__ == "__main__":
    be_sorted = [1, 99, 5, 23, 64, 7, 23, 6, 34, 98, 100, 9]
    logger = logging.getLogger()
    file_handler = logging.FileHandler('tree2.log', encoding='utf-8')
    logger.addHandler(file_handler)
    logging.info('')
    quick_sort(be_sorted, 0, len(be_sorted) - 1)



"""
This module implements the selection sort algorithim
"""



def selection_sort(arr):
    """
    Perform a selection sort on a given list. Return the sorted list.
    Example:

    >>> selection_sort([1, 5, 7, 2, 3, 4, 1])
    [1, 1, 2, 3, 4, 5, 7]
    >>> selection_sort(['a', 'd', 'b', 'c'])
    ['a', 'b', 'c', 'd']
    """
    pass
def sort_by_last_letter(strings):
    def last_letter(s):
        return s[-1]
    return sorted(strings, key=last_letter)
from django.utils.datastructures import SortedDict

def sort_dict(d, values=False):
    idx = values and 1 or 0
    return SortedDict(sorted(d.items(), cmp=lambda x,y: cmp(x[idx], y[idx])))
__author__ = 'bruno'


def odd_even_sort(unordered):
    """
        Worst case O(n^2)
        Best case O(n)
        Worst case space O(1)
    """
    is_sorted = False
    while not is_sorted:
        is_sorted = True

        i = 1
        while i < len(unordered)-1:
            if unordered[i] > unordered[i+1]:
                unordered[i], unordered[i+1] = unordered[i+1], unordered[i]
                is_sorted = False
            i += 2

        i = 0
        while i < len(unordered)-1:
            if unordered[i] > unordered[i+1]:
                unordered[i], unordered[i+1] = unordered[i+1], unordered[i]
                is_sorted = False
            i += 2
    return unordered"""Lab_LineSorting"""
def linesort(line):
    """return string with line sorted"""
    wordlist = [raw_input() for _ in xrange(line)]
    wordlist.sort(key=len)
    for j in wordlist:
        print j
linesort(input())

import random

def unsorted(N):
    return [random.randrange(0, N*10) for r in xrange(N)]

def sort(L):
    sortedL = [L[0]]
    N = len(L)
    for i in xrange(1, N):
        si = len(sortedL) - 1
        while si >= 0 and L[i] < sortedL[si]:
            si -= 1
        if si == len(sortedL) - 1:
            sortedL.append(L[i])
            continue
        temp = sortedL[si+1:]
        sortedL[si+1] = L[i]
        sortedL[si+2:] = temp
    return sortedL


def insertion_sort(L):
    if len(L) == 1:
        return L
    b = insertion_sort(L[1:])
    m = len(b)
    for i in range(m):
        if L[0] <= b[i]:
            return b[:i]+[L[0]]+b[i:]
    return b + [L[0]]

if __name__ == '__main__':
    l = unsorted(10)
    print l
    print sort(l)
    print insertion_sort(l)
__author__ = 'Vyacheslau Karachun'


def sort(array):
    is_sorted = False
    sorted_arr = array[:]
    while not is_sorted:
        difference_absent = True
        for i in range(0, len(array)-1):
            if array[i] > array[i+1]:
                sorted_arr[i] = array[i+1]
                sorted_arr[i+1] = array[i]
                difference_absent = False
        array = sorted_arr[:]
        if difference_absent:
            is_sorted = True
    return sorted_arr

def CountingSort(values, min_key, max_key, key=lambda x: x):
  counts = [0 for _ in xrange(max_key - min_key + 1)]
  for value in values:
    index = key(value) - min_key
    counts[index] += 1

  for i in xrange(1, len(counts)):
    counts[i] += counts[i - 1]

  sorted_values = [None for _ in values]
  for value in reversed(values):
    key_value = key(value)
    index = counts[key_value - min_key] - 1
    sorted_values[index] = value
    counts[key_value - min_key] -= 1
  return sorted_values


def InPlaceCountingSort(values, min_key, max_key, key=lambda x: x):
  """Not stable sort!"""
  counts = [0 for _ in xrange(max_key - min_key + 1)]
  for value in values:
    index = key(value) - min_key
    counts[index] += 1

  j = len(values)
  for i in xrange(len(counts) - 1, -1, -1):
    i_key = i + min_key
    k = j - 1
    for _ in xrange(counts[i]):
      while key(values[k]) != i_key:
        k -= 1
      Swap(values, j - 1, k)
      j -= 1
      k -= 1


def Swap(values, i, j):
  temp = values[i]
  values[i] = values[j]
  values[j] = temp


def GetDigitFunction(digit):
  mask = 10 ** digit

  def GetDigit(x):
    x /= mask
    x -= x / 10 * 10
    return x

  return GetDigit


def NumDecimals(value):
  count = 0
  while True:
    count += 1
    value /= 10
    if not value:
      return count


def RadixSort(values):
  for digit in xrange(NumDecimals(max(values))):
    values = CountingSort(values, 0, 9, key=GetDigitFunction(digit))
  return values


import unittest
import random
import copy


class TestCountingSort(unittest.TestCase):

  def setUp(self):
    self.longMessage = True

  def test_counting(self):
    values = [random.randint(1,10) for _ in xrange(100)]
    sorted_values = CountingSort(values, 1, 10)
    self.assertEqual(sorted(values), sorted_values,
                     msg='original={} sorted={}'.format(values, sorted_values))

  def test_InPlaceCountingSort(self):
    values = [random.randint(1,5) for _ in xrange(20)]
    original_values = copy.deepcopy(values)
    InPlaceCountingSort(values, 1, 10)
    self.assertEqual(sorted(original_values), values,
                     msg='original={} sorted={}'.format(original_values,
                                                        values))


class TestRadixSort(unittest.TestCase):

  def setUp(self):
    self.longMessage = True

  def test_digit(self):
    for x in xrange(0, 10):
      self.assertEqual(x, GetDigitFunction(0)(x))
    for x in xrange(10, 20):
      self.assertEqual(1, GetDigitFunction(1)(x))
    for x in xrange(20, 30):
      self.assertEqual(2, GetDigitFunction(1)(x))

    self.assertEqual(0, GetDigitFunction(1)(4))

  def test_NumDecimals(self):
    self.assertEqual(1, NumDecimals(0))
    self.assertEqual(1, NumDecimals(1))
    self.assertEqual(2, NumDecimals(10))
    self.assertEqual(2, NumDecimals(11))
    self.assertEqual(3, NumDecimals(100))

  def test_RadixSortDense(self):
    values = [random.randint(1,10000) for _ in xrange(10)]
    sorted_values = RadixSort(values)
    self.assertEqual(sorted(values), sorted_values,
                     msg='original={} sorted={}'.format(values, sorted_values))

  def test_RadixSortSparse(self):
    values = [random.randint(1,10) for _ in xrange(100)]
    sorted_values = RadixSort(values)
    self.assertEqual(sorted(values), sorted_values,
                     msg='original={} sorted={}'.format(values, sorted_values))

"""
Created on Thu Sep 24 14:53:03 2015

@author: xavierduportet
"""
import operator


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(my_class):
    mark = operator.itemgetter(0)
    return sorted(my_class, key=mark, reverse=True)


def sort_by_name(my_class):
    name = operator.itemgetter(1)
    return sorted(my_class, key=name)
class Sort():
    def __init__(self):
        pass




    def bubble_sort(self, toBeSorted):
        for e in toBeSorted:
            for i in range(len(toBeSorted) - 1):
                if (toBeSorted[i] > toBeSorted[i+1]):
                    temp = toBeSorted[i]
                    toBeSorted[i] = toBeSorted[i+1]
                    toBeSorted[i + 1] = temp
        return toBeSorted



    def merge_sort(self, toBeSorted):
        if (len(toBeSorted) == 1):
            return toBeSorted

        middle = len(toBeSorted) / 2

        left = toBeSorted[0:middle]
        right = toBeSorted[middle: len(toBeSorted)]

        left = self.merge_sort(left)
        right = self.merge_sort(right)
        result = self.__merge(left, right)

        return result


    def __merge(self, left, right):
        result = []
        while (len(left) > 0 or len(right) > 0):
            if (len(left) > 0 and len(right) > 0):
                if (left[0] <= right[0]):
                    result.append(left[0])
                    left = left[1:len(left)]
                else:
                    result.append(right[0])
                    right = right[1:len(right)]
            elif (len(left) > 0):
                result.append(left[0])
                left = left[1:len(left)]
            else:
                result.append(right[0])
                right = right[1:len(right)]
        return result



"""


"""
class Solution:

    def twoSum(self, num, target):
        sorted_num = num[:]
        sorted_num.sort()
        l, r = 0, len(sorted_num)-1
        while l<r:
            if sorted_num[l]+sorted_num[r]==target:
                break;
            elif sorted_num[l]+sorted_num[r]<target:
                l += 1;
            else:
                r -= 1;
        index1, index2 = 1, 1
        if sorted_num[l]+sorted_num[r]==target:
            for i in xrange(len(num)):
                if num[i]==sorted_num[l] or num[i]==sorted_num[r]:
                    index1, index2 = index2, i+1
        return (index1, index2)


    def twoSum1(self, num, target):

        mapping = {}
        for i in xrange(len(num)):
            if mapping.has_key(target-num[i]):
                return (mapping[target-num[i]], i+1)
            mapping[num[i]] = i+1
        return (0, 0)


if __name__ == '__main__':
    pass
def insertion_sort(input_list):
    if type(input_list) != 'list':
        input_list = list(input_list)

    sorted_list = []

    sorted_list.append(input_list[0])

    for item in input_list[1:]:

        if item >= sorted_list[-1]:
            sorted_list.append(item)

        else:
            for i in range(len(sorted_list)):
                if item < sorted_list[i]:
                    sorted_list.insert(i, item)
                    i +=1
                    break

    return sorted_list

l = [4, 5, 6, 19, 11, 2, 3]

s = ['cat', 'dog', 'bunny', 'apple']

t = (1, 5, 3, 2)

print insertion_sort(l)
print insertion_sort(s)
print insertion_sort(t)'''
Created on Nov 23, 2015

@author: Jonathan
'''

def sort(data):
    alphaSorted = sorted(list(set(data)))
    return sorted(alphaSorted, key = data.count, reverse = True)

if __name__ == '__main__':
    pass



import sys





"Return a list of all edges (v0, w) in E starting at v0. Used by topsort."
def _allEdgesFrom(v0, E):
    resEdges = []
    for v, w in E:
        if v0 == v:
            resEdges.append((v, w))
    return resEdges


"Recursive topsort function."
def _topSort(v, E, visited, sorted, sortedIndices):


    visited[v] = 1
    for v, w in _allEdgesFrom(v, E):

        if not visited[w]:
            _topSort(w, E, visited, sorted, sortedIndices)
        else:
            if not sorted[w]:
                print 'Cyclic dependency in links.'
                sys.exit(0)
    sorted[v] = 1
    sortedIndices.insert(0, v)


"""
Topological sort.

V = list of vertex names
E = list of 0-indexed edge pairs between vertices

Result is a list of sorted vertex names

Based on Topsort by Nathan Wallace, Matthias Urlichs
Hans Nowak, Snippet 302, Dinu C. Gherman
http://www.faqts.com/knowledge_base/view.phtml/aid/4491

Example of use:

import topsort

pairs = [('a', 'b'), ('b', 'c'), ('a', 'd'), ('b', 'd')]
print pairs

(V, E) = topsort.pairsToVertexEdgeGraph(pairs)
print
print V
print E

result = topsort.topSort(V, E)
print
print result
"""
def topSort(V, E):
    n = len(V)
    visited = [0] * n
    sorted  = [0] * n
    sortedIndices = []

    for v in range(n):
        if not visited[v]:
            _topSort(v, E, visited, sorted, sortedIndices)


    sortedElements = [V[i] for i in sortedIndices]

    return sortedElements


""" For use in preparing input for topsort.
Input is a dictionary whose values are the vertices connected to its keys.
Output is a list of pairs for pairsToVertexEdgeGraph
"""
def dictionaryToPairs(dict):
    pairs = [];
    for k in dict:
        for v in dict[k]:
            pairs.append( (k, v) )

    return pairs



"""Convert an element pairs list into (verticesList, edgeIndexList)
   for topSort.

   e.g. wrap( [('a','b'), ('b','c'), ('c','a')] )
         -> (['a','b','c'], [(0,1), (1,2), (2,0)])

   Returns Vertices, (indexed) Edges
"""
def pairsToVertexEdgeGraph(pairs):
    V = set()


    for x, y in pairs:
	V.add(x)
        V.add(y)


    V = [v for v in V]


    indexOf = {}
    i = 0
    for v in V:
        indexOf[v] = i
        i += 1


    E = [(indexOf[x], indexOf[y]) for x, y in pairs]

    return V, E

a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))


from __future__ import print_function

import sys





"Return a list of all edges (v0, w) in E starting at v0. Used by topsort."
def _allEdgesFrom(v0, E):
    resEdges = []
    for v, w in E:
        if v0 == v:
            resEdges.append((v, w))
    return resEdges


"Recursive topsort function."
def _topSort(v, E, visited, sorted, sortedIndices):


    visited[v] = 1
    for v, w in _allEdgesFrom(v, E):

        if not visited[w]:
            _topSort(w, E, visited, sorted, sortedIndices)
        else:
            if not sorted[w]:
                print('Cyclic dependency in links.')
                sys.exit(0)
    sorted[v] = 1
    sortedIndices.insert(0, v)


"""
Topological sort.

V = list of vertex names
E = list of 0-indexed edge pairs between vertices

Result is a list of sorted vertex names

Based on Topsort by Nathan Wallace, Matthias Urlichs
Hans Nowak, Snippet 302, Dinu C. Gherman
http://www.faqts.com/knowledge_base/view.phtml/aid/4491

Example of use:

import topsort

pairs = [('a', 'b'), ('b', 'c'), ('a', 'd'), ('b', 'd')]
print pairs

(V, E) = topsort.pairsToVertexEdgeGraph(pairs)
print
print V
print E

result = topsort.topSort(V, E)
print
print result
"""
def topSort(V, E):
    n = len(V)
    visited = [0] * n
    sorted  = [0] * n
    sortedIndices = []

    for v in range(n):
        if not visited[v]:
            _topSort(v, E, visited, sorted, sortedIndices)


    sortedElements = [V[i] for i in sortedIndices]

    return sortedElements


""" For use in preparing input for topsort.
Input is a dictionary whose values are the vertices connected to its keys.
Output is a list of pairs for pairsToVertexEdgeGraph
"""
def dictionaryToPairs(dict):
    pairs = [];
    for k in dict:
        for v in dict[k]:
            pairs.append( (k, v) )

    return pairs



"""Convert an element pairs list into (verticesList, edgeIndexList)
   for topSort.

   e.g. wrap( [('a','b'), ('b','c'), ('c','a')] )
         -> (['a','b','c'], [(0,1), (1,2), (2,0)])

   Returns Vertices, (indexed) Edges
"""
def pairsToVertexEdgeGraph(pairs):
    V = set()


    for x, y in pairs:
        V.add(x)
        V.add(y)


    V = [v for v in V]


    indexOf = {}
    i = 0
    for v in V:
        indexOf[v] = i
        i += 1


    E = [(indexOf[x], indexOf[y]) for x, y in pairs]

    return V, E

__author__ = 'sereg'

def break_words(stuff):
    """This function will break words"""
    words = stuff.split(' ')
    return words

def sort_words(words):
    """Sort the words"""
    return sorted(words)

def print_fw(words):
    word = words.pop(0)
    return word
def print_lw(words):
    word = words.pop(-1)
    print word
def sort_setnence(sentence):
    words = break_words(sentence)
    return sort_words(words)
def print_fwlw(sentence):
    words = break_words(sentence)
    print_fw(words)
    print_lw(words)

def print_fwlw_sort(sentence):
    words = sort_setnence(sentence)
    print_fw(words)
    print_lw(words)

sentence = "All good things come to those who wait"
print break_words(sentence)
print "-----------------------"
words = break_words(sentence)
print sort_words(words)
print "-----------------------"
print print_fw(words)
print "-----------------------"
print print_lw(words)
print "-----------------------"
sorted_words = sort_words(sentence)
print print_fw(sorted_words)
print "-----------------------"
print print_lw(sorted_words)
print "-----------------------"
sorted_words = sort_setnence(sentence)
print print_fwlw(sentence)
print "-----------------------"
print print_fwlw_sort(sentence)

def sortByCrime(atms):
    sortedAtms = sorted(atms, key=lambda atm: atm['crimes'])
    print sortedAtms
    return sortedAtms
def lensort(lists):
	return sorted(lists,key=lambda x:len(x))
lists=['fgdf','dfg','yuyju']
print lensort(lists)
fruits = ['banana', 'apple', 'fig', 'raspberry', 'aam','strawberry', 'cherry']

def mycomp(var):
    return ord(var[1])

print(sorted(fruits))



print(sorted(fruits, key=mycomp))
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)
'''
Created on Jul 4, 2015

@author: Debanjan Mahata
'''

def sorted_word(word):
    return "".join(sorted(word.lower()))

def sort_anagrams(A):
    hashTable = {}
    for entries in A:
        sorted_entry = sorted_word(entries)
        if sorted_entry in hashTable:
            hashTable[sorted_entry].append(entries)
        else:
            hashTable[sorted_entry] = [entries]

    sortedAnagramList = []

    for vals in hashTable.values():
        sortedAnagramList.extend(vals)

    return sortedAnagramList


if __name__ == "__main__":

    anagramList = ["mates","tablet","god","battle","care","dog","acre","meats","race","teams"]

    print sort_anagrams(anagramList)

from problems.leetcode.LeetcodeProblem import LeetcodeProblem


class Anagrams(LeetcodeProblem):
    def solve(self, strs):
        res = []
        record = {}
        for i, s in enumerate(strs):
            sortedS = str(sorted(list(s)))
            if sortedS in record:
                res.append(s)
                if record[sortedS] != -1:
                    res.append(strs[record[sortedS]])
                    record[sortedS] = -1
            else:
                record[sortedS] = i

        return res

    def verify(self, original_input, input, s1, s2):
        s1.sort()
        s2.sort()
        return s1 == s2

    def input(self):
        from Parser import parseStringArray
        return parseStringArray(open(self.inputPath))

    def output(self):
        from Parser import parseStringArray
        for o in parseStringArray(open(self.outputPath)):
            yield o[0]

problem = Anagrams
"""
Selection Sort
"""
import sys

def selection_sort(lst):
  l = lst[:]
  sorted = []
  while len(l):
    lowest = l[0]
    for x in l:
      if x < lowest:
        lowest = x
    sorted.append(lowest)
    l.remove(lowest)
  return sorted
from pyuca import Collator

def check(sorted_list):
    return 'CORRECT' if fruits == sorted_list else 'WRONG'

fruits = ['aa', 'acerola', 'atemoia', 'caj', 'caju']

print('manual_sort', fruits)

plain_sort = sorted(fruits)

print('plain_sort ', plain_sort, check(plain_sort))

coll = Collator()

pyuca_sort = sorted(fruits, key=coll.sort_key)

print('pyuca_sort ', pyuca_sort, check(pyuca_sort))
import numpy as np
def sort_from_indexes(ind_l,l):
    l_sorted=[]
    for i in range (0,len(ind_l)):
        l_sorted.append(l[ind_l[i]])
    return l_sorted
import fileinput
from random import shuffle
from timer import Timer

l = []
for i in fileinput.input():
    l.append(int(i))

def sort_python(l):
    return sorted(l)

with Timer() as t:
    l = sort_python(l)

print l
print('List length: %i' % len(l))
print('Sort time: %.05fs' % t.interval)def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
import collections

def key_sort_dictionary(d):
    """

    Python's `dict` type doesn't support ordering.

    :param d: A dictionary.

    :returns: OrderedDictionary.
    """

    return collections.OrderedDict(sorted(d.items(), key=lambda t: t[0]))

def partition(p,r):
	q = p
	for u in xrange(p,r):
		if A[u] <= A[r]:
			A[q], A[u] = A[u], A[q]
			q = q + 1
	A[q],A[r] = A[r],A[q]
	return q



def quickSort(p,r):
	if p<r:
		q = partition(p,r)
		quickSort(p,q-1)
		quickSort(q+1,r)


if __name__ == "__main__":
	N = int(raw_input())
	global A
	A = []
	for i in xrange(N):
		A.append(raw_input())
	quickSort(0,N-1)
	print "\nThe sorted list is: ", A









def my_num_comp(x, y):
    if str(x) < str(y):
        return -1
    elif str(x) > str(y):
        return 1
    else:
        return 0

def sorting_test_4():
    print "**** SORTING TEST 4 ****"
    numbers = [3, 1, 11, 2, 24]
    print "numbers before sort:\t\t", numbers


    sorted_numbers = sorted(numbers, cmp=my_num_comp)
    print "sorted_ numbers:    \t\t", sorted_numbers
    print "numbers after sort:\t\t", numbers
    print

sorting_test_4()


def sorting_test_5():
    pass




def sorting_test_6():
    print "**** SORTING TEST 6 ****"
    words = ['aa', 'bb', 'a', 'aaa', 'b', 'bbb']
    print "words before sort:\t\t", words
    sorted_words = sorted(words, key=len)
    print "sorted_words:     \t\t", sorted_words
    print "words after  sort:\t\t", words
    print




def list_sum_cmp(lst_01, lst_02):
    sum_01, sum_02 = sum(lst_01), sum(lst_02)
    if sum_01 < sum_02:
        return -1
    elif sum_01 > sum_02:
        return 1
    else:
        return 0



def sorting_test_7():
    print "**** SORTING TEST 7 ****"
    list_of_lists  = [[1, 2, 3, 5], [4, 0, 1], [0, 0, 1, 0, 1]]
    print "list_of_lists before sort:\t\t", list_of_lists
    sorted_list = sorted(list_of_lists, list_sum_cmp)
    print "sorted list_of_lists:     \t\t", sorted_list
    print "list_of_lists after sort:\t\t", list_of_lists
    print

sorting_test_7()

import math

def findMedianSortedArrays(A, B):
    le = len(A) + len(B)
    C = []
    for i in A:
        C.append(i)
    for i in B:
        C.append(i)
    C.sort()
    if le%2 == 1:
        return C[le/2]
    else:
        return (C[le/2]+C[le/2-1])/2.0


A = [1,2,3,4]
B = [56,7]
print findMedianSortedArrays(A,B)
try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
import app.lookups.sqlite.proteingroups as lookups


def get_sortfnxs(coverage):
    sortfnxs = [sort_pgroup_peptides,
                sort_pgroup_psms,
                sort_pgroup_score,
                sort_evidence_score,
                ]
    if coverage:
        sortfnxs.append(sort_pgroup_coverage)
    sortfnxs.append(sort_alphabet)
    return sortfnxs


def sort_to_get_master(pgroup, coverage):
    sortfnxs = get_sortfnxs(coverage)
    sorted_pg = sort_protein_group(pgroup, sortfnxs, 0)
    return {'master_id': sorted_pg[0][lookups.MASTER_INDEX],
            'protein_acc': sorted_pg[0][lookups.PROTEIN_ACC_INDEX]}


def sort_protein_groups(pgroups, coverage):
    sortfnxs = get_sortfnxs(coverage)
    pgroups_out = {}
    for pgroup in pgroups.values():
        sorted_pg = sort_protein_group(pgroup, sortfnxs, 0)
        pgroups_out[sorted_pg[0][lookups.PROTEIN_ACC_INDEX]] = sorted_pg
    return pgroups_out


def sort_protein_group(pgroup, sortfunctions, sortfunc_index):
    """Recursive function that sorts protein group by a number of sorting
    functions."""
    pgroup_out = []
    subgroups = sortfunctions[sortfunc_index](pgroup)
    sortfunc_index += 1
    for subgroup in subgroups:
        if len(subgroup) > 1 and sortfunc_index < len(sortfunctions):
            pgroup_out.extend(sort_protein_group(subgroup,
                                                 sortfunctions,
                                                 sortfunc_index))
        else:
            pgroup_out.extend(subgroup)
    return pgroup_out


def sort_amounts(proteins, sort_index):
    """Generic function for sorting peptides and psms. Assumes a higher
    number is better for what is passed at sort_index position in protein."""
    amounts = {}
    for protein in proteins:
        amount_x_for_protein = protein[sort_index]
        try:
            amounts[amount_x_for_protein].append(protein)
        except KeyError:
            amounts[amount_x_for_protein] = [protein]
    return [v for k, v in sorted(amounts.items(), reverse=True)]


def sort_pgroup_peptides(proteins):
    return sort_amounts(proteins, lookups.PEPTIDE_COUNT_INDEX)


def sort_pgroup_psms(proteins):
    return sort_amounts(proteins, lookups.PSM_COUNT_INDEX)


def sort_pgroup_score(proteins):
    return sort_amounts(proteins, lookups.PROTEIN_SCORE_INDEX)


def sort_pgroup_coverage(proteins):
    return sort_amounts(proteins, lookups.COVERAGE_INDEX)


def sort_evidence_score(proteins):
    return sort_amounts(proteins, lookups.EVIDENCE_LVL_INDEX)


def sort_coin_toss(proteins):
    return [proteins]


def sort_alphabet(proteins):
    return [sorted(proteins, key=lambda x: x[2])]
from django import template

register = template.Library()

@register.filter
def sort_by_order(value):
    return sorted(value, key=lambda o: o['grouper'].order)

@register.filter("sorted")
def sorted_tag(value, attr):
    return sorted(value, key=lambda o: getattr(o, attr))
import json

def json_serializer(sort=True):
    """
    Returns a function that can serialize to JSON, with unicode enabled,
    nans disallowed, keys sorted, and whitespace-free separators.

    You can override the sorted keys via `sort=False`.
    """
    return json.JSONEncoder(ensure_ascii=False,
                            allow_nan=False,
                            sort_keys=sort,
                            separators=(",",":")).encode

def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: (x[0]/x[1]))
def partition(a, l, r):
    p = a[l]
    i = l + 1
    for j in xrange(l + 1, r):
        if a[j] > p: continue
        a[j], a[i] = a[i], a[j]
        i += 1
    a[l], a[i - 1] = a[i - 1], a[l]
    return i - 1

def choosePivot(a, l, r):

    if 2 == (l - r): return l
    first = a[l]
    final = a[r - 1]
    if 0 == ((r - l) % 2): i = ((r - l) / 2) - 1
    else: i = (r - l) / 2
    mid = a[l + i]
    if (first < mid < final) or (final < mid < first): return l + i
    elif (mid < first < final) or (final < first < mid): return l
    else: return r - 1

def qSort(a, l, r):
    if r - l <= 1: return 0
    p = choosePivot(a, l, r)
    a[l], a[p] = a[p], a[l]
    tot = r - l - 1
    i = partition(a, l, r)
    tot += qSort(a, l, i)
    tot += qSort(a, i + 1, r)
    return tot

if "__main__" == __name__:
    a = []
    with open('QuickSort.txt', 'r') as f:
        for line in f:
            a.append(int(line))
    tot = qSort(a, 0, len(a))
    sorted = True
    for i in range(1, len(a)):
        if a[i - 1] > a[i]:
            sorted = False
            break
    print 'Comparisons: %d' % tot
    if sorted: print 'Sorted'
    else: print 'Incorrectly sorted!'list_to_sort = ['representative','numeric','senile','effluent','ear','bespectacled','elegiac','ex-developer']

def count_e(s):
	return s.count('e')

sorted_list = sorted(list_to_sort,key=count_e)

for item in sorted_list[::-1]:
	print item + ' ' + str(count_e(item))
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
from numpy import array,append,zeros,ones,amin


def dictionaryRead(input_files):

    lines = open(input_files).readlines()
    lines = [line.rstrip().split() for line in lines if line.strip()]

    for line in lines:
        for i in range(len(line)):

            line[i] = float(line[i])

    dictSort = [lines[0]]
    dictSort.append(sorted(lines[1]))
    b0_sortedIndex = sorted(range(len(lines[1])), key = lambda k: lines[1][k])
    b0_sorted = [lines[3][idx] for idx in b0_sortedIndex]
    dictSort.append(sorted(lines[2]))
    nonBasicCoeIndex=sorted(range(len(lines[2])), key=lambda k: lines[2][k])
    dictSort.append(b0_sorted)
    size_constraints=int(lines[0][0])
    for i in b0_sortedIndex:
        coeSorted=[lines[i+4][idx] for idx in nonBasicCoeIndex]
        dictSort.append(coeSorted)

    objSorted=[lines[-1][0]]
    tmp=[lines[-1][idx+1] for idx in nonBasicCoeIndex]
    objSorted.extend(tmp)
    dictSort.append(objSorted)


    return dictSort
a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))__author__ = 'Aneesh Garg'

from Heap import Heap

class HeapSort:

    def sort(self, data):
        print("Heapsort of size "+ str(len(data)))
        if len(data) > 0:
            heap = Heap(data)

            sortedData = []
            while heap.size > 0:
                sortedData.append(heap.removeMin())
            return sortedData
        else:
            return data





import os
import sys
sys.path.append(os.path.join('..'))
import dubious_sort as D
import random
import string

def generate_random_list(n):
    while True:
        mess = [random.choice(string.ascii_lowercase) for i in range(n)]


        if len(set(mess)) > 1:
            return mess

def test_n_10():
    lst = generate_random_list(10)
    assert D.sort(lst) == sorted(lst)





def test_n_100():
    for i in range(100):
        lst = generate_random_list(100)
        assert D.sort(lst) == sorted(lst)

def test_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst) == sorted(lst)

def test_broken_n_1000():
    for i in range(100):
        lst = generate_random_list(1000)
        assert D.sort(lst, broken=True) != sorted(lst)

def test_broken_n_2():
    for i in range(100):
        lst = generate_random_list(2)
        assert D.sort(lst, broken=True) != sorted(lst)
""" sorting algorithms here"""

def merge_sort(array = [6,3,6,3,21,7,3,4,5,3,1]):

	if len(array) <= 1:
		return array
	mid_index = len(array)//2;
	sorted_left = merge_sort(array[:mid_index])
	sorted_right = merge_sort(array[mid_index:])
	print sorted_left
	print sorted_right
	sorted_array = []

	while sorted_left or sorted_right:
		if not sorted_left:
			sorted_array += sorted_right
			sorted_right = []
		elif not sorted_right:
			sorted_array += sorted_left
			sorted_left = []
		else:
			if sorted_left[0] < sorted_right[0]:
				sorted_array.append(sorted_left.pop(0))
			else:
				sorted_array.append(sorted_right.pop(0))
	return sorted_array

def merge_sort_indexed(array = [6,3,6,3,21,7,3,4,5,3,1]):
	print 'todo'


def quicksort(array = [6,3,6,3,21,7,3,4,5,3,1]):
	print 'todo'


""" searching algorithms here """
def binary_search(array = [1,2,3,4,5,6,7,8,9], value = 8, left = 0, right = 8):
	print 'left: '+ str(left) + ', right: '+ str(right)
	if left > right:
		return -1
	if left == right:
		if array[left] == value:
			return left
		else:
			return -1


	middle_index = left + (right-left)//2
	if array[middle_index] == value:
		return middle_index
	elif array[middle_index] > value:
		return binary_search(array, value, left, middle_index-1)
	else:
		return binary_search(array, value, middle_index+1, right)


if __name__ == "__main__":


	print binary_search()


__author__ = 'TeaEra'


def insertion_sort(arr):
    size = len(arr)
    if size <= 1:
        return arr
    sliced_arr = arr[1:]
    sorted_sliced_arr = insertion_sort(sliced_arr)
    for i in range(len(sorted_sliced_arr)):
        if arr[0] < sorted_sliced_arr[i]:
            return sorted_sliced_arr[:i] + [arr[0]] + sorted_sliced_arr[i:]
    return sorted_sliced_arr + [arr[0]]

if __name__ == "__main__":

    print("---")
    print(insertion_sort([]))

    print("---")
    print(insertion_sort(["abc"]))

    print("---")
    print(insertion_sort([9, 1, 3, 7, 4, 2, 8, 5, 0]))def SortedList(input):
    temp = list(str(input))
    temp.sort()
    return temp


i = 1
while True:
    if SortedList(i) == SortedList(2 * i) == SortedList(3 * i) == SortedList(4 * i) == SortedList(5 * i) == SortedList(
                    6 * i):
        print(i)
        break
    i += 1import sys


def simple_sort(numbers):
    sorted_numbers = list()
    for number in numbers:
        sorted_numbers.append(float(number))
    sorted_numbers.sort()
    return sorted_numbers

test_cases = open(sys.argv[1], 'r')
for test in test_cases:

    if not test:
        continue


    sorted_numbers = simple_sort(test.strip().split(' '))
    output = str()
    for number in sorted_numbers:
        output += '{:.3f}'.format(number) + ' '
    output = output.strip()
    print(output)

test_cases.close()



'''
DSU, , ,
 sort
'''

def case_insensitive_sort(string_list):
    auxliliary_list = [ (x.lower(), x) for x in string_list ]
    auxliliary_list.sort()
    return [ x[1] for x in auxliliary_list ]
def case_insensitive_sort_another(string_list):
    return sorted(string_list, key=str.lower)






def sort_by_attr(seq, attr):

    intermd = [ (gettart(x, attr), i, x) for i, x in enumerate(seq) ]
    intermd.sort()
    return [ x[-1] for x in intermd ]


import operator
def sort_by_attr_another(seq, attr):
    return sorted(seq, key = operator.attrgetter(attr))
def sort_by_attr_replace(lst, attr):
    lst[:] = sort_by_attr(lst, attr)


import re
def get_number(s):
    re_digit = re.compile(r'(\d+)')
    pieces = re_digit.split(s)
    pieces[1::2] = map(int, pieces[1::2])
    return pieces[1::2]
def sort_strings_with_numbers(alist):
    anx = [ (get_number(s), s) for s in alist ]
    anx.sort()
    return [ s for __, s in anx ]
def sort_strings_with_numbers_another(alist):
    return sorted(alist, key=get_number)
if __name__ == '__main__':
    alist = ['file1.txt', 'file3.txt', 'file11.txt', 'file21.txt']
    print sort_strings_with_numbers(alist)
    print ' '.join(sort_strings_with_numbers_another(alist))
def sort_a_list(l):
    x = sorted
    return x(l, reverse=True)


from operator import itemgetter
getcount = itemgetter(0)


def sort_by_mark(my_class):
    i = sorted
    return i(my_class,  key=getcount, reverse=True)
getcounts = itemgetter(1)


def sort_by_name(my_class):
    i = sorted
    return i(my_class,  key=getcounts)







from copy import deepcopy
from mergeSort import mergeSort
import random
import sys


def quickSort(listToSort, i, j):
	k = j - i
	if (k == 1):
		if (listToSort[i] > listToSort[j]):
			tmp = listToSort[i]
			listToSort[i] = listToSort[j]
			listToSort[j] = tmp
	elif (k > 1):
		p = random.randint(i, j)
		tmp = listToSort[i]
		listToSort[i] = listToSort[p]
		listToSort[p] = tmp
		i0 = i
		p = i
		start = p + 1
		for i in range(start, (j + 1)):
			if (listToSort[i] <= listToSort[p]):
				tmp = listToSort[i]
				listToSort[(p + 1) : (i + 1)] = listToSort[p : i]
				listToSort[p] = tmp
				p = p + 1
		quickSort(listToSort, i0, p - 1)
		quickSort(listToSort, p + 1, j)
	return listToSort


if __name__ == "__main__":
	if (len(sys.argv) < 2):
		print("\r\nQuick Sort by William M Mortl")
		print("Usage: python quickSort.py \"{comma seperated list of values to sort}\"")
		print("Example: python quickSort.py \"9,111,2,31,1,0\"\r\n")
	else:
		listToSort = map(int, sys.argv[1].split(","))
		print(("\r\nSorting:\r\n%s\r\n") % str(listToSort))
		mergeSorted = mergeSort(deepcopy(listToSort))
		quickSorted = quickSort(deepcopy(listToSort), 0, len(listToSort) - 1)
		print(("Merge Sorted list:\r\n%s\r\n") % str(mergeSorted))
		print(("Quick Sorted list:\r\n%s\r\n") % str(quickSorted))
		print(("Lists equal? %s\r\n") % str(mergeSorted == quickSorted))
"""
generate a binary search tree
with minimum height
"""
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from structs.binary_tree import Node


def array2bst(array):
    array.sort()

    def sort2bst(sorted):
        if not sorted:
            return None
        if len(sorted) == 1:
            return Node(sorted[0])
        if len(sorted) == 2:
            return Node(sorted[1], left=Node(sorted[0]))
        if len(sorted) > 2:
            mid = len(sorted) / 2
            root = Node(sorted[mid])
            left = sort2bst(sorted[:mid])
            right = sort2bst(sorted[mid + 1:])
            root.left = left
            root.right = right
            return root
    return sort2bst(array)


def main():
    root = array2bst([2, 4, 6, 22, 1, 42, 7, 8, 476, 23])

    def bfs(root):
        res = {}
        queue = []
        queue.append((root, 0))
        while queue:
            node, deep = queue.pop(0)
            print node.data,
            if node.left:
                queue.append((node.left, deep + 1))
            if node.right:
                queue.append((node.right, deep + 1))

    bfs(root)
    print ""
    for i in root.in_order():
        print i,
    print ""
    for i in root.pre_order():
        print i,

if __name__ == '__main__':
    main()


import timeit

LIST     = [834, 29, 99, 473, 128, 43, 555, 3243, 666, 12, 0, 3223, 5533, 3214, 987, 4325, 87, 324, 45324, 980, 2343, 92, 23, 45, 433]
NB_ITERS = 500000



def withSort():
    l = [i for i in LIST]
    l.sort()
    return l




def withSorted():
    l = [i for i in LIST]
    return sorted(l)



t1 = timeit.Timer('withSort()',   'from __main__ import withSort')
t2 = timeit.Timer('withSorted()', 'from __main__ import withSorted')

print
print 'Sorting a list'
print ' * with an inplace sort() :', t1.timeit(NB_ITERS)
print ' * with a call to sorted():', t2.timeit(NB_ITERS)
class Solution:




    def mergeSortedArray(self, A, m, B, n):
        for i in range(n):
            A[i+m] = B[i]
        A.sort()

__author__ = 'dihnatsyeu'

def bublesort (ListToSort):

    lenght = len(ListToSort)
    sorted = False
    for j in range(0, lenght-1):
        for i in range(0, lenght-j-1):
            if ListToSort[i] > ListToSort[i+1]:
               temp = ListToSort[i]
               ListToSort[i] = ListToSort[i+1]
               ListToSort[i+1] = temp
               sorted = True
            if sorted == False: break

    return ListToSort

print bublesort([24,1,34,3,72,5,21])
from __future__ import unicode_literals





import pytest
from structures.merge_sort import merge_sort


@pytest.fixture
def sorted_list():
    return [i for i in xrange(10)]


@pytest.fixture
def even_odd_split_list():
    return [x for x in xrange(0, 10, 2)] + [x for x in xrange(1, 10, 2)]


@pytest.fixture
def average_list():
    return [5, 9, 2, 4, 1, 6, 8, 7, 0, 3]


def test_sorted(sorted_list):
    assert merge_sort(sorted_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_worst(even_odd_split_list):
    assert merge_sort(even_odd_split_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_average(average_list):
    assert merge_sort(average_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_repeats():
    l = [3, 6, 7, 3, 9, 5, 2, 7]
    assert merge_sort(l) == [2, 3, 3, 5, 6, 7, 7, 9]


def test_multiple_types():
    l = [3, 'foo', 2.8, True, []]

    assert merge_sort(l) == [True, 2.8, 3, [], 'foo']
def match_ends(words):
  count = 0
  for word in words:
    if len(word) >= 2 and word[0] == word[-1]:
      count += 1
  return count

def front_x(words):
  xwords = []
  otherwords = []
  for word in words:
    if word[0] == 'x':
      xwords.append(word)
    else:
      otherwords.append(word)
  return sorted(xwords) + sorted(otherwords)

def sort_last(tuples):
  return sorted(tuples, key=lambda tuple: tuple[-1])
from Rnaseq import *

class sort_by_significance(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k14 -r ${inputs[0]} > ${ID}.sorted.sig
        '''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.sig']

__author__ = 'Meemaw'



def bubbleSort(aList):
    for i in range(1,len(aList)):
        sorted = True
        for j in range(len(aList)-i):
            if aList[j] > aList[j+1]:
                sorted = False
                aList[j], aList[j+1] = aList[j+1], aList[j]
        if sorted:
            return

import math
import random


def sort_tuple(a, b):
  if a < b:
    return [a, b]
  else:
    return [b, a]



def merge_sorted_arrays(a, b):

  i = 0

  j = 0

  c = []

  while i < len(a) or j < len(b):
    if i < len(a) and j < len(b):

      if a[i] < b[j]:
        c.append(a[i])
        i += 1
      else:
        c.append(b[j])
        j += 1

    elif i < len(a):

      c.extend(a[i:len(a)])
      i = len(a)
    elif j < len(b):

      c.extend(b[j:len(b)])
      j = len(b)
  return c


def merge_sort(array):

  a = array
  halfway = int(math.ceil(len(a)/2.0))

  b = a[0:halfway]

  c = a[halfway:len(a)]


  b_sorted = []
  c_sorted = []
  if len(b) > 2:
    b_sorted = merge_sort(b)
  elif len(b) == 2:
    b_sorted = sort_tuple(*b)
  else:
    b_sorted = b
  if len(c) > 2:
    c_sorted = merge_sort(c)
  elif len(c) == 2:
    c_sorted = sort_tuple(*c)
  else:
    c_sorted = c

  return merge_sorted_arrays(b_sorted, c_sorted)



A = []

for _ in range(101): A.append(random.randint(0,100))

A

merge_sort(A)
from functools import cmp_to_key

def sort_fractions(fractions):
    return sorted(fractions, key=cmp_to_key(\
        lambda x, y: x[0] * y[1] - x[1] * y[0]))def sort_last(x):
  return sorted(x, cmp = comp)

def comp(a, b):
  return cmp(a[-1], b[-1])

print sort_last([[1, 3], [3, 2], [2, 1]])
print sort_last([[2, 3], [1, 2], [3, 1]])
print sort_last([[1, 7], [1, 3], [3, 4, 5], [2, 2]])def search_dictionaries(key, value, lod):
    return [element for element in lod if element[key] == value]


def sort_dictionaries(sort_key, lod):
    return sorted(lod, key=lambda k: k[sort_key])
import sys

def sort_word(word):
    return "".join(sorted(word))


def is_match(word, sortedWord):
    return sortWord(word.lower()) == sortedWord.lower()


def append_results(words, sorted_input):
    results = []
    for key, value in words.items():
        if value.lower() == sorted_input.lower():
            results.append(key)
    return results


def main(word_input = ""):
    dictionary = open("dict").read().splitlines()
    sorted_input = sort_word(word_input.lower())

    words = {}

    for line in dictionary:
        words[line.lower()] = sort_word(line).lower()

    results = append_results(words, sorted_input)

    for result in results:
        print result


if __name__ == "__main__":
    main(sys.argv[1])

def main():
	ls = [24,12,2,37,48,28,26,421,585,352,8]
	sorted_ls = mergeSort(ls)
	print("List started as:")
	print(ls)
	print("Sort list looks like:")
	print(sorted_ls)


def mergeSort(a):
	if (len(a) == 1):
		return a

	mid = len(a) // 2
	left = a[0:mid]
	right = a[mid:]

	left = mergeSort(left)
	right = mergeSort(right)

	return merge(left,right)

def merge(a,b):
	c = []

	while (a and b):
		if (a[0] > b[0]):
			c.append(b[0])
			b.pop(0)
		else:
			c.append(a[0])
			a.pop(0)

	while (a):
		c.append(a[0])
		a.pop(0)

	while(b):
		c.append(b[0])
		b.pop(0)

	return c

main()
def sort_fractions(fractions):
    s = sorted(fractions, key = lambda x: x[0]/x[1])
    return s


def main():
    print (sort_fractions([(2, 3), (1, 2)]))
    print (sort_fractions([(2, 3), (1, 2), (1, 3)]))
    print (sort_fractions([(5, 6), (22, 78), (22, 7), (7, 8), (9, 6), (15, 32)]))


if __name__ == '__main__':
    main()
try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
def selection_sort(list):
    sorted_list = []
    while len(list) > 0:
        sorted_list.append(list.pop(smallest(list)))
    return sorted_list


def smallest(list):
    smallest = list[0]
    position = 0
    for x in range(len(list)):
        if list[x] < smallest:
            smallest = list[x]
            position = x
    return position


import unittest
class SelectionSortTest(unittest.TestCase):

    unsorted = [3, 8, 15, 1, 6, 3 ,2, 5, 99, 43, 77, 23, 12, 1]
    sorted_list = [1, 1, 2, 3, 3, 5, 6, 8, 12, 15, 23, 43, 77, 99]

    def test_selection_sort(self):
        self.assertEqual(self.sorted_list, selection_sort(self.unsorted))


if __name__ == "__main__":
    unittest.main()


def is_sorted(collection):
    a = [ c for c in collection]
    a.sort()
    return a == collection


if __name__ == '__main__':
    print is_sorted([1, 2, 2])
    print is_sorted(['b', 'a'])def break_words(stuff):
	words = stuff.split(' ')
	return words

def sort_words(words):
	return sorted(words)

def print_first_word(words):

	word = words.pop(0)
	print(word)

def print_last_word(words):

	word = words.pop(-1)
	print(word)

def sort_sentence(sentence):

	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

def print_first_and_last_sorted(sentence):
	words = sort_sentence(sentence)
	print_first_word(words)
	print_last_word(words)
def reversed_cmp(x, y):
    if x > y:
        return -1
    if x < y:
        return 1
    return 0

print sorted([36, 5, 12, 9, 21], reversed_cmp)def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])
from operator import itemgetter

class School:

    def __init__(self, name):
        self.name = name
        self.db = {}

    def add(self, student_name, grade):
        if grade in self.db:
            self.db[grade].add(student_name)
        else:
            self.db[grade] = {student_name}

    def grade(self, grade):
        if grade in self.db:
            return self.db[grade]
        else:
            return set()

    def sort(self):
        sorted_keys_db = sorted(self.db.items())
        sorted_db = []
        for grade, students in sorted_keys_db:
            sorted_db.append((grade, tuple(sorted(students))))
        return sorted_db




class SelectionSort:
    """Implementation class for Selection sort."""

    @staticmethod
    def selectionSort( listToSort ):
        """Implementation of the algorithm.

        @param  listToSort  The list to sort.
        @return The sorted list
        """
        res = []
        ok = True
        while ok:
            if listToSort:
                minimum = min(listToSort)
                res.append( minimum )
                listToSort.remove( minimum )
            else:
                ok = False
        return res


def main():
    """Main-method, does testing."""
    import random
    l = []
    for i in range(20):
        l.append( random.randint( 0, 100))

    print( "List of random values: " + str(l) )
    print( "
    res = SelectionSort.selectionSort( l )
    print( "Sorted list: " + str(res) )


if __name__ == "__main__":
    main()
import pytest






from scripts.correlation_parser import sort_tests
from scripts.correlation_parser import sum_tests





@pytest.fixture
def def_list():
    mlist = {'a': 1, 'b': 2, 'c': 3, 'd': 0}
    return mlist

def test_sort_tests_weight(def_list):
    sorted_weight = sort_tests(def_list, order='weight')
    assert sorted_weight == [('d', 0), ('a', 1), ('b', 2), ('c', 3)]

def test_sort_tests_weight_reverse(def_list):
    sorted_weight = sort_tests(def_list, order='weight-reverse')
    assert sorted_weight == [('c', 3), ('b', 2), ('a', 1), ('d', 0)]

def test_sort_tests_alphabet(def_list):
    sorted_alphabetical = sort_tests(def_list, order='alphabet')
    assert sorted_alphabetical == [('a', 1), ('b', 2), ('c', 3), ('d', 0)]

def test_sort_tests_alphabet_reverse(def_list):
    sorted_weight = sort_tests(def_list, order='alphabet-reverse')
    assert sorted_weight == [('d', 0), ('c', 3), ('b', 2), ('a', 1)]

def test_sort_tests_error(def_list):
    with pytest.raises(ValueError):
        sorted_weight = sort_tests(def_list, order='non-existing-option')






def test_sum_tests():
    """Test sumt test func"""
    data = {'pak1': {'test1': 2, 'test2': 5},
            'pak2': {'test1': 1, 'test3': 7},
            'pak3': {'test1': 1, 'test3': 1},
            'pak4': {'test4': 9, 'test2': 4},
    }

    tests = sum_tests(data)
    assert tests == {'test1': 4, 'test2': 9, 'test3': 8, 'test4': 9}


import sys

def insertionSort(a, verbose):
	sortedStart = len(a) - 1
	while sortedStart > 0:
		print "sortedStart =", sortedStart
		for i in xrange(sortedStart - 1, len(a)):
			if i < len(a) - 1 and a[i] > a[i + 1]:
				print "// swapping %s with %s" % (a[i], a[i + 1])
				temp = a[i]
				a[i] = a[i + 1]
				a[i + 1] = temp
				if verbose:
					print a
		sortedStart -= 1
	return a

verbose = sys.argv[1].lower() == "true"
sortThis = [ int(x) for x in sys.argv[2:] ]
print "Unsorted ->\t", sortThis
sortedThis = insertionSort(sortThis, verbose)
print "Sorted ->\t", sortedThis

'''
Created on 2014114
@author: zhanghb
'''
import json
import urllib2
from DataConvert import DataManager
from copy import deepcopy
def TimeListSort(TimeList):
    Result=[]
    InputList=[]
    for item in TimeList:
        if item[-1]=='y':
            InputList.append((int(filter(str.isdigit,item)))*365)
        elif item[-1]=='m':
            InputList.append((int(filter(str.isdigit,item)))*30)
        elif item[-1]=='w':
            InputList.append((int(filter(str.isdigit,item)))*7)
        elif item[-1]=='d':
            InputList.append((int(filter(str.isdigit,item))))
        else:
            print "Input Format Error"
            break
    SortedList=deepcopy(InputList)
    Result.append(InputList)
    SortedList.sort()
    Result.append(SortedList)
    return Result

def div_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        if DaysFromNow<=SortedList[0]:
            CommitNum[UnSortedList.index(SortedList[0])]+=1
        else:
            for i in range(1,len(SortedList)):
                if (DaysFromNow>SortedList[i-1]) and (DaysFromNow<=SortedList[i]):
                    CommitNum[UnSortedList.index(SortedList[i])]+=1
                else:
                    pass
    return  CommitNum
def total_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        for i in range(0,len(SortedList)):
            if DaysFromNow<=SortedList[i]:
                CommitNum[UnSortedList.index(SortedList[i])]+=1
            else:
                pass
    return  CommitNum



def sort(list):
    """Return a sorted list. You can't use python sort method"""

    print("Develop me, please! I'm begging.")

if __name__ == '__main__':
    sort([13, 2, 1, 0])import numpy as np

def argSort(seq):
    return sorted(range(len(seq)), key=seq.__getitem__)

def block(im, p, r = 7):
    return im[p[1]-r:p[1]+r,p[0]-r:p[0]+r,:]

def cond(arr, c):
  return arr[c.argsort()[len(c)-sum(c):]]






def merge_sort(unsorted_list):



	if len(unsorted_list) == 1:
		return unsorted_list



	unsorted_list_a = unsorted_list[0:(len(unsorted_list)/2)]
	unsorted_list_b = unsorted_list[(len(unsorted_list)/2):len(unsorted_list)]


	sorted_list_a = merge_sort(unsorted_list_a)
	sorted_list_b = merge_sort(unsorted_list_b)


	sorted_list = merge(sorted_list_a, sorted_list_b)

	return sorted_list






def merge(list_a, list_b):

	sorted_list = []



	while (len(list_a) > 0 and len(list_b) > 0):
		if list_a[0] < list_b[0]:
			sorted_list.append(list_a[0])
			list_a.pop(0)
		else:
			sorted_list.append(list_b[0])
			list_b.pop(0)



	if len(list_a) == 0:
		sorted_list.extend(list_b)
	if len(list_b) == 0:
		sorted_list.extend(list_a)


	return sorted_list



def merge_unit_test():
	list_a = [1,2,8,9]
	list_b = [3,4,6,10,11]
	sorted_list = merge(list_a, list_b)
	print(sorted_list)





def merge_sort_test():
	list_a = [3,6,1,3,7,8,0,10,22,323,1,5,4,2,85,39]
	sorted_list = merge_sort(list_a)
	print(sorted_list)
def insert(list, n):
    isNmax = True
    try:
        a = next(list)
        while True:
            yield min(a, n)
            if a <= min(a, n):
                a = next(list)
            else:
                isNmax = False;
                while (True):
                    yield a
                    a = next(list)

    except StopIteration:
        if isNmax:
            yield n
        raise StopIteration


def insertionSort(list):
    sorted = iter([])
    for number in list:
        sorted = insert(sorted, number)
    return sorted


input = [0, 6, 7, 4, -3, 9, 100, 15, -22]

print(list(insertionSort(iter(input))))def SortAnagrams(i):
  return sorted(i, lambda x, y: cmp(sorted(x), sorted(y)))

x = ["abcd", "wxyz", "dcba", "zyxw", "cdba"]
print SortAnagrams(x)

def sort_by_indices(data):
    """
    This function sorts data and return permuted indices
    >>> sort_by_indices([1, 3, 0, 9, 5])
    [2, 0, 1, 4, 3]
    """
    return sorted(range(len(data)), key = data.__getitem__)

def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    _test()




import random
import math
from operator import itemgetter

from benchmark import timethese

SAMPLE_SIZE             = 100 * 1000
BENCHMARK_ITERATIONS    = 100


def main():
    print "Generating sample data..."
    sample = generatate_triplets(SAMPLE_SIZE)

    timethese(BENCHMARK_ITERATIONS,
        (
            ("classic",     lambda : sort_classic(sample)),
            ("itemgetter",  lambda : sort_itemgetter(sample)),
            ("GRT-arithm",  lambda : sort_arithmetic(sample)),
            ("GRT-chars",   lambda : sort_chars(sample)),
            ("GRT-bits",    lambda : sort_bits(sample)),
        )
    )


def generatate_triplets(N):
    RANGE = 99
    a = []

    for x in xrange(N):
        a.append(
            (random.randint(0, RANGE), random.randint(0, RANGE), random.randint(0, RANGE))
        )
    return a

def sort_itemgetter(data):
    return sorted(sorted(sorted(data, key=itemgetter(2), reverse=True), key=itemgetter(1)), key=itemgetter(0))


def sort_classic(data):
    def cmp_triplets(a, b):
        return cmp(a[0], b[0]) or cmp(a[1], b[1]) or cmp(b[2], a[2])

    return sorted(data, cmp=cmp_triplets)


def sort_arithmetic(data):
    def unpack(a):
        x = int(a / 100**2)
        y = int(a / 100) - x * 100
        z = 99 - a % 100
        return (x, y, z)

    def pack(s):
        return s[0] * 100**2 + s[1] * 100 + (99 - s[2])

    return map(unpack, sorted(map(pack, data)))


def sort_bits(data):
    def unpack(a):
        return ( (a & 0b111111100000000000000) >> 14, (a & 0b11111110000000) >> 7, ~(a & 0b1111111) )

    def pack(s):
        return (s[0] << 14) | (s[1] << 7) | ~s[2]

    return map(unpack, sorted(map(pack, data)))


def sort_chars(data):
    def unpack(a):
        return (ord(a[0]), ord(a[1]), 99 - ord(a[2]))

    def pack(s):
        return chr(s[0]) + chr(s[1]) + chr(99 - s[2])

    return map(unpack, sorted(map(pack, data)))


if __name__ == '__main__':
    main()










def unique_chars_dict(s):
  chars = {}
  for c in s:
    if c != ' ':
      if c in chars:
        return False
      else:
        chars[c] = 1

  return True


def unique_chars_sort(s):
  sorted_s = sorted(s)
  for i in range(1, len(sorted_s)):
    if sorted_s[i] != ' ':
      if sorted_s[i] == sorted_s[i - 1]:
        return False

  return True




from __future__ import print_function

import sys





"Return a list of all edges (v0, w) in E starting at v0. Used by topsort."
def _allEdgesFrom(v0, E):
    resEdges = []
    for v, w in E:
        if v0 == v:
            resEdges.append((v, w))
    return resEdges


"Recursive topsort function."
def _topSort(v, E, visited, sorted, sortedIndices):


    visited[v] = 1
    for v, w in _allEdgesFrom(v, E):

        if not visited[w]:
            _topSort(w, E, visited, sorted, sortedIndices)
        else:
            if not sorted[w]:
                print('Cyclic dependency in links.')
                sys.exit(0)
    sorted[v] = 1
    sortedIndices.insert(0, v)


"""
Topological sort.

V = list of vertex names
E = list of 0-indexed edge pairs between vertices

Result is a list of sorted vertex names

Based on Topsort by Nathan Wallace, Matthias Urlichs
Hans Nowak, Snippet 302, Dinu C. Gherman
http://www.faqts.com/knowledge_base/view.phtml/aid/4491

Example of use:

import topsort

pairs = [('a', 'b'), ('b', 'c'), ('a', 'd'), ('b', 'd')]
print pairs

(V, E) = topsort.pairsToVertexEdgeGraph(pairs)
print
print V
print E

result = topsort.topSort(V, E)
print
print result
"""
def topSort(V, E):
    n = len(V)
    visited = [0] * n
    sorted  = [0] * n
    sortedIndices = []

    for v in range(n):
        if not visited[v]:
            _topSort(v, E, visited, sorted, sortedIndices)


    sortedElements = [V[i] for i in sortedIndices]

    return sortedElements


""" For use in preparing input for topsort.
Input is a dictionary whose values are the vertices connected to its keys.
Output is a list of pairs for pairsToVertexEdgeGraph
"""
def dictionaryToPairs(dict):
    pairs = [];
    for k in dict:
        for v in dict[k]:
            pairs.append( (k, v) )

    return pairs



"""Convert an element pairs list into (verticesList, edgeIndexList)
   for topSort.

   e.g. wrap( [('a','b'), ('b','c'), ('c','a')] )
         -> (['a','b','c'], [(0,1), (1,2), (2,0)])

   Returns Vertices, (indexed) Edges
"""
def pairsToVertexEdgeGraph(pairs):
    V = set()


    for x, y in pairs:
        V.add(x)
        V.add(y)


    V = [v for v in V]


    indexOf = {}
    i = 0
    for v in V:
        indexOf[v] = i
        i += 1


    E = [(indexOf[x], indexOf[y]) for x, y in pairs]

    return V, E



def mergeSort(arrayForSort):
    if(len(arrayForSort) == 1):
        return arrayForSort
    else:
        length = len(arrayForSort)
        firstSortedArray = mergeSort(arrayForSort[:length/2])
        secondSortedArray = mergeSort(arrayForSort[length/2:])
        sortedArray = mergeTwoArrays(firstSortedArray, secondSortedArray)
        return sortedArray

def mergeTwoArrays(first, second):
    firstArrayIndex = 0
    secondArrayIndex = 0
    resultArray = []

    while (True):
        if(first[firstArrayIndex] <= second[secondArrayIndex]):
            resultArray.append(first[firstArrayIndex])
            firstArrayIndex = firstArrayIndex + 1
        else:
            resultArray.append(second[secondArrayIndex])
            secondArrayIndex = secondArrayIndex + 1

        if(firstArrayIndex == len(first)):
            resultArray.extend(second[secondArrayIndex:])
            break;

        if(secondArrayIndex == len(second)):
            resultArray.extend(first[firstArrayIndex:])
            break;

    return resultArray


array = [3,41,52,26,38,57,9,49]
resultArray = mergeSort(array)
print resultArray
class School:
	def __init__(self,name):
		self.school= name
		self.db = {}
	def add(self,name,Grade):
		grades = self.grade(Grade)
		grades.add(name)
		self.db[Grade] = grades
	def grade(self,Grade):
		return self.db.get(Grade,set())
	def sort(self):
		dbSorted = {}
		for i in sorted(self.db.keys()):
			dbSorted[i] = tuple(self.db[i])
		return dbSortedfrom zope.viewlet.manager import ViewletManagerBase

class SortingViewletManager(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)

from models.models import db, Location, FunRun, Theme, Challenge
import re

def filter_query_parameters(allowed_parameters, request_parameters):
	filtered_parameters = {}
	for k in allowed_parameters:
		if k in request_parameters:
			filtered_parameters[k] = request_parameters[k]
	return filtered_parameters

def select(table, predicate):
	return filter(predicate, table)

def isInt(inp):
	try:
		int(inp)
		return True
	except ValueError:
		return False

def isFloat(inp):
	try:
		float(inp)
		return True
	except ValueError:
		return False

def isNumber(inp):
	return isInt(inp) or isFloat(inp)

def retrieve_entry_points():
	root_urls = {
              		"funruns_url": "/funruns",
                	"themes_url": "/themes",
                	"challenges_url": "/challenges",
                	"locations_url": "/locations"
            	}
	return root_urls

def retrieve_funruns():
	return db.session.query(FunRun).order_by(FunRun.id)

def retrieve_themes():
	return db.session.query(Theme).order_by(Theme.id)

def retrieve_challenges():
	return db.session.query(Challenge).order_by(Challenge.id)

def retrieve_locations():
	return db.session.query(Location).order_by(Location.id)

def split_sort_string(sort_string):

	strings = re.split(':', sort_string)
	if len(strings) < 2:
		strings += ['']
	return (strings[0], strings[1])

def is_sort_descending(sort_order):
	return sort_order == 'desc'


def sort_funruns(funruns, sort_string):
	sort_field, sort_order = split_sort_string(sort_string)

	if sort_field == 'name':
		return sorted(funruns, key=lambda funrun:funrun.name, reverse=is_sort_descending(sort_order))
	elif sort_field == 'date':
		return sorted(funruns, key=lambda funrun:funrun.get_date_object(), reverse=is_sort_descending(sort_order))
	elif sort_field == 'distance':
		if is_sort_descending(sort_order):
			return sorted(funruns, key=lambda funrun:max(funrun.get_lengths()), reverse=is_sort_descending(sort_order))
		else:
			return sorted(funruns, key=lambda funrun:min(funrun.get_lengths()), reverse=is_sort_descending(sort_order))
	elif sort_field == 'price':
		if is_sort_descending(sort_order):
			return sorted(funruns, key=lambda funrun:max(funrun.get_prices()), reverse=is_sort_descending(sort_order))
		else:
			return sorted(funruns, key=lambda funrun:min(funrun.get_prices()), reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_themes':
		return sorted(funruns, key=lambda funrun:len(funrun.funRun_theme), reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_challenges':
		return sorted(funruns, key=lambda funrun:len(funrun.funRun_challenge), reverse=is_sort_descending(sort_order))
	else:
		return funruns

def sort_themes(themes, sort_string):
	sort_field, sort_order = split_sort_string(sort_string)

	if sort_field == 'name':
		return sorted(themes, key=lambda theme:theme.name, reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_runs':
		return sorted(themes, key=lambda theme:len(theme.funruns), reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_challenges':
		return sorted(themes, key=lambda theme:len(theme.theme_challenge), reverse=is_sort_descending(sort_order))
	else:
		return themes

def sort_challenges(challenges, sort_string):
	sort_field, sort_order = split_sort_string(sort_string)

	if sort_field == 'name':
		return sorted(challenges, key=lambda challenge:challenge.name, reverse=is_sort_descending(sort_order))
	elif sort_field == 'difficulty':
		return sorted(challenges, key=lambda challenge:challenge.difficulty, reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_runs':
		return sorted(challenges, key=lambda challenge:len(challenge.funruns), reverse=is_sort_descending(sort_order))
	elif sort_field == 'number_of_themes':
		return sorted(challenges, key=lambda challenge:len(challenge.theme), reverse=is_sort_descending(sort_order))
	else:
		return challenges

def sort_locations(locations, sort_string):
	sort_field, sort_order = split_sort_string(sort_string)

	seasons = {'winter', 'spring', 'summer', 'fall'}

	if sort_field == 'name':
		return sorted(locations, key=lambda location:location.name, reverse=is_sort_descending(sort_order))
	elif sort_field.endswith('_avgTemp'):
		if sort_field[:-len('_avgTemp')] in seasons:
			return sorted(locations, key=lambda location:getattr(location, sort_field), reverse=is_sort_descending(sort_order))
	elif sort_field.endswith('_avgHumidity'):
		if sort_field[:-len('_avgHumidity')] in seasons:
			return sorted(locations, key=lambda location:getattr(location, sort_field), reverse=is_sort_descending(sort_order))
	elif sort_field == 'altitude':
		return sorted(locations, key=lambda location:location.get_altitude_as_integer(), reverse=is_sort_descending(sort_order))
	elif sort_field == 'annual_rainfall':
		return sorted(locations, key=lambda location:location.get_annual_rainfall_as_integer(), reverse=is_sort_descending(sort_order))
	else:
		return locations
import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))
"""
Write a method to sort an array of strings so that all the anagrams are next
to each other
"""

def sort_strings(string_list):
    groups = {}
    for string in string_list:
        key = ''.join(sorted(string))
        if key not in groups:
            groups[key] = [string]
        else:
            groups[key].append(string)

    sorted_anagrams = []
    for key in groups:
        sorted_anagrams = sorted_anagrams + groups[key]

    return sorted_anagrams

if __name__ == '__main__':
    print sort_strings(['bate', 'tab', 'tabe', 'bat', 'moon', 'jade', 'oscar', 'noom', 'rasco', 'mono'])


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k

from operator import attrgetter

class CI_name(object):
    def __init__(self, name):
        self.name = name
        self.ci_name = name.lower()

def sorted_ci(iterable):
    ls = map(CI_name, iterable)
    ls.sort(key=attrgetter("ci_name"))
    return [el.name for el in ls]



def sorted_ci(iterable):
    ls = [(name.lower(), name) for name in iterable]
    ls.sort()
    return [el[1] for el in ls]

if __name__ == "__main__":
    ls = "ciao Nina come Va?".split()
    print sorted(ls)
    print sorted_ci(ls)

store = []

def sort_by_last_letter(strings):
    def last_letter(s):
        return s[-1]
    store.append(last_letter)
    print(last_letter)
    return sorted(strings, key=last_letter)def bubble_sort(arr):
    size = len(arr)
    if size < 2:
        return

    scanLimit = size - 1
    sorted = False

    while not sorted:
        sorted = True
        i = 0

        while i < scanLimit:
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                sorted = False
            i += 1

        scanLimit -= 1

    returndef sort_dict(d):
  return sorted(d.items(), key=lambda x: x[1], reverse=True)


def sort(t):
    if t == []:
        return []
    else:
        pivot = t[0]
        left = [x for x in t if x < pivot]
        right = [x for x in t[1:] if x >= pivot]
        return [sort(left)] + [pivot] + [sort(right)]

def sorted(t):

    return [] if t == [] else sorted(t[0]) + [t[1]] + sorted(t[2])

def search(t, x):
    return len(_search(t,x)) > 0

def insert(t, x):
    subtree = _search(t, x)
    if subtree == []:
    	subtree += [[], x, []]

def _search(t, x):

    if t == [] or x == t[1]:
        return t
    elif x < t[1]:
        return _search(t[0], x)
    else:
        return _search(t[2], x)

print ">>> tree = sort([4,2,6,3,5,7,1,9])"
tree = sort([4,2,6,3,5,7,1,9])
print tree
print ">>> sorted(tree)"
print sorted(tree)
print ">>> search(tree, 6)"
print search(tree, 6)
print ">>> search(tree, 6.5)"
print search(tree, 6.5)
print ">>> insert(tree, 6.5)"
print insert(tree, 6.5)
print ">>> tree"
print tree
print ">>> insert(tree, 3)"
print insert(tree, 3)
print ">>> tree"
print tree
print
print
print ">>> tree = sort([4,2,6,3,5,7,1,9])"
tree = sort([4,2,6,3,5,7,1,9])
print tree
print ">>> _search(tree, 3)"
print _search(tree, 3)
print ">>> _search(tree, 0)"
print _search(tree, 0)
print ">>> _search(tree, 6.5)"
print _search(tree, 6.5)
print ">>> _search(tree, 0) is _search(tree, 6.5)"
print _search(tree, 0) is _search(tree, 6.5)
print ">>> _search(tree, 0) == _search(tree, 6.5)"
print _search(tree, 0) == _search(tree, 6.5)





__author__ = 'ingthor'

import random


def InsertionSort(A):

    n = len(A)
    for j in range(1, n):
        key = A[j]
        i = j - 1
        while (i >= 0) and (A[i] > key):
            A[i + 1] = A[i]
            i -= 1
        A[i + 1] = key
    return A




def InsertionSortAsc(A):

    n = len(A)
    for j in range(1, n):
        key = A[j]
        i = j - 1
        while (i >= 0) and (A[i] < key):
            A[i + 1] = A[i]
            i -= 1
        A[i + 1] = key
    return A




def Test(n, OrderFunc):
    testA = []
    for i in range(0, n):
        testA.append(random.randint(0, n))
    print("UnSorted")
    print(testA)
    sortedA = OrderFunc(testA)
    print("Sorted")
    print(sortedA)
    return
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]
import heapq


class MinHeap():
    def __init__(self):
        self.something = ''

    def extract_min(self):
        print('extract min')

    def insert(self):
        print('insert')

    def heapify(self):
        print('heapify')


def heap_sort(list):
    sorted_list = []
    min_heap = []
    for elem in list:
        heapq.heappush(min_heap, elem)
    for i in range(len(list)):
        sorted_list.append(heapq.heappop(min_heap))
    return sorted_list


print(heap_sort([10, 9, 8, 7, 6, 5, 4, 3]))
def sort_names(list_of_names):
	name_tuples = [(ord(name[0]), name.lower()) for name in list_of_names]
	sorted_name_tuples = sorted(name_tuples)
	sorted_names = [name for value, name in sorted_name_tuples]
	return sorted_names


def get_alph_score(name):
	if name == "":
		return 0
	return (1 + ord(name[0]) - ord("a")) + get_alph_score(name[1:])

def iterate_over_names(name_list):
	sorted_names = sort_names(name_list)
	name_and_position_tupels = [(index + 1) * get_alph_score(name) for index, name in enumerate(sorted_names)]

	return sum(name_and_position_tupels)

if __name__ == "__main__":
	with open ("p22_names.txt", "r") as name_file:
		name_list = name_file.read().replace('"', '').split(',')
		print iterate_over_names(name_list)
def front_x(words):
    a1 = []
    a2 = []
    for item in words:
        if item.startswith('x'):
            a1.append(item)
        else:
            a2.append(item)
    return(sorted(a1) + sorted(a2))


w = ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']
print(front_x(w))


"""
a1.sort()
a2.sort()
return a1+a2
"""





def is_sorted(a):
  i=0
  for num in a:
    if i == a.index(a[-1]):
      return 1
    i=i+1
    if num > a[i]:
      return 0


print'\n\n***************OUTPUT****************\n'
assert(is_sorted((10, 20, 30, 32, 33)))

assert(is_sorted((1,)))

assert(is_sorted((1,2)))

assert(not is_sorted((2, 1)))

assert(not is_sorted((1, 4, 7, 8, 6)))

assert(not is_sorted((10, 20, 30, 25, 34, 45, 67)))

print'\nAll conditions are verified..\n'
'''
Created on 201543

@author: Flowerfan
'''


def sort(graph):
    size = len(graph)
    if size == 1:
        return graph
    mid = int(size/2)
    lgraph = graph[:mid]
    rgraph = graph[mid:]
    sorted_graphl = sort(lgraph)
    sorted_graphr = sort(rgraph)
    newgraph =merge(sorted_graphl,sorted_graphr)
    return newgraph

def merge(lg,rg):
    lsize = len(lg)
    rsize = len(rg)
    size = lsize + rsize
    newG = []
    j = 0
    k = 0
    for i in range(size):
        if  k == rsize or (j < lsize and lg[j].weight < rg[k].weight):
            newG.append(lg[j])
            j += 1
        else:
            newG.append(rg[k])
            k += 1
    return newG





if __name__ == '__main__':
    pass

import random

def isSorted(A):
	return all(A[i] <= A[i+1] for i in range(len(A)-1))

def sort(A):
	while not isSorted(A):
		random.shuffle(A)
	return A
import random, itertools

def bogosort(l):
    '''
    Randomly shuffles a list, in-place, repeatedly until it's sorted.
    '''
    while not is_sorted(l):
        random.shuffle(l)

def is_sorted(l):
    '''
    Checks if a list is sorted.
    '''
    for i, j in itertools.izip(l, l[1:]):
        if i > j:
            return False
    return True

def test():
    sort_these = [1, 3, 2, 4]

    print sort_these
    bogosort(sort_these)
    print sort_these

if __name__ == '__main__':
    test()

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
import numpy as np
r=[['a', 'a', 'a', 'b','c','c','c','c'],[1,2,3,13],[4,5,6,14],[7,8,9,15],[10,11,12,16,4,5,6,14]]

d={r[0][z]:[p[z] for p in r[1:] if z<=len(r[1])-1] for z in xrange(0,len(r[0]))}

def chardiv(lst):
    def pairs(xs):
      for p in zip(xs[:-1], xs[1:]):
        yield p
    sortOrder=[i[0] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedIndep=[i[1] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedDep=[lst[1][z] for z in sortOrder]
    cuts=[];divs=[]
    for x in xrange(1,len(sortedIndep)):
      if not sortedIndep[x-1]==sortedIndep[x]:
        cuts.append(x)
    cuts.insert(0, 0); cuts.insert(len(cuts),len(sortOrder))
    for x,y in pairs(cuts):
      print x, y
      divs.append([sortedIndep[x],np.std(sortedDep[x:y]),[(sortedIndep[z], sortedDep[z]) for z in xrange(x,y)]])
    return divs

print chardiv([r[0],r[4]])
def bubble_sort(sort):
	temp=0
	for i in range(0,len(sort)):
		for j in range(len(sort)-1,i,-1):
			print sort[j],sort[j-1]
			if sort[j] < sort[j-1]:
				temp=sort[j]
				sort[j]=sort[j-1]
				sort[j-1]=temp
	return sort

if __name__=="__main__":
	print "Enter the element: "
	to_sort=[]
	for i in range(0,6):
		x=int(raw_input())
		to_sort.append(x)
	sorted_list=bubble_sort(to_sort)
	print "Sorted list is: ",sorted_list


list = [9, 4, 6, 2, 3, 7, 8, 5, 1, 0]

def mergeSort(list):
	if(len(list) > 1):

		sortedList = []

		mid = len(list) // 2

		leftHalf = list[:mid]
		rightHalf = list[mid:]

		leftHalf = mergeSort(leftHalf)
		rightHalf = mergeSort(rightHalf)

		i = 0
		j = 0

		while(i < len(leftHalf) and j < len(rightHalf)):
			if(leftHalf[i] < rightHalf[j]):
				sortedList = sortedList + [leftHalf[i]]
				i = i + 1
			else:
				sortedList = sortedList + [rightHalf[j]]
				j = j + 1
		while(i < len(leftHalf)):
			sortedList = sortedList + [leftHalf[i]]
			i = i + 1
		while(j < len(rightHalf)):
			sortedList = sortedList + [rightHalf[j]]
			j = j + 1



		return sortedList
	else:
		return list


print(mergeSort(list))"""
An implementation of counting sort.
"""

import random

def counting_sort(array):
	"""
	Perform a counting sort.

	Args:
		array (list of ints): An array of integers.

	Returns:
		A pointer to the sorted copy of `array`.
	"""

	min_val = min(array)
	max_val = max(array)
	counts = [0] * (max_val - min_val + 1)

	for item in array:
		counts[item + min_val] += 1

	sorted_arr = []
	for ind in xrange(len(counts)):
		for repetition in xrange(counts[ind]):
			sorted_arr.append(ind + min_val)

	return sorted_arr

def test_counting_sort():
	"""
	Test `counting_sort()` against Python's inbuilt `sorted()`.

	If `counting_sort()` fails to correctly sort an array, print a message
	containing both the original array and the array after the attempted sort.
	"""

	for i in xrange(100):
		arr = range(-50, 50)
		random.shuffle(arr)

		sorted_arr = counting_sort(arr)
		if sorted_arr != sorted(arr):
			print (
				"counting sort() failed.\n"
				"\tOriginal: %s\n\tAttempted sort: %s"
			) % (arr, sorted_arr)

if __name__ == "__main__":
	test_counting_sort()
from random import randrange
import sorting

def populate_random_data():
	data_limit = randrange(25, 50)
	data = [randrange(0, 999) for i in xrange(data_limit)]
	return data

'''
	Test bubble sort
'''
def test_bubble_sort():
	data = populate_random_data()
	sorting.bubble_sort(data)

	assert sorted(data) == data


'''
	Test insertion sort
'''
def test_insertion_sort():
	data = populate_random_data()
	sorting.insertion_sort(data)

	assert sorted(data) == data

'''
	Test merge sort
'''
def test_merge_sort():
	data = populate_random_data()
	sorting.merge_sort(data)

	assert sorted(data) == data

'''
	Test selection sort
'''
def test_insertion_sort():
	data = populate_random_data()
	sorting.selection_sort(data)

	assert sorted(data) == data


class QuickSort:

    def __init__(self):
        self.less = []
        self.equal = []
        self.greater = []

    def Sort(self, array):
        if len(array) > 1:
            pivotElement = array[0]
            for x in array:
                if x < pivotElement:
                    self.less.append(x)
                if x == pivotElement:
                    self.equal.append(x)
                if x > pivotElement:
                    self.greater.append(x)


            return QuickSort().Sort(self.less) + self.equal + QuickSort().Sort(self.greater)

        else:
            return array


def main():
    array = input('Please enter an array: ')
    quickSortObject = QuickSort()

    sortedArray = quickSortObject.Sort(array)
    print sortedArray


if __name__ == '__main__':
    main()


def is_sorted(sequence, reverse=False):
    return (sorted(sequence, reverse=reverse) == sequence)

def selection_sort(sequence):
    """Returns a sorted list."""

    sequence = list(sequence)

    for j in range(len(sequence) - 1):
        minimum = sequence[j]
        index_of_minimum = j

        for i in range(j + 1, len(sequence)):
            if sequence[i] < minimum:
                minimum = sequence[i]
                index_of_minimum = i

        sequence[j], sequence[index_of_minimum] = sequence[index_of_minimum], \
                sequence[j]

    return sequence

if __name__ == "__main__":
    l = [3, 4, 19, 2, 10, 7, 1, 5, 8]

    sorted_list = selection_sort(l)
    assert is_sorted(sorted_list)
    assert all(v in sorted_list for v in l)
    print "%s became %s" % (l, sorted_list)
import collections

def key_sort_dictionary(d):
    """

    Python's `dict` type doesn't support ordering.

    :param d: A dictionary.

    :returns: OrderedDictionary.
    """

    return collections.OrderedDict(sorted(d.items(), key=lambda t: t[0]))















def canonical(word):
    return sorted(word.lower())

def is_anagram(word_1, word_2):
    return canonical(word_1) == canonical(word_2)

print is_anagram("cat", "dog")
print is_anagram("iceman", "cinema")
from heap import Heap


class HeapSort:

    def __init__(self, sequence, order=None):
        self.__heap = self.__make_heap(sequence, order)

    def h_sort(self):
        sorted_arr = []
        heap_size = self.__heap.size()
        while len(sorted_arr) < heap_size - 1:
            sorted_arr.append(self.__heap.delete())
        return sorted_arr

    def __make_heap(self, sequence, order):
        heap = Heap(order)
        for element in sequence:
            heap.insert(element)
        return heap


def main():
    test_arr = [4, 13, 52, 7, 18, 3, 1, 6]
    sorter = HeapSort(test_arr)
    result = sorter.h_sort()
    print(result)


if __name__ == '__main__':
    main()







import __builtin__

if not hasattr(__builtin__, "sorted"):
    def mySorted(l):

        if type(l) is list:
            l.sort()
        elif type(l) in [range, xrange]:
            l = [x for x in l]
            l.sort()
        elif type(l) is str:
            l = list(l)
            l.sort()

        return l

    __builtin__.sorted = mySorted

if not hasattr(__builtin__, "reversed"):
    def myReversed(l):

        if type(l) is list:
            l.reverse()

        elif type(l) in [range, xrange]:
            l = [x for x in l]
            l.reverse()
        elif type(l) is str:
            l = list(l)
            l.reverse()

        return l

    __builtin__.reversed = myReversed




def selectionSort(listToSort):

	for i in range(len(listToSort)-1,0,-1):
		maxPos = 0
		for j in range(1, i+1):
			if listToSort[j] > listToSort[maxPos]:
				maxPos = j

		tmp = listToSort[i]
		listToSort[i] = listToSort[maxPos]
		listToSort[maxPos] = tmp

	return listToSort





if __name__=="__main__":
    listToSort = [2,7,3,8,5,1,0,5,8,16,39,1,3,23,12,34,82,6,2,8,55,5,20]

    sortedList = selectionSort(listToSort)
    print sortedList
def shell_sort(_list, step):
    sorted_list = _list[:]

    def sort_sublist(l, start, gap):
        for index in range(start, len(l), gap):
            current_value = l[index]
            position = index

            while position >= gap and current_value < l[position - gap]:
                l[position] = l[position - gap]
                position -= gap

            l[position] = current_value

    for i in range(0, step):
        sort_sublist(sorted_list, i, step)

    sorted_list = insertion_sort(sorted_list)

    return sorted_listdef sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])


__date__= 'Apr 13, 2014 '
__author__= 'samuel'




def merge(sorted_A, sorted_B):
    na = len(sorted_A)
    nb = len(sorted_B)
    idxa = 0
    idxb = 0
    rtn_list = []
    while True:
        if idxa == na:
            rtn_list = rtn_list + sorted_B[idxb:nb]
            break
        if idxb == nb:
            rtn_list = rtn_list + sorted_A[idxa:na]
            break
        if sorted_A[idxa] > sorted_B[idxb]:
            rtn_list.append(sorted_B[idxb])
            idxb += 1
        else:
            rtn_list.append(sorted_A[idxa])
            idxa += 1
    print '-> %s' % rtn_list
    return rtn_list


def merge_sort(A):
    n = len(A)
    if n == 1:
        return A
    sub_array_A = merge_sort(A[:n/2])
    sub_array_B = merge_sort(A[n/2:])
    print sub_array_A, sub_array_B,
    return merge(sub_array_A, sub_array_B)


def main():
    A = [1,2,3,9,6,10,5,31,8]
    B = merge_sort(A)
    print ''
    print B


if __name__ == '__main__':
    main()
def getKey(item):
    return item[0] / item[1]


def sort_fractions(fractions):
    return sorted(fractions, key=getKey)


print(sort_fractions([(5, 6), (22, 78), (22, 7), (7, 8), (9, 6), (15, 32)]))
from random import shuffle, randint


def bogo_sort(array):
    while array != sorted(array):
        shuffle(array)
    return array


if __name__ == '__main__':
    assert bogo_sort([2, 1]) == [1, 2]
    assert bogo_sort([15, 21, 16]) == [15, 16, 21]
    assert bogo_sort([47, 52, 51, 1]) == [1, 47, 51, 52]
    assert bogo_sort([47, 87, 51, 1, 2]) == [1, 2, 47, 51, 87]
    array = [randint(0, 100) for _ in range(10)]
    assert bogo_sort(array) == sorted(array)def average(data):
    """finds average of a list of numbers"""
    return sum(data)/float(len(data))
def sum(data):
    """finds sum of a list of numbers"""
    total = 0
    for i in data:
        total+=i
    return total
def _ss(data):
    """Return sum of square deviations of sequence data."""
    c = mean(data)
    ss = sum((x-c)**2 for x in data)
    return ss
def std-dev(data):
    """returns the standard deviation of a list of numbers"""
    n = len(data)
    if n < 2:
        raise ValueError('variance requires at least two data points')
    ss = _ss(data)
    pvar = ss/n
    return pvar**0.5
def mean(data):
    """alias for average. Both mean the same thing. (get it?)"""
    average(data)
def median(data):
    """returns the median of a set of data untested"""
    sortedList = sorted(data)
    lengthOfSortedList = len(sortedList)
    if lengthOfSortedList == 1:
        return sortedList[0]
    elif(lengthOfSortedList%2==0):
        return average(sortedList[(lengthOfSortedList/2)-1:lengthOfSortedList/2])
    else:
        return sortedList[(lengthOfSortedList/2)-1]
def quickSort(data):
    pass
def bubbleSort(data):
    length = len(data)
    sortedList = []
    while(len(sortedList)<length):
        currentHighest = data[0]
        for i in range(data):
            if(data[i]>currentHighest):
                currentHighest = data[i]
        sortedList.append(currentHighest)
    return reversed(sortedList)

def mergeSort(data):
    pass
from simplify_fraction import simplify_fraction

def evaluate_fraction(fraction):
	return float(fraction[0]) / fraction[1]


def sort_fractions(fractions):
	return(sorted(fractions, key=evaluate_fraction))




def sort_last(x):
  return sorted(x, key=foo)

def foo(s):
  return s[-1]

print sort_last([[1, 3], [3, 2], [2, 1]])
print sort_last([[2, 3], [1, 2], [3, 1]])
print sort_last([[1,7],[1,3],[3,4,5],[2,2]])
def sort_names(list_of_names):
	name_tuples = [(ord(name[0]), name) for name in list_of_names]
	sorted_name_tuples = sorted(name_tuples)
	sorted_names = [name for value, name in sorted_name_tuples]
	return sorted_names


def get_alph_score(name):
	if name == "":
		return 0
	return ord(name[0]) + get_alph_score(name[1:])

def iterate_over_names(name_list):
	sorted_names = sort_names(name_list)
	name_and_position_tupels = [(index + 1) * get_alph_score(name) for index, name in enumerate(sorted_names)]
	return sum(name_and_position_tupels)

with open ("p22_names.txt") as name_file:
	name_list = name_file.read().split(',')




def sorted_string(stringToSort):


    sortedList = list(stringToSort)
    sortedList.sort()


    result = ''.join(sortedList)

    return result

if __name__ == '__main__':

    string1 = 'hello'
    string2 = 'teststring'

    print sorted_string(string1)
    print sorted_string(string2)




def bubble(list):
    for index in range(len(list) - 1):
        if list[index] > list[index + 1]:
            greater = list[index]
            lesser = list[index + 1]
            list[index] = lesser
            list[index + 1] = greater


def is_sorted(list):
    for index in range(len(list) - 1):
        if list[index] > list[index + 1]:
            return False
    return True


def bubble_sort(list):
    while not is_sorted(list):
        bubble(list)
    return list


print str(bubble_sort([9,8,7,6,5,4,3,2,1])) + "\n"


print str(bubble_sort([9,8,6,6,5,100,3,2,1])) + "\n"














from __future__ import print_function

import numpy as np


def sorted_random_array(n):
    x = np.random.random(n)
    return x

print("Sorted random values: ", sorted_random_array(10))
def sort_it(list_, n):
    lst2 = sorted( [ ( l.strip()[n-1], l ) for l in list_.split(',') ] )
    lst3 = [ x[1] for x in lst2 ]
    return ','.join(lst3)



lst = 'bill, bell, ball, bull'
n = 2
print sort_it(lst,n)


def is_sorted(sequence, reverse=False):
    return (sorted(sequence, reverse=reverse) == sequence)

def insertion_sort(sequence):
    """Returns a sorted list from a sequence."""


    sequence = list(sequence)

    for i in range(1, len(sequence)):
        current_value = sequence[i]
        j = i
        while (j > 0 and current_value < sequence[j-1]):
            j -= 1
        sequence.insert(j, sequence.pop(i))

    return sequence

def insertion_sort_nonincreasing(sequence):
    """Returns a sorted list from a sequence."""
    sequence = list(sequence)

    for i in range(1, len(sequence)):
        current_value = sequence[i]
        j = i
        while (j > 0 and current_value > sequence[j-1]):
            j -= 1
        sequence.insert(j, sequence.pop(i))

    return sequence

if __name__ == "__main__":
    l = [3, 4, 19, 2, 10, 7, 1, 5, 8]

    sorted_list = insertion_sort(l)
    assert is_sorted(sorted_list)
    print "%s became %s" % (l, sorted_list)

    sorted_nonincreasing_list = insertion_sort_nonincreasing(l)
    assert is_sorted(sorted_nonincreasing_list, reverse=True)
    print "%s became %s" % (l, sorted_nonincreasing_list)
def break_w(words) :
	return words.split(' ')

def get_first(words) :
	return words.pop(0)

def get_last(words) :
	return words.pop(-1)

def sort(words) :
	"""Sorts the words"""
	return sorted(words)

def sort_sentence(words) :
	"""sorts sentence"""
	break_words = break_w(words)
	return sort(break_words)

def print_first_last(sentence) :
	"""prints first and last word from sorted sentence"""
	sw = sort_sentence(sentence)
	print get_first(sw), get_last(sw)


print_first_last("ovo je proba i testiram nesto")
	import random


def random_quick_sort(list_to_sort):
    if len(list_to_sort) > 1:
        less = []
        equal = []
        greater = []
        pivot = list_to_sort[random.randrange(len(list_to_sort))]
        for x in list_to_sort:
            if x < pivot:
                less.append(x)
            elif x == pivot:
                equal.append(x)
            elif x > pivot:
                greater.append(x)
        return random_quick_sort(less) + equal + random_quick_sort(greater)
    else:
        return list_to_sort

array = [20, 3, 3, 19, 88, 7, 22, 7, 4, 2, 99]
sorted_array = random_quick_sort(array)
print(sorted_array)

pass
def merge(list1, list2):
  i = 0
  j = 0
  output = []
  len1 = len(list1)
  len2 = len(list2)
  while i < len1 or j < len2:

    if i < len1 and j < len2:
      if list1[i] < list2[j]:

        output += [list1[i]]
        i = i+1
      else:

        output += [list2[j]]
        j = j+1

    elif i < len1:
      output += [list1[i]]
      i = i+1

    elif j < len2:
      output += [list2[j]]
      j = j+1
  return output
def merge_sort(list):
  length = len(list)

  if length <= 1:
    return list

  else:

    mid = length/2
    left = list[0:mid]
    right = list[mid:]

    sorted_left = merge_sort(left)
    sorted_right = merge_sort(right)

    return merge(sorted_left, sorted_right)
def get_data():
	nums=[]
	while True:
		a=int(raw_input("Enter a number (-1 to exit) : "))
		if a==-1:
			break
		nums.append(a)
	return nums

if __name__=='__main__':
	nums=get_data()
	print "Input data is : ",nums
	print "Sorted data is : ",merge_sort(nums)
def sort_anagram(lst):
    lst_new = [(sorted(s), s) for s in lst]
    lst_new.sort()
    return [t[1] for t in lst_new]

if __name__ == '__main__':
    lst = ['axyz', 'abc', 'yzax', 'bac', 'zyxa', 'fg', 'gf']
    print sort_anagram(lst)
import pandas as pd

def sorted_table(data, sorted_cols, outfile):

    """Generating a csv table which is sorted by some columns

       inputs:
         - data: it must be pandas.Dataframe()
         - sorted_cols: the table sorted by which columns, i.e. ['Date', 'Name']
         - outfile: the path of the csv file, i.e. "./sorted_table.csv"
    """

    return data.sort_values(by=sorted_cols).to_csv(outfile)

import sys
import operator

def primes (q):
  return (i for i in xrange(2,q) if i not in [j*k for j in xrange(2,i/2+1) for k in xrange(2,min(j+1,i/j+1))])

def gap (p, q):
  sorted_primes = list(set(primes(q)) - set(primes(p)))
  sorted_primes.sort()
  n = len(sorted_primes)
  a = []
  high_gaps = {}
  low_gaps = {}
  gapped_primes = {}
  for i in range(n):
    if(0 < i < n - 1):
      gap_l = sorted_primes[i] - sorted_primes[i-1]
      gap_h = sorted_primes[i+1] - sorted_primes[i]
      high_gaps[sorted_primes[i]] = gap_h
      low_gaps[sorted_primes[i]] = gap_l
      print "p(" + str(i) + "): \t" + str(sorted_primes[i]) + " \t" + str(gap_l) +  " " + str(gap_h) + " " + str((gap_h + gap_l)/2)
  gaps_descending = list(reversed(sorted(a)))
  sorted_hg = sorted(high_gaps.items(), key=operator.itemgetter(1), reverse=True)
  sorted_lg = sorted(low_gaps.items(), key=operator.itemgetter(1), reverse=True)
  for i in range (n-2):
    index_l = [y[0] for y in sorted_lg].index(sorted_primes[i+1])
    index_h = [x[0] for x in sorted_hg].index(sorted_primes[i+1])
    sum_indices = index_l + index_h

    gapped_primes[sum_indices] = sorted_primes[i+1]


  sorted_primes_gapped = sorted(gapped_primes.items(), key=operator.itemgetter(0))
  for i in range(10):
    gap_l = low_gaps[sorted_primes_gapped[i][1]]
    gap_h = high_gaps[sorted_primes_gapped[i][1]]
    gap_m = (gap_l + gap_h)/2
    print str(sorted_primes_gapped[i]) + " " + str(gap_h) + " " + str(gap_l) + " " + str(gap_m)




def main(argv):
  if len(sys.argv) < 3:
    print "please try with 2 numbers, p < q"
    sys.exit(2)
  else:
    gap (int(argv[1]), int(argv[2]))

if __name__ == "__main__":
  main(sys.argv)
import numpy as np

def flip(a,i,j):
	temp = a[i:j+1]
	temp = temp[::-1]
	a[i:j+1] = temp
	return a

def pancake_sort(a):
	sorted_ind = -1
	while sorted_ind != len(a) - 1:
		max_unsorted = sorted_ind+1
		for i in xrange(sorted_ind+2,len(a)):
			if a[i] >= a[max_unsorted]:
				max_unsorted = i
		if max_unsorted < len(a) - 1:
			a = flip(a, max_unsorted, len(a))
		elif max_unsorted == len(a)-1:
			a = flip(a, sorted_ind+1, len(a)-1)
			sorted_ind += 1
	return a

print pancake_sort(np.random.randint(100, size=10))
def sortNumber(n):
    list1 = []
    for i in xrange(len(str(n))):
        list1.append(str(n)[i])
    list1.sort()
    return "".join(list1)

def insert(n):
    sortedKey = sortNumber(n**3)
    if sortedKey in permDict:
        permDict[sortedKey].append(n)
    else:
        permDict[sortedKey] = [n]

def main():
    isFound = False
    counter = 1
    while not isFound:
        insert(counter)
        if len(permDict[sortNumber(counter**3)]) == 5:
            isFound = permDict[sortNumber(counter**3)][0] ** 3
        else:
            counter += 1
    print isFound

permDict = {}
main()

"""
Created on Mon Sep 21 11:33:36 2015

@author: A
"""


def sort_a_list(liste):
    liste.sort()
    liste.reverse()
    return liste


def sort_by_mark(liste2):


    liste2.sort(key=lambda liste2: liste2[0], reverse=True)
    return liste2


def sort_by_name(liste2):

    liste2.sort(key=lambda liste2: liste2[1])
    return liste2

class Interval:
    def __init__(self, s=0, e=0):
        self.start = s
        self.end = e


class Solution:


	def merge(self, intervals):
		sortedIntervals = sorted(intervals,key=self.sortIntervals)




		Index = 0
		while Index < len(sortedIntervals)-1:
			if sortedIntervals[Index].end >= sortedIntervals[Index+1].start:
				newStart = sortedIntervals[Index].start
				newEnd = sortedIntervals[Index+1].end if sortedIntervals[Index].end<sortedIntervals[Index+1].end else sortedIntervals[Index].end
				sortedIntervals.pop(Index)
				sortedIntervals.pop(Index)
				sortedIntervals.insert(Index,Interval(newStart,newEnd))
			else:
				Index = Index + 1
		return sortedIntervals
	def sortIntervals(self,interval):
		return interval.start

intervals = []
intervals.append(Interval(1,4))
intervals.append(Interval(1,4))
s = Solution()
s.merge(intervals)import copy

def my_min(l):
  if l == []:
      raise 'this is an empty list'
  else:
      min_elem  = l[0]
      for i in l:
          if min_elem > i:
              min_elem = i
  return min_elem


def my_reverse(l):
    if len(l) == 0:
        raise 999
    else:
        return l[::-1]


def select_sort(list):
    l = copy.deepcopy(list)
    if len(l) == 0:
        raise 999
    else:
        my_sorted = []
        for i in range(len(l)):
            my_sorted.append(my_min(l))
            l.remove(my_min(l))
    return my_sorted


def insert_sort(l):
    if len(l) == 0:
        raise 999
    else:
        my_sorted = [l[0]]
        for i in range(1, len(l)):
            for j in range(len(my_sorted)):
                if my_sorted[j] >= l[i]:
                    my_sorted.insert(j, l[i])
                    break
                elif j == len(my_sorted) - 1:
                    my_sorted.append(l[i])
    return my_sorted


def tear_list(sorted1, sorted2):
    ret_sort = []
    i = j = 0
    while i < len(sorted1) and j < len(sorted2):
        if sorted1[i] < sorted2[j]:
            ret_sort.append(sorted1[i])
            i += 1
        else:
            ret_sort.append(sorted2[j])
            j += 1
    while i < len(sorted1):
        ret_sort.append(sorted1[i])
        i += 1
    while j < len(sorted2):
        ret_sort.append(sorted2[j])
        j += 1
    return ret_sort



def add_up_sort(l):
    if len(l) == 0:
        raise  999
    elif len(l) == 1:
        return l
    else:
        sorted1 = add_up_sort(l[: len(l) / 2])
        sorted2 = add_up_sort(l[len(l) / 2 :])
    return tear_list(sorted1, sorted2)


l = [1, 5, 36, 67, 4, 7, 78, 100]
add_up_sort(l)




def mergeSort(listNums, startPtr, endPtr):
	if (startPtr > endPtr) or (startPtr < 0)  or (endPtr >= len(listNums)):
		return []
	elif startPtr == endPtr:
		return [listNums[startPtr]]

	midPtr = (startPtr+endPtr)/2
	sortedLeft = mergeSort(listNums, startPtr, midPtr)
	sortedRight = mergeSort(listNums, midPtr+1, endPtr)

	sortedList = merge(sortedLeft, sortedRight)


	return sortedList


def merge(sortedLeft, sortedRight):
	if (not sortedLeft) and (not sortedRight):
		return []
	elif not sortedLeft:
		return sortedRight
	elif not sortedRight:
		return sortedLeft
	else:
		leftPtr = 0
		rightPtr = 0
		sortedList = []
		while (leftPtr < len(sortedLeft)) and (rightPtr < len(sortedRight)):
			leftNum = sortedLeft[leftPtr]
			rightNum = sortedRight[rightPtr]
			if leftNum <= rightNum:
				sortedList.append(leftNum)
				leftPtr += 1
			else:
				sortedList.append(rightNum)
				rightPtr += 1
		sortedList.extend(sortedLeft[leftPtr:])
		sortedList.extend(sortedRight[rightPtr:])

	return sortedList



listNums = [2,5,1,6]
N = len(listNums)
print "\noriginal list: {}".format(listNums)
sortedList = mergeSort(listNums, 0, N-1)
print "sorted list: {}\n".format(sortedList)
def solution(A):

    count = 1 if len(A) > 0 else 0


    s = sorted(A)

    for i in range(1,len(s)):
        if s[i] != s[i-1]:
            count += 1
    return count
    passdef bubble_sort(l):
    """
    Bubble Sort
    -----------
    Advantages:
        - stable
        - in-place
    Disadvantages:
        - slow for large data sets
    Time Complexity:
        - worst:   O(n^2)
        - average: O(n^2)
        - best:    O(n)
    Space Complexity:
        - O(1)
    """
    temp = l[:]
    size = len(temp)
    sorted_list = False;
    while not sorted_list:
        modified = False;
        for i in range(1, size):
            if temp[i-1] > temp[i]:
                modified = True;
                temp[i], temp[i-1] = temp[i-1], temp[i]
        if not modified:
            sorted_list = True
    return temp

if __name__ == '__main__':

    help(bubble_sort)
    l = list(range(10, 0, -1))
    print('Unsorted list: ' + str(l));
    l = bubble_sort(l)
    print('Sorted list: ' + str(l))
a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

__author__ = 'thor'

import collections
from collections import OrderedDict


def sort_by_keys(d, reverse=False):
    return OrderedDict(sorted(d.items(), key=lambda t: t[0], reverse=reverse))


def sort_by_value(d, reverse=False):
    return OrderedDict(sorted(d.items(), key=lambda t: t[1], reverse=reverse))


def sort_by_function(d, fun, reverse=False):
    return OrderedDict(sorted(d.items(), key=fun, reverse=reverse))


def ordered_counter(x, sort_by=None, reverse=False):
    d = OrderedDict(collections.Counter(x))
    if sort_by is not None:
        if sort_by == 'count':
            d = sort_by_keys(d, reverse=reverse)
        elif sort_by == 'value':
            d = sort_by_value(d, reverse=reverse)
        else:
            d = sort_by_function(d, fun=sort_by, reverse=reverse)
    return d
def sort(values):
    return split(values)


def merge(left, right):
    sorted_list = []

    while len(left) > 0 or len(right) > 0:
        if len(left) > 0 and len(right) > 0:
            if left[0] < right[0]:
                sorted_list.append(left.pop(0))
            else:
                sorted_list.append(right.pop(0))
        elif len(left) > 0:
            sorted_list.append(left.pop(0))
        elif len(right) > 0:
            sorted_list.append(right.pop(0))

    return sorted_list


def split(values):
    if len(values) is 1:
        return values

    split_value = len(values)/2
    x = split(values[:split_value])
    y = split(values[split_value:])

    return merge(x, y)
l = [1, 3, 2, 5]

print(l)
print(sorted(l))
l.sort()
print(l)
print(l == sorted(l))

print(sorted(l, key=lambda x: -x))
l.sort(key=lambda x: -x)
print(l)
print(l == sorted(l, key=lambda x: -x))

print(sorted(l, key=lambda x: -x, reverse=True))
l.sort(key=lambda x: -x, reverse=True)
print(l)
print(l == sorted(l, key=lambda x: -x, reverse=True))

print(sorted(l, reverse=True))
l.sort(reverse=True)
print(l)
print(l == sorted(l, reverse=True))

print(sorted(l, reverse=False))
l.sort(reverse=False)
print(l)
print(l == sorted(l, reverse=False))


l = list(range(2000))
l.sort()
print(l[0], l[-1])
l.sort(reverse=True)
print(l[0], l[-1])


class A:
    def __init__(self, x):
        self.x = x
    def __lt__(self, other):
        return self.x > other.x
    def __repr__(self):
        return str(self.x)
l = [A(5), A(2), A(1), A(3), A(4)]
print(l)
l.sort()
print(l)
l.sort(reverse=True)
print(l)
def sort_fractions(fractions):
    return sorted(fractions, key=lambda item: item[0] / item[1])
def sort_n_lower(word):
    return "".join(sorted(word.lower()))

def test_for_anagram(word, base):
    return sort_n_lower(word) == sort_n_lower(base) and word.lower() != base

def detect_anagrams(base, candidates):
    return [w for w in candidates if test_for_anagram(w, base) ]

def keynat(string):
    r'''A natural sort helper function for sort() and sorted()
    without using regular expression.

    >>> items = ('Z', 'a', '10', '1', '9')
    >>> sorted(items)
    ['1', '10', '9', 'Z', 'a']
    >>> sorted(items, key=keynat)
    ['1', '9', '10', 'Z', 'a']
    '''
    r = []
    for c in string:
        try:
            c = int(c)
            try: r[-1] = r[-1] * 10 + c
            except: r.append(c)
        except:
            r.append(c)
    return r


def tuples_divisions(fractions):
    divisions = []
    for fraction in fractions:
        x, y = fraction
        divisions.append(x / y)
    return divisions


def combine_tuples_and_divisions(fractions):
    fractions_dict = {}
    for index, pair in enumerate(fractions):
        fractions_dict[tuples_divisions(fractions)[index]] = fractions[index]
    return fractions_dict


def sort_fractions(fractions):
    sorted_fractions = []
    sorted_by_key = sorted(combine_tuples_and_divisions(fractions).items(),
                           key=lambda t: t[0])
    for index, result in enumerate(sorted_by_key):
        sorted_fractions.append(result[1])
    return sorted_fractions


def main():
    print(sort_fractions([(5, 6), (22, 78), (22, 7),
                          (7, 8), (9, 6), (15, 32)]))

if __name__ == '__main__':
    main()
def is_decreasing(seq):

	sort = sorted(seq)
	reverse = sorted(sort, reverse=True)
	if reverse == seq:
		return True
	else:
		return False

print is_decreasing([5,4,3,2,1])
print is_decreasing([1,2,3])
import operator

def sort_dict_by_value(thedict):
    return sorted(thedict.items(), key=operator.itemgetter(1),reverse=True)

def get_top_n_from_dict(thedict,n):
    sorteditems = sort_dict_by_value(thedict)
    return sorteditems[0:n]
def mergeSort(array):
    if len(array) > 1:
        mid = len(array)//2
        leftHalf = array[:mid]
        rightHalf = array[mid:]
        mergeSort(leftHalf)
        mergeSort(rightHalf)
        return merge(leftHalf, rightHalf)

def merge(leftHalf, rightHalf):
    sortedArray = []
    while leftHalf is not None and rightHalf is not None:
        if leftHalf[0] <= rightHalf[0]:
            sortedArray.append(leftHalf.pop(0))
        else:
            sortedArray.append(rightHalf.pop(0))

    if leftHalf:
        sortedArray += leftHalf
    if rightHalf:
        sortedArray += rightHalf
    return sortedArray

array = [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]

print(mergeSort(array))import random

def quick_sort(sortlist):
	left = []
	right = []
	solution = []
	if len(sortlist) <= 1:
		return sortlist
	pivot = sortlist[len(sortlist)/2]
	sortlist.remove(pivot)
	for each in sortlist:
		if each <= pivot:
			left.append(each)
		elif each > pivot:
			right.append(each)
	left_sorted = quick_sort(left)
	right_sorted = quick_sort(right)
	solution.append(left_sorted)
	solution.append(pivot)
	solution.append(right_sorted)
	return solution

list_to_sort = random.sample(range(1,100),10)

print quick_sort(list_to_sort)
def sortedDictValues1(adict):
    items = adict.items()
    items.sort()
    return items


def sortedDictValues2(adict):
    keys = adict.keys()
    keys.sort()

    return [adict[key] for key in keys]

def sortedDictValues3(adict):
    keys = adict.keys()
    keys.sort()
    return map(adict.get,keys )


student = {'name':'Tom','age':25,'score':88}
result = sortedDictValues3(student)
print result




def insertionSort(listToSort):
	for i in range(1,len(listToSort)):

		curVal = listToSort[i]
		pos = i

		while pos > 0 and listToSort[pos-1]>curVal:
			listToSort[pos] = listToSort[pos-1]
			pos = pos-1


		listToSort[pos] = curVal


	return listToSort




if __name__=="__main__":
    listToSort = [2,7,3,8,5,1,0,5,8,16,39,1,3,23,12,34,82,6,2,8,55,5,20]

    sortedList = insertionSort(listToSort)
    print sortedListdef to_digits(n):
    digits = []

    while n != 0:
        digits = [n % 10] + digits
        n //= 10

    return digits

def to_number(n):
    number = 0

    for digit in n:
        number = number * 10 + digit

    return number

def max_number(n):
    return to_number(sorted(to_digits(n), reverse=True))

def min_number(n):
    return to_number(sorted(to_digits(n)))

def sort_n(n, m):
    flag = True
    if m == 0:
        flag = False
    return to_number(sorted(to_digits(n), reverse=flag))

if __name__ == "__main__":
    n = input("Enter n: ")
    n = int(n)

    print("Largest:", sort_n(n, 1))
    print("Smallest:", sort_n(n, 0))



def break_words(stuff):
    words = stuff.split('.')
    return words




def sort_words(words):
    return sorted(words)
print break_words("www.baidu.com")
print sort_words('lsfjabc')


class OrderedDict(object):
  def __init__(self):
    self.d = {}
    self.L = []
    self.sorted = True
  def __getitem__(self, k):
    return self.d[k]
  def __setitem__(self, k, v):
    if k not in self.d:
      self.L.append(k)
      self.sorted = False
    self.d[k] = v
  def __delitem__(self, k):
    del self.d[k]
    self.L.remove(k)
  def __iter__(self):
    if not self.sorted:

      self.sorted = True
    return iter(self.L)

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
import merge
def merge_sort(alist):
	""" (list of number) -> (list of number sorted)

	Return a list of number sorted use O(nlogn) time

	>>> merge_sort([1, 3 ,2, 7, 4, 6])
	[1, 2, 3, 4, 6, 7]
	"""

	n = len(alist)

	if n == 0 or n == 1:
		return alist
	else:
		leftList = alist[:n/2]
		rightList = alist[n/2:]

		leftSorted = merge_sort(leftList)
		rightSorted = merge_sort(rightList)

		return merge.merge(leftSorted, rightSorted)




from django.utils.datastructures import SortedDict


def sort_by_attr(sort_object, key_name, direction=1):
    sort_list = []
    if type(sort_object) == dict:
        for key, item in sort_object.items():
            sort_list.append(item)
    else:
        if type(sort_object) == list:
            sort_list = sort_object
        else:
            for key, item in enumerate(sort_object):
                sort_list.append(item)

    sort_dict = sorted(sort_list, key=lambda k: sort_key(k, key_name, direction))

    return sort_dict


def sort_key(k, key_name, direction):
    if type(k) == dict:
        return k[key_name]*direction
    else:
        return getattr(k, key_name)*direction



from django.utils.datastructures import SortedDict
from bencode import bencode, bdecode

def sort_dict(D):
	result = SortedDict()
	for key in sorted(D.keys()):
		if type(D[key]) is dict:
			D[key] = sort_dict(D[key])
		result[key] = D[key]
	return result












def sort_words(s):

    for i in sorted("\n".join(s.split(',')).split()):
        print i



print sort_words(" one, ,two three,4,")from operator import itemgetter


def sort_a_list(l):
    a = sorted(l, reverse=True)
    return(a)


def sort_by_mark(my_class):
    a = sorted(my_class, reverse=True)
    return(a)


def sort_by_name(my_class):
    getcount = itemgetter(1)
    a = sorted(my_class, key=getcount)
    return(a)
__author__ = 'Antony Cherepanov'

from Objects import Point, PointException


class SortBy(object):
    X_COORD = 0
    Y_COORD = 1


def Start():
    input = [Point(1, 1), Point(5, 7), Point(3, 0), Point(6, 2), Point(10, 10),
        Point(2, 1), Point(0, 10), Point(6, 5), Point(7, 2)]

    result = ClosestPoints(input)
    print "result = ", result


def ClosestPoints(t_input):
    """
     Get two closest points. Algorithm based on Merge Sort
     @input:
     - list of point objects
     @output:
     - list of two points
    """

    pointsSortedX = MergeSortForPoints(t_input, SortBy.X_COORD)
    for i in pointsSortedX:
        print i
    pointsSortedY = MergeSortForPoints(t_input, SortBy.Y_COORD)
    for i in pointsSortedY:
        print i


def MergeSortForPoints(t_points, t_sortByCoord):
    length = len(t_points)
    if 2 < length:
        halfLength = length / 2
        leftHalf = t_points[:halfLength]
        rightHalf = t_points[halfLength:]
        sortedLeft = MergeSortForPoints(leftHalf, t_sortByCoord)
        sortedRight = MergeSortForPoints(rightHalf, t_sortByCoord)
        i = 0
        j = 0
        result = list()
        for k in range(length):
            if len(sortedLeft) <= i:
                result.extend(sortedRight[j:])
                break

            if len(sortedRight) <= j:
                result.extend(sortedLeft[i:])
                break


            if t_sortByCoord == SortBy.X_COORD:
                leftPointCoord = sortedLeft[i].GetX()
                rightPointCoord = sortedRight[j].GetX()
            else:
                leftPointCoord = sortedLeft[i].GetY()
                rightPointCoord = sortedRight[j].GetY()


            if leftPointCoord < rightPointCoord:
                result.append(sortedLeft[i])
                i += 1
            else:
                result.append(sortedRight[j])
                j += 1

        return result

    else:
        if 1 == length:
            return t_points
        elif 2 == length:

            if t_sortByCoord == SortBy.X_COORD:
                first = t_points[0].GetX()
                second = t_points[1].GetX()
            else:
                first = t_points[0].GetY()
                second = t_points[1].GetY()

            if first < second:
                return t_points
            else:
                return [t_points[1], t_points[0]]


Start()'''
Created on Oct 23, 2012

Insertion sorter

@author: hunlan
'''

def sort(urls):
    sorted_urls = [urls.pop()]
    for url in urls:
        for i in range(0, len(sorted_urls)):
            if url < sorted_urls[i]:
                sorted_urls.insert(i, url)
                break
            if i == len(sorted_urls) - 1:
                sorted_urls.append(url)
    return sorted_urls



class BubbleSort:

    def sort(self, array):
        is_sorted = False
        arr_length = len(array)

        while not is_sorted:
            is_sorted = True
            for i in range(0, arr_length - 1):
                if array[i] > array[i+1]:
                    is_sorted = False
                    tmp = array[i]
                    array[i] = array[i+1]
                    array[i+1] = tmp

        return array
class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        dic = {}
        for str in strs:
            sortedStr = ''.join(sorted(str))
            if dic.has_key(sortedStr):
                dic[sortedStr].append(str)
            else:
                dic[sortedStr] = [str]

        result = []
        for key, val in dic.iteritems():
            val.sort()
            result.append(val)
        return resultdef BubbleSort(A):


	size=len(A)
	for i in range(size-1,0,-1):
		j=0
		while j<i:

			if A[j+1]<A[j]:
				A[j+1],A[j]=A[j],A[j+1]
			j=j+1

	return




A=[1,3,5,1,4,6,2,3,90,1,2,4,1,5,7,5,8,4,7]
BubbleSort(A)
print A









from __future__ import print_function

import numpy as np


def sorted_random_array(n):
    x = np.random.random(n)
    return x.sort()

print("Sorted random values: ", sorted_random_array(10))


class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
from django import template
register = template.Library()

@register.filter(name='sort_dict')
def sort_dict(iterable):
	sorted_dict = {}
	sorted_keys = iterable.keys()
	sorted_keys.sort()

	for key in sorted_keys:
		sorted_dict[key] = iterable[key]

	return sorted_dict

def selection_sort(a):
	i=0;j=1;temp=0
	while i<len(a) and j<len(a):
		if a[i] > a[j]:
			temp=a[j]
			a[j]=a[i]
			a[i]=temp
		j=j+1
		i=i+1
	return a



if __name__=="__main__":
	a=[5,3,7,4,2]
	for i in range(0,len(a)):
		sorted_list=selection_sort(a)
	print "The sorted list is: ",sorted_list

from zope.viewlet.manager import ViewletManagerBase

class SortingViewletManager(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)

from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
'''
Created on Oct 10, 2013

@author: av
'''



def _find_a_place_for_first_element(list_to_sort, start, end):
    lower_pointer = start
    upper_pointer = end
    while lower_pointer < upper_pointer:
        while lower_pointer < upper_pointer:
            upper_pointer += -1
            if list_to_sort[upper_pointer] < list_to_sort[lower_pointer]:
                list_to_sort[upper_pointer], list_to_sort[lower_pointer] = list_to_sort[lower_pointer], list_to_sort[upper_pointer]
                break
        while lower_pointer < upper_pointer:
            lower_pointer += +1
            if list_to_sort[lower_pointer] > list_to_sort[upper_pointer]:
                list_to_sort[upper_pointer], list_to_sort[lower_pointer] = list_to_sort[lower_pointer], list_to_sort[upper_pointer]
                break
    return list_to_sort, lower_pointer



def my_quick_sort(list_to_sort, start=None, end=None):
    if start == None:
        start = 0
    if end == None:
        end = len(list_to_sort)
    if end-start < 2:
        return list_to_sort
    list_to_sort, first_element_new_position = _find_a_place_for_first_element( list_to_sort, start, end )
    list_to_sort = my_quick_sort(list_to_sort, start, first_element_new_position)
    list_to_sort = my_quick_sort(list_to_sort, first_element_new_position+1, end)
    return list_to_sort

def is_sorted_asc(vector):
    if len(vector) < 2:
        return True
    return vector[0] <= vector[1] and is_sorted_asc(vector[1:])

if __name__ == '__main__':
    list_to_sort = [13,20,10,10,28,9]
    sorted_list = my_quick_sort(list_to_sort)
    print( sorted_list )
    print( 'Is it sorted ascending?', is_sorted_asc(sorted_list) )

''' Short program to count inversions using merge sort as a basis.
    Input is numbers.txt
'''


def countSplitInversions(a, b):
  sortedA = []

  i = 0
  j = 0
  inversions = 0;

  while i < len(a) and j < len(b):
    if a[i] <= b[j]:
      sortedA.append(a[i])
      i += 1
    else:
      sortedA.append(b[j])
      j += 1
      inversions += len(a) - i
  if i == len(a):
    sortedA.extend(b[j:])

  if j == len(b):
    sortedA.extend(a[i:])

  return sortedA, inversions

def sortAndCountInversions(a):
  if len(a) <= 1:
    return (a, 0)

  leftIndex = int(len(a)/2) - 1
  rightIndex = leftIndex + 1
  leftSorted, leftInversions = sortAndCountInversions(a[0:leftIndex+1])
  rightSorted, rightInversions = sortAndCountInversions(a[rightIndex:])
  sortedA, splitInversions = countSplitInversions(leftSorted, rightSorted)
  return (sortedA, leftInversions + rightInversions + splitInversions)



with open("numbers.txt") as f:
 numbers = [[int(x) for x in line.split()] for line in f]

sortedNumbers, inversions = sortAndCountInversions(numbers)
print inversions








def Merge(A, B):
	S = []
	ai = 0
	bi = 0
	while len(A) > ai and len(B) > bi:
		if A[ai] <= B[bi]:
			x = A[ai]
			ai += 1
		else:
			x = B[bi]
			bi += 1
		S.append(x)
	return S + A[ai:] + B[bi:]

def MergeSort(L):
	if len(L) <= 1:
		return L
	else:
		half = int(len(L) / 2)
		A = L[:half]
		B = L[half:]
		return Merge(MergeSort(A), MergeSort(B))



def main():
	L = [2, 3, 5, 1, 7, 6, 8, 9, 10, 4]
	sorted_L = MergeSort(L)
	print "MergeSort: ", sorted_L

if __name__ == '__main__':
	main()	import sys
from heapq import merge

def internal_merge(left, right):
    ''' A helper method to merge two sorted lists

    :param left: The left sorted list to merge
    :param right: The right sorted list to merge
    :returns: The merged sorted result list
    '''
    result = []
    li, ri = 0, 0
    while li < len(left) and ri < len(right):
        if left[li] <= right[ri]:
            result.append(left[li])
            li += 1
        else:
            result.append(right[ri])
            ri += 1
    if li < len(left):  result.extend(left[li:])
    if ri < len(right): result.extend(right[ri:])
    return result

def sort(coll):
    ''' Given a collection, sort it using the merge
    sort method (sorted by reference).

    O(n log n) performance
    O(n)   storage

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    if len(coll) <= 1:
        return coll
    m = len(coll) / 2
    l = sort(coll[:m])
    r = sort(coll[m:])
    return list(internal_merge(l, r))


def sort_clone(coll):
    ''' Given a collection, sort it using the bubble
    sort method (sorted by copy).

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    return sort(list(coll))




def insert(array, splitIndex, value):
	"""
	insert value into array before item at splitIndex
	"""
	arr1 = array[0:splitIndex]
	arr2 = array[splitIndex:]
	return arr1 + [value] + arr2


def index(x, sorted_a):
	"""
	returns splitIndex
	"""
	for elem in sorted_a:
		if x <= elem:
			return sorted_a.index(elem)
	else:
		return len(sorted_a)

def insertSort(array):
	sorted_arr = [array[0]]
	for x in array[1:]:
		sorted_arr = insert(sorted_arr, index(x, sorted_arr), x)

	return sorted_arr


if __name__ == '__main__':
	print insert([0,1,2,3,4,5], 2, 10)
	print insertSort([1,0,5,19,3,-16])from pyuca import Collator

def check(sorted_list):
    return 'CORRECT' if fruits == sorted_list else 'WRONG'

fruits = ['aa', 'acerola', 'atemoia', 'caj', 'caju']

print('manual_sort', fruits)

plain_sort = sorted(fruits)

print('plain_sort ', plain_sort, check(plain_sort))

coll = Collator()

pyuca_sort = sorted(fruits, key=coll.sort_key)

print('pyuca_sort ', pyuca_sort, check(pyuca_sort))







def get_sorted_dict_keys(keys):
    a = list(keys)
    a.sort()
    return a

def indexing_access(a):
    print(a[0])
    k = a[0]
    assert k == 'a'

def dump_array(arr, d):
    for k in arr:
        print("%s->%d" % (k, d[k]))

def test_dict_keys():
    d = {"a": 1, "b": 2, "c": 3}
    ks = d.keys()


    print(ks)

    array = get_sorted_dict_keys(ks)
    assert(len(array) == 3)
    indexing_access(array)
    dump_array(array, d)
def selection_sort(unsorted_list):
    sorted_list = []
    while unsorted_list:
        minimum = min(unsorted_list)
        unsorted_list.remove(minimum)
        sorted_list.append(minimum)
    return sorted_list

print selection_sort([1,25,67,32,2,4,6,7,8,4,3,32,1,32])
def sort_fractions(fractions):
    return sorted(fractions, key=lambda x: x[0] / x[1])
import random

class ListSorter():
  """docstring for BubbleSort"""
  def __init__(self):
    pass

  def RecursiveBubbleSortMin(self, l):
    """docstring for sort"""


    if len(l) == 1:
      return (l, 0)

    algorithm_complexity = 0
    for i in range(1, len(l)):
      if l[0] > l[i]:
        l[0], l[i] = l[i], l[0]
      algorithm_complexity += 2

    l_min = l[:1]

    (smaller_l, recursive_complexity) = self.RecursiveBubbleSortMin(l[1:])

    return (l_min + smaller_l, algorithm_complexity + recursive_complexity)

  def RecursiveBubbleSortMax(self, l):
    """docstring for sort"""


    if len(l) == 1:
      return (l, 0)

    algorithm_complexity = 0
    current_max_i = 0
    for i in range(1, len(l)):
      if l[current_max_i] > l[i]:
        l[current_max_i], l[i] = l[i], l[current_max_i]
      current_max_i = i
      algorithm_complexity +=2

    l_max = l[-1:]

    (smaller_l, recursive_complexity) = self.RecursiveBubbleSortMax(l[:-1])

    return (smaller_l + l_max, algorithm_complexity + recursive_complexity)

  def BubbleSort(self, l2):
    """docstring for sort2"""

    algorithm_complexity = 0
    l = l2[:]
    for i in range(len(l)):
      for j in range(i, len(l)):
        if l[i] > l[j]:
          l[i], l[j] = l[j], l[i]
        algorithm_complexity += 2
    return l, algorithm_complexity

  def RecursiveMergeSort(self, l):
    """docstring for sort2"""

    if len(l) == 1:
      return (l, 0)


    half_size = len(l)/2
    l1 = l[:half_size]
    l2 = l[half_size:]

    l1_sorted, l1_complexity = self.RecursiveMergeSort(l1)
    l2_sorted, l2_complexity = self.RecursiveMergeSort(l2)


    algorithm_complexity = 0
    l_sorted = []
    x = 0
    y = 0
    while True:
      algorithm_complexity += 2
      if l1_sorted[x] < l2_sorted[y]:
        l_sorted.append(l1_sorted[x])
        x += 1
        if x >= len(l1_sorted):
          l_sorted += l2_sorted[y:]
          break
      else:
        l_sorted.append(l2_sorted[y])
        y += 1
        if y >= len(l2_sorted):
          l_sorted += l1_sorted[x:]
          break
    return (l_sorted, algorithm_complexity + l1_complexity + l2_complexity)

  def RecursiveRandomSort(self, l):

    if len(l) == 1:
      return (l, 0)


    division = random.randint(1, len(l)-1)
    l1 = l[:division]
    l2 = l[division:]

    l1_sorted, l1_complexity = self.RecursiveRandomSort(l1)
    l2_sorted, l2_complexity = self.RecursiveRandomSort(l2)


    algorithm_complexity = 0
    l_sorted = []
    x = 0
    y = 0
    while True:
      algorithm_complexity += 2
      if l1_sorted[x] < l2_sorted[y]:
        l_sorted.append(l1_sorted[x])
        x += 1
        if x >= len(l1_sorted):
          l_sorted += l2_sorted[y:]
          break
      else:
        l_sorted.append(l2_sorted[y])
        y += 1
        if y >= len(l2_sorted):
          l_sorted += l1_sorted[x:]
          break
    return (l_sorted, algorithm_complexity + l1_complexity + l2_complexity)

  def InsertionSort(self, l):
    algorithm_complexity = 0
    for i in range(len(l)):
      val = l[i]

      j = i - 1
      while j >= 0 and val < l[j]:



        algorithm_complexity += 2
        l[j + 1] = l[j]
        j -= 1

      l[j + 1] = val
    return l, algorithm_complexity

  def RecursiveInsertionSort(self, unsorted_list):
    sorted_list = unsorted_list[:1]
    algorithm_complexity = self.__RecursiveInsertionSort(sorted_list,
                                                         unsorted_list[1:])
    return (sorted_list, algorithm_complexity)

  def __RecursiveInsertionSort(self, sorted_list, unsorted_list):
    algorithm_complexity = 0

    if not unsorted_list:
      return algorithm_complexity
    current = unsorted_list[0]
    algorithm_complexity += 2

    j = len(sorted_list) - 1
    sorted_list.append(current)
    while j >= 0 and current < sorted_list[j]:



      sorted_list[j + 1] = sorted_list[j]
      algorithm_complexity += 2
      j -= 1
    sorted_list[j + 1] = current

    algorithm_complexity += self.__RecursiveInsertionSort(sorted_list,
                                                          unsorted_list[1:])
    return algorithm_complexity


  def RecursiveQuicksort(self, l):
    algorithm_complexity = 0
    if len(l) <= 1:
      return l, algorithm_complexity
    pivot_idx = random.randint(0, len(l) - 1)
    less = []
    greater = []
    for i in l:
      if i <= l[pivot_idx]:
        less.append(i)
      else:
        greater.append(i)
      algorithm_complexity += 2
    l_less, a = self.RecursiveQuicksort(less)
    l_greater, b = self.RecursiveQuicksort(greater)

    return l_less + l_greater, (algorithm_complexity + a + b)
pythonsort,sorted
 python listsort,sorted
a = [5,2,1,9,6]

>>> sorted(a)
[1, 2, 5, 6, 9]

>>> sorted(a,reverse = True)
[9, 6, 5, 2, 1]

>>> a.sort()
>>> a
[1, 2, 5, 6, 9]

>>> a.sort(reverse = True)
>>> a
[9, 6, 5, 2, 1]

a.sort() b = a.sort() !

>>> b = ['aa','BB','bb','zz','CC']
>>> sorted(b)
['BB', 'CC', 'aa', 'bb', 'zz']

>>> c =['CCC', 'bb', 'ffff', 'z']
>>> sorted(c,key=len)
['z', 'bb', 'CCC', 'ffff']

>>> d =['CCC', 'bb', 'ffff', 'z']
>>> sorted(d,key = str.lower )
['bb', 'CCC', 'ffff', 'z']

>>> def lastchar(s):
       return s[-1]
>>> e = ['abc','b','AAz','ef']
>>> sorted(e,key = lastchar)
['b', 'abc', 'ef', 'AAz']

>>> f = [{'name':'abc','age':20},{'name':'def','age':30},{'name':'ghi','age':25}]
>>> def age(s):
       return s['age']
>>> ff = sorted(f,key = age)

[{'age': 20, 'name': 'abc'}, {'age': 25, 'name': 'ghi'}, {'age': 30, 'name': 'def'}]

>>> f2 = sorted(f,key = lambda x:x['age'])


def merge_sort(a):
    """
    :param a: a list of numbers
    :return: a new sorted list of numbers those come from param a and without a be sorted
    """
    length = len(a)
    if length < 2:
        return a
    mid = length // 2
    left = merge_sort(a[:mid])
    right = merge_sort(a[mid:])
    a = merge(left, right)
    return a


def merge(a, b):
    """
    :param a: a sorted list of numbers
    :param b: a sorted list of numbers
    :return: a sorted list of numbers those from param a and b
    """
    ans = []
    while a and b:
        if a[0] > b[0]:
            ans.append(b.pop(0))
        else:
            ans.append(a.pop(0))
    ans.extend(a + b)
    return ansimport operator


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(l):
    return sorted(list(l), reverse=True)


def sort_by_name(l):
    return sorted(list(l), key=operator.itemgetter(1), reverse=False)
"""
bubble_sort.py

Worse Case Performance: O(n^2)
Best Case Performance: O(n)
Average Case Performance: O(n^2)

Pseudocode: http://en.wikipedia.org/wiki/Bubble_sort
"""


def bubble_sort(sequence):
	sorted = False

	while not sorted:
		sorted = True
		for i in range(0,len(sequence)-1):
			if sequence[i] > sequence[i+1]:
				sorted = False
				tmp = sequence[i+1]
				sequence[i+1] = sequence[i]
				sequence[i] = tmp

	return sequence


import pytest
from random import randint

from quick_sort import quick_sort

_RANGE = 100


@pytest.fixture
def make_random():
    return [randint(0, 100) for x in range(_RANGE)]


@pytest.fixture
def make_in_order():
    return [x for x in range(_RANGE)]


@pytest.fixture
def make_in_order_reverse():
    return [x for x in range(_RANGE)][::-1]


def test_quick_sort_random(make_random):
    to_sort = make_random
    assert to_sort != sorted(to_sort)
    assert quick_sort(to_sort) == sorted(to_sort)


def test_quick_sort_in_order(make_in_order):
    to_sort = make_in_order
    assert to_sort == sorted(to_sort)
    assert quick_sort(to_sort) == sorted(to_sort)


def test_quick_sort_reverse(make_in_order_reverse):
    to_sort = make_in_order_reverse
    assert to_sort != sorted(to_sort)
    assert to_sort == sorted(to_sort, reverse=True)
    assert quick_sort(to_sort) == sorted(to_sort)


def test_quick_sort_zero():
    to_sort = []
    assert quick_sort(to_sort) == []


def test_quick_sort_one():
    to_sort = [1]
    assert quick_sort(to_sort) == [1]


def test_quick_sort_small():
    to_sort = [1, 3, 2, 4, 5, 9, 8, 7, 6, 10]
    assert quick_sort(to_sort) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
from collections import defaultdict

class School(object):

  def __init__(self, schoolName):
    self.schoolName = schoolName
    self._db = defaultdict(set)

  @property
  def db(self):
    return self._db

  def add(self, name, grade):
    self.db[grade].add(name)

  def grade(self, grade):
    return self.db[grade]

  def sort(self):
    return [(grade, tuple(sorted(self.db[grade]))) for grade in sorted(self.db)]
def sort(coll):
    ''' Given a collection, sort it using the insertion
    sort method (sorted by reference).

    O(n^2) performance
    O(n)   storage

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    for j in range(1, len(coll)):
        k = coll[j]
        i = j - 1
        while i > 0 and coll[i] > k:
            coll[i + 1] = coll[i]
            i = i - 1
        coll[i + 1] = k
    return coll


def sort_clone(coll):
    ''' Given a collection, sort it using the insertion
    sort method (sorted by copy).

    :param coll: The collection to sort
    :returns: The sorted collection
    '''
    return sort(list(coll))
f = open ('QuickSort.txt', 'r')
ar = [int(i) for i in f];
f.close()

def median(a):
    return sorted(a)[1]

def quick_sort(a):
    return _quick_sort(a, 0, len(a))

def _quick_sort(a, l, r):
    c = 0
    if l < r:
        q, c = _partition(a, l, r)
        c += _quick_sort(a, l, q-1)
        c += _quick_sort(a, q, r)
    return c

def _partition(a, l, r):
    p = median([a[l], a[l+(r-l-1)/2], a[r-1]])
    if a[l] == p:
        p_i = l
    elif a[l+(r-l-1)/2] == p:
        p_i = l+(r-l-1)/2
    else:
        p_i = r-1
    a[l], a[p_i] = a[p_i], a[l]
    i = l + 1
    c = 0
    for j in xrange(l+1, r):
        c += 1
        if a[j] < p:
            a[j], a[i] = a[i], a[j]
            i += 1
    a[l], a[i-1] = a[i-1], a[l]
    return i, c

count = quick_sort(ar)
print count
def sort_a_list(L):
    V = sorted(L, reverse=True)
    return(V)


from operator import itemgetter


def sort_by_mark(Y):
    P = sorted(Y, key=itemgetter(0), reverse=True)
    return(P)


def sort_by_name(B):
    S = sorted(B, key=itemgetter(1))
    return(S)

'''
note: really fast on mostly sorted arrays
'''


import random


def insertion_sort(arr, h=1):
  '''  '''
  for i in range(h, len(arr)):
    j = i
    while j >= h and arr[j-h] > arr[j]:
      swap = arr[j-h]
      arr[j-h] = arr[j]
      arr[j] = swap
      j -= h
  return arr


def shell_sort(arr):
  ''' h-sort the array, decrement h, and repeat untill the array has been 1 sorted '''

  h = 1
  while h < len(arr)/3:
    h = 3*h + 1

  while h >= 1:
    insertion_sort(arr, h=h)

    h = h/3
  return arr


def test():


  for i in range(10):
    test_values = tuple(random.randrange(1000) for i in range(100))
    test_sorted = tuple(sorted(test_values))

    assert test_sorted == tuple(shell_sort(list(test_values)))


  pass

if __name__ == '__main__':
  test()



def anagram_sort(str_arr):
  anagram_dict = {}
  sorted_arr = []
  for i in str_arr:
    key = ''.join(sorted(i))
    if key in anagram_dict:
      anagram_dict[key].append(i)
    else:
      anagram_dict[key] = [i]
  for key in anagram_dict:
    sorted_arr += anagram_dict[key]
  return sorted_arr

def break_words(stuff):
    """This function will break up words for us ."""

    words = stuff.split(' ')
    return words

def sort_words(words):
    """Sort the word."""
    return sorted(words)

def print_first_word(words):
    """Prints the first word after poping it off."""
    word = words.pop(0)
    print (word)

def print_last_word(words):
    """Print the last word after poping it off."""
    word = words.pop(-1)
    print (word)

def sort_sentence(sentence):
    """Take in a full sentence and returns the sorted words."""
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    """print the first and last words of the sentence."""
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)

def print_first_and_last_sorted(sentence):
    """sort the words then prints the first and last one."""
    words=sort_sentence(sentence)
    print_first_word(words)
    print_last_word(words)
class SortBy(object):
    def __init__(self):
        pass

    def sort(self, list_):
        if len(list_) <= 10000:
            return sorted(list_)
        else:
            self.sort_in_chunks(list_)

    def sort_in_chunks(self, list_):
        """
        Sort the list by chunks as a parallel operation.

        """
        print selfdef bubble_sort(l):
    """
    Bubble Sort
    -----------
    Advantages:
        - stable
        - in-place
    Disadvantages:
        - slow for large data sets
    Time Complexity:
        - worst:   O(n^2)
        - average: O(n^2)
        - best:    O(n)
    Space Complexity:
        - O(1)
    """
    temp = l[:]
    size = len(temp)
    sorted_list = False;
    while not sorted_list:
        modified = False;
        for i in range(1, size):
            if temp[i-1] > temp[i]:
                modified = True;
                temp[i], temp[i-1] = temp[i-1], temp[i]
        if not modified:
            sorted_list = True
    return temp

if __name__ == '__main__':

    help(bubble_sort)
    l = list(range(10, 0, -1))
    print('Unsorted list: ' + str(l));
    l = bubble_sort(l)
    print('Sorted list: ' + str(l))



def merge_sort(int_array):

    if len(int_array) == 0:
        return None
    elif len(int_array) == 1:
        return int_array


    else:
        l = len(int_array)/2
        first_half = int_array[:l]
        second_half = int_array[l:]
        sorted_first_half = merge_sort(first_half)
        sorted_second_half = merge_sort(second_half)
        return merge_sorted_lists(sorted_first_half, sorted_second_half)

def merge_sorted_lists(first, second):
    sorted_complete_list = []

    while first or second:
        if first and second:
            if first[0] <= second[0]:
                sorted_complete_list.append(first[0])
                first = first[1:]
            else:
                sorted_complete_list.append(second[0])
                second = second[1:]
        elif first:
            sorted_complete_list.extend(first)
            break
        elif second:
            sorted_complete_list.extend(second)
            break

    return sorted_complete_list

if __name__ == "__main__":

    eight_element_list = [8, 0, 12, 2, 5, 7, 3, 10]
    print eight_element_list
    print merge_sort(eight_element_list)
    print

    odd_number_element_list = [-10, 5, 2, 7, 6, 4.4, 3.75]
    print odd_number_element_list
    print merge_sort(odd_number_element_list)
    print

    list_w_dups = [8, 8, 3, 3, 3, 4, 4, 0]
    print list_w_dups
    print merge_sort(list_w_dups)
    print

    sorted_list = [1, 1, 3, 3, 6, 6, 9, 9, 1000, 1000, 5000, 5000, 100000000]
    print sorted_list
    print merge_sort(sorted_list)
    print

    rev_sorted_list = [10, 9, 8, 7, 6, 0, -5, -10]
    print rev_sorted_list
    print merge_sort(rev_sorted_list)
    print
import re

def natsort(string_):
    """Natural sort. Usage: sorted(list, key=natural_sort)"""

    return [int(s) if s.isdigit() else s for s in re.split(r'(\d+)', string_)]
def sort_names(list_of_names):
	name_tuples = [(ord(name[0]), name) for name in list_of_names]
	sorted_name_tuples = sorted(name_tuples)
	sorted_names = [name for value, name in sorted_name_tuples]
	return sorted_names


def get_alph_score(name):
	if name == "":
		return 0
	return ord(name[0]) + get_alph_score(name[1:])

def iterate_over_names(name_list):
	sorted_names = sort_names(name_list)
	name_and_position_tupels = [(index + 1) * get_alph_score(name) for index, name in enumerate(sorted_names)]
	return sum(name_and_position_tupels)

with open ("p22_names.txt") as name_file:
	name_list = name_file.read().split(',')def break_words(stuff) :
	""" This function will break up words for us. """
	words = stuff.split(' ')
	return words

def sort_words(words) :
	""" Sort the words """
	return sorted(words)

def print_first_word(words) :
	""" Prints the first word after popping it off. """
	word = words.pop(0)
	print(word)

def print_last_word(words) :
	word = words.pop(-1)
	print(word)

def sort_sentence(sentence) :
	""" Takes in a full sentence and returns the sorted words """
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)
import math
def findMedianSortedArrays(A, B):
    A.extend(B)
    A.sort()
    n = len(A)
    i1, i2 = int(math.floor((n-1)/2.0)), int(math.floor(n/2.0))
    return (A[i1] + A[i2]) / 2.0
def radix_sort(data, max_digit, digit=1):
  if digit > max_digit:
    return data
  else:
    sorted_list = []
    radix_list = [(i % 10**digit) // (10**(digit-1)) for i in data]
    for d in range(10):
      for i in range(len(data)):
        if radix_list[i] == d:
          sorted_list.append(data[i])
    return radix_sort(sorted_list, max_digit, digit=digit+1)

def sort(data):
  max_digit = max([len(str(i)) for i in data])
  return radix_sort(data, max_digit)



'''
DSU, , ,
 sort
'''

def case_insensitive_sort(string_list):
    auxliliary_list = [ (x.lower(), x) for x in string_list ]
    auxliliary_list.sort()
    return [ x[1] for x in auxliliary_list ]
def case_insensitive_sort_another(string_list):
    return sorted(string_list, key=str.lower)






def sort_by_attr(seq, attr):

    intermd = [ (gettart(x, attr), i, x) for i, x in enumerate(seq) ]
    intermd.sort()
    return [ x[-1] for x in intermd ]


import operator
def sort_by_attr_another(seq, attr):
    return sorted(seq, key = operator.attrgetter(attr))
def sort_by_attr_replace(lst, attr):
    lst[:] = sort_by_attr(lst, attr)


import re
def get_number(s):
    re_digit = re.compile(r'(\d+)')
    pieces = re_digit.split(s)
    pieces[1::2] = map(int, pieces[1::2])
    return pieces[1::2]
def sort_strings_with_numbers(alist):
    anx = [ (get_number(s), s) for s in alist ]
    anx.sort()
    return [ s for __, s in anx ]
def sort_strings_with_numbers_another(alist):
    return sorted(alist, key=get_number)
if __name__ == '__main__':
    alist = ['file1.txt', 'file3.txt', 'file11.txt', 'file21.txt']
    print sort_strings_with_numbers(alist)
    print ' '.join(sort_strings_with_numbers_another(alist))


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
__author__ = 'frank.ma'


class Sorting(object):

    def __init__(self,
                 lst: list):
        self.lst = lst
        self.lst_sorted = None

    def get_list(self):
        return self.lst

    def get_list_sorted(self):
        assert self.lst_sorted is not None, "input list is not sorted yet."
        return self.lst_sorted

    def __merge_sort_rec(self,
                         l: list):
        n = l.__len__()


        if n <= 1:
            return l

        def __merge(lt: list,
                    rt: list):
            merged = []
            while lt and rt:
                if lt[0] < rt[0]:
                    merged.append(lt.pop(0))
                else:
                    merged.append(rt.pop(0))
            merged.extend(lt)
            merged.extend(rt)
            return merged


        m = int(n / 2)

        left = self.__merge_sort_rec(l[:m])
        right = self.__merge_sort_rec(l[m:])

        return __merge(left, right)

    def merge_sort(self):
        self.lst_sorted = self.__merge_sort_rec(self.lst)def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
import random
import copy
from ryanSort import sorters


my_list = []


for i in range(0, 1000):
    my_list.append(random.randrange(0, 999))

def sorted(list_to_check):
    for i in range(1, len(list_to_check)):
        if list_to_check[i-1] > list_to_check[i]:
            return False
    return True

def test_bubble_sort():
    this_list = my_list.copy()
    sorters.bubble_sort(this_list)
    assert sorted(this_list)


def test_selection_sort():
    this_list = my_list.copy()
    sorters.selection_sort(this_list)
    assert sorted(this_list)

def test_insertion_sort():
    this_list = my_list.copy()
    sorters.insertion_sort(this_list)
    assert sorted(this_list)
__author__ = 'abdelrahman'

arr = []

def merge(a, b):
    c = []
    while a and b:
        if a[0] < b[0]:
            c += [a[0]]
            a = a[1: len(a)]
        else:
            c += [b[0]]
            b = b[1: len(b)]
    if a:
        c += a
    else:
        c += b
    return c


def merge_sort(arr):
    if len(arr) == 1:
        return [arr[0]]
    a1 = merge_sort(arr[0: len(arr)/2])
    a2 = merge_sort(arr[len(arr)/2:len(arr)])
    return merge(a1, a2)


with open('rosalind_ms.txt') as f:
    n = int(f.readline())
    arr = f.readline().split()
    arr = map(int, arr)

sorted_arr = merge_sort(arr)
sorted_arr = map(str, sorted_arr)
print(' '.join(sorted_arr))import sort
import unittest
import random

class SortTestFunctions(unittest.TestCase):
    def setUp(self):
        self.ranges = [
            [],
            [1],
            [3, 2, 5, 2, 3, 7, 4, 7],
            [1, 1, 1, 1],
            [1, 1, 1, 2],
            [2, 1, 1, 1],
            [1, 2, 1, 2],
            [4, 3, 2, 1],
            [i for i in random.sample(xrange(0, 1000000000), 1000)],
            [1 for i in xrange(0, 1000)],
            [1 if i < 900 else 2 for i in xrange(0, 1000)],
            [2 if i < 100 else 1 for i in xrange(0, 1000)],
            [i if 1 < 50 else 2 for i in xrange(0, 100)] * 10,
            [i for i in xrange(1000, 0, -1)]
        ]

    def _isSorted(self, sequence):
        prev = None
        for item in sequence:
            if item < prev:
                return False
            prev = item
        return True

    @staticmethod
    def compareTupples(a, b):
        if a[0] == b[0]:
            return 0
        return -1 if a[0] < b[0] else 1

    def _test_sort(self, sort_func_name, *args):
        sort_func = getattr(sort, sort_func_name)
        for range in self.ranges:
            sort_func(range, None, *args)
            self.assertTrue(self._isSorted(range))
        self.assertRaises(TypeError, sort_func, (1, 2, 3), None, *args)
        self.assertRaises(TypeError, sort_func, 'hello', None, *args)
        self.assertRaises(TypeError, sort_func, [1, 2, 3], 'some_func', *args)


        sorted_ranges = [
            [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5)],
            [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)],
        ]
        for sorted_range in sorted_ranges:
            sort_func(sorted_range, self.compareTupples, *args)
            for i in xrange(len(sorted_range)):
                self.assertTrue(i == sorted_range[i][1])

    def test_bubble_sort(self):
        self._test_sort('bubble_sort')

    def test_selection_sort(self):
        self._test_sort('selection_sort')

    def test_coctail_sort(self):
        self._test_sort('coctail_sort')

    def test_insertion_sort(self):
        self._test_sort('insertion_sort')

    def test_shell_sort(self):
        self._test_sort('shell_sort')

    def test_shell_sort_shell_gap(self):
        self._test_sort('shell_sort', 'shell')

    def test_shell_sort_cuira_gap(self):
        self._test_sort('shell_sort', 'cuira')

    def test_comb_sort(self):
        self._test_sort('comb_sort')

    def test_merge_sort(self):
        self._test_sort('merge_sort')

    def test__get_sorted_sequences(self):
        ranges = (
            [],
            [1],
            [3, 2, 5, 2, 3, 7, 4, 7],
            [1, 1, 1, 1],
            [1, 1, 1, 2],
            [2, 1, 1, 1],
            [1, 2, 1, 2],
            [4, 3, 2, 1]
        )
        results = (
            [],
            [(0, 0)],
            [(0, 0), (1, 2), (3, 5), (6, 7)],
            [(0, 3)],
            [(0, 3)],
            [(0, 0), (1, 3)],
            [(0, 1), (2, 3)],
            [(0, 0), (1, 1), (2, 2), (3, 3)]
        )
        for i in xrange(0, len(ranges)):
            result = []
            for seq in sort._get_sorted_sequences(ranges[i], sort.compare):
                result.append(seq)
            self.assertEqual(result, results[i])
            self.assertRaises(TypeError, lambda: sort._get_sorted_sequences('hello', sort.compare).next())

    def test__merge(self):
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 2), (4, 5), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 3), (4, 6), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (-1, 3), (4, 5), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [] * 6, (0, 0), (0, 0), sort.compare)
        self.assertRaises(ValueError, sort._merge, [0, 1, 2, 3, 4, 5], [], (0, 3), (4, 6), sort.compare)
        self.assertRaises(ValueError, sort._merge, [], [] * 6, (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, 'hello', [], (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], 'hello', (0, 3), (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], [], 'hello', (4, 6), sort.compare)
        self.assertRaises(TypeError, sort._merge, [], [], (0, 3), 'hello', sort.compare)
        self.assertRaises(TypeError, sort._merge, [0, 1], [None] * 2, (0, 0), (1, 1), 'hello')

        result = [None] * 7;
        sort._merge([0, 3, 4, 5, 1, 2, 6], result, (1, 3), (4, 5), sort.compare)
        self.assertEqual(result, [None, 1, 2, 3, 4, 5, None])

if __name__ == '__main__':
    unittest.main()
'''
Created on 2013-6-8

@author: Brilliant
'''
def combine2SortedLists(List1, List2):
    if len(List1)> 0 and len(List2)> 0:
        if List1[ 0]>List2[ 0]:
            return [List2[ 0]]+combine2SortedLists(List1, List2[ 1:])
        elif List1[ 0]<List2[ 0]:
            return [List1[ 0]]+combine2SortedLists(List1[ 1:], List2)
        else:
            return [List1[ 0], List2[ 0]]+combine2SortedLists(List1[ 1:], List2[ 1:])
    elif len(List2)== 0:
        return List1
    elif len(List1)== 0:
        return List2

def combineSort(List1):
    NewList1=[]
    for value in List1:
        NewList1.append([value])
    return do_combineSort(NewList1)

def do_combineSort(ListsOfList=[]):
    if len(ListsOfList) == 1:
        return ListsOfList[ 0]

    i = 1
    Result = []
    while i < len(ListsOfList):
        Result.append(combine2SortedLists(ListsOfList[i- 1], ListsOfList[i]))
        i+= 2
    if len(ListsOfList) % 2 == 1 :
        Result.append(ListsOfList[- 1])
    return do_combineSort(Result)

def merge2List(SortedList1 = [], SortedList2 = []):
    Result = []
    while True:
        if SortedList1 == []:
            return Result+SortedList2

        if SortedList2 == []:
            return Result+SortedList1

        v1 = SortedList1[0]
        v2 = SortedList2[0]
        if v1 > v2:
            Result.append(v2)
            SortedList2.pop(0)
        else:
            Result.append(v1)
            SortedList1.pop(0)

def mergeSort(unSortedList):
    if len(unSortedList) <= 1:
        return unSortedList

    Queue = []
    for v in unSortedList:
        Queue.append([v])

    while True:
        if len(Queue) == 1:
            return Queue[0]

        List1 = Queue.pop(0)
        List2 = Queue.pop(0)
        Queue.append(merge2List(List1, List2))

print( combine2SortedLists([1 ,2 ,3 ,4 ], [1 ,6 ,7 ,8 ]))
print( combineSort([6 ,5 ,4 ,3 ,2 ,1 ]))

print( merge2List([1 ,2 ,3 ,4 ], [1 ,6 ,7 ,8 ]))
print( mergeSort([6 ,5 ,4 ,3 ,2 ,1 ]))
Seq=range(1000,1,-2)+range(3000,4000)+range(2000,3000)
Seq.reverse()
print( mergeSort(Seq))
import timeit

num_inversions = 0
def split(number_array):
    array_length = len(number_array)
    first_half = number_array[0:array_length/2]
    second_half = number_array[array_length/2::]
    return first_half, second_half

def sort_and_count_inversions(number_array):
    array_length = len(number_array)
    if array_length == 1:
        return number_array, 0
    else:
        first_half, second_half = split(number_array)
        sorted_first_half, first_half_inversions = sort_and_count_inversions(first_half)
        sorted_second_half, second_half_inversions = sort_and_count_inversions(second_half)
        merged_array, merge_inversions = merge_and_count_split_inversions(sorted_first_half,
                sorted_second_half)
    return merged_array, first_half_inversions + second_half_inversions + merge_inversions

def merge_and_count_split_inversions(sorted_left_array, sorted_right_array):
    sorted_array = []
    split_inversions = 0
    while len(sorted_left_array) > 0 or len(sorted_right_array) > 0:
        if len(sorted_right_array) == 0:
            sorted_array.append(sorted_left_array.pop(0))
        elif len(sorted_left_array) == 0:
            sorted_array.append(sorted_right_array.pop(0))
        elif int(sorted_left_array[0]) < int(sorted_right_array[0]):
            sorted_array.append(sorted_left_array.pop(0))
        else:
            sorted_array.append(sorted_right_array.pop(0))
            split_inversions += len(sorted_left_array)
    return sorted_array, split_inversions


def brute_force(array):
    inversions = 0
    while len(array) > 0:
        first_item = array.pop(0)
        for item in array:
            if int(item) > int(first_item):
                inversions += 1
    return inversions

with open('IntegerList.txt') as f:
   large_array = f.readlines()
   sorted_array, inversions = sort_and_count_inversions(large_array)
   for item in sorted_array:
       print item
   print 'The





def selection_sort(sort_me):
	'''
	selection_sort(list) uses selection sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = selection_sort(my_list)
	'''
	ocount = 0
	while ocount < len(sort_me)-1:
		lpos = icount = ocount
		while icount < len(sort_me):
			if sort_me[icount] < sort_me[lpos]:
				lpos = icount
			icount += 1
		sort_me[lpos], sort_me[ocount] = sort_me[ocount], sort_me[lpos]
		ocount += 1
	return sort_me
def bubble_sort(A):
  swapped = True
  while swapped:
    swapped = False
    for i in range(1,len(A)):
      if A[i-1] > A[i]:
        A[i-1], A[i] = A[i], A[i-1]
        swapped = True
        print(A)
  return A


A = [4, 5, 2, 1, 3]
print(bubble_sort(A))''' BubbleSort Algorithm'''
def bubbleSort(seq):
    not_sorted = True
    n = len(seq)
    print "At the beginning: "
    print seq
    while not_sorted:

        not_sorted = False

        for i in range(n-1):
            if seq[i] <= seq[i+1]:
                continue;
            else:
                temp = seq[i]
                seq[i] = seq[i+1]
                seq[i+1] = temp

            not_sorted = True
            print seq
    return seq
bubbleSort([12, 5, 13, 8, 9, 65])
def insertion_sort(unsorted):
    u"""Return list sorted via insertion sort."""
    for i, val in enumerate(unsorted):
        while val < unsorted[i-1] and i > 0:
            unsorted[i] = unsorted[i-1]
            i -= 1
        unsorted[i] = val
    return unsorted


if __name__ == '__main__':
    from data_structures import time_func
    time_func(insertion_sort)

class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
def _sorted_keys(container, keys, reverse):
    ''' return list of 'keys' sorted by corresponding values in 'container' '''
    aux = [ (container[k], k) for k in keys ]
    aux.sort()
    if reverse: aux.reverse()
    return [k for v, k in aux]
import imfeat


class SortedHistogram(imfeat.Histogram):

    def __init__(self, *args, **kw):
        super(SortedHistogram, self).__init__(*args, **kw)

    def __call__(self, image):
        out = super(SortedHistogram, self).__call__(image)
        out.sort()
        return out

from __future__ import unicode_literals





import pytest
from structures.merge_sort import merge_sort


@pytest.fixture
def sorted_list():
    return [i for i in xrange(10)]


@pytest.fixture
def even_odd_split_list():
    return [x for x in xrange(0, 10, 2)] + [x for x in xrange(1, 10, 2)]


@pytest.fixture
def average_list():
    return [5, 9, 2, 4, 1, 6, 8, 7, 0, 3]


def test_sorted(sorted_list):
    assert merge_sort(sorted_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_worst(even_odd_split_list):
    assert merge_sort(even_odd_split_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_average(average_list):
    assert merge_sort(average_list) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_repeats():
    l = [3, 6, 7, 3, 9, 5, 2, 7]
    assert merge_sort(l) == [2, 3, 3, 5, 6, 7, 7, 9]


def test_multiple_types():
    l = [3, 'foo', 2.8, True, []]

    assert merge_sort(l) == [True, 2.8, 3, [], 'foo']

import sys

def readWords(argv):
  f = open(argv)
  str = f.read()
  f.close
  return str

def sortDictionary(dictionary):
  sorted_dictionary = [(v,k) for k,v in dictionary.items()]
  sorted_dictionary.sort()
  sorted_dictionary.reverse()
  return sorted_dictionary

def insertWords2Dictionary(str_list):
  dictionary = {}
  for word in str_list:
    dictionary[word] = dictionary.get(word, 0) + 1
  return dictionary

str = readWords(sys.argv[1])
str_list = str.split()
dictionary = insertWords2Dictionary(str_list)
sorted_dictionary = sortDictionary(dictionary)
print "All count is" ,len(str_list)
for count, word in sorted_dictionary[:20]:
    print count, word
__author__ = 'Aristide'

def main():
    list_to_sort = raw_input("Enter the numbers to sort, e.g: 53784298 : ")
    print sort(map(lambda char: int(char)), list(list_to_sort))


def sort(unsorted_list):
    """
    sort splits any list with more than one element in two parts, calls itself on the sublists,
    and calls merge with the returned sorted lists. When the parameter is an empty list or a
    single element list, sort just returns the list as the output.

    Doctests:
    Test empty list
        >>> sort([])
        []

    Test single element list
        >>> sort([3])
        [3]

    Test all even length sublists list
        >>> sort([9,3,6,7,5,4,3,2])
        [2, 3, 3, 4, 5, 6, 7, 9]

    Test odd length list
        >>> sort([9,3,6,8,7,5,4,3,2])
        [2, 3, 3, 4, 5, 6, 7, 8, 9]

    """
    output = []

    if len(unsorted_list) <= 1:
        output = unsorted_list
    else:


        left_sorted_list = sort(unsorted_list[0:(len(unsorted_list)/2)])
        right_sorted_list = sort(unsorted_list[(len(unsorted_list)/2):])

        output = merge(left_sorted_list, right_sorted_list)

    return output


def merge(left_sorted_list, right_sorted_list):
    """
    merge traverses each sorted list comparing the front elements. The smaller of the two is the next element in the
    sorted merged list
    """
    merged_sorted_list = [None] * (len(left_sorted_list) + len(right_sorted_list))

    iLeft = 0
    iRight= 0

    iMerged = 0

    while iMerged < len(merged_sorted_list):
        if iLeft == len(left_sorted_list):
            merged_sorted_list[iMerged:] = right_sorted_list[iRight:]
            iMerged = len(merged_sorted_list)
        elif iRight == len(right_sorted_list):
            merged_sorted_list[iMerged:] = left_sorted_list[iLeft:]
            iMerged = len(merged_sorted_list)
        elif left_sorted_list[iLeft] < right_sorted_list[iRight]:
            merged_sorted_list[iMerged] = left_sorted_list[iLeft]
            iLeft += 1
            iMerged += 1
        else:
            merged_sorted_list[iMerged] = right_sorted_list[iRight]
            iRight +=1
            iMerged += 1

    return merged_sorted_list


if __name__ == "__main__":

    import doctest
    doctest.testmod(verbose=True)
class MergeSort:

    def __init__(self):
        pass

    def mergeSort(self, argList):

        sortedList = []

        if len(argList) == 1:
            return argList

        mid = int(len(argList)/2)
        sortedLeftList = self.mergeSort(argList[:mid])
        sortedRightList = self.mergeSort(argList[mid:])

        leftIndex = 0
        rightIndex = 0
        listIndex = 0



        while leftIndex < len(sortedLeftList) and rightIndex < len(sortedRightList):
            if sortedLeftList[leftIndex] > sortedRightList[rightIndex]:
                sortedList += [sortedRightList[rightIndex]]
                rightIndex += 1
            else:
                sortedList += [sortedLeftList[leftIndex]]
                leftIndex += 1

        sortedList += sortedLeftList[leftIndex:]
        sortedList += sortedRightList[rightIndex:]

        return sortedList


if __name__ == "__main__":

    toBeSortedList = [5,3,8,2,1,9,7]
    sorter = MergeSort()
    myList = sorter.mergeSort(toBeSortedList)
    print myListdef keynat(string):
    r'''A natural sort helper function for sort() and sorted()
    without using regular expression.

    >>> items = ('Z', 'a', '10', '1', '9')
    >>> sorted(items)
    ['1', '10', '9', 'Z', 'a']
    >>> sorted(items, key=keynat)
    ['1', '9', '10', 'Z', 'a']
    '''
    r = []
    for c in string:
        try:
            c = int(c)
            try: r[-1] = r[-1] * 10 + c
            except: r.append(c)
        except:
            r.append(c)
    return r   def merge(a, b):
    '''function to merge 2 sorted list'''

    i ,j = 0, 0
    c = []
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1
    c += a[i:]
    c += b[j:]
    return c



















def merge_sort(seq):
    '''recursive function to merge and sort'''

    if len(seq) == 1:
        return seq
    else:
        mid = int(len(seq)/2)
        head = merge_sort(seq[:mid])
        end = merge_sort(seq[mid:])
        return merge(head, end)








def insenstiveSort(stringList):
    return sorted(stringList, key=str.lower)

def insenstiveSort(stringList):
    """ For both str and unicode"""
    return sorted(stringList, key=lambda x: x.lower())

print(insenstiveSort(['a', 'B', 'c']))
def break_words(stuff):
	''' doc comment duh ! '''
	return stuff.split()

def sort_words(words):
	return sorted(words)

def print_first_word(words):
	print words.pop(0)

def print_last_word(words):
	print words.pop(-1)

def sort_sentence(sentence):
	words = break_words(sentence)
	return sort_words(words)

def print_first_and_last(sentence):
	words = break_words(sentence)
	print_first(words)
	print_last(words)

def print_first_and_last_sorted(sentence):
	""" This is a pydoc comment """
	words = sort_sentence(sentence)
	print_first(words)
	print_last(words)
def break_words(stuff):
    """This function will break up words for us ."""

    words = stuff.split(' ')
    return words

def sort_words(words):
    """Sort the word."""
    return sorted(words)

def print_first_word(words):
    """Prints the first word after poping it off."""
    word = words.pop(0)
    print (word)

def print_last_word(words):
    """Print the last word after poping it off."""
    word = words.pop(-1)
    print (word)

def sort_sentence(sentence):
    """Take in a full sentence and returns the sorted words."""
    words = break_words(sentence)
    return sort_words(words)

def print_first_and_last(sentence):
    """print the first and last words of the sentence."""
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)

def print_first_and_last_sorted(sentence):
    """sort the words then prints the first and last one."""
    words=sort_sentence(sentence)
    print_first_word(words)
    print_last_word(words)
__author__ = 'luowen'








list1 = [1, 3, 4, 55, 2, 233, 21, 22]

def key(x):
    if x < 20:
        return True
    else:
        return False
resultSet = sorted(list1, key=key)
print(resultSet)

resultSet = sorted(list1)
print(resultSet)

resultSet = sorted(list1, reverse=True)
print(resultSet)

set1 = {"a", "x", "c", "d"}

resultSet = sorted(set1)
print(resultSet)







class Solution:

    def threeSum(self, arr):
        sorted_arr = sorted(arr)
        triplets = []
        result = []
        for i in range(len(sorted_arr)):
            for j in range(i + 1, len(sorted_arr)):
                for k in range(j + 1 , len(sorted_arr)):
                    if sorted_arr[i] + sorted_arr[j] + sorted_arr[k] == 0:
                        triplets.append([sorted_arr[i], sorted_arr[j], sorted_arr[k]])
        triplets.sort()
        for i in range(len(triplets)):
            if i == 0 or triplets[i] != triplets[i-1]:
                result.append(triplets[i])
        return result

solution = Solution()
print solution.threeSum([-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6])
def shell_sort(sort_me):
	'''
	shell_sort(list) uses shell sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = shell_sort(my_list)
	'''
	gaps = [23, 16, 9, 4, 3, 2, 1]
	for gap in gaps:
		i = gap
		while i < len(sort_me):
			temp, j = sort_me[i], i
			while j >= gap and sort_me[j-gap] > temp:
				sort_me[j] = sort_me[j - gap]
				j -= gap
			sort_me[j] = temp
			i += 1
	return sort_me
from django import template

register = template.Library()

@register.filter
def sort(values, arg):
    if arg:
        return sorted(values)
    else:
        return values
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
class Solution:



    def isAnagram(self, s, t):
        s_sort = ''.join(sorted(s))
        t_sort = ''.join(sorted(t))
        return True if s_sort == t_sort else False

def extsort(a):
	for i in a:
		return sorted(a,key=lambda x:x[i.find('.'):])
a=['a.c', 'a.py', 'b.py', 'bar.txt', 'foo.txt', 'x.c']
print extsort(a)
def sort_strings_with_embedded_numbers(alist):
    return sorted(alist, key=embedded_numbers)
from hypothesis import given
from hypothesis.strategies import lists, integers, builds

def pop_least(list1,list2):
    """return the smaller element from one of two ordered lists, and remove it
    """
    if list1[0] <= list2[0]:
        return list1.pop(0)
    return list2.pop(0)

def merge_sorted_lists(sorted_list_1, sorted_list_2):
    """merge two ascending lists"""
    retlist = []
    while sorted_list_1 and sorted_list_2:
        retlist.append(pop_least(sorted_list_1,sorted_list_2))
    retlist.extend(sorted_list_1 if sorted_list_1 else sorted_list_2)
    return retlist

def sort_list(l):
    l.sort()
    return l

@given(builds(sort_list,lists(integers())),builds(sort_list,lists(integers())))
def test_merge(l1,l2):
    merged = merge_sorted_lists(list(l1),list(l2))
    expected = list(l1)
    expected.extend(l2)
    expected.sort()
    assert merged == expected

if __name__ == '__main__':
    test_merge()
from Rnaseq import *

class sort_by_name(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k3 ${inputs[0]} > ${ID}.sorted.name
        '''
        return usage

    def output_list(self, *args):
        return ['${ID}.sorted.name']

import unittest

def merge_sort(array):
  if len(array) == 1:
    return array
  else:
    result = []
    first_sorted = merge_sort(array[:len(array)//2])
    second_sorted = merge_sort(array[len(array)//2:])
    while (len(first_sorted) and len(second_sorted)):
      result.append(first_sorted.pop(0)) if (first_sorted[0] <= second_sorted[0]) else result.append(second_sorted.pop(0))
    return result + first_sorted + second_sorted


def test(expected, actual):
    sort = merge_sort(actual)
    assert expected == sort
    print actual, "is sort as", sort

test([1], [1])
test([1, 2], [2, 1])
test([1, 2, 3], [2, 3, 1])
test([1, 2, 3, 4], [2, 3, 1, 4])
test([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 6, 2, 3, 5, 1, 7, 4, 9, 8])
test([1, 1, 1, 2, 3, 4, 6, 7, 8, 8, 10], [10, 6, 7, 8, 8, 1, 1, 2, 1, 3, 4])

if __name__ == '__main__':
  unittest.main()def is_sorted(a):
	a.sort()
	return a


print is_sorted([2,1,3])
def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist
class QuickSort:

    def quick_sort(self, array):
        if len(array) < 1:
            return array
        else:
            less, more, equal = [], [], []
            pivot = array[0]
            for i in array:
                if i < pivot:
                    less.append(i)
                elif i > pivot:
                    more.append(i)
                else:
                    equal.append(i)
            less_sorted = self.quick_sort(less)
            more_sorted = self.quick_sort(more)
            return less_sorted + equal + more_sorted

if __name__ == '__main__':
    qs = QuickSort()
    array = [4, 65, 2, -31, 0, 99, 83, 782, 1]
    print(qs.quick_sort(array))list_to_sort = ['representative','numeric','senile','effluent','ear','bespectacled','elegiac','ex-developer']

def count_e(s):
	return s.count('e')

sorted_list = sorted(list_to_sort,key=count_e)

for item in sorted_list[::-1]:
	print item + ' ' + str(count_e(item))
def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]

'''
Created on 2014114
@author: zhanghb
'''
import json
import urllib2
from DataConvert import DataManager
from copy import deepcopy
def TimeListSort(TimeList):
    Result=[]
    InputList=[]
    for item in TimeList:
        if item[-1]=='y':
            InputList.append((int(filter(str.isdigit,item)))*365)
        elif item[-1]=='m':
            InputList.append((int(filter(str.isdigit,item)))*30)
        elif item[-1]=='w':
            InputList.append((int(filter(str.isdigit,item)))*7)
        elif item[-1]=='d':
            InputList.append((int(filter(str.isdigit,item))))
        else:
            print "Input Format Error"
            break
    SortedList=deepcopy(InputList)
    Result.append(InputList)
    SortedList.sort()
    Result.append(SortedList)
    return Result

def div_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        if DaysFromNow<=SortedList[0]:
            CommitNum[UnSortedList.index(SortedList[0])]+=1
        else:
            for i in range(1,len(SortedList)):
                if (DaysFromNow>SortedList[i-1]) and (DaysFromNow<=SortedList[i]):
                    CommitNum[UnSortedList.index(SortedList[i])]+=1
                else:
                    pass
    return  CommitNum
def total_CommitSum(url,*TimeList):
    url_data = urllib2.urlopen(url).readline()
    json_r=json.loads(url_data)
    SortedList=[]
    UnSortedList=[]
    CommitNum=[]

    if not TimeList:
        UnSortedList=[30,90,180]
        SortedList=[30,90,180]
    else:
        temp=TimeListSort(TimeList)
        UnSortedList=temp[0]
        SortedList=temp[1]
    CommitNum=[0]*len(SortedList)
    for item in json_r:
        DaysFromNow=DataManager(item[u'commit'][u'committer'][u'date'])
        for i in range(0,len(SortedList)):
            if DaysFromNow<=SortedList[i]:
                CommitNum[UnSortedList.index(SortedList[i])]+=1
            else:
                pass
    return  CommitNum


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def insertion_sort(sort_me):
	'''
	insertion_sort(list) uses insertion sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = insertion_sort(my_list)
	'''
	ocount = 1
	while ocount < len(sort_me):
		icount = ocount - 1
		val = sort_me[ocount]
		while icount >= 0:
			if sort_me[icount] > val:
				sort_me[icount+1] = sort_me[icount]
			else:
				break
			icount -= 1
		sort_me[icount+1] = val
		ocount += 1
	return sort_me
__author__ = 'D'
'''
Intent: Define a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.
[Copied from GOF Site]

For this implementation I will create two sorting algorithms for different value types: least first and greatest first
I will then hand one of these to a SorterClass, whose data will be in string form and the sorting Algortihms
will be called uniformly.
'''

class SortingStrategy():
    def sort(self,listToSort):
        pass

class LeastFirstStrategy(SortingStrategy):
    def sort(self,listToSort):
        return sorted(listToSort)

class GreatestFirstStrategy(SortingStrategy):
    def sort(self,listToSort):
        return sorted(listToSort,reverse=True)


class SortUser():
    _itemsToSort = 1,3,2,5,0,4

    def __init__(self,sortingMethod):
        self.sortMethod = sortingMethod

    def returnSortedItems(self):
        return self.sortMethod.sort(self._itemsToSort)


def demonstrate():
    leastSort = SortUser(LeastFirstStrategy())
    greatSort = SortUser(GreatestFirstStrategy())

    print("Least Sort: ")
    print(leastSort.returnSortedItems())
    print("Great Sort: ")
    print(greatSort.returnSortedItems())

if __name__ == '__main__':
    demonstrate()from time import sleep
from threading import Thread

class SleepSort:
	def __init__(self, to_sort):
		self.list_to_sort = to_sort
		self.sorted_items = []

	def sleep_sort(self, arg):
		sleep(arg)
		self.sorted_items.append(arg)
	def sort(self):
		threads = []
		for i in self.list_to_sort:
			t = Thread(target=self.sleep_sort, args=(i,))
			t.start()
			threads.append(t)
		for a in threads:
			a.join()
		return list(self.sorted_items)
sort = SleepSort([1, 4, 3, 9, 11, 2])
print(sort.sort())from random import shuffle, randint


def bogo_sort(array):
    while array != sorted(array):
        shuffle(array)
    return array


if __name__ == '__main__':
    assert bogo_sort([2, 1]) == [1, 2]
    assert bogo_sort([15, 21, 16]) == [15, 16, 21]
    assert bogo_sort([47, 52, 51, 1]) == [1, 47, 51, 52]
    assert bogo_sort([47, 87, 51, 1, 2]) == [1, 2, 47, 51, 87]
    array = [randint(0, 100) for _ in range(10)]
    assert bogo_sort(array) == sorted(array)def case_insensitive_sort(string_list):
    return sorted(string_list, key=str.lower)
__author__ = 'tanchao@github'


def solution(A, B, C, D):
    F = [A, B, C, D]
    F.sort()

    return abs(F[1] - F[2]) + abs(F[2] - F[0]) + abs(F[0] - F[3])

if __name__ == '__main__':
    print solution(-1, 3, 5, 5)
def sorted_2_3(iterable):
    alist = list(iterable)
    alist.sort()
    return alist



def sortOnMedia(data):
    sortedData = sorted(data, key=lambda x: x.getMedia())
    return sortedData

def sortOnCompany(data):
    sortedData = sorted(data, key=lambda x: x.getCompany())
    return sortedData

def sortOnCategory(data):
    sortedData = sorted(data, key=lambda x: x.getCategory())
    return sortedData

def sortOnCategorySize(data):
    """
    Assume that the data input is a list sorted by category
    """
    categories = []
    for i in data:
        if len(categories) == 0:
            categories.append([i])
        else:
            if i.getCategory() == categories[-1][-1].getCategory():
                categories[-1].append(i)
            else:
                categories.append([i])

    sortedCategories = sorted(categories, key=lambda x: len(x), reverse=True)
    sortedData = []
    for category in sortedCategories:
        for i in category:
            sortedData.append(i)
    return sortedData

def sortInput(data):
    data = sortOnCompany(data)
    data = sortOnMedia(data)
    data = sortOnCategory(data)
    data = sortOnCategorySize(data)
    return data

__author__ = 'cman'

import unittest
from algorithms import merge_sort
from utils import assertions, data


def suite():
    return unittest.TestLoader().loadTestsFromTestCase(MergeSortTest)


class MergeSortTest(unittest.TestCase):

    def test_sort(self):
        test = data.random_ints(100)
        merge_sort.sort(test)
        self.assertTrue(assertions.is_sorted(test))


if __name__ == '__main__':
    unittest.main()
from random import randrange
import sorting

def populate_random_data():
	data_limit = randrange(25, 50)
	data = [randrange(0, 999) for i in xrange(data_limit)]
	return data

'''
	Test bubble sort
'''
def test_bubble_sort():
	data = populate_random_data()
	sorting.bubble_sort(data)

	assert sorted(data) == data


'''
	Test insertion sort
'''
def test_insertion_sort():
	data = populate_random_data()
	sorting.insertion_sort(data)

	assert sorted(data) == data

'''
	Test merge sort
'''
def test_merge_sort():
	data = populate_random_data()
	sorting.merge_sort(data)

	assert sorted(data) == data

'''
	Test selection sort
'''
def test_insertion_sort():
	data = populate_random_data()
	sorting.selection_sort(data)

	assert sorted(data) == dataimport random

def sort(array):

    print(array)
    print('using built in sort to check if array is sorted ')
    print(sorted(array))

    return array

def initArray(array):



    return array


def main():
    array = [0, 5, 1]
    print(array)
    array = initArray(array)
    print(array)
    array = sort(array)
    print(array)


main()
class Solution:



    def twoSum(self, nums, target):
        sort_num = sorted(nums)
        i = 0
        j = len(sort_num) - 1

        while i < j:
            diff = sort_num[i] + sort_num[j] - target
            if diff == 0:
                index1 = nums.index(sort_num[i])+1

                index2 = len(nums) - nums[::-1].index(sort_num[j])
                return sorted([index1, index2])
            elif diff < 0:
                i = i + 1
            else:
                j = j - 1

        return []
        '''
Created on Nov 10, 2015

@author: st.becker
'''
import math

class Scorer(object):
    '''
    classdocs
    '''


    def __init__(self):
        '''
        Constructor
        '''

    def sort(self, setToSort, board):
        def sortKey(word):
            weight = 0
            for value in range(10):
                weight += board.countOverlapForValue(value, word) * math.pow(10, -value)
            return weight

        return sorted(setToSort,key=sortKey,reverse=True)



def is_sorted(t):
	orig = t[:]
	t.sort()
	if t == orig:
		return True
	else:
		return False

t = [5,1,3,9]
print "Initial List : ",
print t

case = is_sorted(t)

if case == True:
	print "Yeah..!! That list is Sorted "
else:
	print "It's not sorted"


def cumulativeInsert(hash, item, val):
    if item in hash:
        hash[item] += val
    else:
        hash[item] = val
    return hash


def count2Ratio(hash):
    N = sum(hash.values())
    hash = dict([(item, float("%.3f"%(hash[item]*100.0/N))) for item in hash])
    return N, hash



def joint_with_sortedHash(sortedList, hash):
    tupleArr = []
    for item in sortedList:
        tuple = (item[0], item[1], hash[item[0]])
        tupleArr.append(tuple)

    return tupleArr


def sortHash(hash, sortField, reversedFlag):
    sortedList = sorted(hash.items(), key = lambda a:a[sortField], reverse=reversedFlag)
    return sortedList

def output_sortedHash(hash, sortField, reversedFlag):
    sortedList = sortHash(hash, sortField, reversedFlag)
    for item in sortedList:
        print item[0], "\t", item[1]

from listQfile import ListQ

class Sort(ListQ):
    def __init__(self, unsortedList):
        self.items = unsortedList
        self.sortedList = []
        self.magicSort()

    def __str__(self):
    	s = ''
    	for n in self.sortedList:
    		s = s + str(n) + ' '
    	return s


    def magicSort(self):
        while not self.isEmpty():
            self.put(self.get())
            self.sortedList.append(self.get())def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]
input = [1,5,3,7,6,2,9,3,5,6]
sorted = 0

def insSort(input, i, sorted):

    if sorted == len(input):
        return input

    elif input[i] >= input[i-1]:
        sorted += 1
        insSort(input, sorted, sorted)

    elif input[i] < input[i-1]:
        input[i], input[i-1] = input[i-1], input[i]

        insSort(input, i-1, sorted)


insSort(input, 1, 0)

print(input)
'''
Created on 2015-08-30
'''

class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        strs.sort()
        d, result = dict(), []
        for s in strs:

            sorted_s = ''.join(sorted(s))
            if sorted_s not in d:
                d[sorted_s] = [s]
                result.append(d[sorted_s])
            else:
                d[sorted_s].append(s)
        return result

if __name__ == '__main__':
    passdef comb_sort(sort_me):
	'''
	comb_sort(list) uses comb sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = comb_sort(my_list)
	'''
	gap = len(sort_me)

	while gap > 1 or swapped:
		gap = int(gap / 1.3)
		if gap < 1:
			gap = 1
		i = 0
		swapped = False
		while i + gap < len(sort_me):
			if sort_me[i] > sort_me[i+gap]:
				sort_me[i], sort_me[i+gap] = sort_me[i+gap], sort_me[i]
				swapped = True
			i += 1
	return sort_me
def sorted(data, key):
    mapping = {}
    for x in data:
        mapping[key(x)] = x
    keys = mapping.keys()
    keys.sort()
    return [mapping[x] for x in keys]
def sortedDictValues(adict):
    keys = adict.keys()
    keys.sort()
    return [adict[key] for key in keys]


def sortchar(W):
	L = list(W)
	L.sort()
	return ''.join(L)

if __name__ == "__main__":
	wordList = ['abcd','bacd','e','f','rt','tr','zzz','zz','dcab']
	map1 = {}
	output = []
	for w in wordList:
		sorted_w = ''.join(sorted(w))
		if sorted_w not in map1:
			map1[sorted_w] = [w]
		else:
			map1[sorted_w].append(w)
	for k in map1.keys():
		if len(map1[k])>1:
			output.append(map1[k])
	print output;


try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))


def ThirdGreatest(ary):

	myDict = {}



	for i in range(len(ary)):
		myDict[ary[i]] = i


	sortedByLength = sorted(myDict, key=len, reverse=True)



	if len(sortedByLength[1]) == len(sortedByLength[2]):

		if myDict[sortedByLength[1]] > myDict[sortedByLength[2]]:
			return sortedByLength[1]
		else:
			return sortedByLength[2]
	elif len(sortedByLength[2]) == len(sortedByLength[3]):
		if myDict[sortedByLength[2]] > myDict[sortedByLength[3]]:
			return sortedByLength[2]
		else:
			return sortedByLength[3]
	else:
		return sortedByLength[2]

def main():

	result = ThirdGreatest(["hello", "world", "after", "all"] )
	print result

if __name__ == "__main__":
  main()from tempfile import NamedTemporaryFile
import subprocess

def report_diff(correct_report_path, test_report_path):

    sorted_correct = NamedTemporaryFile()
    presort_correct = open(correct_report_path)
    for line in sorted(presort_correct):
        sorted_correct.file.write(line)
    sorted_correct.file.flush()


    sorted_test = NamedTemporaryFile()
    presort_test = open(test_report_path)
    for line in sorted(presort_test):
        sorted_test.file.write(line)
    sorted_test.file.flush()

    result = subprocess.Popen(["diff", "-b", sorted_correct.name, sorted_test.name],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result.wait()
    return "".join(result.stdout)def detect_anagrams(w, poss):
    return filter(lambda p: anagram(w, p), poss)


def anagram(w, p):
    return w.lower() != p.lower() and sort(w.lower()) == sort(p.lower())


def sort(word):
    return sorted(list(word.lower()))
f={'a':2,'d':5,'c':3,'b':8}
def sort(f):
	return[(f[i])for i in sorted(f.keys())]
print sort(f)








def Merge(A, B):
	S = []
	ai = 0
	bi = 0
	while len(A) > ai and len(B) > bi:
		if A[ai] <= B[bi]:
			x = A[ai]
			ai += 1
		else:
			x = B[bi]
			bi += 1
		S.append(x)
	return S + A[ai:] + B[bi:]

def MergeSort(L):
	if len(L) <= 1:
		return L
	else:
		half = int(len(L) / 2)
		A = L[:half]
		B = L[half:]
		return Merge(MergeSort(A), MergeSort(B))



def main():
	L = [2, 3, 5, 1, 7, 6, 8, 9, 10, 4]
	sorted_L = MergeSort(L)
	print "MergeSort: ", sorted_L

if __name__ == '__main__':
	main()
from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
def sort_goods_by_name(goods):
    return sorted(goods, key=lambda good: good.good_name)


def sort_goods_by_country(goods):
    return sorted(goods, key=lambda good: good.good_country)


def sort_goods_by_price(goods):
    return sorted(goods, key=lambda good: good.good_price)


def sort_goods_in_order_by_name(order):
    return sorted(order.goods, key=lambda good: good.good_name)


def sort_goods_in_order_by_price(order):
    return sorted(order.goods, key=lambda good: good.good_price)def sort_a_list(a):
    b = sorted(a, reverse=True)
    return(b)


def sort_by_mark(c):
    import operator
    d = sorted(c, key=operator.itemgetter(0), reverse=True)
    return(d)


def sort_by_name(e):
    import operator
    f = sorted(e, key=operator.itemgetter(1))
    return(f)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def break_words(stuff) :
	""" This function will break up words for us. """
	words = stuff.split(' ')
	return words

def sort_words(words) :
	""" Sort the words """
	return sorted(words)

def print_first_word(words) :
	""" Prints the first word after popping it off. """
	word = words.pop(0)
	print(word)

def print_last_word(words) :
	word = words.pop(-1)
	print(word)

def sort_sentence(sentence) :
	""" Takes in a full sentence and returns the sorted words """
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)

class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))


def wave(A):
    sorted_list = sorted(A)
    wave_list = []
    while len(sorted_list)>0:
    	if len(sorted_list)>1:
    		wave_list.append(sorted_list.pop(1))
    		wave_list.append(sorted_list.pop(0))
    	else:
    		wave_list.append(sorted_list.pop(0))
    return wave_list

print wave([1,2,3,4,5])import moka

def selection_sort(data):
	if len(data) < 2:
		return data

	min = data[0]
	for i in data:
		if i < min:
			min = i

	data.remove(min)
	sorted_data = selection_sort(data)
	sorted_data.insert(0, min)
	return data

def insertion_sort(data, sorted_data = None):
	if not sorted_data:
		sorted_data = []

	if len(data) == 0:
		return sorted_data

	first = data[0]
	rest = data[1:]

	if len(sorted_data) == 0:
		sorted_data.append(data[0])
		return insertion_sort(rest, sorted_data = [first])

	if first >= sorted_data[-1]:
		sorted_data.append(first)
		return insertion_sort(rest, sorted_data = sorted_data)

	for i in range(len(sorted_data) - 1, -1, -1):
			if first >= sorted_data[i]:
				sorted_data.insert(i + 1, first)
				return insertion_sort(rest, sorted_data = sorted_data)

	sorted_data.insert(0, first)

	return insertion_sort(rest, sorted_data = sorted_data)

def merge_sort(data):
	def merge_arrays(a, b, result = None):
		print a, b, result
		if not result:
			result = []

		if len(a) == 0 and  len(b) == 0:
			return result

		if len(a) > 0 and len(b) > 0:
			if a[0] < b[0]:
				result.append(a[0])
				return merge_arrays(a[1:], b, result)
			if a[0] > b[0]:
				result.append(b[0])
				return merge_arrays(a, b[1:], result)
			result.append(a[0])
			result.append(b[0])
			return merge_arrays(a[1:], b[1:], result)

		if len(a) > 0:
			result.extend(a)
			return result

		result.extend(b)
		return result

	if len(data) < 2:
		return data

	if len(data) == 2:
		if data[1] < data[0]:
			return [data[1], data[0]]
		return data

	mid_point = len(data) / 2

	return merge_arrays(merge_sort(data[0:mid_point]), merge_sort(data[mid_point: len(data)]))


sorts = [selection_sort, insertion_sort, merge_sort]

def insert(input, key):
    return [x for x in input if x <= key] + [key] + [x for x in input if x > key]

def insertSortRec(listToSort):
    if(len(listToSort) <= 1): return listToSort

    return insert(insertSortRec(listToSort[1:]), listToSort[0])

def insertSortIt(listToSort):
    sortedList = []
    for i in range(0,len(listToSort)):
        value = listToSort[i]
        sortedList = insert(sortedList, value)
    return sortedList

def insertSortInPlace(listToSort):
    for currentPos in range(1, len(listToSort)):
        currentValue = listToSort[currentPos]
        leftHandPos = currentPos-1
        while leftHandPos >= 0 and listToSort[leftHandPos] > currentValue:
            listToSort[leftHandPos + 1] = listToSort[leftHandPos]
            leftHandPos = leftHandPos -1
        listToSort[leftHandPos] = currentValue
    return listToSort


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
def break_words(stuff):
  return stuff.split(' ')

def sort_words(words):
  return sorted(words)

def print_first_word(words):
  print words.pop(0)

def print_last_word(words):
  print words.pop(-1)

def sort_sentence(sentence):
  words = break_words(sentence)
  return sort_words(words)

def print_first_and_last(sentence):
  words = break_words(sentence)
  print_first_word(words)
  print_last_word(words)

def print_first_and_last_sorted(sentence):
  words = sort_sentence(sentence)
  print_first_word(words)
  print_last_word(words)"""
Merge function for 2048 game.
"""

def merge(line):
    """
    Function that merges a single row or column in 2048.
    """
    non_zero_el = sort_line(line)[1]
    sorted_line = sort_line(line)[0]

    for index in range(non_zero_el - 1):
        if (sorted_line[index] == sorted_line[index + 1]) and (sorted_line[index]):
            sorted_line[index] = sorted_line[index] * 2
            sorted_line[index + 1] = 0
        else:
            sorted_line[index] = sorted_line[index]

    return sort_line(sorted_line)[0]


def sort_line(a_list):
    """
    Function that shifts all non-zero elements to the left
    """
    index = 0
    a_zerolist = [0] * len(a_list)
    for element in a_list:
        if element:
            a_zerolist[index] = element
            index += 1
    return a_zerolist, index

print merge([2, 2, 2, 2, 2])def anagram_check(strings):
	q=['orchestra','asian']
	li_sort = sorted(list(strings))
	for word in q:
		z = sorted(list(word))
		if z == li_sort:
			return word
print anagram_check('carthorse')
store = []

def sort_by_last_letter(strings):
    def last_letter(s):
        return s[-1]
    store.append(last_letter)
    print(last_letter)
    return sorted(strings, key=last_letter)def merge_sort(arr):

  if len(arr) > 1:
    middle = len(arr) / 2
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])
    return merge(left, right)
  else:
    return arr

def merge(left, right):
  sorted_arr = []

  while len(left) and len(right):
    if left[0] <= right[0]:
      sorted_arr.append(left[0])
      left = left[1:]
    else:
      sorted_arr.append(right[0])
      right = right[1:]

  if len(right):
    sorted_arr += right
  if len(left):
    sorted_arr += left
  return sorted_arr






__author__ = 'xujw'

def less(v,w):
	return v < w

def exch(a,i,j):
	t = a[i]
	a[i] = a[j]
	a[j] = t

def sort(a):
	for i in range(0,len(a)):

		min = i
		for j in range(i+1,len(a)):
			if less(a[j],a[min]):
				min = j
		exch(a,i,min)

def show(a):
	print(a)

def isSorted(a):
	for i in range(1,len(a)):
		if less(a[i],a[i-1]):
			return False
	return True

if __name__ == "__main__":
	a = [6,2,8,1,9]
	print isSorted(a)
	sort(a)
	show(a)
	print isSorted(a)





def insertionSort(a):
	for i in range(1,len(a)):
		j=i
		newValue=a[j]
		while j>0 and a[j-1]>newValue:
			a[j]=a[j-1]
			j-=1
		a[j]=newValue
	return a

def mergeSort(a):
	if len(a)==1:
		return a
	else:
		a1=mergeSort(a[:len(a)/2])
		a2=mergeSort(a[len(a)/2:])


		return merge(a1,a2)

def merge(a1,a2):
	idx1,idx2=0,0
	a_sorted=[]
	while idx1<len(a1) and idx2<len(a2):
		if a1[idx1]<a2[idx2]:
			a_sorted.append(a1[idx1])
			idx1+=1
		else:
			a_sorted.append(a2[idx2])
			idx2+=1
	if idx1<len(a1):
		a_sorted.extend(a1[idx1:])
	else:
		a_sorted.extend(a2[idx2:])

	return a_sorted

if __name__=="__main__":
	a=[9,8,7,6,5,4,3]
	print 'a',a
	aSort=insertionSort(a)
	print 'a insertSorted:',aSort
	b=[9,8,7,6,5,4,3,2]
	bMerge=mergeSort(b)
	print 'b:',b
	print 'b MergeSorted:',bMerge



	import random
def CosmicRaySort(n):
    while n != sorted(n):

    return n

n = []
for x in range(10):
    n.append(random.randint())
print CosmicRaySort(n)
numbers = [5, 2, 3, 1, 4]
print "numbers"
print sorted(numbers)

student_tuples = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),]

def sort_students(arg):
    return arg[2]

print "tuples"
print sorted(student_tuples, key=sort_students)


def list2dict(list):
    dict = {}
    for k in list: dict[k] = None
    return dict

def sorted_keys(dict):
    k = dict.keys()
    k.sort()
    return k
d = {3:'3', 1:'1', 2:'2', 0:'0'}
def sortedDictValues1(adict):
    items = adict.items()
    print items

    items.sort()
    return [value for key, value in items]

def sortedDictValues2(adict):
    keys = adict.keys()
    print keys
    keys.sort()
    return [dict[key] for key in keys]

def sortedDictValues3(adict):
    keys = adict.keys()
    keys.sort()
    return map(adict.get, keys)

if __name__ == '__main__':
    print sortedDictValues3(d)
a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))


"""
File: quicksort.py
Author: Hong-Wei Ng
Email: lightalchemist@gmail.com
Github: https://github.com/lightalchemist
Description: Recursive implementation of quicksort
to sort an array A in place.
"""

import random

def partition(A, p, begin, end):
    """Partition the subarray A[begin:end] about the pivot p
    where begin <= p < end
    and return the new index of the pivot in the A."""
    pivot = A[p]
    left = begin
    right = end - 2
    A[p], A[end-1] = A[end-1], A[p]

    while left < right:
        if A[left] <= pivot:
            left += 1
        else:
            A[left], A[right] = A[right], A[left]
            right -= 1




    if A[left] <= pivot:
        A[right + 1], A[end-1] = A[end-1], A[right + 1]
        return right + 1
    else:
        A[left], A[end-1] = A[end-1], A[left]
        return left


def pick_pivot(begin, end):
    """Return index of pivot which is a value in [begin, end)."""
    return random.randint(begin, end-1)


def quicksort_helper(A, begin, end):
    if end - begin <= 1:
        return A

    p = pick_pivot(begin, end)
    p = partition(A, p, begin, end)
    quicksort_helper(A, begin, p)
    quicksort_helper(A, p+1, end)


def sort(A):
    """"Recursive implementation of Quicksort
    to sort an array A in place."""
    quicksort_helper(A, 0, len(A))
    return A


def test():
    S = []
    S_sorted = sort(S)
    assert S_sorted == []

    S = [-1]
    S_sorted = sort(S)
    assert S_sorted == [-1]

    S = [-1, -3]
    S_sorted = sort(S)
    assert S_sorted == [-3, -1]

    S = [2, 2, -1, -1, 3, 10, 100]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = [2, 3, -1, 0, 5]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = range(20)
    random.shuffle(S)
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = range(20)
    random.shuffle(S)
    S = [s if random.randint(0, 1) else -s for s in S]
    S_sorted = sort(S)
    assert S_sorted == sorted(S)

    S = range(10)
    S_sorted = sort(S)
    assert S_sorted == sorted(S)


if __name__ == '__main__':
    test()
class Anagram:
    def __init__(self, test_word):
        self.word = test_word
        self.sorted_word = self._sort_word(test_word)

    def match(self, candidates):
        matches = []
        for candidate in candidates:
            if candidate == self.word:
                continue
            if self._sort_word(candidate) == self.sorted_word:
                matches.append(candidate)
        return matches

    def _sort_word(self, word):
        return sorted(list(word.lower()))


class ContentViewletManager(object):
    def sort(self, viewlets):
        return sorted(viewlets, lambda x, y: cmp(x[0], y[0]))
import operator
def sort_by_attr(seq, attr):
    return sorted(seq, key=operator.attrgetter(attr))
def sort_by_attr_inplace(lst, attr):
    lst.sort(key=operator.attrgetter(attr))
__author__ = 'Ronaldo'

import pandas as pd

class SortingStore:


    class LookupModes:
        EXACT_MATCH, EXACT_OR_GREATER = range(2)

    def __init__(self, dataframe):
        self.df = dataframe
        self.sorted_views = {}

    def set_sorted_view(self, sorted_view, key_column, ascending):
        self.df = sorted_view
        self.sorted_views = {key_column + `ascending`:sorted_view}

    def get_sorted_view(self, key_column, ascending):

        sorted_view = self.sorted_views.get(key_column + `ascending`)

        if not isinstance(sorted_view,pd.DataFrame):
            sorted_view = self.df.sort_index(by=[key_column], ascending=[0])
            self.sorted_views[key_column + `ascending`] = sorted_view

        return sorted_view


    def lookup(self, key_column, key_value, ascending=1, lookupMode = LookupModes.EXACT_MATCH):

        sorted_view = self.get_sorted_view(key_column, ascending)

        if lookupMode == self.LookupModes.EXACT_OR_GREATER:
            a = sorted_view[sorted_view[key_column]>=key_value]
            return a.irow(-1)



import unittest
import random
import HW3

N = 100
random_array = range(1, N)
random.shuffle(random_array)
sorted_array = sorted(random_array)

class TestSortMethods(unittest.TestCase):

  def setUp(self):
    return

  def test_mergeSort(self):
      self.assertEqual(HW3.mergeSort(random_array), sorted_array)

  def test_bubblesort(self):
      self.assertEqual(HW3.bubblesort(random_array), sorted_array)

  def test_quicksort(self):
      self.assertEqual(sorted(random_array), sorted_array)

if __name__ == '__main__':
    unittest.main()import urllib
import urllib2

from basesort import BaseSort


class HerokuSort(BaseSort):

    def exec_request(self):

        data = urllib.urlencode({'css': self.original})
        ua = 'Sublime Text 2 - CSScomb'
        req = urllib2.Request("http://csscomb.herokuapp.com/sort.php", data, headers={'User-Agent': ua})
        file = urllib2.urlopen(req, timeout=10)

        sorted_css = file.read()

        if len(sorted_css) > 0:
            return sorted_css
        else:
            return None
try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
def insertionsort(L):
	return calInsertionsort(L, 0)

def calInsertionsort(L, sortedIdx):
	if sortedIdx + 1 == len(L):
		return L

	sortData = L[sortedIdx+1]

	for idx in xrange(0, sortedIdx + 1):
		if sortData < L[idx]:
			del L[sortedIdx+1]
			L.insert(idx, sortData)
			break

	return calInsertionsort(L, sortedIdx+1)""" Say you have an array for which the ith element is the price of a given stock on day i."""
""" If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit."""

def maxProfit(prices):

	max_profit = get_maxProfit(prices)
	return max_profit


def get_maxProfit(prices):
	min_so_far = float("inf")
	max_profit_so_far = 0
	for price in prices:
		if (price - min_so_far) > max_profit_so_far:
			max_profit_so_far = (price - min_so_far)
		if price < min_so_far:
			min_so_far = price
	return max_profit_so_far


def adjusted_merge_sort(prices):
	length = len(prices)
	if length == 1:
		return prices, 0
	middle_idx = length/2
	first_part, second_part = prices[:middle_idx], prices[middle_idx:]
	first_sorted, first_max_profit = adjusted_merge_sort(first_part)
	second_sorted, second_max_profit = adjusted_merge_sort(second_part)
	max_profit = second_sorted[-1] - first_sorted[0]
	if max_profit < first_max_profit:
		max_profit = first_max_profit
	if max_profit < second_max_profit:
		max_profit = second_max_profit
	new_sorted = []
	i, j = 0, 0
	while i<len(first_sorted) and j<len(second_sorted):
		if first_sorted[i] < second_sorted[j]:
			new_sorted.append(first_sorted[i])
			i += 1
		else:
			new_sorted.append(second_sorted[j])
			j += 1
	while i < len(first_sorted):
		new_sorted.append(first_sorted[i])
		i += 1
	while j < len(second_sorted):
		new_sorted.append(second_sorted[j])
		j += 1
	return new_sorted, max_profit

if __name__ == '__main__':
	prices = [4, 5, 2, 10, 1, 3]
	print maxProfit(prices)
def detect_anagrams(word, word_list):
    sort = sorted(word.lower())
    return [w for w in word_list if sorted(w.lower()) == sort and w.lower() != word.lower()]


from lixian_plugins.api import task_filter

@task_filter(protocol='sort', batch=True)
def sort_by_name(keyword, tasks):
	'''
	Example:
	lx list sort:
	lx download 0/sort:/[0-1]
	'''
	return sorted(tasks, key=lambda x: x['name'])
from heap import Heap

def insertion_sort(array):
	"""
	Standard insertion sort alogrithm

	Arguments:
		array - array of numbers

	Returns:
		array - array sorted in increasing order
	"""

	for i in range(1, len(array)):
		j = i - 1
		while j >= 0 and array[j] > array[i]:
			array[i], array[j] = array[j], array[i]
			i = j
			j-=1

	return array

def selection_sort(array):
	"""
	Standard selection sort algorithm.

	Arguments:
		array - array of numbers

	Returns:
		array - array sorted in increasing order
	"""

	for i in range(0, len(array)-1):

		min_index = None

		for j in range(i, len(array)):

			if not min_index:
				min_index = j
			else:
				if array[j] < array[min_index]:
					min_index = j
		array[i], array[min_index] = array[min_index], array[i]

	return array

def merge(array1, array2):
	"""
	Take two sorted arrays and merge them in sorted order.

	Arguments:
		array1 - first array to be sorted
		array2 - second array to be sorted

	Returns:
		sorted_array - merged arrays in sorted manner
	"""

	sorted_array = []
	while array1 and array2:
		if array1[0] < array2[0]:
			sorted_array.append(array1.pop(0))
		else:
			sorted_array.append(array2.pop(0))

	if not array1:
		sorted_array.extend(array2)
	elif not array2:
		sorted_array.extend(array1)

	return sorted_array

def merge_sort(array):
	"""
	Merge sort a given array in ascending order

	Arguments:
		array - potentially unsorted array

	Returns:
		sorted_array - sorted array in ascending order
	"""
	if len(array) == 1 or not array:
		return array

	else:
		sorted_array = merge(merge_sort(array[0:len(array)/2]), merge_sort(array[len(array)/2:]))

	return sorted_array

def quick_sort(array, start=0, end=None):
	"""
	Perform a quick sort in place

	Arguments:
		array - array to be sorted
		start - starting index of array to be sorted
		end - end index of array to be sorted

	Returns:
		array - sorted array
	"""

	if not array:
		return

	if not end:
		end = len(array)-1

	pivot = end
	curr_index = start

	while curr_index != pivot:
		if array[curr_index] > array[pivot]:
			array[curr_index], array[pivot-1] = array[pivot-1], array[curr_index]
			array[pivot-1], array[pivot] = array[pivot], array[pivot-1]
			curr_index = start
			pivot-=1
		else:
			curr_index+=1

	if pivot - start > 1:
		quick_sort(array, start, pivot-1)
	if pivot < end-2:
		quick_sort(array, pivot + 1, end)

	return array

def heap_sort(array):
	"""
	Performs a heap sort

	Arguments:
		array - array of integers to be sorted

	Returns:
		array - sorted array
	"""

	sorted_array = []
	array_heap = Heap(array)

	while array_heap.size > 0:
		sorted_array.append(array_heap.remove())

	return sorted_arrayimport collections


class School(object):

    def __init__(self, school_name):
        self.school_name = school_name
        self.db = collections.defaultdict(set)

    def __str__(self):
        return self.school_name

    def add(self, student, grade):
        self.db[grade].add(student)

    def grade(self, grade_number):
        return self.db[grade_number]

    def sort(self):
        grades = sorted([key for key in self.db])
        sorted_list = [(grade, tuple(sorted([name for name in self.db[grade]]))) for grade in grades]
        return sorted_listtry:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
def bubble_sort(list):
    sorted_list = list[:]

    for i in range(0, len(sorted_list)):
        for j in range(0, len(sorted_list) - 1):
            if sorted_list[j] > sorted_list[j + 1]:
                temp = sorted_list[j]
                sorted_list[j] = sorted_list[j + 1]
                sorted_list[j + 1] = temp

    return sorted_list
"""
diteur de Spyder

Ceci est un script temporaire.
"""

from operator import itemgetter


def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(my_class):
    return sorted(my_class, reverse=True)


def sort_by_name(my_class):
    return sorted(my_class, key=itemgetter(1))

import random

def exercise_sort(sort, gen=random.random):
    """Run some tests on the sorting function, sort"""
    for n in [0, 1, 100, 1000, 10000]:
        a = [gen() for _ in range(n)]
        b = a[:]

        c = sort(b)
        if c is None: c = b
        assert(sorted(a) == list(c))


import unittest
from random import randrange
from sorting import *

TEST_TIMES = 10
ARRAY_LENGTH = 10


def create_random_list():
    return [randrange(-10, 10) for i in range(ARRAY_LENGTH)]


def sort(unsorted_list):
    return unsorted_list.sort()


class TestCase(unittest.TestCase):
    def setUp(self):
        self.lists = [create_random_list() for i in range(TEST_TIMES)]

    def test_bubble_sort(self):
        for lis in self.lists:
            li = lis
            assert bubble_sort(li) == sorted(lis)

    def test_insert_sort(self):
        for lis in self.lists:
            li = lis
            assert insert_sort(li) == sorted(lis)

    def test_select_sort(self):
        for lis in self.lists:
            li = lis
            assert select_sort(li) == sorted(lis)

    def test_quick_sort(self):
        for lis in self.lists:
            li = lis
            quick_sort(li, 0, ARRAY_LENGTH-1)
            assert li == sorted(lis)


if __name__ == '__main__':
    unittest.main()def sort_fractions(fractions):
	return sorted(fractions, key = lambda x: x[0]/x[1])
import numpy as np

def argSort(seq):
    return sorted(range(len(seq)), key=seq.__getitem__)

def block(im, p, r = 7):
    return im[p[1]-r:p[1]+r,p[0]-r:p[0]+r,:]

def cond(arr, c):
  return arr[c.argsort()[len(c)-sum(c):]]
def merge(list1, list2):
  i = 0
  j = 0
  output = []
  len1 = len(list1)
  len2 = len(list2)
  while i < len1 or j < len2:
    if i < len1 and j < len2:
      if list1[i] < list2[j]:
        output += [list1[i]]
        i = i+1
      else:
        output += [list2[j]]
        j = j+1
    elif i < len1:
      output += [list1[i]]
      i = i+1
    elif j < len2:
      output += [list2[j]]
      j = j+1
  return output


def merge_sort(list):
  length = len(list)
  if length <= 1:
    return list
  else:
    mid = length/2
    left = list[0:mid]
    right = list[mid:]
    sorted_left = merge_sort(left)
    sorted_right = merge_sort(right)
    return merge(sorted_left, sorted_right)

def get_input():
	a=[]
	while(1):
	  x = int(raw_input())
	  if(x==-1):
	     break
	  a.append(x)
        return a

def display_result(sorted_nums):
	print sorted_nums


if __name__ == '__main__':

	print "enter the numbers to be sorted and -1 to exit "
	nums = get_input()

	sorted_nums = merge_sort(nums)

	print "sorted numbers: "
	display_result(sorted_nums)
import sys

def readWords(argv):
  f = open(argv)
  str = f.read()
  f.close
  return str

def sortDictionary(dictionary):
  sorted_dictionary = [(v,k) for k,v in dictionary.items()]
  sorted_dictionary.sort()
  sorted_dictionary.reverse()
  return sorted_dictionary

def insertWords2Dictionary(str_list):
  dictionary = {}
  for word in str_list:
    dictionary[word] = dictionary.get(word, 0) + 1
  return dictionary

str = readWords(sys.argv[1])
str_list = str.split()
dictionary = insertWords2Dictionary(str_list)
sorted_dictionary = sortDictionary(dictionary)
print "All count is" ,len(str_list)
for count, word in sorted_dictionary[:20]:
    print count, word
def slaveSort(seq):
    '''
    Given a sequence of sequences, sort all according to the
    sort order of the first sequence.
    '''
    z = list(zip(*seq))
    z.sort()
    return zip(*z)


if __name__ == '__main__':
    lists = (('cat', 'bat', 'rat'),(1,2,3),(4,5,6))
    sortedLists = slaveSort(lists)
    for l in sortedLists:
        print(l)def sort_a_list(l):
   x = sorted
   return x(l, reverse=True)
from operator import attrgetter, itemgetter
getcount = itemgetter(0)
def sort_by_mark(my_class):
    i = sorted
    return i(my_class,  key=getcount, reverse=True)
getcounts = itemgetter(1)
def sort_by_name(my_class):
    i = sorted
    return i(my_class,  key=getcounts)
def sort_a_list(l):
    return sorted(l, reverse=True)


def sort_by_mark(my_class):
    return sorted(my_class, reverse=True)


from operator import itemgetter


def sort_by_name(my_class):
    return sorted(my_class, key=itemgetter(1))
from Rnaseq import *

class sort_by_sample(Step):
    def __init__(self,**kwargs):
        Step.__init__(self,**kwargs)

    def usage(self,context):
        usage='''
sort -k5,6 ${inputs[0]} > ${ID}.sorted.sample
        '''
        return usage

    def output_list(self,*args):
        return ['${ID}.sorted.sample']



""" sort the count of words and display top 3 along with count"""

import sys


def getSortedCounts(wordCountFileName, separator):
    sortedCounts = []
    with open(wordCountFileName, 'r') as wordCountFile:
        for line in wordCountFile:

            line = line.strip()
            word, count = line.split(separator, 1)
            try:
                sortedCounts.append((word, int(count)))
            except ValueError:

                pass
    sortedCounts = sorted(sortedCounts, key = lambda wCount: wCount[1])
    return sortedCounts





def main():
    if len(sys.argv) >= 2:
        wordCountFileName = sys.argv[1]
        sortedCounts = getSortedCounts(wordCountFileName, '\t')

        print sortedCounts[0][0], '\t', sortedCounts[0][1]
        print sortedCounts[1][0], '\t', sortedCounts[1][1]
        print sortedCounts[2][0], '\t', sortedCounts[2][1]
    else:
        print 'Err: word count file should be passed'

if __name__ == '__main__':
    main()


def sort_last(x):
    return sorted(x, key=lambda x:x[-1])

print sort_last([[1, 3], [3, 2], [2, 1]])
print sort_last([[2, 3], [1, 2], [3, 1]])
print sort_last([[1, 7], [1, 3], [3, 4, 5], [2, 2]])
def process_item(self, item, spider):
    return sorted(item['body'])
from heap import Heap

def insertion_sort(array):
	"""
	Standard insertion sort alogrithm

	Arguments:
		array - array of numbers

	Returns:
		array - array sorted in increasing order
	"""

	for i in range(1, len(array)):
		j = i - 1
		while j >= 0 and array[j] > array[i]:
			array[i], array[j] = array[j], array[i]
			i = j
			j-=1

	return array

def selection_sort(array):
	"""
	Standard selection sort algorithm.

	Arguments:
		array - array of numbers

	Returns:
		array - array sorted in increasing order
	"""

	for i in range(0, len(array)-1):

		min_index = None

		for j in range(i, len(array)):

			if not min_index:
				min_index = j
			else:
				if array[j] < array[min_index]:
					min_index = j
		array[i], array[min_index] = array[min_index], array[i]

	return array

def merge(array1, array2):
	"""
	Take two sorted arrays and merge them in sorted order.

	Arguments:
		array1 - first array to be sorted
		array2 - second array to be sorted

	Returns:
		sorted_array - merged arrays in sorted manner
	"""

	sorted_array = []
	while array1 and array2:
		if array1[0] < array2[0]:
			sorted_array.append(array1.pop(0))
		else:
			sorted_array.append(array2.pop(0))

	if not array1:
		sorted_array.extend(array2)
	elif not array2:
		sorted_array.extend(array1)

	return sorted_array

def merge_sort(array):
	"""
	Merge sort a given array in ascending order

	Arguments:
		array - potentially unsorted array

	Returns:
		sorted_array - sorted array in ascending order
	"""
	if len(array) == 1 or not array:
		return array

	else:
		sorted_array = merge(merge_sort(array[0:len(array)/2]), merge_sort(array[len(array)/2:]))

	return sorted_array

def quick_sort(array, start=0, end=None):
	"""
	Perform a quick sort in place

	Arguments:
		array - array to be sorted
		start - starting index of array to be sorted
		end - end index of array to be sorted

	Returns:
		array - sorted array
	"""

	if not array:
		return

	if not end:
		end = len(array)-1

	pivot = end
	curr_index = start

	while curr_index != pivot:
		if array[curr_index] > array[pivot]:
			array[curr_index], array[pivot-1] = array[pivot-1], array[curr_index]
			array[pivot-1], array[pivot] = array[pivot], array[pivot-1]
			curr_index = start
			pivot-=1
		else:
			curr_index+=1

	if pivot - start > 1:
		quick_sort(array, start, pivot-1)
	if pivot < end-2:
		quick_sort(array, pivot + 1, end)

	return array

def heap_sort(array):
	"""
	Performs a heap sort

	Arguments:
		array - array of integers to be sorted

	Returns:
		array - sorted array
	"""

	sorted_array = []
	array_heap = Heap(array)

	while array_heap.size > 0:
		sorted_array.append(array_heap.remove())

	return sorted_arrayimport unittest

def counting_sort(list_to_sort, max):
    possition = [ 0 for i in range(max + 2)]

    for e in list_to_sort:
        possition[e] += 1

    sum = 0
    for i in range(max + 2):
        temp = possition[i]
        possition[i] = sum
        sum += temp

    sorted_list = [0]*len(list_to_sort)
    for i in range(len(sorted_list)):
        sorted_list[possition[list_to_sort[i]]] = list_to_sort[i]
        possition[list_to_sort[i]] += 1

    return sorted_list

class Test_counting_sort(unittest.TestCase):
    def test_sort_empty(self):
        self.assertEqual(counting_sort([],0),[])

    def test_sort_one_element(self):
        self.assertEqual(counting_sort([1],1),[1])

    def test_sort_two_sorted_elements(self):
        self.assertEqual(counting_sort([1,2],2),[1,2])

    def test_sort_two_unsorted_elements(self):
        self.assertEqual(counting_sort([2,1],2),[1,2])

    def test_sort_three_unsorted_elements(self):
        self.assertEqual(counting_sort([2,1,3],3),[1,2,3])

    def test_sort_three_reverse_elements(self):
        self.assertEqual(counting_sort([3,2,1],3),[1,2,3])

    def test_sort_random_numbers(self):
        import random

        random_list = [random.randint(0,100) for i in range(1000)]
        sorted_list = counting_sort(random_list[:],100)

        random_list.sort()
        self.assertEqual(sorted_list,random_list)

    def test_sort_5_elements(self):
        self.assertEqual(counting_sort([4,3,1,2,3],4),[1,2,3,3,4])

if __name__ == "__main__":
    unittest.main()def sort(arr):
    return sorted(arr)
    return sorted(l, reverse=True)


from operator import itemgetter


def sort_by_mark(my_class):
    return sorted(my_class, key=itemgetter(0), reverse=True)

from operator import itemgetter


def sort_by_name(my_class):
    return sorted(my_class, key=itemgetter(1))
def sortStringsToAnagram(strings):
  sortedDict = {}
  for strng in strings:
    key = ''.join(sorted(strng))
    print key
    if key in sortedDict:
      sortedDict[key].append(strng)
    else:
      sortedDict[key] = [strng]
  out = []
  for key in sortedDict:
    for strng in sortedDict[key]:
      out.append(strng)
  return out

def main():
  test = ["god", "a","abc","c","bac","dog"]
  out = sortStringsToAnagram(test)
  print out

main()
def is_sorted(a):
	a.sort()
	return a


print is_sorted([2,1,3])




from collections import OrderedDict
import operator


def sort_constituencies_by_party_popularity(constituencies, party):
    sorted_constituencies = OrderedDict(sorted(constituencies.iteritems(),
                                               key=lambda x: x[1][party]))
    sorted_constituencies = reversed(sorted_constituencies)
    return sorted_constituencies


def sort_parties_by_seats(party_seats):
    sorted_seats = sorted(party_seats.items(),
                          key=operator.itemgetter(1),
                          reverse=True)
    return sorted_seats


def allocate_seats(constit, party_seats):
    """
    For the given dict of constituencies and the votes per party they have,
    and the given dictionary of seats per party, allocate an MP/seat to each
    constituency on a first-come-first-served basis, ranked by popularity.
    """
    constituencies = dict(constit)
    constituency_seats = {}
    for constituency, _ in constituencies.items():
        constituency_seats[constituency] = ''
    sorted_seats = sort_parties_by_seats(party_seats)
    for party, seats in sorted_seats:
        allocated = 0
        sorted_constituencies = sort_constituencies_by_party_popularity(
            constituencies, party)
        for constituency in sorted_constituencies:
            if allocated == seats:
                break
            constituency_seats[constituency] = party
            constituencies.pop(constituency)
            allocated += 1
    return constituency_seats
def break_words(stuff) :
	""" This function will break up words for us. """
	words = stuff.split(' ')
	return words

def sort_words(words) :
	""" Sort the words """
	return sorted(words)

def print_first_word(words) :
	""" Prints the first word after popping it off. """
	word = words.pop(0)
	print(word)

def print_last_word(words) :
	word = words.pop(-1)
	print(word)

def sort_sentence(sentence) :
	""" Takes in a full sentence and returns the sorted words """
	words = break_words(sentence)
	print_first_word(words)
	print_last_word(words)


def sort(list):
    """Return a sorted list. You can't use python sort method"""

    print("Develop me, please! I'm begging.")

if __name__ == '__main__':
    sort([13, 2, 1, 0])try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))
def comparator(a, b):
    if a[0] / float(a[1]) > b[0] / float(b[1]):
        return 1
    elif a[0] / float(a[1]) == b[0] / float(b[1]):
        return 0
    return -1


def sort_fractions(fractions):
    return sorted(fractions, comparator)

print (sort_fractions([(2, 3), (1, 2)]))
print (sort_fractions([(2, 3), (1, 2), (1,3)]))
from random import Random

class BogoSort(object):
	def sort(self, list):
		while not self.isSorted(list):
			self.shuffle(list)
		return list

	def isSorted(self, list):
		return sorted(list) == list

	def shuffle(self, list):
		Random().shuffle(list)
		return list





def selection_sort(arr):

	unsorted_sz = len(arr)
	i = 0


	while i < unsorted_sz:

		lowest = i
		j = i + 1

		while j < unsorted_sz:
			if arr[j] < arr[lowest]:
				lowest = j
			j = j + 1


		tmp = arr[lowest]
		arr[lowest] = arr[i]
		arr[i] = tmp

		i = i + 1
	return


t1 = range(1, 11)
t1.reverse()
t1_sorted = t1[:]
t1_sorted.sort()
selection_sort(t1)
if t1 == t1_sorted:
	print "success"
else:
	print "sort failed"


t2 = range(1, 1001)
t2.reverse()
t2_sorted = t2[:]
t2_sorted.sort()
selection_sort(t2)
if t2 == t2_sorted:
	print "success"
else:
	print "sort failed"



try:


    [].sort(key=lambda: None)

    def sorted(iterable, cmp=None, key=None, reverse=False):
        l = list(iterable)
        l.sort(cmp=cmp, key=key, reverse=reverse)
        return l

except TypeError:


    def sorted(iterable, key=None, reverse=False):
        l = list(iterable)
        if key:
            l = [(key(i), i) for i in l]
        l.sort()
        if key:
            l = [i[1] for i in l]
        if reverse:
            l.reverse()
        return l
__author__ = 'cenk'










































def maximumGap(A):
    if len(A) == 1:
        return 0
    B = []
    for index,i in enumerate(A):
        B.append((i,index))

    B = sorted(B,key=lambda tup: tup[0])

    indexes = [i[1] for i in B]

    ans = 0
    maxIndex =  indexes[len(indexes) -1]

    for i in range(0,len(indexes))[::-1]:

        ans = max(ans,maxIndex - indexes[i])
        maxIndex = max(maxIndex, indexes[i])

    return ans

print maximumGap([ 2,3,5,1,6 ])












def main():
	a = [1, 20, 55,10,15]
	b = []
	b = middle(a)
	print 'Old : ', a
	print 'New :', b
	c =[]
	a.sort()
	print 'Old Sorted : ',a
	print 'New Sorted : ',middle(a)

def middle(a):
	b = []
	b = a[1:4]
	return b

if __name__=='__main__':
	main()

"""Write a method to sort an array of strings so that all the anagrams
are next to each other"""


def anagram_sort(words):
    return sorted(words,  key=lambda x: sorted(x))


def test_anagram_sort():
    words = ['tabu', 'ate',  'beta', 'bade', 'tuba', 'abet',
             'tea', 'abut', 'bead', 'abed', 'beat', 'eat']
    print words
    print anagram_sort(words)


def main():
    test_anagram_sort()


if __name__ == '__main__':
    main()
def breakWords(stuff):
	return stuff.split(' ')

def sortWords(words):
	return sorted(words)

def printFirstWord(words):
	print words.pop(0)

def printLastWord(words):
 	return words.pop(-1)

def sortSentence(sentence):
	return sortWords(breakWords(sentence))

def printFirstAndLast(sentence):
	words = breakWords(sentence)
	printFirstWord(words)
	printLastWord(words)

def printFirstAndLastSorted(sentence):
	words = sortSentence(sentence)
	printFirstWord(words)
	printLastWord(words)from create_list import random_list, is_sorted


def bubble_sort(my_list):
    """
    Perform bubble sort on my_list.
    """
    while not is_sorted(my_list):
        for i in range(len(my_list) - 1):
            if my_list[i] > my_list[i + 1]:
                my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
    return my_list

my_list = random_list(50)
print(my_list)
print(is_sorted(my_list))

sorted_list = bubble_sort(my_list)
print(sorted_list)
print(is_sorted(sorted_list))
import math
import random

l = []
for i in range(0,2 ** 24):
    l.append(i)

random.shuffle(l)

print "sort start"

def sort(l):
    if len(l) == 1 or len(l) == 0:
        return l
    pivot = random.choice(l)
    less = []
    more = []
    for i in l:
        if i < pivot:
            less.append(i)
        else:
            more.append(i)
    print abs(len(more) - len(less))
    return sort(less) + sort(more)

def abs(n):
    return max(n, -n)

def isSorted(l):
    prev = l[0];
    for i in l:
        if i < prev:
            return False
        else:
            prev = i
    return True

l2 = sort(l)
print "sort done"

print isSorted(l2)

import sys, random;

def merge_min_sort_rec(list, depth):
	if (len(list) <= 1):
		return list;
	print ' '*depth, "sorting list len", len(list);

	divpt = len(list)/2;
	listx = list[0:divpt];
	listy = list[divpt:len(list)];
	sorted_lx = merge_min_sort_rec(listx, depth+1);
	sorted_ly = merge_min_sort_rec(listy, depth+1);
	sorted = [];
	x = 0;
	y = 0;
	while ((x < len(sorted_lx)) and \
	(y < len(sorted_ly))):
		if (sorted_lx[x][1] < sorted_ly[y][1]):
			sorted.append(sorted_lx[x]);
			x += 1;
		else:
			sorted.append(sorted_ly[y]);
			y += 1;
	sorted += sorted_lx[x:];
	sorted += sorted_ly[y:];
	print ' '*depth, "returning list", len(list);
	return sorted;

def merge_min_sort(list):
	newlist = merge_min_sort_rec(list, 0);
	return newlist;

def choose_inequality(elemx, elemy, choice):
	if (not(choice)):
		if (elemx < elemy):
			return 1;
		else:
			return 0;
	else:
		if (elemx > elemy):
			return 1;
		else:
			return 0;

def merge_sort_rec(list, maxmin, display, depth):
	if (len(list) <= 1):
		if (display):
			print ' '*depth, list;
		return list;
	if (display):
		print ' '*depth, "sorting list len", len(list);

	divpt = len(list)/2;
	listx = list[0:divpt];
	listy = list[divpt:len(list)];
	sorted_lx = merge_sort_rec(listx, maxmin, display, depth+1);
	sorted_ly = merge_sort_rec(listy, maxmin, display, depth+1);

	sorted = [];
	x = 0;
	y = 0;
	while (choose_inequality(x, len(sorted_lx), 0) and \
	choose_inequality(y, len(sorted_ly), 0)):
		if (choose_inequality(sorted_lx[x][1], sorted_ly[y][1], maxmin)):
			sorted.append(sorted_lx[x]);
			x += 1;
		else:
			sorted.append(sorted_ly[y]);
			y += 1;
	sorted += sorted_lx[x:];
	sorted += sorted_ly[y:];
	if (display):
		print ' '*depth, "returning list", len(list);
	return sorted;

def merge_sort(list, maxmin, display):
	newlist = merge_sort_rec(list, maxmin, display, 0);

	return newlist;








pairs_A = [int(s) for s in open("Median.txt").read().rstrip().split()]
l = [1, 2, 3, 4, 5]

def medians(array):
	m_k = 0
	sorted_list = []
	medians = []
	for element in array:
		sorted_list.append(element)
		sorted_list.sort()
		print len(sorted_list)
		if len(sorted_list)%2 == 0:
			m_k = sorted_list[len(sorted_list)/2-1]
		elif len(sorted_list) == 1:
			m_k = sorted_list[0]
		elif len(sorted_list)%2 == 1:

			m_k = sorted_list[(len(sorted_list)+1)/2-1]
		else:
			return "error"
		print "m_k = " , m_k , "\n"
		medians.append(m_k)
	return sum(medians)%10000

print "sum"
print medians(pairs_A)a = [2,1,-4,3,0,6]
a.sort()
print a
b = "rksdubtheynjmpwqzlfiovxgac"
print sorted(b,None,lambda x: ord(x))
c = [2,1,-4,3,0,6]
print sorted(c)
print sorted(c, lambda x, y: y - x);

class Test:
    def __init__(self, id, value):
        self.id = id
        self.value = value
    def __repr__(self):
        return "id: " + str(self.id) + " value: " + self.value

d = [ Test(4, "test"), Test(3, "test"), Test(6, "test"), Test(1, "test"), Test(2, "test"), Test(9, "test"), Test(0, "test") ]
print sorted(d, lambda x, y: y - x, lambda x: x.id, True)

print c
print sorted(c, None, None, True)

c.sort(reverse=True)
print c
c.sort()
print c
c.sort(lambda x, y: y - x, lambda x: pow(x, 2), True)
print c

L = [7, 3, -2, 4]
d = {'a': 5, 'b': 9}

def g(k):
    return d[k]

print(g('a'))
print(sorted(d.keys(), None, g))

print(sorted(d.keys(), None, None))

print(sorted(d.keys(), None, lambda x: d[x]))

def myabs(x):
    return abs(x)

print(sorted(L, None, myabs))
print(sorted(L, None, lambda x: myabs(x)))

print(sorted(L, None, lambda x: abs(x)))

print(sorted(L, None, abs))

print(sorted(L, key=lambda x: -x, reverse=True))

print(sorted(L, key=lambda x: -x))def keynat(string):
    r'''A natural sort helper function for sort() and sorted()
    without using regular expression.

    >>> items = ('Z', 'a', '10', '1', '9')
    >>> sorted(items)
    ['1', '10', '9', 'Z', 'a']
    >>> sorted(items, key=keynat)
    ['1', '9', '10', 'Z', 'a']
    '''
    r = []
    for c in string:
        try:
            c = int(c)
            try: r[-1] = r[-1] * 10 + c
            except: r.append(c)
        except:
            r.append(c)
    return r   import random
'''
02 Median of Two Sorted Arrays
https://oj.leetcode.com/problems/median-of-two-sorted-arrays/
There are two sorted arrays A and B of size m and n respectively.
Find the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
'''

def createRandList(n,a,b):
    A = []
    for i in range(n):
        A.append(random.randint(a,b))
    return A


def isEven(i):
    return True if i&1 == 0 else False


def mergeTwoSorted(A,B):
    if len(A) == 0:
        return B
    if len(B) == 0:
        return A

    C = []
    i = 0
    j = 0
    while i< len(A) and j < len(B):
        if A[i] < B[j]:
            C.append(A[i])
            i += 1
        else:
            C.append(B[j])
            j += 1
    while i< len(A):
        C.append(A[i])
        i += 1
    while j< len(B):
        C.append(B[j])
        j += 1
    return C
'''
median of a sorted list
'''
def medianSorted(A,s,l):
    if l & 1 == 0:
        return (float(A[(l>>1)+s]) + float(A[(l>>1)+s-1])) / 2.0
    else:
        return A[(l>>1)+s]

def medianTwoSortedRec(A, sa, la, B, sb, lb):

    if (la >=0 and la < 3) or (lb >= 0 and lb < 3):
        C = mergeTwoSorted(A,B)
        return medianSorted(C,0,len(C))


    ca = (la>>1)-1 if isEven(la) else la>>1
    cb = (lb>>1)-1 if isEven(lb) else lb>>1
    c = min(ca,cb)
    ma = medianSorted(A,sa,la)
    mb = medianSorted(B,sb,lb)
    if ma < mb:
        return medianTwoSortedRec(A,sa+c,la-c,B,sb,lb-c)
    else:
        return medianTwoSortedRec(A,sa,la-c,B,sb+c,lb-c)

def medianTwoSorted(A, B):
    return medianTwoSortedRec(A,0,len(A),B,0,len(B))

def main():
    repeat = 5
    for i in range(repeat):
        n = i+5
        A = createRandList(n,i*2,(i+n)*2)
        B = createRandList(n+1,i*2,(i+n)*2)
        A.sort()
        B.sort()
        print A
        print B
        print medianTwoSorted(A,B)


        C = mergeTwoSorted(A,B)
        print C
        print medianSorted(C,0,len(C))

if __name__ == "__main__":
    main()
import random
from collections import deque

def quick_sort(l):
    if len(l) < 2:
        return l
    piv = random.randint(0, len(l)-1)
    smaller = []
    larger = []


    for item in l[0:piv]:
        if item > l[piv]:
            larger.append(item)
        else:
            smaller.append(item)

    for item in l[piv+1:]:
        if item > l[piv]:
            larger.append(item)
        else:
            smaller.append(item)

    sorted_smlr = quick_sort(smaller)
    sorted_lrgr = quick_sort(larger)
    return sorted_smlr + [l[piv]] + sorted_lrgr


def merge_sort(l):
    if len(l) < 2:
        return l
    l1 = l[0:len(l)/2]
    l2 = l[len(l)/2:]
    print "l1:%s" % l1
    print "l2:%s" % l2

    sorted_l1 = deque(merge_sort(l1))
    sorted_l2 = deque(merge_sort(l2))
    sorted_l = []

    while len(sorted_l1) > 0 and len(sorted_l2) > 0:
        if sorted_l1[0] > sorted_l2[0]:
            sorted_l.append(sorted_l2.popleft())
        else:
            sorted_l.append(sorted_l1.popleft())

    if len(sorted_l1) > 0:
        sorted_l += list(sorted_l1)

    if len(sorted_l2) > 0:
        sorted_l += list(sorted_l2)

    return sorted_l


if __name__ == '__main__':
    import numpy as np
    import datetime



    sizes = [20]

    for siz in sizes:

        l = np.random.randint(siz, size=siz)
        print "source: %s" % l

        t0 = datetime.datetime.now()


        result = merge_sort(l)

        dt = datetime.datetime.now() - t0

        print "result: %s" % result
        print "%d\t%d days %d seconds %d microsecondsecs" % (siz, dt.days, dt.seconds, dt.microseconds)


def merge_sort(sort_me):
	'''
	merge_sort(list) uses merge sort algorithm to sort a list.
	It accepts a list and returns a sorted list.

	>>> my_list = merge_sort(my_list)
	'''
	if len(sort_me) < 2:
		return sort_me
	mid = int(len(sort_me)/2)
	lower = merge_sort(sort_me[:mid])
	upper = merge_sort(sort_me[mid:])
	merge = []

	i, j = 0, 0
	while i < len(lower) and j < len(upper):
		if lower[i] <= upper[j]:
			merge.append(lower[i])
			i += 1
		else:
			merge.append(upper[j])
			j += 1
	merge += lower[i:]
	merge += upper[j:]
	return merge



import sys
import random
import time
class Sort(object):

    def __init__(self, i):
        self.sorted_list = []
        for i in range(1, i+1):
            self.sorted_list.append(i)

    def shuffle(self):
        i = len(self.sorted_list) - 1
        while i > 0:
            j = random.randint(0, i)
            tmp = self.sorted_list.pop(j)
            self.sorted_list.insert(j, self.sorted_list[i-1])
            self.sorted_list.pop(i)
            self.sorted_list.insert(i,tmp)
            i = i-1
        return self.sorted_list

    def sort(self):
       return self._rec_sort(self.sorted_list)

    def _rec_sort(self, L):
        if len(L) <= 1:
            return L
        pivot = L.pop(random.randint(0,len(L)-1))
        less = []
        greater = []
        for i in L:
            if i <= pivot:
                less.append(i)
            else:
                greater.append(i)
        return (self._rec_sort(less) + [pivot] + self._rec_sort(greater))

    def get_list(self):
        return self.sorted_list

    def set_list(self, newlist):
        if isinstance(newlist, list):
            self.sorted_list = newlist
        else:
            print "Bad!"

args = 100
if len(sys.argv) > 1:
    args = int(sys.argv[1])
a = Sort(args)
print "Starting list:\n\n" + str(a.get_list()) + "\n\n"
shuffledlist = a.shuffle()
print "Shuffled list:\n\n" + str(shuffledlist) + "\n\n"
sorted_listlist = a.sort()
print "sorted_list list:\n\n" + str(sorted_listlist) + "\n\n"

def merge_sort(to_sort_list):
    if len(to_sort_list) == 1:
        return to_sort_list
    half = len(to_sort_list) / 2
    to_sort_list[:] = merge(merge_sort(to_sort_list[:half]), merge_sort(to_sort_list[half:]))
    return to_sort_list

def merge(left_list, right_list):
    left_pos = right_pos = 0
    sorted_list = []
    while True:
        if left_list[left_pos] < right_list[right_pos]:
            sorted_list.append(left_list[left_pos])
            left_pos = left_pos + 1
            if left_pos == len(left_list):
                sorted_list = sorted_list + right_list[right_pos:]
                break
        else:
            sorted_list.append(right_list[right_pos])
            right_pos = right_pos + 1
            if right_pos == len(right_list):
                sorted_list = sorted_list + left_list[left_pos:]
                break
    return sorted_list

to_sort_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
merge_sort(to_sort_list)
print to_sort_list
from django import template
register = template.Library()

@register.filter
def hash(h, key):
    return h[key]

@register.filter
def sort_hash(h, key):
    return sorted(h[key], key=lambda x: x.lower())
def merge_sort(unsorted):
    """ Base case """
    if len(unsorted) <= 1:
        return unsorted

    """ Split array into two halves """
    mid = len(unsorted) // 2
    left_half = merge_sort(unsorted[:mid])
    right_half = merge_sort(unsorted[mid:])

    return merge(left_half, right_half)

def merge(left_half, right_half):
    """ Compare halves and merge into sorted list """
    sorted_list = []

    while len(left_half) > 0 and len(right_half) > 0:
        if left_half[0] < right_half[0]:
            sorted_list.append(left_half.pop(0))
        else:
            sorted_list.append(right_half.pop(0))

    if len(left_half) > 0:
        sorted_list.extend(left_half)

    if len(right_half) > 0:
        sorted_list.extend(right_half)

    return sorted_list

unsorted = [98, 35, 28, 44, 10, 6, 110]
print merge_sort(unsorted)


def ThirdGreatest(ary):

	myDict = {}



	for i in range(len(ary)):
		myDict[ary[i]] = i


	sortedByLength = sorted(myDict, key=len, reverse=True)



	if len(sortedByLength[1]) == len(sortedByLength[2]):

		if myDict[sortedByLength[1]] > myDict[sortedByLength[2]]:
			return sortedByLength[1]
		else:
			return sortedByLength[2]
	elif len(sortedByLength[2]) == len(sortedByLength[3]):
		if myDict[sortedByLength[2]] > myDict[sortedByLength[3]]:
			return sortedByLength[2]
		else:
			return sortedByLength[3]
	else:
		return sortedByLength[2]

def main():

	result = ThirdGreatest(["hello", "world", "after", "all"] )
	print result

if __name__ == "__main__":
  main()class Solution:




    def containsNearbyAlmostDuplicate(self, nums, k, t):
        if len(nums) == 0:
            return False

        sorted_array = []
        for idx in range(len(nums)):
            sorted_array.append((idx, nums[idx]))

        sorted_array.sort(key=lambda x: x[1])

        for each in range(len(nums)):
            target = each+1

            while target < len(nums) and sorted_array[target][1] - sorted_array[each][1] <= t:
                if abs(sorted_array[target][0] - sorted_array[each][0]) <= k:
                    return True
                else:
                    target += 1

        return Falsedef is_sorted(a):
	a.sort()
	return a


print is_sorted([2,1,3])
"""
An implementation of counting sort.
"""

import random

def counting_sort(array):
	"""
	Perform a counting sort.

	Args:
		array (list of ints): An array of integers.

	Returns:
		A pointer to the sorted copy of `array`.
	"""

	min_val = min(array)
	max_val = max(array)
	counts = [0] * (max_val - min_val + 1)

	for item in array:
		counts[item + min_val] += 1

	sorted_arr = []
	for ind in xrange(len(counts)):
		for repetition in xrange(counts[ind]):
			sorted_arr.append(ind + min_val)

	return sorted_arr

def test_counting_sort():
	"""
	Test `counting_sort()` against Python's inbuilt `sorted()`.

	If `counting_sort()` fails to correctly sort an array, print a message
	containing both the original array and the array after the attempted sort.
	"""

	for i in xrange(100):
		arr = range(-50, 50)
		random.shuffle(arr)

		sorted_arr = counting_sort(arr)
		if sorted_arr != sorted(arr):
			print (
				"counting sort() failed.\n"
				"\tOriginal: %s\n\tAttempted sort: %s"
			) % (arr, sorted_arr)

if __name__ == "__main__":
	test_counting_sort()
SORT_BY = 'field'
ORDER = 'order'


class StandardDicSort(object):

    def __init__(self, *sort_field):
        self.sort_field = sort_field
        super(StandardDicSort, self).__init__()

    def sort_by(self, request, to_be_sorted):
        sort_key = request.GET.get(SORT_BY)
        if sort_key in self.sort_field:
            return sorted(to_be_sorted, key=lambda d: d.get(sort_key), reverse=request.GET.get(ORDER) == 'desc')
        return to_be_sortedfrom listQfile import ListQ

class Sort(ListQ):
    def __init__(self, unsortedList):
        self.items = unsortedList
        self.sortedList = []
        self.magicSort()

    def __str__(self):
    	s = ''
    	for n in self.sortedList:
    		s = s + str(n) + ' '
    	return s


    def magicSort(self):
        while not self.isEmpty():
            self.put(self.get())
            self.sortedList.append(self.get())def selection_sort(A):

    for i in range(len(A)):
        minval = float("inf")
        minindx = -1
        for j in range(i,len(A)):
            if A[j] < minval:
                minval = A[j]
                minindx = j
        A[i], A[minindx] = A[minindx], A[i]

    return A

assert selection_sort([4,8,3,7,2,6,1,5,0]) == sorted([4,8,3,7,2,6,1,5,0])

__author__ = 'steve1281'

store = []

def sort_by_last_letter(strings):
    def last_letter(s):
        return s[-1];
    store.append(last_letter)
    print(last_letter)
    return sorted(strings, key=last_letter)

def bubble_sort(a):
    sorted = False
    while not sorted:
        sorted = True
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                a = a[:i-1] + a[i] + a[i-1] + a[i+1:]
                sorted = False
    return a


    def __init__(self, items):
        self._items = list(items)

    def add(self, item):
        self._items.append(item)

    def __getitem__(self, index):
        return self._items[index]

    def sort(self):
        self._items.sort()

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "SimpleList({!r})".format(_items)


class SortedList(SimpleList):
    def __init__(self, items=()):
        super().__init__(items)
        self.sort()

    def add(self, item):
        super().add(item)
        self.sort()

    def __repr__(self):
        return "SortedList({!r})".format(list(self))

class IntList(SimpleList):
    def __init__(self, items=()):
        for x in items: self._validate(x)
        super().__init__(items)

    @staticmethod
    def _validate(x):
        if not isinstance(x, int):
            raise TypeError('IntList only supports integer values.')

    def add(self, item):
        self._validate(item)
        super().add(item)

    def __repr__(self):
        return "IntList({!r})".format(list(self))

class SortedIntList(IntList, SortedList):
    def __repr__(self):
        return 'SortedIntList({!r})'.format(list(self))def bubble_sort(l):
  is_sorted = False

  counter = 0
  while is_sorted == False:
    is_sorted = True

    for i in range(len(l) - 1):
      num1, num2 = l[i], l[i+1]
      if num1 > num2:
        is_sorted = False
        l[i], l[i+1] = num2, num1
  return l

print bubble_sort([6, 5, 3, 1, 8, 7, 2, 4])
def break_words(text):
    words = text.split(' ')
    return words


def sort_words(words):
    sorted_words = sorted(words)
    return sorted_words


def print_first_word(words):
    word = words.pop(0)
    print word


def print_last_word(words):
    word = words.pop(-1)
    print word


def sort_sentence(sentence):
    words = break_words(sentence)
    sorted_words = sort_words(words)
    return sorted_words


def print_first_and_last_word_sentence(sentence):
    words = break_words(sentence)
    print_first_word(words)
    print_last_word(words)


def print_first_and_last_word_soted_sentence(sentence):
    words = break_words(sentence)
    sorted_words = sort_words(words)
    print_first_word(sorted_words)


    print_last_word(sorted_words)
def sort_fractions(fractions):
	arr = sorted(fractions,key = lambda x : x[0]/x[1])
	return arr"""
Given two sorted integer arrays A and B, merge B into A as one sorted array.

Example
A = [1, 2, 3, empty, empty], B = [4, 5]

After merge, A will be filled as [1, 2, 3, 4, 5]
"""

class Solution:
    """
    @param A: sorted integer array A which has m elements,
              but size of A is m+n
    @param B: sorted integer array B which has n elements
    @return: void
    """





    def mergeSortedArray(self, A, m, B, n):
        i = m - 1
        j = n - 1
        index = m + n - 1
        while i >= 0 and j >= 0:
            if A[i] > B[j]:
                A[index] = A[i]
                index -= 1
                i -= 1
            else:
                A[index] = B[j]
                index -= 1
                j -= 1

        while i >= 0:
            A[index] = A[i]
            index -= 1
            i -= 1
        while j >= 0:
            A[index] = B[j]
            index -= 1
            j -= 1


A = [1, 2, 3, '-inf', '-inf']
B = [2, 5]
Sol = Solution()
Sol.mergeSortedArray(A, 3, B, 2)
print Aimport random
from time import time

__author__ = 'rabbi'


class ShellSort:
    def __init__(self, unSortedList):
        self.unSortedList = unSortedList

    def shellSort(self):
        """
        Shell Sort
        """
        gap = len(self.unSortedList) // 2

        while gap > 0:

            for i in range(gap, len(self.unSortedList)):
                val = self.unSortedList[i]
                j = i
                while j >= gap and self.unSortedList[j - gap] > val:
                    self.unSortedList[j] = self.unSortedList[j - gap]
                    j -= gap
                self.unSortedList[j] = val
            gap //= 2

        return self.unSortedList


if __name__ == '__main__':
    unSortedList = [12, 10, 8, 5, 9, 13, 20, 18, 17, 2, 4, 5, 1]
    for i in range(100000):
        unSortedList.append(random.randint(1, 50000))
    shellSort = ShellSort(unSortedList)
    startTime = time()
    sortedList = shellSort.shellSort()
    endTime = time()
    print sortedList
    print "Execution Time: %f" % (endTime - startTime)
from zope.viewlet.manager import ViewletManagerBase

class SortingViewletManager(ViewletManagerBase):

    def sort(self, viewlets):
        return sorted(viewlets)


__author__ = "bt3"




def insertion_sort(seq):
    ''' sort a sequence using the insertion sort alg '''
    for i in range(1, len(seq)):
        j = i
        while j > 0 and seq[j-1] > seq[j]:
            seq[j-1], seq[j] = seq[j], seq[j-1]
            j -= 1
    return seq


def insertion_sort_rec(seq, i = None):
    ''' sort a sequence using the recursive insertion sort alg '''
    if i == None: i = len(seq) -1
    if i == 0: return i
    insertion_sort_rec(seq, i-1)
    j = i
    while j > 0 and seq[j-i] > seq[j]:
        seq[j-1], seq[j] = seq[j], seq[j-1]
        j -= 1
    return seq


def test_insertion_sort():
    seq = [3, 5, 2, 6, 8, 1, 0, 3, 5, 6, 2, 5, 4, 1, 5, 3]
    assert(insertion_sort(seq) == sorted(seq))
    assert(insertion_sort_rec(seq) == sorted(seq))


if __name__ == '__main__':
    test_insertion_sort()








from __future__ import unicode_literals
import pytest
from structures.insertion_sort import insertion_sort


@pytest.fixture
def sorted_list():
    return [i for i in xrange(10)]


@pytest.fixture
def reverse_list():
    return [i for i in xrange(9, -1, -1)]


@pytest.fixture
def average_list():
    return [5, 9, 2, 4, 1, 6, 8, 7, 0, 3]


def test_sorted(sorted_list):
    insertion_sort(sorted_list)
    assert sorted_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_worst(reverse_list):
    insertion_sort(reverse_list)
    assert reverse_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_average(average_list):
    insertion_sort(average_list)
    assert average_list == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


def test_repeats():
    l = [3, 6, 7, 3, 9, 5, 2, 7]
    insertion_sort(l)
    assert l == [2, 3, 3, 5, 6, 7, 7, 9]


def test_multiple_types():
    l = [3, 'foo', 2.8, True, []]

    insertion_sort(l)
    assert l == [True, 2.8, 3, [], 'foo']


import random

def get_random_list(num=10):
    l = range(0, num)
    random.shuffle(l)
    return l

def is_sorted(l):
    for i in range(0, len(l)-1):
        if l[i] > l[i+1]:
            return False
    return True

def quick_sort(nums=[]):
    quick_sort.cnum = 0
    quick_sort.swaps = 0
    def swap(l, i, j):
        if i == j:
            return
        temp = l[i]
        l[i] = l[j]
        l[j] = temp
        quick_sort.swaps +=1

    def sublist_sort(nums, a, b):
        if a >= b:
            return
        pivot = nums[b]
        i = a
        j = b-1
        while i<=j:
            while nums[i] < pivot:
                quick_sort.cnum +=1
                if i >= b:
                    break
                i += 1

            while nums[j] >= pivot:
                quick_sort.cnum +=1
                if j <= a:
                    break
                j -= 1
            if i<j:
                swap(nums, i, j)
                i += 1
                j -= 1
            else:
                break

        swap(nums, i, b)
        sublist_sort(nums, a, i-1)
        sublist_sort(nums, i+1, b)

    if len(nums) > 0:
        sublist_sort(nums, 0, len(nums)-1)

def quick_sort2(nums=[]):
    if len(nums) == 0:
        return []
    else:
        return quick_sort2([x for x in nums[1:] if x < nums[0]]) + [nums[0]] + quick_sort2([x for x in nums[1:] if x>=nums[0]])

if __name__ == '__main__':
    l = get_random_list(20)
    print l
    quick_sort(l)
    print l
    print "Sorted: %s,

def swap_lis(lis, i):
	lis[i], lis[i + 1] = lis[i + 1], lis[i]
      	return 0

def sort(lis, limit):
	for i in range(limit):
		[swap_lis(lis, j) if lis[j] > lis[j + 1] for j in range(limit)]
	return lis


lis = input("enter the list\n")
limit = len(lis) - 1
lis_sorted = sort(lis, limit)
print "the sorted list is %r"%(lis_sorted)


import pygame

class MergeSort():
  """docstring for MergeSort"""
  def __init__(self):
    pass

  def RecursiveSort(self, l):
    """docstring for sort2"""

    if len(l) == 1:
      return (l, 0)


    half_size = len(l)/2
    l1 = l[:half_size]
    l2 = l[half_size:]

    l1_sorted, l1_complexity = self.RecursiveSort(l1)
    l2_sorted, l2_complexity = self.RecursiveSort(l2)


    algorithm_complexity = 0
    l_sorted = []
    x = 0
    y = 0
    while True:
      algorithm_complexity += 2
      if l1_sorted[x] < l2_sorted[y]:
        l_sorted.append(l1_sorted[x])
        x += 1
        if x >= len(l1_sorted):
          l_sorted += l2_sorted[y:]
          break
      else:
        l_sorted.append(l2_sorted[y])
        y += 1
        if y >= len(l2_sorted):
          l_sorted += l1_sorted[x:]
          break
    return (l_sorted, algorithm_complexity + l1_complexity + l2_complexity)

class Element():
  """docstring for Animation"""
  def __init__(self, elem, pos):
    self.elem = elem
    self.pos = pos

  def getRect(self):
    self.rect = pygame.Rect(self.pos * 10, 0, 1, self.elem)

  def changePos(self, new_pos):
    self.pos = new_pos

  def update(self):
     pygame.display.update()

  def Iteration(self):
    self.getRect()
    self.update()

def main():
  animation = MergeSort()

if __name__ == '__main__':
  main()






from compare import cmp

def quicksortCmp(c, toSort):
    if len(toSort) <= 1:
        return toSort

    end = len(toSort) - 1
    pivot = toSort[end]

    low = []
    high = []

    for num in toSort[:end]:
        if  cmp(c, num, pivot, (num <= pivot)):
            low.append(num)
        else:
            high.append(num)

    sortedList = quicksortCmp(c, low)
    sortedList.append(pivot)
    sortedList.extend(quicksortCmp(c, high))
    return sortedList

def quicksort(A):
	c = []
	x = quicksortCmp(c, A)
	return c



def sortOnMedia(data):
    sortedData = sorted(data, key=lambda x: x.getMedia())
    return sortedData

def sortOnCompany(data):
    sortedData = sorted(data, key=lambda x: x.getCompany())
    return sortedData

def sortOnCategory(data):
    sortedData = sorted(data, key=lambda x: x.getCategory())
    return sortedData

def sortOnCategorySize(data):
    """
    Assume that the data input is a list sorted by category
    """
    categories = []
    for i in data:
        if len(categories) == 0:
            categories.append([i])
        else:
            if i.getCategory() == categories[-1][-1].getCategory():
                categories[-1].append(i)
            else:
                categories.append([i])

    sortedCategories = sorted(categories, key=lambda x: len(x), reverse=True)
    sortedData = []
    for category in sortedCategories:
        for i in category:
            sortedData.append(i)
    return sortedData

def sortInput(data):
    data = sortOnCompany(data)
    data = sortOnMedia(data)
    data = sortOnCategory(data)
    data = sortOnCategorySize(data)
    return data

def insertion_sort(A):
    n = len(A)
    for j in range(2,n):
        key = A[j]
        i = j-1
        while i > 0 and A[i]>key:
            A[i+1] = A[i]
            i = i-1
        A[i+1] = key
    return A
if __name__ == '__main__':
    A = [3,7,6,5,5,5,34,56]
    print "A:", A
    print "Sorted array after insertion sort", insertion_sort(A)import numpy as np
r=[['a', 'a', 'a', 'b','c','c','c','c'],[1,2,3,13],[4,5,6,14],[7,8,9,15],[10,11,12,16,4,5,6,14]]

d={r[0][z]:[p[z] for p in r[1:] if z<=len(r[1])-1] for z in xrange(0,len(r[0]))}

def chardiv(lst):
    def pairs(xs):
      for p in zip(xs[:-1], xs[1:]):
        yield p
    sortOrder=[i[0] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedIndep=[i[1] for i in sorted(enumerate(lst[0]), key=lambda x:x[1], reverse=False)]
    sortedDep=[lst[1][z] for z in sortOrder]
    cuts=[];divs=[]
    for x in xrange(1,len(sortedIndep)):
      if not sortedIndep[x-1]==sortedIndep[x]:
        cuts.append(x)
    cuts.insert(0, 0); cuts.insert(len(cuts),len(sortOrder))
    for x,y in pairs(cuts):
      print x, y
      divs.append([sortedIndep[x],np.std(sortedDep[x:y]),[(sortedIndep[z], sortedDep[z]) for z in xrange(x,y)]])
    return divs

print chardiv([r[0],r[4]])class Solution:

    def findMedianSortedArrays(self, A, B):
        C = A + B
        C.sort()
        l = len(C)
        if l % 2 == 0:
        	return float(C[l/2] + C[l/2-1]) / 2
        else:
        	return float(C[l/2])


if __name__ == '__main__':
	s = Solution()
	a = [3,2,1,9,8]
	b = [3,6,4]
	print s.findMedianSortedArrays(a, b)
unsorted_lists = [
    [3, 4, 6, 5],
    [9, 8, 7, 6, 5, 4, 3, 2, 1],
    [1, 2, 3, 5, 6, 7, 9, 0],
    [-1, -5, -3, -4],
    [4, 3, 2, 1, 9, 8, 7, 6, 5],
]


def merge_sort(unsorted_list):

    if len(unsorted_list) <= 1:
        return unsorted_list
    mid = len(unsorted_list) // 2
    left_half = merge_sort(unsorted_list[:mid])
    right_half = merge_sort(unsorted_list[mid:])




    sorted_list = []
    i, k = 0, 0
    while i < len(left_half) and k < len(right_half):
        if left_half[i] < right_half[k]:
            sorted_list.append(left_half[i])
            i += 1
        else:
            sorted_list.append(right_half[k])
            k += 1

    sorted_list.extend(left_half[i:])
    sorted_list.extend(right_half[k:])

    return sorted_list


if __name__ == '__main__':


    for ulist in unsorted_lists:
        print(merge_sort(ulist))

def break_words(stuff):

    w = stuff.split(' ')
    return w

def words_sorted(w):

    s = sorted(w)
    return s

def print_first_word(w):

    p = w.pop(0)
    return p

def print_last_word(w):

    p = w.pop(-1)
    return p

def sort_sentence(s):

    w = break_words(s)
    return words_sorted(w)

def print_first_and_last(s):

    w = break_words(s)
    return print_first_word(w), print_last_word(w)

def print_f_n_l_sorted(s):
    w = sort_sentence(s)
    return print_first_word(w), print_last_word(w)


ss = "All good things come to those who wait."
w = break_words(ss)

q1 = break_words(ss)
print '1 ', q1
q2 = words_sorted(w)
print '2 ', q2
q3 = print_first_word(w)
print '3 ', q3
q4 = print_last_word(w)
print '4 ', q4
q5 = sort_sentence(ss)
print '5 ', q5
q6 = print_first_and_last(ss)
print '6 ', q6
q7 = print_f_n_l_sorted(ss)
print '7 ', q7


try:
    sorted
except:
    def sorted(data):
        data = list(data)
        data.sort()
        return data
import itertools
def top10(data, howtosort):
    return list(itertools.islice(howtosort(data), 10))



def radix_sort(list_1d,num_digits):
    for digit in range(num_digits):
        current_digits=[(x/(10**digit))%10 for x in list_1d]
        (sorted_list_digits,sorted_list_index)=counting_sort(current_digits,9)
        sorted_list=[list_1d[sorted_list_index[i]] for i in range(len(sorted_list_index))]
        list_1d=sorted_list
    return list_1d


print radix_sort([345,999,765,764,444,789,300],3)
print radix_sort([3,100,2],3)
print radix_sort([3,2],1)
print radix_sort([2,3],1)
print radix_sort([1,3,2,3,4,5,6,7,0,2,3,99,50,10],2)
