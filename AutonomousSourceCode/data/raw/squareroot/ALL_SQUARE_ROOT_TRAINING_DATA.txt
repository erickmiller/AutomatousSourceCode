def FindOrderMagnitude(n):
	o = 0

	while (n >= 1):
		n /= 10
		o += 1

	return o

def FindSquareRoot(n, eps):
	assert(n >= 0)

	low = 0.0
	upp = n

	k = 0
	r = (low + upp) * 0.5
	## r = 10 ** (FindOrderMagnitude(n) * 0.5)
	e = abs((r * r) - n)

	## binary-search
	while (e > eps):
		if ((r * r) >= n):
			upp = r
		else:
			low = r

		r = (low + upp) * 0.5
		e = abs((r * r) - n)
		k += 1

	return (r, k)

(r0, k0) = FindSquareRoot(123.456, 0.01)
(r1, k1) = FindSquareRoot(777.777, 0.01)

print("sqrt=%f (%f) iters=%d" % (r0, r0 * r0, k0))
print("sqrt=%f (%f) iters=%d" % (r1, r1 * r1, k1))


import threading
import _thread
import time
import math
import random


#Square Root Calculator
def mySqrt():
    print()
    print ('***Square Root Calculator***')
    print()
    print ('Please enter your number of choice:')

    x = int (input())

    time.sleep(2)
    
    """Returns the square root of x if x is a perfect square.
Prints an error message and returns none if otherwise."""
    ans = 0
    if x>=0:
        while ans*ans <x:
            ans = ans + 1
        if ans*ans == x:
            print(x, 'is a perfect square.')


            y = math.sqrt(x)
            a = (y, 'is the square root of' , x)
            print (a)

            f = open('sqrt.txt','w+')
            f.write(a)
            f.close()
            
            return ans
        
        else:
            print(x, 'is not a perfect square.')
            return None    
    else: 
            print(x, 'is a negative number.')
            
mySqrt()




#BMI Calculator
def BMI():
    print()
    print("***Body Mass Index(BMI) Calculator***")
    print()
    print("Please fill out the following:")
    print()
    x = eval(input("Your weight in Kilograms: "))
    y = eval(input("Your Height in Meters: "))

    '''BMI formula is mass(Kg) /(Height(m))* (Height(m))'''
    x = float(x)
    y = float(y)

    slp = random.randint(5,7)
    
    print('sleep time chosen is', slp , 'seconds')
    time.sleep(slp)

    c = (((x)/(y*y)))

    print (c , 'is your BMI')
    print()

    print('BMI CHART')
    print ('Below 18.5 = Underweight')
    print ('Between 18.5 and 24.9 = Normal')
    print ('Between 25 and 29.9 = Overweight')
    print ('Above 30.0 = Obese')
    
BMI()

m = random.randint(1,8)
print ()
print('integer generated is ',m)


if m % 2 == 0:
    print('--BMI calculator chosen:: The integer is even')
    _thread.start_new_thread(BMI, ())
else:
    print('Square root calculator chosen:: The integer is odd')
    _thread.start_new_thread(mySqrt, ())


#!/usr/bin/env python
""" Example run of the pythonREST server

To test, run this script (either python example_server.py or
as an executable ./python), and in a seperate terminal
call, for example (square root of 10):

curl -X POST http://0.0.0.0:9090 -d '{"fun":"root_fun", "params":{"n" : 10}}'

Or, in a seperate terminal, execute the example_client.py file.
"""

import math
import time

import pythonrest

def square_fun(params):
    """
    Square the scalar input
    """
    return {"value": params["n"]**2}

def root_fun(params):
    """
    Find the root of the scalar input
    """
    return {"value": math.sqrt(params["n"])}

def one_plus_inverse(params):
    if params["n"] == 0:
        return {"value": None}
    else:
        return {"value": 1.0 + 1.0/params["n"]}

def wait_5_secs(params):
    time.sleep(5)
    return {"value": 1}

pyserver = pythonrest.PyServer()
pyserver.add_post_fun(square_fun)
pyserver.add_post_fun(root_fun)
pyserver.add_post_fun(one_plus_inverse)
pyserver.add_post_fun(wait_5_secs)
pyserver.run()


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/env python

def r8_sqrt_i4 ( i ):

#*****************************************************************************80
#
## R8_SQRT_I4 returns the square root of an I4 as an R8.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license. 
#
#  Modified:
#
#    25 July 2014
#
#  Author:
#
#    John Burkardt
#
#  Parameters:
#
#    Input, integer I, the number whose square root is desired.
#
#    Output, real R8_SQRT_I4, the value of sqrt(I).
#
  from math import sqrt

  value = sqrt ( float ( i ) )

  return value


__author__ = 'Step'

def bisect(square, left_end=0, right_end=None):
    """
    Square root realisation using bisection method.
    Usage:
    bisect(square, left_end, right_end)
    where square - number from which root is extracted,
    and left_end, right_end are the ends of segment where we're looking for root, optional parameters

    >>> bisect(18)
    4
    >>> bisect(9)
    3
    >>> bisect(100, 0, 50)
    10

    :type square int
    :type left_end int
    :type right_end int
    """

    if square < 0:
        raise ValueError('Cannot extract root of negative number')
    if right_end is None:
        right_end = square
    if right_end - left_end <= 1:
        return rounding_correction(lambda x: x * x - square, [right_end])
    else:
        middle = (right_end + left_end) / 2
        if middle * middle - square < 0:
            return bisect(square, middle, right_end)
        else:
            return bisect(square, left_end, middle)

def rounding_correction(func, roots):
    """
    Last attempt to get rid of rounding errors
    Usage:
    rounding_correction(func, roots), where func is testing function and roots are suspected roots

    >>> rounding_correction(lambda x: x * x - 4, [2])
    2
    >>> rounding_correction(lambda x: x * x - 15, [3])
    4

    Output: list of corrected roots, or root if one.

    :type func function
    :type roots list
    """

    def error(x):
        return abs(func(x))

    roots_testing = map(lambda root: [root - 1, root, root + 1], roots)
    roots_test = map(lambda pot_roots: map(error, pot_roots), roots_testing)

    roots = [roots_testing[i][roots_test[i].index(min(roots_test[i]))] for i in xrange(len(roots))]
    return roots if len(roots) > 1 else roots[0]

def get_roots(a, b, c, discr):
    """
    Main solver

    >>> get_roots(1, -4, 4, 0)
    [2, 2]
    >>> get_roots(50, -225, 253, 25)
    [2, 2]

    :type a int
    :type b int
    :type c int
    :type discr int
    """
    doub_a = a << 1
    sqrt_discr = bisect(discr)
    t1 = - b - sqrt_discr
    t2 = - b + sqrt_discr
    root_l = t1 / doub_a
    root_r = t2 / doub_a

    roots = rounding_correction(lambda x: a * x**2 + b * x + c, [root_l, root_r])
    return roots


def main():
    a, b, c = map(lambda x: int(x), raw_input().split())
    if a == 0 and b == 0 and c == 0:  # checking if solution is all rational numbers
        print -1
        exit()
    if not a:  # checking if equation is linear
        if b:
            print 1
            if not (-b == 2 * c):
                print rounding_correction(lambda x: b * x + c,[- c / b])
            else:
                print 1
        else:
            print 0
        exit()

    # starting to solve quadratic equation
    discriminant = b ** 2 - 4 * a * c
    if discriminant < 0:
        print 0
    elif not discriminant:
        print 1
        print get_roots(a, b, c, discriminant)[0]
    else:
        print 2
        res = get_roots(a, b, c, discriminant)
        print res[0]
        print res[1]

if __name__ == '__main__':
    main()

# 2/7/14 While Loops

A = 20
B = 5

while A >= B:
    print "A is now", A
    A = A-1

# Calculate square root with while loop

def square_root(N):
    guess = 1.0
    while abs(N - guess**2) > 0.000000000000001:
        quotient = N/guess
        guess = (guess + quotient)/2.0
    return guess

print "The square root of 2 is:", square_root(2)
print "The square root of 4 is", square_root(4)
print "The square root of 25 is:", square_root(25)
print "The square root of 5184 is:", square_root(5184) # 72
print "The square root of 159.283 is:", square_root(159.283) # 12.620

"""
Program that asks the user for a positive number and then outputs the
approximated square root of the number. Use Newton's method to find the
square root, with epsilon = 0.01. (Epsilon is the allowed error, plus or
minus, when you square your calculated square root and compare it to
your original number.)
"""


def ask_for_number():
    """Asks user for a positive number"""
    number = 0
    while True:
        if number > 0:
            return number
        try:
            number = int(input("Please provide a positive nuumber: "))
        except:
            pass


def newtons_method(num, guess=None):
    """Calculates the square root of a number."""
    if guess is None:
        # picked 20 out of thin air. Let me know if I should change.
        guess = 20

    new_guess = .5*(num/guess+guess)

    if new_guess == guess:
        print("The square root of {} is {}.".format(num, guess))
    else:
        newtons_method(num, new_guess)

newtons_method(num=ask_for_number())

# -*- coding: utf-8 -*-
# Problem 80
# Square root digital expansion

# It is well known that if the square root of a natural number is not an integer,
# then it is irrational. The decimal expansion of such square roots is infinite
# without any repeating pattern at all.

# The square root of two is 1.41421356237309504880..., and the digital sum of the
# first one hundred decimal digits is 475.

# For the first one hundred natural numbers, find the total of the digital sums
# of the first one hundred decimal digits for all the irrational square roots.

from time import time
import decimal


def digit_sums(n):
    """
    take the square root of "n", get rid of ".", kep the first 100 digits,
    then return the sum of the 100 digits
    """
    decimal.getcontext().prec = 105     # seems that 100 is not precise enough

    square_root_str = str(decimal.Decimal(n).sqrt()).replace(".", "")[:100]
    return sum(map(int, square_root_str))
    
start_time = time()

perfect_squares = [i ** 2 for i in xrange(1, 11)]

sum_ = 0
for i in xrange(1, 101):
    if not i in perfect_squares:
        sum_ += digit_sums(i)

print "Answer:", sum_

print "Total Time: ", time() - start_time

# Completed on Sat, 29 Mar 2014, 23:16
# Solve by:  10044
# ---------------
# Answer: 40886
# Total Time:  0.0119998455048
# [Finished in 0.2s]

###
### Unit 4 Code
###

def euclid(a, b):
    if b == 0:
        return a
    return euclid(b, a % b)

def extended_euclid(a, b):
    """Returns (s, t) where as + bt = gcd(a, b)"""
    if b == 0:
        return (1, 0)
    else:
        (s, t) = extended_euclid(b, a % b)
        return (t, s - (a / b) * t)

### This is all ridiculously inefficient code for clarity, not for any
### practical purpose!

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def totient(n):
    """Brute force computation of Euler's totient (not for large n)."""
    return [i for i in range(n) if gcd(i, n) == 1]

def is_primitive_root(g, q):
    reached = []
    x = g
    while True:
        if x in reached:
            break
        reached.append(x)
        x = (x * g) % q
    return len(reached) == q - 1

def square(x): return x * x

def mod_exp(a, b, q):
    if b == 0:
        return 1
    if b % 2 == 0:
        return square(mod_exp(a, b / 2, q)) % q
    else:
        return (a * mod_exp(a, b - 1, q)) % q
    
def generator_permutation(g, q):
    return [mod_exp(g, i, q) for i in range(1, q)]

    
def primitive_roots(q):
    """Brute force search for primitive roots of a prime q."""
    return [i for i in range(1, q) if is_primitive_root(i, q)]

#def toy_diffie_helman(q, alpha):
    

from math import sqrt
'''
http://projecteuler.net/problem=9
'''

def square_sum(m,n):
	return m*m+n*n

def test_square(val):
	root = sqrt(val)
	if root == int(root):
		return 1
	else:
		return 0

if __name__ == '__main__':
	cnt = 0
	sqcnt = 0
	for xx in xrange(1,999):
		for yy in xrange(xx+1,999-xx):
			cnt += 1
			sqsum = square_sum(xx, yy)
			sqroot = sqrt(sqsum)
			if sqroot < yy:
				break
			if test_square(sqsum):
				sqcnt += 1
				if (xx+yy+sqroot)==1000:
					print(xx,"^2 + ",yy,"^2 = ",sqroot,"^2")
	print("cnt = ", cnt)
	print("sqcnt = ", sqcnt)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""
This script allows the user to find the square root of a number.
"""

def squareroot(number):
    estimate = number / 2
    epsilon = 0.000000000001

    while True:
        # print estimate
        root = 0.5 * (estimate + number / estimate)
        if abs(root - estimate) < epsilon:
            return root
        else:
            estimate = root

if __name__ == "__main__":
    number = float(raw_input("What would you like to find the square root of?\n"))
    print squareroot(number)
def newtonSqrt(n):
	approx = 0.5 * n
	better = 0.5 * (approx + n/approx)
	while better != approx:
		approx = better
		better = 0.5 * (approx + n/approx)
	return approx

x = float(input("what number would you like to square root?"))
print (newtonSqrt(x))
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

"""To test the square root algorithm in this chapter, you could compare
it with math.sqrt. Write a function named test_square_root that prints a table.

The first column is a number, a; the second column is the square root of a
computed with the function from Section 7.5; the third column is the square root
computed by math.sqrt; the fourth column is the absolute value of the difference
between the two estimates."""


import math

def square_root(a):
    a = float(a)
    x = a/2
    while True:
        y = (x + a/x) / 2
        if x == y:
            break
        x = y
    return x

def square_root_table(n_range):
    for num in range(1, n_range):
        print num,
        print square_root(num),
        print math.sqrt(num),
        print abs(square_root(num) - math.sqrt(num))

# Plus grand diviseur

import math

def is_prime(N):
	square_root = math.sqrt(N)
	dividers = [ d for d in range(2,int(square_root)+1) ]
	for d in dividers:
		if N % d == 0:
			return False
	return True

N = 600851475143

square_root = math.sqrt(N)
int_range = range(1,int(square_root)+1)
int_range.reverse()

for i in int_range:
	if N % i == 0 and is_prime(i):
		break

f = open('p003.txt','w')
f.write(str(i))
f.close()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from lusmu.core import Input, Node, update_inputs
from lusmu.visualization import visualize_graph
import math
import operator


a = Input(name='length of cathetus a')
b = Input(name='length of cathetus b')


def square(x):
    return x ** 2


def sum_(*args):
    return sum(args)


def sqrt(square):
    print '** taking square root of {:.2f}'.format(square)
    return math.sqrt(square)


area_a = Node(name='square of a',
              action=square,
              inputs=Node.inputs(a))
area_b = Node(name='square of b',
              action=square,
              inputs=Node.inputs(b))
area_hypothenuse = Node(name='square of hypothenuse',
                        action=sum_,
                        inputs=Node.inputs(area_a, area_b))
hypothenuse = Node(name='length of hypothenuse',
                   action=sqrt,
                   inputs=Node.inputs(area_hypothenuse))
sin_alpha = Node(name='sin of alpha',
                 action=operator.div,
                 inputs=Node.inputs(a, hypothenuse))
alpha = Node(name='angle alpha',
             action=math.asin,
             inputs=Node.inputs(sin_alpha))
sin_beta = Node(name='sin of beta',
                action=operator.div,
                inputs=Node.inputs(b, hypothenuse))
beta = Node(name='angle beta',
            action=math.asin,
            inputs=Node.inputs(sin_beta))


print 'Enter float values for a and b, e.g.\n> 3.0 4.0'
while True:
    answer = raw_input('\n> ')
    if not answer:
        break
    value_a, value_b = answer.split()
    update_inputs([(a, float(value_a)),
                   (b, float(value_b))])
    print 'Length of hypothenuse: {:.2f}'.format(hypothenuse.value)
    print 'Angle alpha: {:.2f} degrees'.format(math.degrees(alpha.value))
    print 'Angle beta: {:.2f} degrees'.format(math.degrees(beta.value))


try:
    visualize_graph([hypothenuse], 'triangle.png')
    print 'View triangle.png to see a visualization of the traph.'
except OSError:
    print 'Please install graphviz to visualize the graph.'

#!/usr/bin/python
# Filename: chessboard.py
# -*- coding: utf-8 -*-

from Tkinter import *
import tkFont
import numpy as np
from string import maketrans
import time

class FICS(object):       
        pass
class ChessBoard(FICS):
        def __init__(self, data):
            self._data = data
        def create_chessboard(self):
            self.root = Tk() 
            self.square_size = 90
            self.font_size = self.square_size+2
            self.chessboard = Canvas(self.root,
                                     width=self.square_size*8,
                                     height=self.square_size*8)
            self.update_chessboard(self._data) # Draw the chessboard
            self.chessboard.pack()
            self.board_exist = True
        def update_chessboard(self, data):
            data = data[::-1]
            in_table = 'prnbqkx-RNBQKPX'          
            out_table ='prnbqkx tmvwloX'
            tran_table = maketrans(in_table, out_table)
            pieces = converted_data = list(data.translate(tran_table, ' <12>'))
            col = False,True
            colour_square = ( (col[0],col[1])* 4 + (col[1],col[0])*4 )*4
            file_board = [('a',0),('b',1),('c',2),('d',3),('e',4),
                          ('f',5),('g',6),('h',7),]
            rank_board = [('8',7),('7',6),('6',5),('5',4),('4',3),('3',2),
                          ('2',1),('1',0),]
            pieces=''
            for x,y in zip(colour_square,converted_data):
                    if x and y!=chr(32):
                        pieces = pieces+(y.upper())
                    elif x and y==chr(32):
                        pieces = pieces+('+')
                    else:
                        pieces = pieces+y
            # Create the master data list
            square = list(
                           [(7*self.square_size-x[1]*self.square_size,
                            y[1]*self.square_size,
                            x[0]+y[0],
                            pieces[(y[1]*8)+x[1]],)
                            for y in rank_board for x in file_board]
                         )
            self.chessboard.delete(ALL)
            for x in square:
                    self.output = self.chessboard.create_text(x[0]+self.square_size/2,
                                                              x[1]+self.square_size/2,
                                                              fill='black', font=('Chess Cases',
                                                               self.font_size,
                                                               'normal'))     
                    self.chessboard.itemconfig(self.output, text=x[3])
            self.chessboard.update_idletasks()
            return

        def show_bb(self, data):
        ''' Dev version shows a bitboard when testing.'''
        
                if data.type is not str:
                        result= np.binary_repr(data, 68)[::-1]
                else:
                        result = data
                print result[56:64]
                print result[48:56]
                print result[40:48]
                print result[32:40]
                print result[24:32]
                print result[16:24]
                print result[8:16]
                print result[0:8]

#-----------------------------------------------------------------------------------
#! /usr/bin/env python
# --------------------------------------------------------
# SQUARE ROOT CALCULATOR USING INTERVALL-SPLITTING
#
# description:
#	simple s_root approximation function _square_root(param1)
#	usage: int.py => enter positive number
#
# options: 
# 	return_param_1 = number of needed steps
#  	return_param_2 = final result of square root
#
# (c) fred
# --------------------------------------------------------
# settings [don't change unless you are babo]
steps = 1000 # number of max loop_steps
debug = 5   # max number of lines for debugging output

# app_description
print   '[-----------------------------]\n'+ \
	'|-- SQUARE ROOT  CALCULATOR --|\n'+ \
	'|-----------------------------|\n'+ \
	'|--  using intervall-split  --|\n'+ \
	'[-----------------------------]'

# normal input
num = raw_input('[*] Please insert number: ')

# func_for_calculation using black magic c0de :)
def _square_root(num):

	# lazy error_checking for failheads
	try: num = float(num)
	except ValueError: 
		print '[!] Value has to be a number'
		return -1
	if(num<=0): 
		print '[!] Value has to be positive'; 
		return -2

	print '[-] Calculating square root of: '+str(num)

	#set start_intervall limits [0,num]
	_I_o = num; 	# upper limit
	_I_u = 0; 	# lower limit
	print '[-] Lower limit: '+str(_I_u)+' Upper limit: '+str(_I_o)
	if(int(debug)>0): print '[-] Debug-information:'

	#black magic :>
	for i in range(0, steps): 

		_I_t = (_I_o+_I_u)/2 	 # define intervall-split
		if i<debug:              # print temp value, temp intervall and square
			print '['+str(i+1)+'] value: '+str(_I_t) \
			+'\tIntervall: ['+str(_I_u)+','+str(_I_o)+']'
		# check by type_cast to str char_by_char for len(_x_) cause no
		# external routines were allowed such as substr(), find() etc..
		# accuracy max 10^-10 due to length of [float]
		if(str(_I_t*_I_t)==str(num)):  break
		elif(_I_t*_I_t>num): _I_o=_I_t # change upper intervall limit
		elif(_I_t*_I_t<num): _I_u=_I_t # change lower intervall limit

	print '[.] .......................'
	if(i==steps-1):
		print '[!] '+str(steps-1)+' steps are reached: cant guarantee full accuracy'
		
	res1 = str(i+1)		# final number of steps
	res2 = str(_I_t)	# final result
	print '['+res1+'] Found square root with accuracy of 10^-10: ['+res2+']' # output
	return(res1,res2)	# return the shit to _main_ if needed (addr of call func)

# simple call root_function, usage of return[0],return[1] possible as well
_square_root(num)

# EOF 12.2013

__author__ = 'root'
def Square(x):
    return SquareHelper(abs(x), abs(x))

def SquareHelper(n, x):
    if n == 0:
        return 0
    return SquareHelper(n-1, x) + x
print Square(5)
print Square(-4)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from math import sqrt

def squareRootBi(x, epsilon):
	"""Assumes < >= 0 and epsilon > 0
	return y s.t. y * y is with in epsilon of x"""
	assert x >= 0, + str(x)
	assert epsilon > 0, + str(epsilon)
	low = 0
	high = x
	guess = (low + high) / 2.0
	ctr = 1  # counter
	while abs(guess **2 - x) > epsilon and ctr <= 100:
		if guess ** 2 < x:
			low = guess
		else:
			high = guess
		guess = (low + high)/2.0
		ctr += 1
	assert ctr <= 100
	print 'Bi method. NumIterations:', ctr, ' Estimate:', guess
	return guess

print squareRootBi(20000000000000000000, 0.01)
print sqrt(200000000000000000000)
from subtract_square_state import SubtractSquareState

class GameStateNode:
    '''
    A tree of possible states for a two-player, sequential move, zero-sum,
    perfect-information game.

    value: GameState -- the game state at the root of this tree
    children: list -- all possible game states that can be reached from this
 	game state via one legal move in the game.  children is None until grow
	is called.
    '''

    def __init__(self, game_state):
        ''' (GameStateNode, GameState) -> NoneType

        Initialize a new game state tree consisting of a single root node 
	that contains game_state.
        '''
        self.value = game_state
        self.children = []

    def __eq__(self, other):
        ''' (GameStateNode, object) -> bool

        Return whether this GameStateNode is equivalent to other, i.e., they
        contain equivalent GameStates, and equivalent children.  The order of
        their children does not matter.

        >>> s1 = SubtractSquareState('p1', current_total = 6)
        >>> s2 = SubtractSquareState('p2', current_total = 5)
        >>> s3 = SubtractSquareState('p1', current_total = 2)
        >>> leaf1 = GameStateNode(s1)
        >>> leaf2 = GameStateNode(s2)
        >>> leaf3 = GameStateNode(s3)
        >>> leaf1.__eq__(leaf2)
        False
        >>> root1 = GameStateNode(s1)
        >>> root1.children = [s2, s3]
        >>> root2 = GameStateNode(s1)
        >>> root1.__eq__(root2)
        False
        >>> root2.children = [s2, s3]
        >>> root1.__eq__(root2)
        True
        '''
        # Checking that the children lists have the same contents requires
        # checking that every element of one list is in the other, and vice
        # versa. Since checking "in" causes calls to the __eq__ method, we
        # end up recursing.
        return (type(self) == type(other) and
                self.value == other.value and        
                same_contents(self.children, other.children))


    def __str__(self):
        ''' (GameStateNode) -> str

        Return a convenient string representation of GameStateNode(self).

        >>> s = SubtractSquareState('p1', current_total = 17)
        >>> node = GameStateNode(s)
        >>> print(node)
        Current total: 17; next player: p1
        '''
        return self.value.__str__()


    def grow(self):
        ''' (GameStateNode) -> NoneType

        Grow the tree of all possible game state nodes that can be reached
	starting from this one.

        Assume that the game is finite (and so the tree will be finite).
        
        >>> a0 = SubtractSquareState('p1', current_total = 0)
        >>> b1 = SubtractSquareState('p2', current_total = 1)
        >>> a2 = SubtractSquareState('p1', current_total = 2)
        >>> b3 = SubtractSquareState('p2', current_total = 3)
        >>> a4 = SubtractSquareState('p1', current_total = 4)
        >>> b0 = SubtractSquareState('p2', current_total = 0)
        >>> a0_node = GameStateNode(a0)
        >>> b1_node = GameStateNode(b1)
        >>> b1_node.children = [a0_node]
        >>> a2_node = GameStateNode(a2)
        >>> a2_node.children = [b1_node]
        >>> b3_node = GameStateNode(b3)
        >>> b3_node.children = [a2_node]
        >>> b0_node = GameStateNode(b0)
        >>> a4_node = GameStateNode(a4)
        >>> a4_node.children = [b0_node, b3_node]
        >>> root = GameStateNode(SubtractSquareState('p1', current_total = 4))
        >>> root.grow()
        >>> root.__eq__(a4_node)
        True
        '''
        self.children = []
        moves = self.value.possible_next_moves()
        for move in moves:
            state = self.value.apply_move(move)
            node = GameStateNode(state)
            node.grow()
            self.children.append(node)


def same_contents(L1, L2):
    ''' (list, list) -> bool
    
    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.
    
    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and 
            all([x in L2 for x in L1]) and 
            all([x in L1 for x in L2]))


def _nodes(root):
    ''' (GameStateNode) -> list
    
    Return the list of nodes in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_nodes(root))
    13
    '''
    nodes = [root]
    for node in root.children:
        nodes += _nodes(node)
    return nodes


def node_count(root):
    ''' (GameStateNode) -> int
    
    Return the number of nodes in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    return len(_nodes(root))


def _leafs(root):
    '''(GameStateNode) -> list
    
    Return the list of leaves in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_leafs(root))
    4
    '''
    leafs = []
    if root.value.over:
        leafs.append(root)
    for node in root.children:
        leafs += _leafs(node)
    return leafs


def leaf_count(root):
    '''(GameStateNode) -> int
    
    Return the number of leaves in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    return len(_leafs(root))


def _distinct_nodes(root):
    '''(GameStateNode) -> set
    
    Return the set of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_nodes(root))
    10
    '''
    nodes = set()
    nodes.add(str(root))
    for node in root.children:
        nodes |= _distinct_nodes(node)
    return nodes


def distinct_node_count(root):
    '''(GameStateNode) -> int
    
    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    return len(_distinct_nodes(root))


def _distinct_leafs(root):
    '''(GameStateNode) -> set
    
    Return the set of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_leafs(root))
    2
    '''
    leafs = set()
    if root.value.over:
        leafs.add(str(root))
    for node in root.children:
        leafs |= _distinct_leafs(node)
    return leafs
                      

def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int
    
    Return the number of leaves representing distinct game states in the
    tree rooted at root.
       
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    return len(_distinct_leafs(root))


def branching_stats(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    result = {}
    nodes = _nodes(root)
    for i in range(len(nodes)):
        count = 0
        for node in nodes:
            if len(node.children) == i:
                count += 1
        if count > 0:
            result[i] = count
    return result

            
def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]
    
    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    leafs = _leafs(root)
    p1 = p2 = tie = 0
    for leaf in leafs:
        if leaf.value.winner("p1"):
            p1 += 1
        elif leaf.value.winner("p2"):
            p2 += 1
        else:
            tie += 1
    return [p1, p2, tie]


def _games(root, games=[], t=[]):
    '''(GameStateNode, games, t) -> list of list

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_games(root))
    4
    '''
    t = t + [root]
    if root.value.over:
        games = games + [t]
    for node in root.children:
        games = _games(node, games, t)
    return games


def game_lengths(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    result = {}
    games = _games(root)
    for game in games:
        lenght = len(game) - 1
        result[lenght] = result.get(lenght, 0) + 1
    return result


def game_descriptions(root):
    ''' (GameStateNode) -> list of str
    
    Return a list containing a str describing each complete game that is
    possible from the game stored at root.
    
    Assume root is the root of a game state tree specifically for the game
    Subtract Square.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    descriptions = []
    games = _games(root)
    for game in games:
        abbreviateds = [abbreviated(node.value) for node in game]
        description = " -> ".join(abbreviateds)
        if game[-1].value.winner("p1"):
            description += " = p1 wins!"
        elif game[-1].value.winner("p2"):
            description += " = p2 wins!"
        else:
            description += " = tie!"
        descriptions.append(description)
    return descriptions   

            
def abbreviated(s):
    '''(GameState) -> str
    
    Return an abbreviated str representation of SubtractSquareState s.
    '''
    
    return "{}:{}".format(s.next_player, s.current_total)

if __name__ == '__main__':
    import doctest
    doctest.testmod()



"""
An algorithm for finding the square root of an integer, x

Start by initializing s as a guess. 
If we take the average of s + x/s for enough iterations, we will
always converge on the square root.

Why: If our guess, s, is too small, x/s will be larger than the true square root
	 If our guess, s, is too large, x/s will be smaller than the true squeare root
	 If it's just right, x/s will be the square root.

Therefore, continuous average iterations will hone in on the true square root!

Enhancements: max_iteration and tolerance -- cap the iterations, but check the delta of s at each 
			  iteration and break from the loop if delta is less than our tolerance level.


"""

def sqrt(number, guess, max_iterations=200, tolerance=1.e-14):
	
	s = guess

	for k in range(max_iterations):
		print ("Before iteration: %s, s = %20.15f" % (k, s))
		s0 = s
		s = 0.5 * (s + number/s)
		delta_s = s - s0
		if abs(delta_s / number) < tolerance:
			break
	print ("After %s iterations, s = %20.15f" % (k+1, s))
	return s 



if __name__ == "__main__":
	sqrt(16, 1)

def matches_template(nr):
  nr_str = str(nr)
  return (len(nr_str) == 19 and
          nr_str[0] == '1' and
          nr_str[2] == '2' and
          nr_str[4] == '3' and
          nr_str[6] == '4' and
          nr_str[8] == '5' and
          nr_str[10] == '6' and
          nr_str[12] == '7' and
          nr_str[14] == '8' and
          nr_str[16] == '9' and
          nr_str[18] == '0')

def solve():
  min_root = 1010101010   # multiple of 10, >= sqrt(1020304050607080900)
  max_root = 1389026620   # multiple of 10, <= sqrt(1929394959697989990)
  for root in range(min_root, max_root+1, 10):
    square = root * root
    if matches_template(square):
      return root
  return None

print(solve())

#!/usr/bin/python

import math

def is_square(apositiveint):
	if(apositiveint==1):
		return True
	x = apositiveint // 2
	seen = set([x])
	while x * x != apositiveint:
		x = (x + (apositiveint // x)) // 2
		if x in seen:
			return False
		seen.add(x)
	return True

def is_fair(num):
	number=list(str(num))
	length=len(number)
	for i in range(0,length/2+1):
		if(number[i]!=number[length-1-i]):
			return False
	return True

T = int(raw_input())

for case in xrange(1,T+1):
	split=raw_input().split(" ")
	A=long(split[0])
	B=long(split[1])
	count=0
	num=A
	while num<=B:
		if(is_fair(num)):
			if(is_square(num)):
				root = long(math.sqrt(num))
				if(is_fair(root)):
					count = count+1
		num=num+1
	print "Case #"+str(case)+": "+str(count)
		

def square_root(x):
	"""
	this is the ancient way to calculate the square_root
	step 1: you guess a number g, and get the result of g**2
	step 2: if it's not close enough to X, take a new guess "g" with the formula below
	step 3: go back to step 2 until it's close enough.
	"""
	g = 42.0
	while g * g - x < -0.001 or g * g - x > 0.001:
		g = (g + x / g) / 2
	return g

def test():
	print square_root(9)
	print square_root(100)
	print square_root(0)
	print square_root(25)

test()

def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x    = 1
    xOld = 1
    while True:
        aux = ( x + ( n / x ) ) / 2
        if aux == x:
            return x
        if aux == xOld:
            return min(x, xOld)
        xOld = x
        x = aux

pattern = [9, 8, 7, 6, 5, 4, 3, 2, 1]

def check(x):
    n = x * x
    for x in pattern:
        if n % 10 != x:
            return False
        n /= 100
    return True

def solve():
    start = iSqrt(19293949596979899)
    start /= 10
    n = start
    while n > 0:
        if check(10 * n + 3):
            return 100 * n + 30
        if check(10 * n + 7):
            return 100 * n + 70
        n -= 1
    return 0

if __name__ == "__main__":
    result = solve()
    print "Result: %d" % result

__author__ = 'student'


import math

class Function:
    def __init__(self, key, header, explanation, compute):
        self.key = key
        self.header = header
        self.explanation = explanation
        self.compute = compute

def sqrt(x):
    return math.sqrt(x)

function_list = [
    Function('sqrt', 'SQRT', "Square root function", sqrt),
    Function('sqr', "Square", "Square of the argument", (lambda x : x*x)),
    Function('log2', "Log2", "Binary logarithm", (lambda x : math.log2(x))),
    Function('cube', "Cube", "Cube of the argument", (lambda x: x*x*x))
    ]

def getFunctionByKey(key):
    for func in function_list:
        if key == func.key:
            return func

# Modified 2/7/14

# Can't skip any of these, must give N, then accuracy if you want, then guess
def square_root(N, accuracy=0.000001, guess=1.0):
    
    while abs(N - guess**2) > accuracy:
        quotient = N / guess
        guess = (guess + quotient)/2.0
    return guess

print "The square root of 2 is:", square_root(2)
print "The square root of 2 is:", square_root(2, 0.001)
print "The square root of 4 is:", square_root(4, 0.000001)
print "The square root of 25 is:", square_root(25, 0.0002)
print "The square root of 1000 is:", square_root(1000, 0.01, 30)
print "The square root of 2000 is:", square_root(2000, guess=35)
print "The square root of 3000 is:", square_root(3000, guess=40, accuracy=0.01)

# This files contains all the operations that are used frequently (by me) while solving the problems from project euler as functions.
import math

def is_prime(num):
	"""Determines whether a number is prime or not."""
	square_root = int(math.ceil(math.sqrt(num)))
	for n in range(2, square_root+1):
		if num % n == 0:
			if num != n:
				return False

	return True

def factors(num):
	"""Finds all the factors of a given number and returns them as a list."""
	if is_prime(num) == True:
		factors = [1, num]
		return factors
	else:
		factors = [1]
		square_root = int(math.ceil(math.sqrt(num)))
		
		for n in range(2, square_root+1):
			if num % n == 0:
				factors.append(n)

		for n in range(1, len(factors)):
			new_n = num / factors[n]
			if new_n not in factors:
				factors.append(num / factors[n])

		factors.append(num)
		return factors

def prime_factors(num):
	num_factors = factors(num)
	prime_factors = []

	for n in num_factors:
		if is_prime(n):
			prime_factors.append(n)

	return prime_factors
import numpy
import time
import math
start_time = time.time()

def get_primes(n):
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    sieve = numpy.ones(n / 3 + (n % 6 == 2), dtype=numpy.bool)
    for i in xrange(1, int(n ** 0.5) / 3 + 1):
        if sieve[i]:
            k = 3 * i + 1 | 1
            sieve[k * k / 3::2 * k] = False
            sieve[k * (k - 2 * (i & 1) + 4) / 3::2 * k] = False
    return numpy.r_[2, 3, ((3 * numpy.nonzero(sieve)[0][1:] + 1) | 1)]


lim = 10 ** 50
root = lim ** 0.5
primes = get_primes(int(math.sqrt(lim))+1)

squares = set()
for i in primes:
    if primes[i] > root:
        break
    square = j = primes[i] ** 2
    while j < lim:
        squares.add(j)
        j += square

print len(squares)
print 2 ** 50 - len(squares)

print 'Seconds', time.time() - start_time

__author__ = 'Shivaji'
import math

def squareroot(a,b):
    a1=a*a
    b1=b*b
    c=a1+b1
    result=math.sqrt(c)
    print("Result of square root of a %d and b %d is %c",a,b,result)
    if result.is_integer()==False:
        return 0
    else:
        return result


a=3
b=4
c=5
sum=0
n=2

while(True):
    result=squareroot(a,b) #square root of a square + b square
    if result:
        c=result
        sum=a+b+c
        if sum>=1000:
            print("a:%n b: %n c: %n sum is",a,b,c,math.pow(a,2)+math.pow(b,2),math.pow(c,2),sum)
            break
        else:
            a=3*n
            b=4*n
            n=n+1

a1=3*n-1
# https://www.hackerrank.com/challenges/encryption
# square substitution cypher
def squareCypher(s):
    from math import sqrt
    s = s.replace(' ', '')

    root = sqrt(len(s))
    cols = int(root) + 1 if root % 1 else int(root)

    result = ''
    for i in range(cols):
        for j in range(cols):
            index = j * cols + i
            if index < len(s):
                result += s[index]

        result += ' '

    return result

print squareCypher(raw_input())
"""
Root object

Format:

"""

import Lexer
from Command import Command
from Root import Root

class SquareRoot(Command):
	def __init__(self):
		super(self.__class__, self).__init__(1)

	def apply_args(self,args):
		return Root().apply_args([" "]+args)
# -*- coding: utf-8 -*-

import math

# math.sqrt fuction

def square_root(a):
	x = a
	while True:
	    y = (x + a/x) / 2.0
	    if abs(y-x) < 0.001:
	        break
	    x = y
	return y

def test_square_root(a):
	ary = []
	ary.append(a)
	ary.append(square_root(a))
	ary.append(math.sqrt(a))
	ary.append(abs(ary[1]-ary[2]))
	return ary

i = 1
while i < 10:
	print test_square_root(i)
	i = i + 1
'''
7/23/12
Page 24
'''

def testable(x):
    r"""
    The 'testable' funtion returns the square root of its
    parameter, or 3, whichever is larger.
    >>> testable(7)
    3.0
    >>> testable(16)
    4.0
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    return x**0.5
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

__author__ = 'swenson'

import math

def example_function(x):
    """Compute the square root of x and return it."""
    return math.sqrt(x)
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

class Calculator(object):

	def __init__(self):
		self.result = 0
	
	def add(self, n):
		self.result = self.result + n

	def subtract(self, n):
		self.result = self.result - 1

	def multiply(self, n):
		pass

	def divide(self, n):
		self.result = self.result / n

	def square(self, n):
		self.result = n * n

	def squareRoot(self, n):
		while True:
			pass

	def clear(self):
		self.result = 0

	def switchOn(self):
		self.result = 0

	def switchOff(self):
		pass

	def getResult(self):
		return self.result

import numpy as np
from scipy import sparse


def square_root(x):
    return np.sqrt(x)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# encoding: utf8
'''
Count Complete Tree Nodes
Given a complete binary tree, count the number of nodes.

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.




'''

import unittest
from pprint import pprint
import pdb

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution1: # TLE
    # @param {TreeNode} root
    # @return {integer}
    def countNodes(self, root):
        if root==None:
            return 0
        return 1+self.countNodes(root.left)+self.countNodes(root.right)

class Solution: 
    # @param {TreeNode} root
    # @return {integer}
    def countNodes(self, root):
        if root==None:
            return 0
        leftdepth=0
        rightdepth=0
        p=root
        while p.left:
            p=p.left
            leftdepth+=1
        p=root
        while p.right:
            p=p.right
            rightdepth+=1
        if leftdepth==rightdepth:
            return 2**(leftdepth+1)-1
        else:
            return 1+self.countNodes(root.left)+self.countNodes(root.right)

class testCase(unittest.TestCase):
    def setUp(self):
        pass
        self.a=Solution()

    def testLeet(self):
        a=['10100',
            '10111',
            '11111',
            '10010',]
        self.assertEqual(self.a.maximalSquare(a), 4)
        self.assertEqual(self.a.maximalSquare(["1"]), 1)
        a=["0001",
            "1101",
            "1111",
            "0111",
            "0111"]
        self.assertEqual(self.a.maximalSquare(a), 9)

if __name__ == '__main__':
    unittest.main()
# coding=utf-8
# AC Rate: 22.3%
# https://oj.leetcode.com/problems/sqrtx/

# Implement int sqrt(int x).
# Compute and return the square root of x.

class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        
import math

def is_square(n):
    root = int(math.sqrt(n))
    if root*root == n:
        return True
    else:
        return False


def count_side(a,b):
    n_pt = 0
    
    for x in range(0,a+1):
        for y in range(0,b+1):
            if y*a  == -b*x + a*b:
                n_pt+=1
    return n_pt


def calc_twice_area(a,b,c,d):
    area = 0
    area += a*b
    area += a*d
    area += d*c
    area += b*c

    return area

def count_square_quads(m):
    boundary = {}
    for i in range(1,m+1):
        for j in range(1,m+1):
            boundary[i + j*(10**4)] = count_side(i,j)

    n_with_square = 0
    for a in range(1,m+1):
        if m==100: print "a = ", a
        for b in range(1,m+1):
            for c in range(1,m+1):
                for d in range(1,m+1):
                    tot_boundary = (boundary[a+b*(10**4)] + 
                                    boundary[a+d*(10**4)] + 
                                    boundary[d+c*(10**4)] + 
                                    boundary[b+c*(10**4)] )
                    tot_boundary-=4
                    n_pts = int(calc_twice_area(a,b,c,d) - tot_boundary + 2)
                    n_pts /= 2
                    if is_square(n_pts): n_with_square += 1
    print "number of squares for m = ", m, "is", n_with_square

count_square_quads(1)
count_square_quads(2)
count_square_quads(3)
count_square_quads(4)
count_square_quads(5)
count_square_quads(6)
count_square_quads(7)
count_square_quads(8)
count_square_quads(9)
count_square_quads(10)
count_square_quads(11)
count_square_quads(12)
count_square_quads(13)
count_square_quads(14)
count_square_quads(15)
count_square_quads(100)

# Odd period square roots
# Problem 64
# All square roots are periodic when written as continued fractions and can be written in the form:


# It can be seen that the sequence is repeating. For conciseness, we use the notation v23 = [4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely.

# The first ten continued fraction representations of (irrational) square roots are:

# v2=[1;(2)], period=1
# v3=[1;(1,2)], period=2
# v5=[2;(4)], period=1
# v6=[2;(2,4)], period=2
# v7=[2;(1,1,1,4)], period=4
# v8=[2;(1,4)], period=2
# v10=[3;(6)], period=1
# v11=[3;(3,6)], period=2
# v12= [3;(2,6)], period=2
# v13=[3;(1,1,1,1,6)], period=5

# Exactly four continued fractions, for N = 13, have an odd period.

# How many continued fractions for N = 10000 have an odd period?

import time
import help
from math import sqrt

def solve(max):
    print(len(list(filter(hasOddRootPeriod, range(1,max+1)))))
    
def hasOddRootPeriod(a):
    return getRootPeriod(a) % 2 == 1

def getRootPeriod(a):
    l = help.conFraction(a)
    return len(l)-1
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def square_root(a, x):
	y = ( x + a/x) / 2
	if y == x:
		return y
	return square_root(a, y)


print square_root(4,3)

import time

start_time = time.time()

txt = open('98.txt').read().split(',')


def is_anagram(a, b):
    """
    Check if a is an anagram of b
    """
    return set(str(a)) == set(str(b))


def is_palindrom(n):
    return str(n)[::-1] == str(n)


#def get_squares(a, b):
#    """
#    Gets the squares between a and b
#    """
#    start, end = a ** 0.5, b ** 0.5
#    for root in xrange(start, end):



def get_square_anagram(a):
    """
    Ex.: 36 ** 2 = 1296 anagram of 9216 = 96 ** 2
    """


lim = int((10 ** 11) ** 0.5)

squares = [i ** 2 for i in range(lim)]
print len(squares)

print time.time() - start_time, 'seconds'

from math import pow

def sqrt_n(value, exponent):
    return pow(value, 1.0/exponent)

class Visitor(object):
    def __init__(self):
        pass
    def visitNumber(self, number):
        pass
    def visitPlus(self, plus):
        pass
    def visitMul(self, mul):
        pass
    def visitPower(self, power):
        pass
    def visitSquareRoot(self, sqrt):
        pass

class CalculatorVisitor(Visitor):
    def __init__(self):
        pass

    def visitNumber(self, number):
        return int(number.value.value)

    def visitPlus(self, plus):
        return plus.left.accept(self) + plus.right.accept(self)

    def visitMul(self, mul):
        return mul.left.accept(self)* mul.right.accept(self)

    def visitPower(self, power):
        return pow(power.value.accept(self), power.power.accept(self))

    def visitSquareRoot(self, sqrt):
        return sqrt_n(sqrt.value.accept(self), sqrt.sqrtpower.accept(self))

    def visitEquation(self, eq):
        return

class PrinterVisitor(Visitor):
    def __init__(self):
        pass

    def visitNumber(self, number):
        return "{}".format(number.value)

    def visitPlus(self, plus):
        return "({} + {})".format(plus.left.accept(self), plus.right.accept(self))

    def visitMul(self, mul):
        return "({} * {})".format(mul.left.accept(self), mul.right.accept(self))

    def visitPower(self, power):
        return "pow({}, {})".format(power.value.accept(self), power.power.accept(self))

    def visitSquareRoot(self, sqrt):
        return "sqrt_n({}, {})".format(sqrt.value.accept(self), sqrt.sqrtpower.accept(self))

    def visitEquation(self, eq):
        return "{} = {}".format(eq.left.accept(self), eq.right.accept(self))

class Expression(object):
    def __init__(self):
        pass

class SquareRoot(Expression):
    def __init__(self, value, sqrtpower):
        self.value = value
        self.sqrtpower = sqrtpower
    def accept(self, visitor):
        return visitor.visitSquareRoot(self)

class Power(Expression):
    def __init__(self, value, power):
        self.value = value
        self.power = power
    def accept(self, visitor):
        return visitor.visitPower(self)

class Mul(Expression):
    def __init__(self, left, right):
        self.left = left
        self.right = right
    def accept(self, visitor):
        return visitor.visitMul(self)

class Plus(Expression):
    def __init__(self, left, right):
        self.left = left
        self.right = right
    def accept(self, visitor):
        return visitor.visitPlus(self)

class Number(Expression):
    def __init__(self, value):
        self.value = value
    def accept(self, visitor):
        return visitor.visitNumber(self)

class Equation(Expression):
    def __init__(self, left, right):
        self.left = left
        self.right = right
    def accept(self, visitor):
        return visitor.visitEquation(self)



def Sqrt(x, e):
    if x == 0:
        return 0
    # find the square root between i&j
    i,j = 1, x/2+1
    # while error allows
    while j-i >= e :
        c = (i+j)/2
        if c**2 == x:
            return c
        elif c**2 > x:
            j = c - e
        else:
            i = c + e
    return j

print Sqrt(2,0.001)

import math

#######################
# Statistical helpers #
#######################

def avg(vals):
    """Calculate average of values in list."""
    return sum(vals) / float(len(vals))


def disp(y_1, y_2):
    """Calculate sum of differences between f[] and y[] values."""
    total = 0
    for i in range(min(len(y_1),
                       len(y_2))):
        total += (y_1[i] - y_2[i]) ** 2

    return total

def std(y_1, y_2):
    """Calculate square root of dispersion."""
    return math.sqrt(disp(y_1, y_2))

import sys,math
#-------------------------------------------------
def distance(x,y) :
	"""
	Prints distance from origin to (x,y).
	Using Pytagoras c = sqrt(a**2+b**2)

	"""
	# Square the argumnts and add them.
	
	a = x**2 + y**2

	# Return the square root.

	return math.sqrt(a)

# Retrieve the command line arguemtns and 
# converte the string to floating-point numbers.


x = float(sys.argv[1])
y = float(sys.argv[2])

# Call the distance function.

d = distance(x,y)

#Print the result.

print 'Distance to origin =', d

import copy
import pickle
import re
import sys
import time

from Dawg import Dawg
from sets import Set
from Square import *

global dawg
valueMap = {'A':1, 'B':4, 'C':4, 'D':2, 'E':1, 'F':4, 'G':3, 'H':3, 'I':1, 'J':10, 'K':5, 'L':2, 'M':4, 'N':2, 'O':1, 'P':4, 'Q':10, 'R':1, 'S':1, 'T':1, 'U':2, 'V':5, 'W':4, 'X':8, 'Y':3, 'Z':10, '*':0}
rack = []  #list of tiles
spaceSquareList = []
crossCheckSet = Set()
plays = {}
boardHorizontal = []
boardVertical = []
global adjacentPlacedTileId
bestScore = 0
bestPlay = 'no plays'
global currentBoard

def formatBoard():
  global rack
  rack = re.findall('[a-z]|[*]', sys.argv[1])
  
  boardInput = open('../resources/board.txt').read().split()
  row = []
  for rowInputString in boardInput:
    rowInputList = re.findall('[-]|DW|TW|DL|TL|[a-z]', rowInputString)
    boardHorizontal.append(createRowLinkedList(rowInputList))

  collumn = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]] 
  for rowInputString in boardInput:
    for collumnNum, squareInput in enumerate(re.findall('[-]|DW|TW|DL|TL|[a-z]', rowInputString)):
      collumn[collumnNum].append(squareInput)
  for collumnInputList in collumn:
    boardVertical.append(createRowLinkedList(collumnInputList))
    
def createRowLinkedList(inputList):
  parseSquare(inputList)
  
  rowHead = extendRowRight(inputList)

  return rowHead

def extendRowRight(inputList):
  input = inputList[0]
  square = parseSquare(input)
  
  if len(inputList[1::]) > 0:
    square.nextSquare = extendRowRight(inputList[1::])
    return square
  else:
    endSquare = Square()
    endSquare.tile = '$'
    square.nextSquare = endSquare
    return square

def parseSquare(input):
  square = Square()
  if input == 'DW':
    square.wordBonus = 2
  elif input == 'TW':
    square.wordBonus = 3
  elif input == 'DL':
    square.letterBonus = 2
  elif input == 'TL':
    square.letterBonus = 3
  else:
    square.tile = input
  
  return square

def findWords(row, rowPointer, rowString):
  global adjacentPlacedTileId
  
  row.append(rowPointer)
  rowString += rowPointer.tile
  
  #tiles on the board (k == 0)
  m = re.search('([a-z]+)-$', rowString)
  if m != None:
    adjacentPlacedTileId = row[m.end(1)].id
    partialWord = row[m.start(1):m.end(1)]
    ExtendRight(partialWord, dawg.getNode(m.group(1)), rowPointer)
    
  #adding tiles from rack (k > 0)
  m = re.search('(-*)-[a-z]$', rowString)
  if m != None:
    adjacentPlacedTileId = row[m.end(1)+1].id
    partialWord = row[m.start(1):m.end(1)]
    LeftPart(partialWord, dawg.root, len(m.group(1)), row[m.end(1)])
    
  if rowPointer.nextSquare != None:
    findWords(row, rowPointer.nextSquare, rowString)
  
def LeftPart(partialWord, N, limit, square):
  ExtendRight(partialWord, N, square)
  if limit > 0:
    for Eletter, Enode in N.edges.items():
      if Eletter in rack:
        #insert tile at anchor square (pushing back the current leftPart --LP[])
        rack.remove(Eletter)
        #push LP back to the left one tile to make room for new tile to be placed at anchor square
        shiftLPLeft(partialWord, Eletter)
        LeftPart(partialWord, Enode, limit-1, square)
        #remove tile from anchor space, push LP back to the right
        shiftLPRight(partialWord)
        rack.append(Eletter)

def shiftLPLeft(leftPart, newTile):
  rightTile = newTile
  leftPart.reverse()
  for square in leftPart:
    tempTile = square.tile
    square.tile = rightTile
    rightTile = tempTile
  leftPart.reverse()

def shiftLPRight(leftPart):
  leftTile = '-'
  for square in leftPart:
    tempTile = square.tile
    square.tile = leftTile
    leftTile = tempTile

def ExtendRight(partialWord, N, square):
  if N.final and (square.tile == '-' or square.tile == '$'):
    addLegalMove(partialWord)
  if (square.tile == '-'):
    for Eletter, Enode in N.edges.items():
      if Eletter in rack : #TODO: and (E.letter in crossCheckSet)
        if square.nextSquare != None:
          rack.remove(Eletter)
          square.tile = Eletter
          partialWord.append(square)
          ExtendRight(partialWord, Enode, square.nextSquare)
          partialWord.pop()
          square.tile = '-'
          rack.append(Eletter)
  if re.match("^[a-z]$", square.tile):
    if square.tile in N.edges:
      Enode = N.edges[square.tile]
      if square.nextSquare != None:
        partialWord.append(square)
        ExtendRight(partialWord, Enode, square.nextSquare)
        partialWord.pop()

def addLegalMove(move):
  global adjacentPlacedTileId
  
  for square in move:
    if square.id == adjacentPlacedTileId:
      tallyPoints(move)

def tallyPoints(move):
  global bestScore
  global bestPlay
  
  score = 0
  word = ''
  wordBonus = 1
  for placement in move:
    if (placement.tile != '-' and placement.tile != '$'):
      word += placement.tile
      score += valueMap.get(placement.tile.upper()) * int(float(placement.letterBonus))
      wordBonus = wordBonus * placement.wordBonus
  score = score * wordBonus
  if score >= bestScore:
    bestScore = score
    bestPlay = ''
    for square in currentBoard:
      while square.nextSquare != None:
        bestPlay += '|' + square.tile
        square = square.nextSquare
      bestPlay += '|\n'
  plays[word] = score
#  print word, score

def sortMoves():  
  playList = [x for x in plays.items()]
  playList.sort(key = lambda x: x[0]) # sort by key
  playList.sort(key = lambda x: x[1]) # sort by value
  for word, score in playList:
    print word, score

if __name__ == '__main__':  
  start = time.time()
  dawg = Dawg()
  try:
      dawg = pickle.load(open('../resources/save.p', 'rb'))
  except:
    words = open("enable1.txt", 'rt').read().split()
    words.sort()
    for word in words:
      dawg.insert(word)
    dawg.finish()
    pickle.dump(dawg, open('../resources/save.p', 'wb'))

#  formatSpace() #creates rack, spaceSquareList
  
  formatBoard()
  for rowNum in range(0,15):
    plays = {}
    print '____ROW: ', rowNum
    rowHead = boardHorizontal[rowNum]
    currentBoard = boardHorizontal
    findWords(list(), rowHead, '')
    
  print bestPlay
  print bestScore
#    sortMoves()
  for collumnNum in range(0,15):
    plays = {}
    print '____COL: ', collumnNum
    collumnHead = boardVertical[collumnNum]
    currentBoard = boardVertical
    findWords(list(), collumnHead, '')
#    sortMoves()  
    
  print bestPlay
  print bestScore
  print time.time() - start

'''
Created on 16.08.2014


Problem 12 of Euler Problems

"What is the value of the first triangle number to have over five hundred divisors"
https://projecteuler.net/problem=12

@author: vls
'''
import Problem_001
import Problem_003
import numpy

def return_all_factors(n):
    """faster way to get all factors"""
    #primes=Problem_003.primesfrom2to(n)
    square_root = int(numpy.sqrt(n))
    if square_root*square_root!=n:
        return reduce(list.__add__, 
                ([i, n//i] for i in range(1,int(square_root)) if n % i == 0))
    else:
        factor_list = reduce(list.__add__,([i, n//i] for i in range(1,int(square_root)) if n % i == 0))
        factor_list.append(square_root)
        return factor_list

def do_problem_12():
    """method is too slow! -after several hours no result: up to triangle number: 63850650"""        
    number_of_factors = 0
    n=11300
    
    while number_of_factors<=500:
        n=n+1
        number_of_factors=len(Problem_003.list_factors(Problem_001.sum_of_all_whole_numbers(n)))
        if n%100==0:
            print str(Problem_001.sum_of_all_whole_numbers(n))+':'+str(number_of_factors)
        
    print '*****'
    print str(Problem_001.sum_of_all_whole_numbers(n))+':'+str(number_of_factors)
    
def get_number_of_factors(n):
    square_root = numpy.sqrt(n)
    number_of_factors=0
    if n%square_root==0:
        number_of_factors=-1
   
    for i in range(1,int(square_root)+1):
        if n%i ==0:
            number_of_factors+=2
    return number_of_factors

def do_problem_12_try2(max_factors):
    """method is too slow! -after several hours no result: up to triangle number: 63850650"""        
    number_of_factors = 0
    n=0
    
    while number_of_factors<=max_factors:
        n=n+1
        number_of_factors=get_number_of_factors(Problem_001.sum_of_all_whole_numbers(n))

    dictionary ={}

    dictionary[Problem_001.sum_of_all_whole_numbers(n)] = return_all_factors(Problem_001.sum_of_all_whole_numbers(n))
    
    return dictionary

    
if __name__ == '__main__':
    print do_problem_12_try2(500)
import math

def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a/x) / 2
        if abs(y-x) < epsilon:
            return y
        x = y

a = 1.0
print len(str(a))*" "
while a < 10:
    print str(a) + (14 - len(str(a)))*" ",
    res1 = square_root(a)
    print str(res1) + (14 - len(str(res1)))*" ",
    res2 = math.sqrt(a)
    print str(res2) + (14 - len(str(res2)))*" ",
    print abs(res1-res2)
    a += 1

def square_root(n, start=None, end=None):
  if start == None: start = 1
  if end == None: end = n
  mid = (end + start) / 2
  print (start, end, mid)
  squared_n = mid * mid
  if squared_n == n:
    return mid
  elif squared_n > n:
    return square_root(n, start, mid)
  elif squared_n < n:
    return square_root(n, mid, end)

print square_root(625)



import math

def is_prime(n):
	if n < 2:
		return False
	i = 2
	while (i*i) <= n:
		if n%i == 0:
			return False
		i+=1
	return True

def is_palindromic(num):
    return str(num) == str(num)[::-1]

def square_sum(num):
	root = int(math.sqrt(num))
	sum = 0
	index = 1
	while index < root:
		sum = 0
		for i in xrange(index, root+1):
			sum += i*i
			if sum == num:
				print i,sum
				return True
			if sum > num:
				break
	
		index+=1
	return False

numbers = []
for i in xrange(1,100000000):
	if is_palindromic(i) and square_sum(i):
		numbers.append(i)

print sum(numbers)
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from IPython import embed
from pylab import *
class LinearEvaluator(object):
	"""Evaluate a bilinear learner"""
	def __init__(self):
		super(LinearEvaluator, self).__init__()
	
	def evaluate(self,X,Y,theta,bias=None):
		pass

class SquareEval(LinearEvaluator):
	"""sum of the square difference between y and x . theta + bias"""
	def __init__(self):
		super(SquareEval, self).__init__()

	def evaluate(self,X,Y,theta,bias=None):
		total = 0;
		dotproduct = X.dot(theta)
		if bias is not None: dotproduct += bias
		diff = Y - dotproduct
		diff = diff[~np.isnan(diff)]
		total = pow(diff[~np.isnan(diff)],2).sum()
		dotproduct[np.isnan(Y)] = 0
		diffmat = ((Y - dotproduct)[~np.isnan(Y)])
		diffmat = diffmat.reshape(Y.shape[1],Y.shape[0]/Y.shape[1]).T
		diffmatsse = pow(diffmat,2).sum(axis=0)
		return {
			"totalsse":total,
			"diff":diffmat,
			"diffsse":diffmatsse,
			"dotproduct":dotproduct
		}

class MeanEval(SquareEval):
	"""The SquareEval divided by the total number of Ys (i.e. tasks and days)
	being estimated"""
	def __init__(self):
		super(MeanEval, self).__init__()

	def evaluate(self,X,Y,theta,bias=None):
		ssed = super(MeanEval,self).evaluate(X,Y,theta,bias)
		ndays = Y.shape[0]/Y.shape[1]
		ssed["totalsse"] = ssed["totalsse"]/Y[~np.isnan(Y)].size
		ssed["diff"] = ssed["diff"]/ndays
		ssed["diffsse"] = ssed["diffsse"]/ndays
		return ssed

class RootMeanEval(MeanEval):
	"""The square root of the MeanEval"""
	def __init__(self):
		super(RootMeanEval, self).__init__()

	def evaluate(self,X,Y,theta,bias=None):
		ssed = super(RootMeanEval,self).evaluate(X,Y,theta,bias)
		ssed["totalsse"] = sqrt(ssed["totalsse"])
		ssed["diffsse"] = sqrt(ssed["diffsse"])
		return ssed
		
		
		
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import math

def square_root(a):
	x = a/2.0
	epsilon = 0.0000000001
	while True:
		y = (x + a/x) / 2
		if abs(y-x) < epsilon:
			break
		x = y
	return x

def test_square_root(a):
	i = 1.0	
	while i <= a:
		print i,
		print square_root(i),
		print math.sqrt(i),
		print abs(square_root(i) - math.sqrt(i))
		i = i + 1

test_square_root(9)



# Chapter 7
# Section 7.2

def countdown(n):
    while n > 0:
        print n
        n = n - 1
    print 'Blastoff!'

countdown(10)

def sequence(n):
    while n != 1:
        print n,
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1

sequence(80)
sequence(45)
sequence(20.7)
sequence(35.7985654)

# Ex. 7.1
def print_n(s,n):
    while n >= 0:
        print s
        n = n - 1

print_n('Hello',5)

# Section 7.5 Square roots
# Ex. 7.2
def approx_sqrt(a,g):
    """ Returns the aproximation of the square root of the first parameter accurate to ten decimal places. The second parameter is your guess of what the square root is.
    """
    import math
    if g < 0:
        print 'The square root of a number is never negative. Guess a positive value'
        return
    while True:
        m = (g+(a/(g*1.0)))/2.0
        if math.fabs(g-m) < (10**(-10)):
            return m
        g = m

print approx_sqrt(38,6)

# Ex. 7.4
def eval_loop():
    while True:
        r = raw_input('Mathematical expression = ')
        if r == 'done' or r == 'Done':
            break
        print eval(r)
    print 'Done!'
    return

eval_loop()

import math
import utils

def magnitude(v):
    return math.sqrt(sum(v[i]*v[i] for i in range(len(v))))


def add(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(x) for x in zip(u, v)] 
    else:
        utils.error('Vectors are of different length (utils_math: add)')
    return a


def sub(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [ u[i]-v[i] for i in range(len(u)) ]
    else:
        utils.error('Vectors are of different length (utils_math: sub)')
    return a


def dot(u, v):    
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [ sum(u[i]*v[i] for i in range(len(u))) ]
        print('\n', a, '\n')
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a


def normalize(v):
    vmag = magnitude(v)
    return [ v[i]/vmag  for i in range(len(v)) ]
    

def squareRoot(list):
    return [math.sqrt(x) for x in list]    


def square(list):
    return [x ** 2.0 for x in list]

def fft(signal):
   n = len(signal)
   if n == 1:
      return signal
   else:
      Feven = fft([signal[i] for i in range(0, n, 2)])
      Fodd = fft([signal[i] for i in range(1, n, 2)])
 
      combined = [0] * n
      for m in range(n/2):
         combined[m] = Feven[m] + omega(n, -m) * Fodd[m]
         combined[m + n/2] = Feven[m] - omega(n, -m) * Fodd[m]
 
      return combined

from itertools import izip

def sqrt(x):
    """
    Trivial square root implementation.
    """
    return x ** 0.5


def dot(x, y):
    """
    Compute the dot product of two equal length vectors, `x`, and `y`.
    """
    return sum(n * m for n, m in izip(x, y))

#!/usr/bin/env python

import math
import time


def findroot(anum):
    """
    Find square root of a number
    """
    try:
        time.sleep(10)
        return math.sqrt(anum)
    except TypeError:
        return 'Not a number'
    except ValueError:
        return 'Value error'
    except KeyboardInterrupt:
        return 'keyboard interrupt error occurred'


def main():
    """
    main method
    """
    print findroot(9)

if __name__ == '__main__':
    main()

import primes
import math

def minimal_solution(D):
    # Find smallest integer whose square > D.
    root = int(math.sqrt(D)) + 1
    while True:
        left = root*root-1
        if left % D == 0:
            if primes.is_square(left/D):
                return root 
        root += 1

def solve66(max_D):
    largest = 0
    for D in range(max_D):
        if not primes.is_square(D):
            min_solution = minimal_solution(D)
            if min_solution > largest:
                print min_solution
                largest = min_solution
    return largest

print "finished! " + str(solve66(1001))
        


import math

def is_prime(n):
    # Brute force testing of primality.  Test against every integer
    # less than a number's square root.
    for i in range(0, int(math.sqrt(n))+1):
        if n % i == 0:
            return False
    return True

#return the square root of x
def square(x, delta):
    start = 1
    end = x
    if (x<1):
        start = 0
    sq = float(end+start)/2

    while(abs(sq*sq - x) > delta):
        if (sq*sq > x):
            end = sq
        else:
            start = sq
        sq = (end+start)/2
    return sq

print square(4, 0.001)
print square(5, 0.001)
print square(0.5, 0.001)
print square(0.9, 0.001)
#!/usr/bin/env python

# -------
# RMSE.py
# -------

def square_of_difference(x, y) :
    """
    Squares the differences between actual and predicted ratings
    x is one rating from the list of actual ratings
    y is one rating from the list of predicted ratings
    return the difference of each actual and predicted rating squared
    """
    rating_dict = {'1' : 1, '2' : 2, '3' : 3, '4' : 4, '5' : 5}
    actual = rating_dict[x]
    pred = float(y)
    sd = (actual - pred) ** 2
    assert type(sd) is float
    return sd
  
def mean(a) :
    """
    Calculates the average of a list
    a is the list of ints or floats to average
    return the average of the numbers in the input list
    """
    assert type(a) is list
    m = sum(a) / len(a)
    assert 0 <= m <= 16
    return m
    
def rmse(a,p) :
    """
    Calculates the root mean square error between 2 lists
    a is the list of actual ratings
    p is the list of predicted ratings
    return root mean square error between the two input lists
    """
    assert type(a) is list
    assert type(p) is list
    assert len(a) == len(p) 
    r = mean(map(square_of_difference, a, p)) ** .5
    assert 0 <= r <= 4
    return r






def subtract(x, y):
     return x - y
     
def add(x, y):
     return x + y

def power(x, y):
     return x ** y

def multiply(x,y):
     return x*y


def divide(x,y):
     return x/y

def square(x):
     return x ** 2

def sqr_root(x):
     return x ** 0.5



def find_root(a, b):
    i = float(a)
    step = float(b)
    return step - ((step ** 2 - i) / (2 * step))


def square_root(in_put, precision):
    """
    :param input: Takes an input number
    :param precision: Takes a precision to output
    :return: The square root of the input number
    """
    in_put = float(in_put)
    precision = 1 / (10 ** float(precision))

    if in_put < 0:
        raise Exception("The square root of a negative number is non-real")
    elif in_put == 0:
        return 0
    else:
        error = None
        step = int(in_put) - 1
        while error > precision or error is None:
            step = find_root(in_put, step)
            error = step ** 2 - in_put
        return step


if __name__ == "__main__":
    print square_root(4, 4)
    print square_root(10.9, 100)

def func(a,n):
    return (
        
        ((a-1)**n)%(a*a),
        ((a+1)**n)%(a*a),
        ((a-1)**n+(a+1)**n)%(a*a)
        )


import math

def primes():
    '''Yields the sequence of primes via the Sieve of Eratosthenes.'''
    yield 2                 # Only even prime.  Sieve only odd numbers.

    # Generate recursively the sequence of primes up to sqrt(n).
    # Each p from the sequence is used to initiate sieving at p*p.
    roots = primes()
    root = roots.next()
    square = root*root

    # The main sieving loop.
    # We use a hash table D such that D[n]=2p for p a prime factor of n.
    # Each prime p up to sqrt(n) appears once as a value in D, and is
    # moved to successive odd multiples of p as the sieve progresses.
    D = {}
    n = 3
    while True:
        if n >= square:     # Time to include another square?
            D[square] = root+root
            root = roots.next()
            square = root*root

        if n not in D:      # Not witnessed, must be prime.
            yield n
        else:               # Move witness p to next free multiple.
            p = D[n]
            q = n+p
            while q in D:
                q += p
            del D[n]
            D[q] = p
        n += 2
prem =primes()
p=prem.next()
print p
n=1
stop=0
while stop <10000000000:
    n+=1
    p=prem.next()
    if n%2==0:
        continue
    stop= 2*n*p
    ##stop=func(p,n)[2]
    print p,n,stop


import math

def get_continued_fraction(square_root_argument):
  first_appearance = {}
  sequence = []
  square_root_floor = int(math.sqrt(square_root_argument))
  if square_root_floor ** 2 == square_root_argument:
    return [square_root_floor], []
  a, b, c = square_root_floor, square_root_floor, 1
  while (a, b, c) not in first_appearance:
    first_appearance[a, b, c] = len(sequence)
    sequence.append(a)
    c = (square_root_argument - b ** 2) / c
    a = int((math.sqrt(square_root_argument) + b) / c)
    b = -(b - a * c)
  index = first_appearance[a, b, c]
  return sequence[:index], sequence[index:]

def main():
  odd_period_count = 0
  max_period = 0
  max_period_argument = 0
  for n in xrange(10001):
    period = len(get_continued_fraction(n)[1])
    if period > max_period:
      max_period = period
      max_period_argument = n
    if period % 2 == 1:
      odd_period_count += 1
  return odd_period_count

if __name__ == '__main__': print main()

from math import *

def square_root(a):
  epsilon = 0.0000001
  x = a/2.0
  while True:
    print x
    y = (x + a/x) / 2
    if abs(y-x) < epsilon:
      break
    x = y
  return x

print "Give me a number to calculate the square root of: ",
a = raw_input()
a = float(a)
print("The square root of %f is %f") % (a, square_root(a))


"""
It is well known that if the square root of a natural number 
is not an integer, then it is irrational. The decimal expansion 
of such square roots is infinite without any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and the digital 
sum of the first one hundred decimal digits is 475.

For the first one hundred natural numbers, find the total of the digital 
sums of the first one hundred decimal digits for all the irrational square roots.
"""
from Helper import isSquare
from math import sqrt
from decimal import getcontext, Decimal

def sumStringNumbers(n):
	total = 0
	for number in n:
		total += int(number)
	return total

def main():
	total = 0
	getcontext().prec = 102
	for n in range(2, 101):
		if not isSquare(n):
			root = str(Decimal(n).sqrt())
			root = root.replace('.','')
			total += sumStringNumbers(root[:100])
	print total

if __name__ == "__main__":
    main()

# Samir Silbak
# Cryptography 1

import gmpy2

def is_prime(exponent):
    for k in range(0,10000000):
        p = 10**exponent + k
        a = gmpy2.powmod(2, p-1, p)

        if (a == 1): 
            print "k = ", k
            return

def square_roots(base, prime):
        exponent = (prime + 1)/4
        root_1 = (base ** exponent) % prime
        root_2 = prime - root_1

        print "\n"
        print "first root = %i \nsecond root = %i\n" % (root_1, root_2)
        return

def probable_prime(prime, count):
    for k in range(1,10000000):
        p = prime + k
        a = gmpy2.powmod(2, p-1, p)

        if (a == 1): 
            print "k = ", k
            count += 1

            if count == 4: 
                return

is_prime(10)
is_prime(25)
is_prime(50)

square_roots(5739,100003)
probable_prime(16157879263,0)

import math
from fractions import gcd
 
def problem7(): return find_prime_by_index(10001)
 
def find_prime_by_index(i):
        return generate_fixed_amount_of_primes(i)[-1]
 
# we do not need to store intermediate primes, but this function can be a good auxiliary function for other euler problems
def generate_fixed_amount_of_primes(n):
        assert(n > 0)
        primes = [2, 3] # first primes
        current_number = primes[1]
        while (len(primes) < n):
                current_number += 2
                square_root = math.floor(math.sqrt(current_number))
                prime = True
                for p in primes:
                        if p > square_root: break
                        elif current_number % p == 0:
                                prime = False
                                break
 
                if prime: primes.append(current_number)
        return primes[:n]
def babylon(root): #Julio Cesar Gonzalez Uribe A01229898
    b=root
    cont=1
    guess=b/2
    if(root==0):
    	return print(root)
    elif(root<0):
    	return print('Error the root can not be negative')
    else:
      while(cont<=3):
        a=root/guess
        ave=(a+guess)/2
        guess=ave
        cont=cont+1
      print (guess) 
num=float(input('give me the number that you want to know his square root: '))
print(babylon(num))        
import math

def is_prime(num):
    
    for i in range(2, num/2):
        if num % i == 0:
            return False
    
    return True

def highest_factor(num):
    square_root = int(math.sqrt(num))
    
    for i in reversed(range(2,square_root)):
      if num % i == 0:
          if is_prime(i):
              return i
              
print highest_factor(600851475143)
"""
Exercise 7.3. 

To test the square root algorithm in this chapter, you could compare it with
math.sqrt. Write a function named test_square_root that prints a table like this:

1.0     1.0             1.0             0.0
2.0     1.41421356237   1.41421356237   2.22044604925e-16
3.0     1.73205080757   1.73205080757   0.0
4.0     2.0             2.0             0.0
5.0     2.2360679775    2.2360679775    0.0
6.0     2.44948974278   2.44948974278   0.0
7.0     2.64575131106   2.64575131106   0.0
8.0     2.82842712475   2.82842712475   4.4408920985e-16
9.0     3.0             3.0             0.0

The first column is a number, a; 
the second column is the square root of a, computed with the function from Section 7.5; 
the third column is the square root computed by math.sqrt; 
the fourth column is the absolute value of the difference between the two estimates.
"""
import math

def square_root(a):
    x = a / 3.0
    epsilon = 0.000000000001
    while abs(a - (x**2)) > epsilon:
        x = (x + a/x) / 2
    return x
    
def test_square_root(b):
    for i in range (1, b):
        print "%g\t\t%g\t\t\t%g\t\t%g" % (float(i), square_root(i), math.sqrt(i), (square_root(i) - math.sqrt(i)))
        
test_square_root(10)
        
import pygame
from pygame.locals import *
from PIL.ImageTk import PhotoImage
from PIL import Image
import tkinter, tkinter.font


from .tomb import Tomb

class TombGUI(object):
	def __init__(self, tkroot):
		pygame.init()

		self.root = tkroot
		self.root.config(cursor="plus")
		self.width = 720
		self.height = 480
		self.screen = pygame.display.set_mode((self.width,self.height))
		self.canvas = tkinter.Canvas(self.root, width=self.width, height=self.height)
		self.view_width = 480
		self.view_height = 320
		self.view_x = 30
		self.view_y = 20
		self.message_buffer = 6
		self.messages = ["Welcome to Hellatomb!"]
		self.cell_width = 16
		self.cell_height = 16
		self.pad_pixels = 4
		self.x = None
		self.y = None
		self.z = None
		self.img_path = "C:/Users/m543015/Desktop/GitHub/htomb/htomb/images/"
		#self.img_path = "C:/Users/Glenn/Documents/GitHub/htomb/htomb/htomb/images/"
		self.images = {}

	def go(self):
		self.root.mainloop()
		self.root.lift()
		self.root.focus_set()
		
	def go(self):
		while True:
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					Tomb.controls.key(event)
				if event.type == MOUSEDOWN:
					Tomb.controls.click()
						
	def image(self, s):
		if s not in self.images:		
			image = pygame.image.load(self.img_path + s +".png").convert()
			self.images[s] = img
		return self.images[s]
		
	def prepare_scene(self):	
		self.canvas.delete("all")
		
	def draw_at(self, img, x, y):
		self.canvas.create_image(self.pad_pixels+x*self.cell_width, self.pad_pixels+y*self.cell_height, image=self.image(img), anchor=tkinter.NW)
		
	def draw_at(self,img,x,y):
		self.scene.blit(self.image(img),(self.pad_pixels+x*self.cell_width, self.pad_pixels+y*self.cell_height))
		
	def draw_message(self,message,n):
		fixed = tkinter.font.nametofont("fixed")
		self.canvas.create_text(2*self.pad_pixels,self.pad_pixels+(self.view_y+2+n)*self.cell_height,text=message,font=fixed, anchor=tkinter.NW)
		
	def draw_message(self,message,n):
		pass
		
	def draw_update(self):
		self.canvas.pack()
		
	def draw_update(self):
		self.scene.update()
		
	def draw_messageboard(self):
		self.canvas.create_rectangle(self.pad_pixels,self.pad_pixels+(self.view_y+2)*self.cell_height,self.view_width+self.pad_pixels,self.height-self.pad_pixels,fill="AntiqueWhite1")
	
	def draw_messageboard(self):
		pass
		
	
	def draw(self):
		self.prepare_scene()
		
		if self.x == None:
			self.x = Tomb.player.x
		if self.y == None:
			self.y = Tomb.player.y
		if self.z == None:
			self.z = Tomb.player.z
		
		if self.x <= self.view_x/2:
			from_x = 0
		elif self.x >= Tomb.zone.width - self.view_x/2:
			from_x = Tomb.zone.width - self.view_x
		else:
			from_x = self.x - int(self.view_x/2)
			
		if self.y <= self.view_y/2:
			from_y = 0
		elif self.y >= Tomb.zone.height - self.view_y/2:
			from_y = Tomb.zone.height - self.view_y
		else:
			from_y = self.y - int(self.view_y/2)
		
		for y in range(self.view_y):
			for x in range(self.view_x):
				square = Tomb.zone.grid(from_x+x,from_y+y,self.z)
				
				self.draw_at(square.image,x,y)
				if square.floor().designation:
					self.draw_at(square.floor().designation.image,x,y)
				if square.designation:
					self.draw_at(square.designation.image,x,y)
				if square.ceiling().designation:
					self.draw_at(square.ceiling().designation.image,x,y)
				if square.explored:
					if square.floor().items and not square.floor().solid():
						self.draw_at(self.image(square.floor().items[-1].image),x,y)
					if square.items:
						self.draw_at(self.image(square.items[-1].image),x,y)
					if square.ceiling().items and not square.ceiling().solid():
						self.draw_at(self.image(square.ceiling().items[-1].image),x,y)

					if square.floor().feature:
						self.draw_at(square.floor().feature.image,x,y)
					if square.feature:
						self.draw_at(square.designation.image,x,y)
					if square.ceiling().feature:
						self.draw_at(square.floor().designation.image,x,y)
							
					if square.visible:	
						if square.floor().creature:
							self.draw_at(square.floor().creature.image,x,y)
						if square.creature:
							self.draw_at(square.creature.image,x,y)
						if square.ceiling().creature:
							self.draw_at(square.ceiling().creature.image,x,y)
					else:
						self.draw_at("fog",x,y)
							
		for y,command in enumerate(self.commands):
			pass
			##self.canvas.create_text(self.view_x*self.cell_width+2*self.pad_pixels,y*self.cell_height, text=command, font=fixed, anchor=tkinter.NW)
			
		##self.canvas.create_text(self.pad_pixels,self.pad_pixels+(self.view_y)*self.cell_height,text=self.print_position(),font=fixed, anchor=tkinter.NW)
		##self.canvas.create_text(self.pad_pixels,self.pad_pixels+(self.view_y+1)*self.cell_height,text=self.print_status(),font=fixed, anchor=tkinter.NW)
		
		self.draw_messageboard()
		i = 0
		for message in reversed(self.messages):
			self.draw_message(i,message)
			i+=1
	
		self.draw_update()

	def draw_square(self, square, img):
		if self.x == None:
			self.x = Tomb.player.x
		if self.y == None:
			self.y = Tomb.player.y
		if self.z == None:
			self.z = Tomb.player.z
		
		if self.x <= self.view_x/2:
			from_x = 0
		elif self.x >= Tomb.zone.width - self.view_x/2:
			from_x = Tomb.zone.width - self.view_x
		else:
			from_x = self.x - int(self.view_x/2)
			
		if self.y <= self.view_y/2:
			from_y = 0
		elif self.y >= Tomb.zone.height - self.view_y/2:
			from_y = Tomb.zone.height - self.view_y
		else:
			from_y = self.y - int(self.view_y/2)
			
		self.draw_at(img,square.x-from_x,square.y-from_y)
		self.canvas.pack()		
	
				
				
	def push_message(self, message):
		if len(self.messages)>=self.message_buffer:
			self.messages.pop()
			
		self.messages.insert(0,message)
		
	def print_menu(self, n):
		items = Tomb.player.items
		spells = Tomb.player.spells
		if n == 0:
			return "Inventory:"
		elif n > 0 and n <= len(items):
			return "- " + items[n-1].name
		elif n == len(items)+1:
			return " "
		elif n == len(items)+2:
			return "Spells:"
		elif n >= len(items)+3 and n < len(items)+3+len(spells):
			return "- " + spells[n-4-len(items)].name
		else:
			return " "
	
	def print_position(self):
		player = Tomb.player
		return player.name + " at " "X: "+str(player.x)+", Y: "+str(player.y)+", Z: "+str(player.z)
		
	def print_status(self):
		player = Tomb.player
		return	 "Wounds: " + str(player.wounds) + "/" + str(player.toughness) \
				+ "  Prowess:" + str(player.prowess) \
				+ "  Anxiety(Contempt): " + str(player.anxiety) + "(" + str(player.contempt) + ")" \
				+ "  Infamy: " + str(player.infamy)
				
	def print_inventory(self):
		pass
	
	def print_spells(self):
		pass
	
	def print_equipment(self):
		pass
		
	def click(self,event):
		pass
		
				
class ControlContext(object):
	def __init__(self):
		Tomb.gui.commands = [
			'Left Mouse: look',
			'Arrows/NumPad: move',
			'Space Bar: brood',
			'Shift: survey',
			'. : dig down',
			', : dig up / stack stones',
			'g : pick up an item',
			'd : drop an item',
			'z : raise a zombie',
			'o : give / cancel orders'
		]
				
	def key(self,event):
		if event.key in (K_UP,K_KP_8):
			Tomb.player.try_move(0,-1,0)
		elif event.key in (K_LEFT,K_KP_4):
			Tomb.player.try_move(-1,0,0)
		elif event.key in (K_RIGHT,K_KP_6):
			Tomb.player.try_move(1,0,0)
		elif event.key in (K_DOWN,K_KP_2):
			Tomb.player.try_move(0,1,0)
		elif event.key == (K_KP_7):
			Tomb.player.try_move(-1,-1,0)
		elif event.key == (K_KP_9):
			Tomb.player.try_move(1,-1,0)
		elif event.key == (K_KP_1):
			Tomb.player.try_move(-1,1,0)
		elif event.key == (K_KP_3):
			Tomb.player.try_move(1,1,0)
		elif event.key == (K_KP_5):
			Tomb.player.wait()
		elif event.key == (K_PERIOD):
			Tomb.player.dig(Tomb.player.square.floor())
		elif event.key == (K_COMMA):
			if Tomb.player.square.ceiling().solid():
				Tomb.player.dig(Tomb.player.square.ceiling())
			else:
				Tomb.player.build_wall(Tomb.player.square)
		elif event.key == K_SPACE:
			#for now...
			Tomb.player.wait()
		elif event.key == K_g:
			Tomb.player.get()
		elif event.key == K_d:
			Tomb.player.drop()
		elif event.key == K_z:
			Tomb.player.spells[0].cast()
		elif event.key == K_o:
			Tomb.controls = ChooseOrdersContext()
			Tomb.gui.push_message("Choose orders.")
		elif event.key in (K_RSHIFT, K_LSHIFT):
			Tomb.controls = SurveyContext()
		else:
			print(event.key)
			
		Tomb.gui.x = Tomb.player.x
		Tomb.gui.y = Tomb.player.y
		Tomb.gui.z = Tomb.player.z
		
		Tomb.gui.draw()
		
		
		
	def clicked_square(self, event):
		x = int(event.x/Tomb.gui.cell_width)
		y = int(event.y/Tomb.gui.cell_height)
			
		if Tomb.gui.x <= Tomb.gui.view_x/2:
			from_x = 0
		elif Tomb.gui.x >= Tomb.zone.width - Tomb.gui.view_x/2:
			from_x = Tomb.zone.width - Tomb.gui.view_x
		else:
			from_x = Tomb.gui.x - int(Tomb.gui.view_x/2)
				
		if Tomb.gui.y <= Tomb.gui.view_y/2:
			from_y = 0
		elif Tomb.gui.y >= Tomb.zone.height - Tomb.gui.view_y/2:
			from_y = Tomb.zone.height - Tomb.gui.view_y
		else:
			from_y = Tomb.gui.y - int(Tomb.gui.view_y/2)
							
		square = Tomb.zone.grid(from_x+x,from_y+y,Tomb.gui.z)
		return square
		
		
	def click_look(self, square):
		if not square.level_ground():
			Tomb.player.look(square)
		else:
			Tomb.player.look(square.level_ground())
	
			
	def clicked_menu(self, event):
		pass
	

	def click(self):
		x, y = pygame.mouse.get_pos()
		if x >= 0 and x < Tomb.gui.view_width and y >= 0 and y < Tomb.gui.view_height:
			square = self.clicked_square(event)
			if not square:
				print("freak out!")
			self.click_look(square)
		elif x >= Tomb.gui.view_width and y > Tomb.gui.cell_height:
			self.clicked_menu(event)
			#clicked in inventory or spells
			#y = int(y/16)
			#print(y)
			#if y < len(Tomb.player.items)+1:
			#	Tomb.gui.push_message(Tomb.player.items[y-1].name)
			#elif y > len(Tomb.player.items)+2 and y < len(Tomb.player.items)+3+len(Tomb.player.spells):
			#	Tomb.player.spells[y-len(Tomb.player.items)-4].cast()	
		Tomb.gui.draw()
	
		
class ChooseOrdersContext(ControlContext):
	def __init__(self):
		Tomb.root.bind_all("<Key>",self.key)
		Tomb.root.bind_all("<Button-1>",self.click)
		Tomb.gui.commands = [
			'Esc : go back',
			'd : dig',
			'w : build walls',
			'g : guard post',
			's : stockpile goods',
			'x : remove designation'
		]
	
	def key(self,event):
		if event.keycode == 27:
			Tomb.gui.push_message("Canceled.")
			Tomb.controls = ControlContext()
		elif event.keycode == 68:
			DigOrders().give_orders()
		elif event.keycode == 87:
			BuildWallsOrders().give_orders()
		elif event.keycode == 83:
			StockpileGoodsOrders().give_orders()
		elif event.keycode == 71:
			GuardPostOrders().give_orders()
		elif event.keycode == 88:
			RemoveDesignationOrders().give_orders()
		else:
			print(event.keycode)
			
		Tomb.gui.draw()
		
	
class DeadContext(ControlContext):
	def key(self,event):
		Tomb.root.quit()
	
	
class SurveyContext(ControlContext):
	def __init__(self):
		Tomb.root.bind_all("<Key>",self.key)
		Tomb.root.bind_all("<Button-1>",self.click)
		Tomb.gui.commands = [
			'Left Mouse: look',
			'Arrows/NumPad: move view',
			'Shift/Esc: exit survey',
			'. : survey up',
			', : survey down',
			'o : give orders',
			'x : cancel orders',
			'w : orders to dig'
		]
		self.x = Tomb.player.x
		self.y = Tomb.player.y
		self.z = Tomb.player.z
		
	def try_shift(self,x,y,z):
		self.x+=x
		self.y+=y
		self.z+=z
		self.x = max(self.x,int(Tomb.gui.view_x/2))
		self.y = max(self.y,int(Tomb.gui.view_y/2))
		self.z = max(self.z,1)
		self.x = min(self.x,Tomb.zone.width-1-int(Tomb.gui.view_x/2))
		self.y = min(self.y,Tomb.zone.height-1-int(Tomb.gui.view_y/2))
		self.z = min(self.z,Tomb.zone.depth-2)

	def key(self,event):
		if event.keycode in (38,104):
			self.try_shift(0,-1,0)
		elif event.keycode in (37,100):
			self.try_shift(-1,0,0)
		elif event.keycode in (39,102):
			self.try_shift(1,0,0)
		elif event.keycode in (40,98):
			self.try_shift(0,1,0)
		elif event.keycode == (103):
			self.try_shift(-1,-1,0)
		elif event.keycode == (105):
			self.try_shift(1,-1,0)
		elif event.keycode == (97):
			self.try_shift(-1,1,0)
		elif event.keycode == (99):
			self.try_shift(1,1,0)
		elif event.keycode == (190):
			self.try_shift(0,0,-1)
		elif event.keycode == (188):
			self.try_shift(0,0,1)
		elif event.keycode == (27):
			Tomb.controls = ControlContext()
			Tomb.gui.x = Tomb.player.x
			Tomb.gui.y = Tomb.player.y
			Tomb.gui.z = Tomb.player.z
		elif event.keycode == 79:
			Tomb.controls = ChooseOrdersContext()
			Tomb.gui.push_message("Choose orders.")
		else:
			print(event.keycode)

		if event.keycode != 27:	
			Tomb.gui.x = self.x
			Tomb.gui.y = self.y
			Tomb.gui.z = self.z
	
		Tomb.gui.draw()
		
	def click_look(self, square):
		Tomb.player.look(square)
		
		
class SelectAreaContext(ControlContext):
	def __init__(self, caller, outline):
		Tomb.root.bind_all("<Key>",self.key)
		Tomb.root.bind_all("<Button-1>",self.click)
		self.square1 = None
		self.square2 = None
		self.caller = caller
		self.outline = outline
		
	def key(self,event):
		from .tomb import Tomb
		if event.keycode == 27:
			Tomb.gui.push_message("Canceled.")
			Tomb.controls = ControlContext()
		
		Tomb.gui.draw()
		
	def click(self,event):
		if event.x >= 0 and event.x < Tomb.gui.view_width and event.y >= 0 and event.y < Tomb.gui.view_height:
			#let the order-specific methods determine what to do with the squares returned
			square = self.clicked_square(event)
			if not self.square1:
				self.square1 = square
			else:
				if square.z != self.square1.z:
					#except now this is true by definition...
					Tomb.gui.push_message("Both corners must be at same altitude.")
				else:
					self.square2 = square
					x1 = min(self.square1.x,self.square2.x)
					x2 = max(self.square1.x,self.square2.x)
					y1 = min(self.square1.y,self.square2.y)
					y2 = max(self.square1.y,self.square2.y)
					area = set()
					if self.outline:
						for x in x1,x2:
							for y in range(y1,y2+1):
								area.add(Tomb.zone.grid(x,y,self.square1.z))		
						for x in range(x1,x2+1):
							for y in y1,y2:
								area.add(Tomb.zone.grid(x,y,self.square1.z))				
					else:
						for x in range(x1,x2+1):
							for y in range(y1,y2+1):
								area.add(Tomb.zone.grid(x,y,self.square1.z))		

					Tomb.controls = ControlContext()
					self.caller.receive_area(self.square1, self.square2, area)
			
		elif event.x >= Tomb.gui.view_width and event.y > Tomb.gui.cell_height:
			clicked_menu(event)
			
		Tomb.gui.draw()
		if self.square1:
			Tomb.gui.draw_square(self.square1,"designate")
		if self.square2:
			Tomb.gui.draw_square(self.square2,"designate")
			

class SelectSquareContext(ControlContext):
	def __init__(self, caller):
		Tomb.root.bind_all("<Key>",self.key)
		Tomb.root.bind_all("<Button-1>",self.click)
		self.square1 = None
		self.square2 = None
		self.caller = caller
		
	def key(self,event):
		from .tomb import Tomb
		if event.keycode == 27:
			Tomb.gui.push_message("Canceled.")
			Tomb.controls = ControlContext()
		
		Tomb.gui.draw()
		
	def click(self,event):
		if event.x >= 0 and event.x < Tomb.gui.view_width and event.y >= 0 and event.y < Tomb.gui.view_height:
			#let the order-specific methods determine what to do with the squares returned
			square = self.clicked_square(event)
			self.caller.receive_square(square)
			Tomb.controls = ControlContext()
		
		Tomb.gui.draw()
			
		
class DigOrders(object):
	def give_orders(self):
		controls = SelectAreaContext(self,False)
		Tomb.gui.push_message("Select area to dig.")
		
	def receive_area(self, square1, square2, area):
		from .creatures import DigTask
		#if there is at least one square filled in, dig out the selected level
		at_level = False
		for square in area:
			if square.solid():
				at_level = True
		#otherwise, drop down and dig out the floor
		for square in area:
			if at_level and square.solid():
				task = DigTask(square)
			elif not at_level and square.floor().solid():
				task = DigTask(square.floor())
				
			
class BuildWallsOrders(object):
	def give_orders(self):
		controls = SelectAreaContext(self,"outline")
		Tomb.gui.push_message("Select area to build walls.")
		
	def receive_area(self, square1, square2, area):
		from .creatures import BuildTask
		#okay, I think what should happen is...determine what level the corners are at...no...they're all at the same level...okay...
		level_ground = square1.level_ground()
		if level_ground == square1:
			for square in area:
				if not square.solid() and square.floor().solid():
					task = BuildTask(square)
		elif level_ground == square1.ceiling():
			for square in area:
				if not square.ceiling().solid() and square.solid():
					task = BuildTask(square.ceiling())
		elif level_ground == square1.floor():
			for square in area:
				if not square.floor().solid() and square.floor().floor().solid():
					task = BuildTask(square.floor())	
		
		#only build on squares that are empty and have solid floors
		#for square in area:
			#if not square.solid() and square.floor().solid():
				#task = Task(square)
				
			
class RemoveDesignationOrders(object):
	def give_orders(self):
		controls = SelectAreaContext(self, False)
		Tomb.gui.push_message("Select area to remove designations.")
		
	def receive_area(self, square1, square2, area):
		at_level = False
		above_level = False
		#if at least one square on the same level has a task, delete from this level
		for square in area:
			if square.designation:
				at_level = True
		#then try the ceiling
		if not at_level:
			for square in area:
				if square.ceiling().designation:
					above_level = True
		#...and default to the floor
		for square in area:
			if at_level and square.designation:
				Tomb.gui.push_message("Removed designation for " + square.name + ".")
				square.designation.delete()
			elif above_level and square.ceiling().designation:
				Tomb.gui.push_message("Removed designation for " + square.ceiling().name + ".")
				square.ceiling().designation.delete()
			elif not at_level and not above_level and square.floor().designation:
				Tomb.gui.push_message("Removed designation for " + square.floor().name + ".")
				square.floor().designation.delete()
				
				
class GuardPostOrders(object):
	def give_orders(self):
		controls = SelectSquareContext(self)
		Tomb.gui.push_message("Select square to guard around.")
		
	def receive_square(self, square):
		from .creatures import GuardTask
		if square.level_ground():
			GuardTask(square.level_ground())
		else:
			GuardTask(square)
		
	
class StockpileGoodsOrders(object):
	def give_orders(self):
		controls = SelectSquareContext(self)
		Tomb.gui.push_message("Select square to stockpile around.")
		
	def receive_square(self, square):
		from .creatures import GatherTask
		square = square.level_ground()
		if square:
			GatherTask(square)
from __future__ import division
import numpy as np


class Regression(object):

    def __init__(self, d_mat, t_vec):
        """
        prepends 1's onto each row in the design matrix, and runs regressions,
        to find w.

        :param d_mat (Design matric):
        :param t_vec (Target vector):
        """

        self.d_mat = np.array(map(lambda x: [1] + x, d_mat))
        self.t_vec = np.array(t_vec)

    def predict(self, x):
        raise Exception('Not yet implemented')

    def root_mean_square(self):
        """
        Find the root-dimension_means-square error for the given regression
        :return:
        """
        N = len(self.d_mat)

        guess_sum = 0
        for i in range(N):
            guess_sum += (self.t_vec[i][0] - self.predict(i))**2

        return np.sqrt((1/N) * guess_sum)
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# sqrt_recursive.py - finding square roots

ERROR = 0.0000000001

def square(x):
    """Returns the square of a number."""
    return x*x

def average(x,y):
    """Returns the average of two numbers."""
    return (x + y) / 2

def my_abs(x):
    """Returns the absolute value of x."""
    if x < 0:
        return -x
    else:
        return x

def sqrt(x, guess, error):
    """Recursive version."""
    if my_abs(square(guess) - x) < error:
        return guess
    else:
        return sqrt(x, average(guess, x / guess), error)

#main
print(sqrt(float(input("Square Root of: ")), 1, ERROR))

import sys
import math


def newton(a, x):
    return (x + (a/x))/2.0

def square_root(a, x):
    current_x = x
    next_x = newton(a, current_x)
    error = 0.000001
    count = 1
    while abs(next_x - current_x) > error:
        current_x = next_x
        next_x = newton(a, current_x)
        count += 1
        b = next_x * 1.0
    # print "Number of iterations:", count
    # print b


square_root(5, 7000)

sys.stdout.write('{:<3},{:<20},{:<20},{:<20},{:<20}\n'.format('n', "square_root",
                    "math.sqrt", "difference", "is difference < 0.000001?"))
for i in range (0,10):

    sys.stdout.write('{:<3},{:<20},{:<20},{:<20},{:<20}\n'.format(i, math.sqrt(i)))

import sys
import os
import math

# bruce = 5
# print bruce,
# bruce = 7
# print bruce
# the output of this program is 5 7
# the comma suppresses the new line in the print statement

# Note = is an assignment, == is statement of equality

# Initialize a variable like so: x = 0; x = x + 1

# Repeating identical or similar tasks without making errors
# is something computers do well and people do poorly.

def countdown (n):
	while n > 0:
		print n
		n = n - 1
	print 'Blastoff!'

def take_break():
	while True:
		line = raw_input('> ')
		if line == 'done':
			break
		print line
	print 'Done!'

def square_root (a):
	epsilon = 0.00001
	x = a
	while True:
		y = (x + a/x) / 2
		if abs(y-x) < epsilon:
			break
		x = y
	return x

print square_root (5.00)

# Ex 7.3 
def test_square_root(a):
	print a,
	print "\t",
	x = square_root(a)
	print x,
	print "\t",
	y = math.sqrt(a)
	print y,
	print "\t",
	return abs(x-y)

print test_square_root(5)
print test_square_root(4)

def eval_loop():
	while True:
		line = raw_input('> ')
		if line == 'done':
			break
		print eval(line)
	return 'Done!'
	
# Ex. 7.5
def factorial(n):
	if n == 0:
		return 1
	else:
		recurse = factorial (n - 1)
		result = n * recurse
		return result

def estimate_pi():
	k = 0
	total = 0
	while True:
		den = (factorial (k)**4)*(396**(4*k))
		num = (factorial (4 * k))*(1103+26390*k)
		so = num / den
		total += so
		if so < 1e-15:
			break
		k += 1
	total = (2 * math.sqrt(2) * total) /9801
	return 1 / total

print estimate_pi()
print math.pi
'''
Function for extrcating the
square root
For negative numbers there are no real zeroes
'''

def sqrt2(x,debug=False):
    '''
    square root of a give number
    '''
    if x==0:
        return 0
    elif x<0:
        print "*** Error, x must be non-negative"
        #return 'nan'
    assert x>0. and type(x) is float, "should not get here"
            
    s = 1.
    kmax = 100
    tol = 1.e-14
    for k in range(kmax):
        if debug:
            print "Before iterations %s, s=%20.15f" % (k,s)
        s0 = s
        s = 0.5 * (s + x/s)
        delta_s = s - s0
        #print(delta_s)
        if abs(delta_s / float(x)) < tol:
            break
    if debug:
        print "After iterations %s, s=%20.15f" % (k+1,s)
    return s



# -*- coding: utf-8 -*-
"""
Implement int sqrt(int x).

Compute and return the square root of x.

@author: weichen
"""
class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        if x < 0: return -1
        if x == 0: return 0
            
        s = 1; e = x/2 + 1    
        
        while s <= e:
            m = (s + e)/2
            if m*m <= x and (m+1)*(m+1) > x:
                return m
            elif m*m < x:
                s = m + 1
            else:
                e = m - 1
        return 0
    
#    USE Newton's method, works also for float!!!!!!!!!!
    def sqrt2(self, x):
        if x < 0: return -1
        if x == 0: return 0

        lasty = 0
        y = x/2.
        while abs(lasty - y) > 1e-3:
            lasty = y
            y = (y + x/y)/2
            
        return int(y)


        
if __name__ == "__main__":
    test = Solution()
    l = [2,4,8,9,10]
    for i in l:
        print "the sqrt root of", i, "is", test.sqrt2(i)
            
from math import sqrt

def sieve(limit):
  primes = [True] * limit
  primes[0] = primes[1] = False

  for (i, is_prime) in enumerate(primes):
    if is_prime:
      yield i
      for n in xrange(i*i, limit, i):
        primes[n] = False

def is_twice_square(num):
  square_root = sqrt(num / 2)
  return square_root == int(square_root)

def P046():
  primes = [_ for _ in sieve(10000)]
  found = True
  i = 1

  while (found):
    found = False
    i += 2
    j = 0

    while (i >= primes[j]):
      if is_twice_square(i - primes[j]):
        found = True
        break
      j += 1

  return i

print P046()
__author__ = "BeepC"

from tkinter import *


class Board:

    squares = {}
    active_square = None
    active_state = -1
    active_x = -1
    active_y = -1
    last_x = -1
    last_y = -1
    dragging = False
    clicked = False
    drag_plane = ""
    drag_coord = -1

    def __init__(self, master, x, y, launcher_used):

        self.frame = Frame(master, bg="GREY28")
        self.x = x
        self.y = y
        self.frame.tk_focusFollowsMouse()
        self.frame.grid()

        launcher_used.destroy()

        self.frame.bind_all("<Button-1>", self.start_mark)
        self.frame.bind_all("<ButtonRelease-1>", self.end_mark)
        self.frame.bind_all("<B1-Motion>", self.drag)

        for j in range(0, self.y):
            for i in range(0, self.x):
                square_id = "{0},{1}".format(i, j)
                self.squares[square_id] = Square(self.frame, self, i, j)

        self.frame.lift()

    def start_mark(self, event):

        self.clicked = True
        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        self.active_square = self.squares["{0},{1}".format(event_grid[0], event_grid[1])]
        self.active_x, self.active_y = [int(i) for i in self.active_square().split(',')]
        self.last_x = self.active_x
        self.last_y = self.active_y

        if self.active_square.state == 0:
            self.active_square.state = 1
        elif self.active_square.state == 1:
            self.active_square.state = 2
        elif self.active_square.state == 2:
            self.active_square.state = 0

        self.active_state = self.active_square.state
        print(self.active_square())

    def drag(self, event):

        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        event_x, event_y = [int(i) for i in event_grid]

        if event_x < 0:
            event_x = 0
        elif event_x >= self.x:
            event_x = self.x - 1

        if event_y < 0:
            event_y = 0
        elif event_y >= self.y:
            event_y = self.y - 1

        event_square = self.squares["{0},{1}".format(event_x, event_y)]

        if self.drag_coord != -1:
            self.drag_mark(event_square, event_x, event_y)
            return None

        if self.clicked is True and self.dragging is False:

            if self.active_x == event_x and self.active_y != event_y:
                    self.drag_coord = event_x
                    self.drag_plane = "V"
                    self.dragging = True
            elif self.active_y == event_y and self.active_x != event_x:
                    self.drag_coord = event_y
                    self.drag_plane = "H"
                    self.dragging = True

    def drag_mark(self, event_square, event_x, event_y):
        if self.drag_plane == "V" and event_y != self.last_y:

            event_square = self.squares["{0},{1}".format(self.drag_coord, event_y)]
            last_square = self.squares["{0},{1}".format(self.drag_coord, self.last_y)]

            if event_square.dragged is False and event_square != self.active_square:
                event_square.dragged = True
                event_square.state = self.active_state

            elif last_square.dragged is True and last_square != self.active_square:
                last_square.dragged = False
                last_square.state = last_square.prev_state

            self.last_y = event_y

        elif self.drag_plane == "H" and event_x != self.last_x:

            event_square = self.squares["{0},{1}".format(event_x, self.drag_coord)]
            last_square = self.squares["{0},{1}".format(self.last_x, self.drag_coord)]

            if event_square.dragged is False and event_square != self.active_square:
                event_square.dragged = True
                event_square.state = self.active_state

            elif last_square.dragged is True and last_square != self.active_square:
                last_square.dragged = False
                last_square.state = last_square.prev_state

            self.last_x = event_x

    def end_mark(self, event):

        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        event_x, event_y = [int(i) for i in event_grid]

        if event_x < 0:
            event_x = 0
        elif event_x >= self.x:
            event_x = self.x - 1

        if event_y < 0:
            event_y = 0
        elif event_y >= self.y:
            event_y = self.y - 1

        event_square = self.squares["{0},{1}".format(event_x, event_y)]

        for square in self.squares:
            self.squares[square].prev_state = self.squares[square].state
            self.squares[square].dragged = False

        self.clicked = False

        if self.dragging is True:

            event_square.prev_state = self.active_state
            event_square.dragged = False
            print(event_square())

            self.active_square = None
            self.active_state = 0
            self.dragging = False
            self.drag_coord = -1
            self.active_x = -1
            self.active_y = -1
            self.last_x = -1
            self.last_y = -1


class Square(Label):

    __state = 2
    __prev_state = 2
    __dragged = False

    def __init__(self, frame, board, x, y):

        super(Square, self).__init__(frame)

        self.frame = frame
        self.board = board
        self.x = x
        self.y = y

        self.tk_focusFollowsMouse()

        self.grid(row=self.y, column=self.x, padx=1, pady=1)
        self.config(image="", height=1, width=2, bg="BLANCHED ALMOND")

    def __call__(self):
        return "{0},{1}".format(self.x, self.y)

    @property
    def state(self):
        return self.__state

    @state.setter
    def state(self, value):
        if value == 0:
            self.config(bg="BLACK")
        elif value == 1:
            self.config(bg="WHITE")
        else:
            self.config(bg="BLANCHED ALMOND")
        self.__state = value

    @property
    def prev_state(self):
        return self.__prev_state

    @prev_state.setter
    def prev_state(self, value):
        self.__prev_state = value

    @property
    def dragged(self):
        return self.__dragged

    @dragged.setter
    def dragged(self, value):
        self.__dragged = value


class CCLauncher(Frame):

    def __init__(self, master):

        super(CCLauncher, self).__init__(master)

        self.master = master
        self.button_frame = Frame(master)

        self.pack()
        self.button_frame.pack()

        self.get_x_entry = Entry(self)
        self.get_y_entry = Entry(self)
        self.get_x_label = Label(self, text="How many columns?")
        self.get_y_label = Label(self, text="How many rows?")
        self.ok_button = Button(self.button_frame, text="OK", command=self.click_ok, width=10)
        self.ok_button.bind("<Return>", self.click_ok)

        self.get_x_entry.grid(row=0, column=1, sticky='E')
        self.get_y_entry.grid(row=1, column=1, sticky='E')
        self.get_x_label.grid(row=0, column=0, sticky='W')
        self.get_y_label.grid(row=1, column=0, sticky='W')
        self.ok_button.pack()

        self.get_x_entry.focus_set()

    def click_ok(self, events=None):
        make_board(int(self.get_x_entry.get()), int(self.get_y_entry.get()), self.master)


def make_board(x, y, launcher_used):

    global checker_board
    global root
    root = Tk()
    root.tk_focusFollowsMouse()
    checker_board = Board(root, x, y, launcher_used)
    root.mainloop()

launcher_root = Tk()
launcher = CCLauncher(launcher_root)
launcher_root.mainloop()

from Tkinter import *
from Game import Game
from SettingsGUI import SettingsGUI
class GUI(object):

  def __init__ (self, settings, game):
    self.settings = settings
    self.game = game
    self.game.addListener(self)
    self.root = Tk()
    self.root.withdraw()
    self.window = Toplevel(self.root)
    self.cause = None
    self.window.title("Minesweeper")
    self.window.protocol("WM_DELETE_WINDOW", self.cleanup)
    
    self.buttons = {}
    for square in game.squares:
      btn = Button(self.window, width=2, height=1, command=self.getClick(*square))
      btn.bind("<ButtonRelease-3>", self.getRightClick(*square))
      btn.grid(row=square[0], column=square[1])
      self.buttons[square] = btn
    
    self.timerId = None
    self.timer = Label(self.window)
    self.timer.grid(row=self.game.m, column=0)
    
    self.minesLeft = Label(self.window, text=str(self.game.num_mines))
    self.minesLeft.grid(row=self.game.m, column=self.game.n-1)
    
    menu = Menu(self.window)
    self.window.config(menu=menu)
    filemenu = Menu(menu)
    menu.add_cascade(label="File", menu=filemenu)
    
    filemenu.add_command(label="New Game", command=self.restart)
    filemenu.add_command(label="Options", command=self.doOptions)
    filemenu.add_command(label="Exit", command=self.exit)
    
    self.tick()
    
  def start(self):
    self.root.mainloop()
    return self.cause
  
  def getClick(self, i, j):
    def f(event=None):
      self.game.click(i, j)
    return f
  def getRightClick(self, i, j):
    def f(event):
      self.game.rightClick(i,j)
    return f
  
  def tick(self):
    self.game.tick()
    self.timerId = self.timer.after(1000, self.tick)
  
  def stopGame(self):
    if self.timerId is not None:
      self.timer.after_cancel(self.timerId)
      self.timerId = None
      
  def update(self):
    for coord in self.buttons:
      char = self.game.getChar(*coord)
      if char == Game.Square.UNCLICKED:
        self.buttons[coord].config(text="")
      elif char == Game.Square.FLAG or char == Game.Square.QUESTION or char == Game.Square.MINE:
        self.buttons[coord].config(text=char)
      elif isinstance(self.buttons[coord], Button):
        self.buttons[coord].destroy()
        lbl = Label(self.window, text=char, width=2, height=1)
        lbl.grid(row=coord[0], column=coord[1])
        lbl.bind("<ButtonRelease-3>", self.getRightClick(*coord))
        self.buttons[coord] = lbl
      else:
        self.buttons[coord].config(text=char)
    self.timer.config(text="%03d" % self.game.time)
    self.minesLeft.config(text="%03d" % (self.game.num_mines - self.game.num_flagged))
    if not self.game.isPlaying():
      self.stopGame()
  
  def exit(self):
    if self.game.isPlaying():
      self.game.lose()
    self.cleanup()
  
  def restart(self):
    if self.game.isPlaying():
      self.game.lose()
    self.cause = "RESTART"
    self.cleanup()
  
  def doOptions(self):
    self.optwindow = SettingsGUI(self.settings, self.root, self.receiveOpts)
    
    
  def receiveOpts(self):
    if not self.optwindow.cancelled:
      self.cause = "OPTIONS"
      if self.game.isPlaying():
        self.game.lose()
      self.cleanup()
    else:
      print "CANCELLED"
      
  def cleanup(self):
    self.root.destroy()
    self.stopGame()
def are_chunks_encrypted(fname):
    """
    calculate chi square root for each chunks and judge specified file is
    encrypted or not.

    :param str fname:   source file name to be calculated.
    :return: 0 if chunks are not encrypted , others if not.
    """
    pass


def is_file_encrypted(fname):
    """
    calculate chi square root for the specified file and judge specified file
    is encrypted or not.

    :param str fname:   source file name to be calculated.
    :return: 0 if file is not encrypted , others if not.
    """
    pass

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Project 6:
# Name:Steven Kordell
# Date: 04/29/2015
# Mailbox number: 663

# Given N and phi(N), solve for p and q

import math

def intSqrt(square):
    ''' returns the integer square root of square
    if it exists, otherwise the closest
    integer smaller than the square root'''
    bits = int(math.log(square, 2) // 2)
    sqrt = 2 ** bits
    for idx in range(bits, -1, -1):
        if ((sqrt + 2 ** idx) ** 2 <= square):
            sqrt = sqrt + 2 ** idx
    return sqrt

if __name__ == "__main__":    
    N = 95108693570035270144657857241002423425941108178488256393099501537459309973338659032070137401466057288093251338945346909386662950709297073547026782605536851430009315154963250527483541499661777610571226461548017983537357340977791191782144166557488091378280662921890402461825132632264736288885016437441408031437
    phiN = 95108693570035270144657857241002423425941108178488256393099501537459309973338659032070137401466057288093251338945346909386662950709297073547026782605536831849545762403179260357125717820498921119322654216449244793611407031294391525498300469688335255546240141624625909322093238921327083984345759003847642930236

    # compute possible p's and q's
    q = (1 + N - phiN - intSqrt(((-1 - N + phiN) ** 2) - 4 * N)) / 2
    p = N / q
    
    print "p = " + str(p)
    print "q = " + str(q)

import math

def square_root(a,x):
    for i  in a:
         	y = (x + i/x) / 2
              return y

def math_squrt(a,x):
	for j  in a: 
		m = math.sqrt(j)
 		return m

def test_square_root(a,x):
	for k in a:

		     m = math_squrt(k,x)
    		     y = square_root(k,x)
     		     c = m - y
    		 print a ,'         ',  m ,'                ', y,'          ', c


test_square_root(range(10),3)


def isprime(n):
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    max_divisor = int(n ** 0.5) # square root of n
    divisor = 5
    while divisor <= max_divisor:
        if n % divisor == 0 or n % (divisor + 2) == 0:
            return False
        divisor += 6
    return True
# Heron of Alexandria documented a methon to compute the square root
# we are going to write a program to do the same - how exciting :)


def squareRoot(x):
    g = x/2.0
    while True:
        g = (g + x/g)/2.0
        if (abs(x - g**2) <= 0.001):
            break
    return g

while True:
    try:
        num = int(raw_input("Enter integer: "))
        break
    except ValueError:
        print 'Invalid Integer!! Please Try Again...'

sroot = squareRoot(num)
sroot = round(sroot, 3)
print "square root of {0}: {1}".format(num, sroot)

# This software is distributed under the GNU Lesser General Public License.
 #  See the root of this repository for details.
 #  Copyright 2011, 2012 Daniel Powell 

from synthsound import *

out = initsynth()
sine_wave_1 = wavefunction(440, 9500, sin) # A pure 440 Hz (concert A4) tone.
sine_wave_2 = wavefunction(445, 9500, sin) # Very slightly sharp.

for i in xrange(1200):
	out.write(stereoframes(sine_wave_1, sine_wave_2, i*128)) # Interference beats are audible at a rate of 5 Hz

def square(x):
	# A square waveform.
	if x%TWO_PI < PI:
		return 1
	return -1

square_wave = wavefunction(440, 9500, square)
for i in xrange(1200):
	out.write(monoframes(swave, i*128)) # what a horrible sound

def square_root(a):
    
    x = 3
    epsilon = 0.000000000001
    while True:
        y = (x + a/x) /2
        if abs(y-x) < epsilon:
            break
        x = y
    return x


if __name__ == '__main__':
    print(square_root(49))

import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)

"""This function will approximate the square root of a number using Newton's Method"""

x = float(input("Enter a positive number and I will find the square root: "))

def square_root(x):
    y = x/2
    count = 0
    while abs((y**2) - x) > 0.01:
        y = (y+x/y)/2
        count += 1
        print("After iterating {} times, my guess is {}.".format(count, y))
    return y
print("The square root of {} is {}.".format(x, square_root(x)))

"""Exercise 7.2. Encapsulate this loop in a function called square_root that takes a as a parameter,
chooses a reasonable value of x, and returns an estimate of the square root of a."""

def my_square_root(a,x) :
    e = 0.0001
    while True :
        y=(x+a/x)/2
        if abs(y-x) < e :
            return y
            break
        x = y

n = 8
import math
for i in range (n):
    a = i+1
    x = i+1    
    c2 = round(my_square_root(float(a),float(x)),3)
    c3 = round(math.sqrt(i+1),3)
    c4 = round(abs(c2-c3),3)
    print(i+1,c2,c3,c4)
    

'''

Implement int sqrt(int x).

Compute and return the square root of x.

Created on Jan 12, 2014

@author: Songfan
'''

''' thought: binary search from 0 to x and judge if the current val square is greater or less than x '''

def sqrt(x):
    assert(x > 0), 'input error'
    if x < 2: return x
    
    first = 0
    last = x // 2
    ''' caveat: 'last' is init to be x/2, while(first <= last) '''
    while(first <= last):
        mid = (first + last) // 2
        val = mid * mid
        if val == x: return mid
        elif val < x: first = mid + 1
        else: last = mid - 1
    return mid

x = 80
print sqrt(x)
def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess

import sys


def main():
    print(sqrt(9))
    print(sqrt(2))
    try:
        print(sqrt(-1))
    except ValueError as e:
        print(e, file=sys.stderr)

    print("Program execution continues normally here.")

if __name__ == '__main__':
    main()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/python

import random

# cool grid pattern about prime factors
# each cell is sum of the cell above and cell to the left 
# HOWEVER no number can exist that has multiple of the same prime factor
# if this would happen then you have to automatically take out all duplciate 
# copies of this factor
# Eg 12 reduces to 6

def genGrid(rows, cols):
    initVal = 0
    grid = [[initVal for r in range(rows)] for c in range(cols)]
    setStartingVals(grid)
    for r, row in enumerate(grid):
        for c, val in enumerate(row):
            # Skip custom starting condition cells
            if val != initVal:
                continue

            upVal = 0
            if r != 0:
                upVal = grid[r-1][c]

            leftVal = 0
            if c != 0:
                leftVal = grid[r][c-1]

            sum = upVal + leftVal
            grid[r][c] = removeDuplicateFactors(sum)

    return grid

def setStartingVals(grid):
    grid[0][1] = removeDuplicateFactors(random.randrange(1000))
    grid[1][0] = removeDuplicateFactors(random.randrange(1000))

# Returns largest squarefree multiple of n
def removeDuplicateFactors(n):
    factors = primeFactors(n)
    uniqueFactors = []
    for factor in factors:
        if factor not in uniqueFactors:
            uniqueFactors.append(factor)
    product = reduce(lambda x,y: x*y, uniqueFactors, 1)
    return product

def primeFactors(n):
    factors = []
    remaining = n
    while True:
        # TODO could optimize speed by not calling firstPF() in a loop. 
        # Because this re-searches the low primes over and over
        # Also could memoize list of low primes, etc. 
        nextFactor = firstPrimeFactor(remaining)
        # If no next factor found, we are done.
        if nextFactor <= 0:
            return factors

        # Else save the factor, shrink 'remaining', and proceed
        factors.append(nextFactor)
        remaining = remaining / nextFactor

def isPrime(n):
    return firstPrimeFactor(n) == n

def firstPrimeFactor(n):
    if n < 2:
        return -1

    candidate = 2
    while candidate * candidate <= n:
        if n % candidate == 0:
            return candidate

        # Increment to next candidate factor.
        while True:
            # Go to next odd number, ie +2 unless we're at 2.
            if candidate == 2:
                candidate = 3
            else:
                candidate = candidate + 2

            if isPrime(candidate) or candidate**2 > n:
                break

    # Case where n is prime
    return n

def printGrid(grid):
    for r, row in enumerate(grid):
        for c, val in enumerate(row):
            if val <= 9999:
                print("{:4d}".format(val)),
            else:
                print("XXXX"),
        print("")

# 1 does not count. 
# If n is squarefree, returns 1
def firstSquareFactor(n):
    root = 2
    square = root * root
    while square <= n:
        if n % square == 0:
            return square
        root = root + 1
        square = root * root
    return 1


# Are any of the factors of n perfect squares? (not counting 1 obviously)
def isSquareful(n):
    return firstSquareFactor(n) != 1

# 'for a given range, what is the ratio of squareful to squarefree integers?'
def printSurvey(start, count):
    for i in range(start, start + count):
        if isSquareful(i):
            print(str(i) + ' has a square factor')
        else:
            print(str(i) + ' does not have a square factor')




# commands for 'python factorsgrid.py'
# printSurvey(25129935713329319, 50)

# 42,56 fits my screen (2015 july 2 at 1248)
#printGrid(genGrid(42,56))


#Playing with math module and definition
#yen kha 6/6/2014"""

#example 1: import math module

#import math
#from math import *  #this imports all math modules from python library

"""import sqrt, exp #this imports only square root and exponential modules 
from math"""

#example 2: create a small program prompting user to enter a value with
#a defined square root function"""

x = raw_input ("enter a value to calculate square root of x")

print x

def square (x):
    return x*x






from decimal import *

__author__ = 'Eddie'

START_NUM = 00000000
END_NUM = 99999999
REQUIRED_ROOT_LIST = [1, 4, 7, 9]

def solve():
    for num in range(START_NUM, END_NUM+1):
        super_number = generate_super_number(num)
        print "Checking {0}, {1}".format(str(num).zfill(8), super_number)
        if is_perfect_square(super_number):
            return int(Decimal(super_number).sqrt())

    return None

def get_digital_root(num):
    """
    Gets the digital sum of a number
    :param num: Int
    :return: Int
    """
    while len(str(num)) > 1:
        r = 0
        while num:
            r, num = r + num % 10, num / 10
        num = r

    return num

def generate_super_number(num):
    """
    Shuffles num in between 1234567890 to generate the special number to check.
    :param num: Int
    :return: Int
    """
    new_num = int('0'.join(list(str(num).zfill(8))) + '000')
    new_num += 1020304050607080900
    return int(new_num)

def is_perfect_square(num):
    """
    Determines whether or not a number is a perfect square. Checks using its digital root first to
    rule out impossible choices. We know that for a number to be a square number, its digital root
    must be 1, 4, 7, or 9
    :param num: Int
    :return: Boolean
    """
    digital_root = get_digital_root(num)
    if digital_root not in REQUIRED_ROOT_LIST:
        return False

    # Satisfies the square digital root test, now actually check if its a perfect square.
    if Decimal(num).sqrt() % 1 == 0:
        return True

    return False

if __name__ == "__main__":
    answer = solve()
    print "The answer is: {0}".format(answer)
"""
Clifton Crosland
Project Euler 206 - Find the concealed square - 1_2_3_4_5_6_7_8_9_0
"""
import math

DIGITS = [1,2,3,4,5,6,7,8,9,0]

def is_concealed_number(n):
  matches = 0
  while n != 0:
    digit = n % 10
    if digit != DIGITS[10 - 1 - matches]:
      return False
    matches += 1
    n /= 100
  return matches == 10
  
def main():
  MIN = 1020304050607080900
  MAX = 1929394959697989990
  root = int(math.sqrt(MIN))
  while True:
    if root % 100 == 30 or root % 100 == 70:
      square = root * root
      # Since the square ends in a 0, then the root must be a multiple of 10.
      # Hence, the square must be a multiple of 100.  Since the third to last digit
      # of the square is a 9, then the square must end in 900.  We can get 900 if
      # the last two digits of the root are 30 or 70 (30^2 = 900, 70^2 = 4900).
      if square % 1000 == 900:
        if is_concealed_number(square):
          print "Rock on!"
          print "square = %d, root = %d" % (square, root)
          return
    root += 10
  
if __name__ == "__main__":
  main()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

class BilinearEvaluator(object):
	"""Evaluate a bilinear learner"""
	def __init__(self,learner):
		super(BilinearEvaluator, self).__init__()
		self.learner = learner
	
	def evaluate(self,X,Y):
		pass

class SquareEval(BilinearEvaluator):
	"""Evaluate using the sum square error"""
	def __init__(self, learner):
		super(SquareEval, self).__init__(learner)

	def evaluate(self,X,Y):
		if type(X) is not list:
			X = [X]
		total = 0
		for i in range(len(X)):
			y = Y[i:i+1,:]
			x = X[i].T
			total+=self._sumSquaredError(
				x,y,
				self.learner.u,
				self.learner.w,
				self.learner.bias
			)
		return total
	def _sumSquaredError(self,x,y,u,w,bias=None):
		total = 0
		for t in range(u.shape[1]):
			# ipdb.set_trace()
			dotproduct = u[:,t:t+1].T.dot(x).dot(w[:,t:t+1])[0,0]
			withoutbias = dotproduct
			if bias is not None: dotproduct += bias[0,t]
			# logging.info("task=%d,y=%2.5f,v=%2.5f,vb=%2.5f,delta=%3.9f"%(
			# 	t,y[0,t],dotproduct,withoutbias,
			# 	pow(y[0,t]-dotproduct,2)
			# ))
			total+= pow(y[0,t] - dotproduct,2)
		return total

class MeanSquareEval(BilinearEvaluator):
	"""Evaluate using the sum square error"""
	def __init__(self, learner):
		super(MeanSquareEval, self).__init__(learner)
		self.se = SquareEval(learner)

	def evaluate(self,X,Y):
		if type(X) is not list:
			X = [X] 
		return self.se.evaluate(X,Y)/(Y.shape[0] * Y.shape[1])
		
class RootMeanSquareEval(BilinearEvaluator):
	"""Evaluate using the sum square error"""
	def __init__(self, learner):
		super(RootMeanSquareEval, self).__init__(learner)
		self.mse = SquareEval(learner)

	def evaluate(self,X,Y):
		return sqrt(self.mse.evaluate(X,Y))
#!/usr/bin/env python
# 6yr old math, find square root of a number
# usage: ./square-number $number

import sys
from sys import argv

# catch error if no input entered
if len(argv) > 1:
    print "processing.."
else:
    print "you need to enter a number bud"
    sys.exit()

# capture input as our number
n = argv[1]
# turn our number into an integer
n = int(n)

# lifting the math
def square(n):
    """Returns the square of a number."""
    squared = n ** 2
    print "%d squared is %d." % (n, squared)
    return squared

square(n)

# -*- coding: utf-8 -*-
"""

    Find the square root of a number
    --------------------------------

    Find the square root of any number (square root can be a real number)
    without using any library function.

"""


def problem():
    """ Attempt to solve the problem """

    return 'N/A'

if __name__ == "__main__":

    print problem()

__Author__ = "Conor O'Kelly"


"""
Pseudocode

Get input
    Convert input to int

Test if input negative
    If negative quit
    If positive continue

While input is not equal to (integer ** 2 ) or count
    count += 1

    if (integer ** 2) == input
        Square root found
    if input == count
        square root not found

"""

# squre root finder function

def square_root():

    number = get_input_int()

    if number > 0:
        find_square(number)
    else:
        print "The number entered is below 0. Program quiting."

# Find square root

def find_square(number):

    result = 0
    count = 0
    
    # Test exhaustive enumberation
    while number != result and number != count:

        # Order is important. Need to increase count. Then generate result for testing
        count += 1
        result = count ** 2
            
    # Print correct statements
    if number == result:
        print "The square root of %i is %i" % (number, count)
    else:
        print "Could not find the square root for the number %i" % (number)

    

# Get input and convert to in function

def get_input_int():

    number = raw_input ("Please give me a number \n")
    number = int(number)

    return number

# Test 1
square_root()

'''
7/23/12
Page 24
'''

def testable(x):
    r"""
    The 'testable' funtion returns the square root of its
    parameter, or 3, whichever is larger.
    >>> testable(7)
    3.0
    >>> testable(16)
    4.0
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    return x**0.5
from turtle import *
import tkinter
from heap import *
from math import fabs

data = {}
data['globVisited'] = []


class Queue:
    def __init__(self):
        self.items = Heap()
    def enqueue(self, anitem):
        self.items.insert(anitem)
    def dequeue(self):
        return self.items.delMin()
    def isEmpty(self):
        return self.items.size()==0
    def size(self):
        return self.items.size()
    def empty(self):
        self.items = Heap()
        
def main():
    root = tkinter.Tk()
    root.title("Best First Search")
    cv = ScrolledCanvas(root,600,600,600,600)
    cv.pack(side = tkinter.LEFT)
    frame = tkinter.Frame(root)
    frame.pack(side = tkinter.RIGHT)
    t = RawTurtle(cv)
    t.ht()
    m = RawTurtle(cv)
    screen = t.getscreen()
    screen.setworldcoordinates(0,0,600,600)
    mazeFile = open("maze.txt","r")
    rows = int(mazeFile.readline())
    cols = int(mazeFile.readline())
    maze = []
    for line in mazeFile:
        maze.append(line)
    Q = Queue()
    squareWidth = 600/cols
    squareHeight = 600/rows
    
    class Node:
        def __init__(self,col,row):
            self.row = row
            self.col = col
        def __str__(self):
            st = str(self.col) + ',' + str(self.row)
            return st
        def getCol(self):
            return self.col
        def getRow(self):
            return self.row
        def __lt__(self,other):
            if manhattenDistance(self) < manhattenDistance(other):
                return True
        def __eq__(self,other):
            if self.row == other.row and self.col == other.col:
                return True
            
    class Path:
        def __init__(self,turtle,visitedList):
            self.t = turtle
            self.visitedList = visitedList
        def getTurtle(self):
            return self.t
        def setTurtle(self,turtle):
            self.t = turtle
        def getPath(self):
            return self.visitedList
        def setPath(self,visitedList):
            self.visitedList = visitedList
        def __lt__(self,other):
            if manhattenDistance(self.getPath()[0]) < manhattenDistance(other.getPath()[0]):
                return True
        def __eq__(self,other):
            if manhattenDistance(self.getPath()[0]) == manhattenDistance(other.getPath()[0]):
                return True
    
    for c in range(cols):
        if maze[0][c] == ' ':
            startCol = c
    for c in range(cols):
        if maze[rows-1][c] == ' ':
            endCol = c
    startNode = Node(startCol,0)
    goalNode = Node(endCol,rows-1)
    
    def manhattenDistance(currentNode):
        curRow = currentNode.getRow()
        curCol = currentNode.getCol()
        goalRow = goalNode.getRow()
        goalCol = goalNode.getCol()
        rowDiff = goalRow - curRow
        colDiff = goalCol - curCol
        return fabs(colDiff) + fabs(rowDiff)
    
    def drawmaze():
        screen.tracer(0)
        mazeSquares = ((0,0),(squareHeight,0),(squareHeight,squareWidth),(0,squareWidth))
        screen.register_shape("square",mazeSquares)
        m.shape("square")
        m.ht()
        m.up()
        currentWidth = 0
        currentHeight = 600
        m.goto(300,300)
        for i in range(rows):
            screen.update()
            for j in range(cols):
                if maze[i][j] == "*":
                    m.goto(currentWidth,currentHeight)
                    m.stamp()
                currentWidth += squareWidth
                if currentWidth >= 600:
                    currentWidth = 0
                    currentHeight -= squareHeight
        screen.tracer(1)
        
    def adjacentNode(stackObject):
        turtle,visitedList = stackObject
        currentNode = visitedList[0]
        row = currentNode.getRow()
        col = currentNode.getCol()
        adjList = []
        if col != cols-1:
            if maze[row][col+1] == ' ':
                if data['globVisited'].count((col+1,row)) == 0:
                    data['globVisited'].append((col+1,row))
                    adjList.append(Node(col+1,row))
        if col != 0:
            if maze[row][col-1] == ' ':
                if data['globVisited'].count((col-1,row)) == 0:
                    data['globVisited'].append((col-1,row))
                    adjList.append(Node(col-1,row))
        if row != rows-1:
            if maze[row+1][col] == ' ':
                if data['globVisited'].count((col,row+1)) == 0:
                    data['globVisited'].append((col,row+1))
                    adjList.append(Node(col,row+1)) 
        if row != 0:
            if maze[row-1][col] == ' ':
                if data['globVisited'].count((col,row-1)) == 0:
                    data['globVisited'].append((col,row-1))
                    adjList.append(Node(col,row-1))
        if len(adjList) != 0:
            if len(adjList) > 1:
                temp = adjList.pop()
                newVisitedList = [temp] + visitedList
                turtle.goto((temp.getCol() * squareWidth) + (squareWidth/2),600 - (temp.getRow() * squareHeight) - (squareHeight/2))
                newStackObject = Path(turtle,newVisitedList)
                Q.enqueue(newStackObject)
                while adjList != []:
                    temp1 = adjList.pop()
                    newTurtle = RawTurtle(cv)
                    newTurtle.pu()
                    newTurtle.ht()
                    newTurtle.goto((temp1.getCol() * squareWidth) + (squareWidth/2),600 - (temp1.getRow() * squareHeight) - (squareHeight/2))
                    newTurtle.st()
                    newTurtle.pd()
                    newTurtle.pencolor("red")
                    newTurtle.pensize(7)
                    newVisitedList = [temp1] + visitedList
                    newStackObject = Path(newTurtle,newVisitedList)
                    Q.enqueue(newStackObject)
            else:
                temp = adjList.pop()
                newVisitedList = [temp] + visitedList
                newStackObject = Path(turtle,newVisitedList)
                turtle.goto((newVisitedList[0].getCol() * squareWidth) + (squareWidth/2),600 - (newVisitedList[0].getRow() * squareHeight) - (squareHeight/2))
                Q.enqueue(newStackObject)
            
    def bfs(startingNode,goalNode):
        visitedList = [startingNode]
        startRow = startingNode.getRow()
        startCol = startingNode.getCol()
        data['globVisited'].append((startCol,startRow))
        t.pu()
        t.ht()
        t.pensize(7)
        t.pencolor("red")
        t.goto((startCol * squareWidth) + (squareWidth/2),600 - (startRow * squareHeight) - (squareHeight/2))
        t.pd()
        t.st()
        Q.enqueue(Path(t,visitedList))
        while not Q.isEmpty():
            pathObject = Q.dequeue()
            turtle = pathObject.getTurtle()
            visitedList = pathObject.getPath()
            stackObject = (turtle,visitedList)
            if visitedList[0] == goalNode:
                drawFinishedPath(visitedList)
                Q.empty()
            else:
                adjacentNode(stackObject)
    
    def drawFinishedPath(finishedPath):
        t.pencolor("green")
        t.pensize(7)
        t.ht()
        t.pu()
        while finishedPath != []:
            nextNode = finishedPath.pop(0)
            c = nextNode.getCol()
            r = nextNode.getRow()
            prevc = nextNode.getCol()
            prevr = nextNode.getRow()
            t.goto((c * squareWidth) + (squareWidth/2),600 - (r * squareHeight) - (squareHeight/2))
            t.st()
            t.pd()
            
    drawmaze()
    bfs(startNode,goalNode)
    root.mainloop()
    
    
                
main() 
def testable(x):
    r"""
    The testable function returns the square root of its parameter, or 3, whichever is larger
    >>> testable(7)
    3.0
    
    >> testable(16)
    4.0
    
    >> testable(9)
    3.0
    
    >> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    else:
        return x ** 0.5


def sqrt(x):
    '''Compute square roots using the method of Helon of Alexandria.

        Args: 
            X: The number for which the square root is be computed

        Returns:
            The square root of x.

        Raises:
            ValueError: If x is Negative
    '''
    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x/ guess) / 2.0
        i += 1
    return guess

import sys

def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed")
        print(sqrt(6)) 
    except ValueError as e:
        print(e, file=sys.stderr)

    print("Program execution continutes normally here")

if __name__ == '__main__':
    main()
import numpy as np 
import random as r 
from scipy import misc
import matplotlib.pyplot as plt
import math
import os

def getColor(char):
	r = char
	g = char*char%256
	b = char*char*char%256
	return [r,g,b]

filename = os.getcwd() + '/codeToSquare.py'
filename = '/media/dodo/M3NT0R/Privat/Projekte/ticTacToe/tic5.py'
f1 = open(filename,'r')
content = f1.read()
f1.close()

content = list(content)
content2 = []
for element in content:
	content2.append(ord(element))
content = content2
length = len(content)

squareRoot = int(math.sqrt(length))+1
rest = squareRoot*squareRoot - length
restString = rest*' '
restArray = list(restString)
for element in restArray:
	content.append(ord(element))

height = squareRoot
width = squareRoot

image = []
for i in range(height):
	image.append([])

for i in range(height):
	for i2 in range(width):
		char = content[i2+i*width]
		image[i].append(getColor(char))

image = misc.toimage(image)
misc.imsave('test.png',image)


import math


def square_root ( a ):
    """Computes squar root of a
    """
    espilon = 0.1e-11
    x = a
    while True:
        y = ( x + a / x ) / 2.0
        if abs( y - x ) < espilon:
            return y
        x = y


def test_square_root():
    """Compares custom square and math.sqrt.
    """
    a = 1.0
    while a < 10.0:
        print a, '{:<13}'.format( square_root( a ) ), \
                '{:<13}'.format( math.sqrt( a ) ), \
                abs( square_root( a ) - math.sqrt( a ) )
        a += 1


test_square_root()

import math

def square_root(a):
    a = float(a)
    x = 10.0
    while True:
        y = (x+a/x)/2
        if abs(y-x)< 0.000000000001:
            break
        x = y
    return x

def layout(m):
    s = str(m)
    return s+' '*(14-len(s))

def printout():
    n = 1
    while n<10:
        n = float(n)
        colOne = square_root(n)
        colTwo = math.sqrt(n)
        diff = abs(colOne-colTwo)
        print (layout(n),)
        print (layout(colOne))
        print (layout(colTwo))
        print (layout(diff))
        n += 1

printout()        
        

import pickle
from ocr import *
from Tkinter import *
import tkFont
from PIL import *
import ImageDraw
from img_to_txt import *
from network import *
from threading import Timer

class PixelBoard:
    
    def __init__(self, master, network):
        self.master = master
        self.square = 50
        self.network = network
        
        self.state = [0] * 100
        
        self.menubar = Menu(self.master)
        self.menubar.add_command(label="Exit", command=self.master.quit)
        self.master.config(menu=self.menubar)
    
        self.canvas = Canvas(self.master, bg = "white", width = 500, height = 500)
        self.canvas.bind("<Button-1>", self.click)
        self.master.bind("<Configure>", self.resize)
        self.canvas.pack(side=LEFT)
    
    def resize(self, event):
        old_square = self.square
        self.square = min(self.canvas.winfo_width(), self.canvas.winfo_height()) / 10
        if self.square == 0:
            self.square = 50
        self.update()
    
    def click(self, event):
        y = int(event.y // self.square) 
        x = int(event.x // self.square)
        self.state[10 * y + x] = 1 - self.state[10 * y + x]
        print(get_char(self.network, self.state))
        self.update()
        
    def update(self):
        s = self.square
        for i in range(10):
            for j in range(10):
                if self.state[10 * j + i]:
                    self.canvas.create_rectangle(s * i, s * j, s * (i+1), s * (j+1), fill = "gray")
                else:
                    self.canvas.create_rectangle(s * i, s * j, s * (i+1), s * (j+1), fill = "white")
        self.canvas.update_idletasks()

class DrawingBoard:
    
    def __init__(self, master, network):

        self.master = master
        self.square = 500
        self.radius = 15
        self.network = network
        self.up = False
        self.print_timer = 0
        
        self.image = Image.new("RGB", (self.square, self.square), (255, 255, 255))
        self.draw = ImageDraw.Draw(self.image)
        
        self.menubar = Menu(self.master)
        self.menubar.add_command(label="Exit", command=self.master.quit)
        self.master.config(menu=self.menubar)
    
        self.canvas = Canvas(self.master, bg = "white", width = self.square, height = self.square)
        self.canvas.bind("<Motion>", self.motion)
        self.canvas.bind("<ButtonPress-1>", self.click)
        self.canvas.bind("<ButtonRelease-1>", self.release)
        self.master.bind("<Configure>", self.resize)
        self.master.bind("<Return>", self.recognize)
        self.canvas.pack(side=LEFT)
    
    def resize(self, event):
        old_square = self.square
        self.square = min(self.canvas.winfo_width(), self.canvas.winfo_height())
        if self.square == 0:
            self.square = 500
        self.update()
    
    def click(self, event):
        self.up = True
        self.draw_circle(event)
        if self.print_timer:
            self.print_timer.cancel()
        self.print_timer = Timer(1.0, self.recognize, [event])
        self.update()
    
    def motion(self, event):
        if self.up:
            self.draw_circle(event)
        self.update()
    
    def draw_circle(self, event):
        self.canvas.create_oval(event.x - self.radius, event.y - self.radius, 
                                event.x + self.radius, event.y + self.radius,
                                fill="black")
        self.draw.ellipse((event.x - self.radius, event.y - self.radius, 
                          event.x + self.radius, event.y + self.radius), fill="black")
    
    def release(self, event):
        self.up = False
        self.print_timer.start()
    
    def recognize(self, event):
        bitstring = image_to_bits(self.image, 10)
        l = []
        for i in bitstring:
            l.append(float(i))
        s = get_char(self.network, l)
        print(s)
        
        self.image = Image.new("RGB", (self.square, self.square), (255, 255, 255))
        self.draw = ImageDraw.Draw(self.image)
        self.canvas.delete(ALL)
        tempfont = tkFont.Font(family='Helvetica',size = 50)
        self.canvas.create_text(self.square / 2, self.square - 50, text = s, font = tempfont)
        
    def update(self):
        self.canvas.update_idletasks()

if __name__ == "__main__":
    root = Tk()
    
    try:
        n = load_network('ocr_save')
        app = DrawingBoard(root, n)
        root.mainloop()
    except IOError:
        print("run ocr.py first!")

#!/bin/python

def squareRootBi(x, epsilon):  
  assert epsilon > 0, 'epsilon must be postive, not ' + str(epsilon) 
  low = 0 
  high = max(x, 1) 
  guess = (low + high)/2.0 
  ctr = 1 
  while abs(guess ** 2 - x) > epsilon: 
    #print 'low:', low, 'high:', high, 'guess:', guess
    if guess**2 < x: 
      low = guess 
    else: 
      high = guess 
    guess = (low + high) / 2.0 
    ctr += 1 
    assert ctr <= 1000, 'iteration count exceeded' 
  print 'iterations:', ctr, 'Estimate:', guess 
  return guess
 
x = int(raw_input('Enter a value for x: '))
epsilon = float(raw_input('Enter an epsilon value (accuracy): '))
print squareRootBi(x, epsilon)

# this program will attempt to find the square root of a number, using binary search


from math import sqrt 

def square_root(a, iters=8):
		"""a = number to find the square root of 
		x = number of passes
		square_root calculates a square root using Newton's method
		"""
		y = 0
		x = a/3
		for i in range(iters):
				y = (x + a/x) / 2
				x = y
				#print (" guess is {0}".format(y))
		
		return y

for i in range(1,10):
		print("{0} {1:.9f} {2:.9f} {3}".format(i, square_root(i), sqrt(i),  abs(square_root(i) - sqrt(i))) )
		

import math

def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True
    else:
        return False



for i in range(1,1001):
    for j in range(1,1001):
        ab = i**2 + j**2
        c = math.sqrt(ab)
        if is_square(ab) == True and i > j and (i + j) == 1000 - c:
            print(i,j,c)
            print(i*j*c)
            print(i+j+c)
        
  

'''
calculate.py

Include methods that add and multiply two numbers and return the results. 
Also include a method that returns the square root of a number.
'''

from math import sqrt

def add(x,y):
    return x + y

def multiply(x,y):
    return x * y

def square_root(x):
    return sqrt(x)


"""Exercise 7.2. Encapsulate this loop in a function called square_root that takes a as a parameter,
chooses a reasonable value of x, and returns an estimate of the square root of a."""

def my_square_root(a,x) :
    e = 0.0001
    while True :
        y=(x+a/x)/2
        if abs(y-x) < e :
            return y
            break
        x = y

a = input("Find square root of which number? ",)
x = input("What is your first guess?")    
result = round(my_square_root(float(a),float(x)),3)
print("The square root of ",a,"is ",result)

#-*-coding:utf-8-*-
'''
@author: Hung-Hsin Chen
@mail: chenhh@par.cse.nsysu.edu.tw
@license: GPLv2
'''

from PyMOGEP.decorator import symbol
import numpy as np

__all__ = ['op_ln', 'op_log10', 'op_power', 'op_exp', 'op_power10', 'op_square',
           'op_cube', 'op_root', 'op_cube_root', 'op_inverse']

@symbol('LN')
def op_ln(x):
    return np.log(x)

@symbol('LOG10')
def op_log10(x):
    return np.log10(x)

@symbol('^')
def op_power(x, y):
    return x**y

@symbol('E^')
def op_exp(x):
    return np.exp(x)

@symbol('10^')
def op_power10(x):
    return 10 ** x

@symbol('^2')
def op_square(x):
    return x*x

@symbol('^3')
def op_cube(x):
    return x*x*x

@symbol('Q')
def op_root(x):
    return np.sqrt(x)

@symbol('Q3')
def op_cube_root(x):
    return x ** (1./3)

@symbol('^-1')
def op_inverse(x):
    return 1./x


from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from math import sqrt

def rms(a):
    """
    Computes the root mean square of *a*, which is a numpy array. The
    result is a double constant.
    """
    return sqrt((a**2).mean())

def cmc(a):
    """
    Computes the cubic root mean cube of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a**3).mean())**(1.0/3.0)

def nmn(a,n):
    """
    Computes the nth root mean nth power of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a**n).mean())**(1/float(n))

def mySqrt():
    n=int(input("O hai, please enter a number you'd like to take square root of it:"))
    if n>0:
	    approximation = 0.5 * n
	    b = 0.5 * (approximation + n/approximation)
	    while b != approximation:
             approximation = b
             b = 0.5 * (approximation + n/approximation)
    else: 
        print("please enter a nonzero value")
    return approximation
def main():
    print(mySqrt())
main()

def solver():
    """ Find the unique positive integer whose square has the form
    1_2_3_4_5_6_7_8_9_0 where _ is a single digit

    We can find the maximum and minimum boundary of square roots
    that satisfy 1020304050607080900 < n ** 2 < 1929394959697989990

    Note that a square ending in "0" has to end in at least "00",
    therefore we can simplify the problem to fnding the bounds of
    10203040506070809 < n ** 2 < 19293949596979899 and then multiplying
    the square root by 10
    
    (solved 2014-11-29)
    """
    min_bound = int(10203040506070809 ** 0.5)
    max_bound = int(19293949596979899 ** 0.5) + 1

    for number in xrange(min_bound, max_bound):
        if str(number ** 2)[::2] == "123456789":
            return number * 10  # multiply back by 10

solver()
#! /usr/bin/env python 
from fraction import *
from math import *

def solvePellEquation(D):
   x = -1
   y = -1
   a = [int(sqrt(D)), int(1.0 / (sqrt(D) - int(sqrt(D))))]
   pnm2 = a[0]             # p[n - 2]
   pnm1 = a[1] * pnm2 + 1  # p[n - 1]
   qnm2 = 1                # q[n - 2]
   qnm1 = a[1]             # q[n - 1]
   Pnm2 = 0                # P[n - 2]
   Pnm1 = a[0]             # P[n - 1]
   Qnm1 = D - a[0] * a[0]  # Q[n - 1]
   n = 2
   found = False
   while not found:
      Pn = a[n - 1] * Qnm1 - Pnm1
      Qn = (D - Pn * Pn) / Qnm1
      a.append(int((a[0] + Pn) / Qn))
      pn = a[n] * pnm1 + pnm2
      qn = a[n] * qnm1 + qnm2
      if a[n] == 2 * a[0]:    # When a[n] == 2a0 we have the term where the continued fraction becomes periodic
         if (n - 1) % 2 != 0: # n - 1 odd -> return (p[n - 1], q[n - 1])
            x = pnm1
            y = qnm1
         else:                # n - 1 even -> return (p[2n - 1], q[2n - 1])
            pnm2 = pnm1
            pnm1 = pn
            qnm2 = qnm1
            qnm1 = qn
            Pnm1 = Pn
            Qnm1 = Qn
            limit = 2 * n - 1 # Want to return p and q at point 2n - 1
            while n < limit:
               n = n + 1
               Pn = a[n - 1] * Qnm1 - Pnm1
               Qn = (D - Pn * Pn) / Qnm1
               a.append(int((a[0] + Pn) / Qn))
               pn = a[n] * pnm1 + pnm2
               qn = a[n] * qnm1 + qnm2
               pnm2 = pnm1
               pnm1 = pn
               qnm2 = qnm1
               qnm1 = qn
               Pnm1 = Pn
               Qnm1 = Qn
            x = pn
            y = qn
         found = True
      pnm2 = pnm1
      pnm1 = pn
      qnm2 = qnm1
      qnm1 = qn
      Pnm1 = Pn
      Qnm1 = Qn
      n = n + 1
   return x, y

if __name__ == "__main__":
   squareRootOfSquareNumber = 2
   largestD = -1
   largestX = -1
   for D in range(2, 1000):
      if D != (squareRootOfSquareNumber * squareRootOfSquareNumber):
         x, y = solvePellEquation(D)
         if x > largestX:
            largestX = x
            largestD = D
      else:
         squareRootOfSquareNumber = squareRootOfSquareNumber + 1

   print 'Answer: D =', largestD, 'and x =', largestX

# from math import sqrt

__author__ = 'Shane'
# Uses Newton's Method to estimate the square root of a positive number


def mysqrt(n, x):
    if abs(n - x ** 2) < 0.0000000000001:
        return x
    else:
        x = (x + n / x) / 2
        return mysqrt(n, x)


def main():
    a = 0
    while a <= 0:
        a = float(input("Enter a number: "))
        if a <= 0:
            print("")
            print("Please enter a positive number!")
    sqrta = mysqrt(a, 1)
    print("")
    print("The square root of", a, "is about", sqrta)
    # print("Error: ", sqrta - sqrt(a))

main()

'''
# To display a list:
for i in range(1,21):
    print("The square root of", i, "is about", mysqrt(i, 1))
'''

#/bin/python

# http://projecteuler.net/problem=211

'''
For a positive integer n, let 2(n) be the sum of the squares of its divisors. For example,

2(10) = 1 + 4 + 25 + 100 = 130.
Find the sum of all n, 0  n  64,000,000 such that 2(n) is a perfect square.
'''

from prime import get_divisors

def is_perfect_square(n):
    root = n**0.5
    return root == int(root)

tot = sum((n for n in range(0,60000000) if is_perfect_square(sum(get_divisors(n)))))
#tot = sum((n for n in range(0,600000) if is_perfect_square(sum(get_divisors(n)))))
print(tot)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!usr/bin/env python
#python3_only


import sys
import math
import pprint


def main():
	try:
		print(sqrt(9))
		print(sqrt(2))
		print(sqrt(10))
		print(is_prime(5))
		print("This never printed.")
		prime_square_divisors = {x*x:(1, x, x*x) for x in range(101)
						 if is_prime(x)}
		pp = pprint.pprint
		pp(prime_square_divisors)
	except ValueError as e:
#		print(e, file=sys.stderr)
		print("Program execution continues normally here.")


def sqrt(x):
	
	if x < 0:
		raise ValueError("Cannot compute square root"
						 " of negative number {}".format(x))
	guess = x
	i = 0
	while guess * guess != x and i < 20:
		guess = (guess + x / guess) / 2.0
		i += 1 
	return guess


def is_prime(x):
	if x < 2:
		return False
	for i in range(2, int(sqrt(x)) + 1):
		if x % i == 0:
			return False
	return True
	
	
if __name__ == '__main__':
	main()
#	[x for x in range(101) if is_prime(x)]


###Implement int sqrt(int x).

###Compute and return the square root of x.
## (x/2+1)**2 >= x**2
#time O(logn)
#space O(n1)

def Sqrt(x):
	if x == 0:
		return 0
	i = 1
	j = x//2+1
	while (i <= j):
		center = (i+j)//2
		if center**2 == x:
			return center
		elif center **2 >x:
			j = center-1
		else:
			i = center+1
	return j

#!/usr/bin/python
# Used to generate source_root() calls

import logging
import os
import sys

from pom_utils import PomUtils


logger = logging.getLogger(__name__)


class RootBuildGenerator(object):

  def __init__(self):
    pass

  def generate(self):
    modules = PomUtils.get_modules()

    contents = "# Automatically generated by {0}\n\n".format(os.path.basename(sys.argv[0]))
    for module in modules:
      contents += "square_maven_layout('{0}')\n".format(module)

    return contents


def main():
  print RootBuildGenerator().generate()

if __name__ == "__main__":
  main()

def testable(x):
    r"""

    The `testable` function returns the square root of its parameter,
    or 3, whichever is larger.

    >>> testable(7)
    3.0

    >>> testable(16)
    4.0

    >>> testable(9)
    3.0

    >>> testable(10) == 10 ** 0.5
    True

    """

    if x < 9:
        return 3.0
    return x ** 0.5

#!/usr/bin/python
from math import sqrt
'''
    Purpose: https://projecteuler.net/problem=12
    A direct brute force approach
    @author:Pramod S   
'''
def numberofDivisors(num):
    nod,squareRoot=0,int(sqrt(num))
    for i in range(1,squareRoot+1):
        if(num%i==0):
            nod+=2
    if((squareRoot*squareRoot) == num):
        nod = nod - 1
    return nod
    
def main():
    number,i=0,1
    while(numberofDivisors(number) < 500):
        number+=i
        i+=1
    print("Result: {0}".format(number))
if __name__ == "__main__":
    main()

# Miscellaneous utilities.

def reverse_number(n, base=10):
    result = 0
    while n > 0:
        result = result * base + n % base
        n //= base
    return result

def is_palindrome(n, base=10):
    return n == reverse_number(n, base)

def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0
    a, b = divmod(n.bit_length(), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y

'''
Problem 45:

Triangle, pentagonal, and hexagonal numbers are generated by the following
formulae:

Triangle   | Tn=n(n+1)/2  | 1, 3, 6, 10, 15, ...
Pentagonal | Pn=n(3n-1)/2 | 1, 5, 12, 22, 35, ...
Hexagonal  | Hn=n(2n-1)   | 1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
'''
from p042 import is_square
from p044 import pentagonal
from math import sqrt

def is_triangular(tn):
    '''Leverages:
    The inverse of triangular: n = -1/2 + 1/2 * sqrt(1 + 8 * tn)
    Therefore, 1 + 8 * pn must be square for tn to be triangular.
    Also, since n must be an integer, the evaluated sqrt must be odd
    '''
    special_factor = 1 + 8 * tn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 2 == 1:
            return True
    return False

def is_hexagonal(hn):
    '''Leverages:
    The inverse of hexagonal: n = -1/4 + 1/4 * sqrt(1 + 8 * hn)
    Therefore, 1 + 8 * hn must be square for hn to be hexagonal.
    Also, since n must be an integer, the evaluated sqrt must:
        Have a modulus of 3 with 4
    '''
    special_factor = 1 + 8 * hn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 4 == 3:
            return True
    return False

def is_joint_number(num):
    return is_triangular(num) and is_hexagonal(num)


def find_next_joint_number(nth_pentagonal=1):
    while not is_joint_number(pentagonal(nth_pentagonal)):
        nth_pentagonal += 1
    return pentagonal(nth_pentagonal)

def main():
    print find_next_joint_number(nth_pentagonal=166)

if __name__ == "__main__":
    main()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#! /usr/bin/env python3

import math

def isSquare(a) :
	return math.sqrt(a) == float(math.floor(math.sqrt(a)))


def squareRootDigitByDigit (number, numberOfDigits) :

	squareRootResult = 0

	numberRest = number
	remainder = 0

	digit = 0
	while digit < numberOfDigits  :

		c = 0

		if numberRest != 0 :
			log10OfRest = math.floor(math.log10(numberRest))

			if log10OfRest % 2 == 1 :
				log10OfRest -= 1

			magnitudeOfRest = int(math.pow(10,log10OfRest))

			#if numberRest > 9 :
			#	magnitudeOfRest /= 10
			

			c = int(numberRest / magnitudeOfRest)

			numberRest -= c*magnitudeOfRest

		else :
			numberRest = 0
		

		c += remainder*100




		# c is prepared

		p = squareRootResult

		# p is prepared

		y = c
		x = 0
		while y <= c :

			y = (20*p + x) * x

			x += 1

		x -= 2
		y = (20*p + x) * x

		# x,y is prepared

		remainder = c - y

		squareRootResult = squareRootResult*10 + x

		#print("c",c, "rest",numberRest, "mag",magnitudeOfRest, "p",p, "x",x, "y",y, "->", squareRootResult)



		digit += 1


	return squareRootResult


def digitSum (number) :

	sum = 0
	rest = number

	while len(rest) > 0 :

		digit = int(rest[0])
		rest = rest[1:]

		sum += digit

	return sum


sumsum = 0

i = 2
while i < 101 :

	if isSquare(i) == False :

		digits = squareRootDigitByDigit(i,100)

		sum = digitSum(digits.__str__())

		sumsum += sum

		print(i, ":", sum, digits)

	i += 1


print(sumsum)


from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/python

#============================================================================
# Project Euler: http://wwww.projecteuler.net
# Problem 7: http://projecteuler.net/index.php?section=problems&id=7
# What is the 10001st prime number?
#============================================================================

#import libraries/modules
import sys
from math import sqrt, floor

#find square root of passed number
def squareRoot(x):
     root = int(floor(sqrt(x)))
     #make the root number odd
     if root % 2 == 0:
          root +=1
     return root

#checks to see if number is prime
def checkPrime(x):
     prime = True   #flag
     
     #basic simple check to see if number passed is even, if it is then it's not a prime number
     if x % 2 == 0: 
          return False
     
     checkedNumber = squareRoot(x)
     for i in range(3,checkedNumber+2,2):
          if x % i == 0:
               prime = False
               break
     return prime

count = 3
primeCount = 2

#main 
while primeCount < 10001:
     count += 2
     if checkPrime(count):
          primeCount +=1
 
print "The 10001 prime number is", count
def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high)/2.0
    ctr = 1
    while abs(guess**2 - x) > epsilon and ctr <= 100:
        #print 'guess**2 - x is greater than epsilon : ' , epsilon , 'low:', low, 'high:', high, 'guess:', guess
        if guess**2 < x:
            low = guess
            print 'guess**2 - x is less than epsilon : ' , epsilon , ' and now low value is ', low
        else:
            high = guess
            print 'guess**2 - x is greater than epsilon : ', epsilon , ' and now high value is ', high
        guess = ( low + high )/2.0
        print guess
        ctr += 1
        print ctr
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:' , ctr, 'Estimate:', guess
    return guess


def testBi():
    print ' squareRootBi(4, 0.0001)'
    squareRootBi(4, 0.0001)
    print ' squareRootBi(9, 0.0001)'
    squareRootBi(9, 0.0001)
    print ' squareRootBi(2, 0.0001)'
    squareRootBi(2, 0.0001)
    print ' squareRootBi(0.25, 0.0001)'
    squareRootBi(0.25, 0.0001)
    #In last case, the iteration process is excedded the term 100, so the program stop.


def squareRootNR(x, epsilon):
    """Assume x >= 0 and epsilon >0
        Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, ' x must be non non-negative, not' + str(x)
    assert epsilon > 0, ' epsilon must be positive, not negative'
    x = float(x)
    guess = x/2.0
    guess = 0.0001
    deff = guess**2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:
        #print 'Error:', diff, 'Guess: ', guess
        guess = guess - diff/(2.0*guess)
        diff = guess**2 - x
        ctr += 1
        assert ctr <= 100, 'Iteratoin count exceeded'
        print 'NR method. Num. iterations:', ctr,  'Estimate'
     

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# Name: LeptonPair.py
#
# CMS Open Data
#
# Description: sums pairs of leptons and gets their mass, energy, momentum and transverse momentum
#
# Returns: 


__author__ = "Palmerina Gonzalez Izquierdo"
__copyright__ = "Copyright (C) 2015 Palmerina G. I."
__license__ = "Public Domain"
__version__ = "1.0"
__maintainer__ = "Palmerina Gonzalez"
__email__ = "pgi25@alumnos.unican.es"

import ROOT
import math
import numpy as np
from DataFormats.FWLite import Events, Handle

class LeptonPair(object):

	def __init__(self, l1, l2, vertex):
	 	"""
	 	l1, l2: leptons 
	 	It sums the four-momentums of l1 and l2 and gets their mass, their energy and their transverse momentum
	 	"""

		self.l1 = l1
		self.l2 = l2		
		self.vertex = vertex

 		self.px = self.l1.px()+self.l2.px() #GeV/c
 		self.py = self.l1.py()+self.l2.py()
 		self.pz = self.l1.pz()+self.l2.pz()
		self.energy = self.l1.energy() + self.l2.energy() #GeV

		self.squareEnergy = np.power(self.energy,2)			
	 	self.squareP = np.power(self.px,2) + np.power(self.py,2) + np.power(self.pz,2)
		
	 	#l.px(),l.py(),l.pz() and l.energy() are ROOT methods


	def mass(self):
	 	#invariant mass
		squareM = self.squareEnergy-self.squareP
		if squareM < 0:
			return np.sqrt(-squareM) # con un - en el codigo de TLorentzVector
		else:
			return np.sqrt(squareM) # in natural units (GeV/c**2)
		

	def pt(self):
	 	#Total transverse momentum
	 	return np.sqrt(np.power(self.px,2) + np.power(self.py,2))



	def pt1(self):
	 	# Transverse momentum of lepton 2
	 	return np.sqrt(np.power(self.l1.px(),2) + np.power(self.l1.py(),2))


	def pt2(self):
	 	# Transverse momentum of lepton 2
	 	return np.sqrt(np.power(self.l2.px(),2) + np.power(self.l2.py(),2))


	def eta1(self):
	 	return self.l1.eta()


	def eta2(self):
	 	return self.l2.eta()



	def dB1(self):
		return self.l1.dB(self.l1.PV3D)


	def dB2(self):
		return self.l2.dB(self.l2.PV3D)


	def distance1(self):
		return self.l1.vertex().z()-self.vertex.z()


	def distance2(self):
		return self.l2.vertex().z()-self.vertex.z()









from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from fractions import Fraction

class Problem57:
    def getSquareRootIteration(self, iterations):
        if iterations == 1:
            return Fraction(3,2)
        n = 2
        for _ in range(1, iterations):
            n = 2 + Fraction(1, n)
        return 1 + Fraction(1, n)
        
    def answer(self):
        bigNumSum = 0
        for i in range(1, 1001):
            print("iteration:" + str(i))
            frac = self.getSquareRootIteration(i)
            if len(str(frac.numerator)) > len(str(frac.denominator)):
                bigNumSum += 1
        return bigNumSum
#!/usr/bin/python

from project_euler import timeit

cache = {}


def square_root_convergents(upper_limit):
    pell = [0, 1]
    H = [1, 1]

    res = 0
    for n in range(2, upper_limit + 1):
        pell.append(2 * pell[n - 1] + pell[n - 2])
        H.append(H[n - 1] + 2 * pell[n - 1])
        if len(str(H[n])) > len(str(pell[n])):
            res += 1

    return res


timeit(square_root_convergents, 1000)

#!/usr/bin/env python3
import math

def square_root(n):
    s = int(math.sqrt(n))
    if s * s == n:
        return s
    else:
        return None

def triangulars(limit):
    for a in range(1, limit):
        for b in range(a, limit):
            c = square_root(a * a + b * b)
            if c and c < limit: yield a, b, c

perimeters = dict()
for a, b, c in triangulars(1000):
    p = a + b + c
    if p <= 1000:
        if p in perimeters:
            perimeters[p] += 1
        else:
            perimeters[p] = 1

def max_by_value(d):
    max_key = None
    max_value = None
    for k in d:
        if not max_value or d[k] > max_value:
            max_key = k
            max_value = d[k]
    return max_key

print(max_by_value(perimeters))

'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
###############################################################################
"""
Question:
    LintCode: http://www.lintcode.com/en/problem/sqrtx/

    Implement int sqrt(int x).
    Compute and return the square root of x.
    Example
        sqrt(3) = 1
        sqrt(4) = 2
        sqrt(5) = 2
        sqrt(10) = 3

Analysis:
    Binary search. Find the last number which square of it <= x.
"""

class Solution:
    """
    @param x: An integer
    @return: The sqrt of x
    """
    def sqrt(self, x):
        start, end = 1, x
        while start + 1 < end:
            mid = start + (end - start) / 2
            if mid * mid <= x:
                start = mid
            else:
                end = mid
        if end * end <= x:
            return end
        else:
            return start
import math

def is_prime(num):
    
    for i in range(2, num):
        if num % i == 0:
            return False
    
    return True

def prime_factor_powers(num):
    square_root = int(math.sqrt(num)) + 1
    prime_factors = []
    
    for i in range(2,square_root):
        if num % i == 0:
            if is_prime(i):
                prime_factors.append(i)

    prime_factor_powers = []

    # calculating powers of factors
    for prime_factor in prime_factors:
        dividend = num
        power = 0
        while dividend % prime_factor == 0:
            dividend /= prime_factor
            power += 1
        prime_factor_powers.append(power)

    return prime_factor_powers

def solution():
    n = 1
    triangle_number = 1
    num_divisors = 1
    prime_powers = []

    while num_divisors <= 500:
        n += 1
        triangle_number += n
        prime_powers = prime_factor_powers(triangle_number)
        product = 1
        for power in prime_powers:
            product *= power + 1
        num_divisors = product 

    return n, triangle_number, num_divisors

solution()
# General iterative solving, recursive version I
# ----------------------------------------------
def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    if done(guess):
        return guess
    else:
        return iter_solve(update(guess), done, update)

# General iterative solving, recursive version II
# -----------------------------------------------
def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    def solution(guess):
        if done(guess):
            return guess
        else:
            return solution(update(guess))
    return solution(guess)

# General iterative solving, iterative version
# --------------------------------------------
def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    while not done(guess):
        guess = update(guess)
    return guess

# General iterative solving with iteration limit, recursive
# ---------------------------------------------------------
def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    def solution(guess, iteration_limit):
        if done(guess):
            return guess
        elif iteration_limit <= 0:
            raise ValueError("failed to converge")
        else:
            return solution(update(guess), iteration_limit-1)
    return solution(guess, iteration_limit)

# General iterative solving with iteration limit, iterative
# ---------------------------------------------------------
def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    while not done(guess):
        if iteration_limit <= 0:
            raise ValueError("failed to converge")
        guess, iteration_limit = update(guess), iteration_limit-1
    return guess

# Direct implementation of square root using Newton's method
# ----------------------------------------------------------
def square_root(x):
    """Compute an approximation to the square root of X.
    >>> round(square_root(9), 10)   # round to 10 decimal places
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    tol = abs(x) * 1.0e-10
    y = x * 0.5
    while abs(y*y - x) > tol:
        y -= (y * y - x) / (2.0 * y)    # y = y - (y*y - x)/ (2.0 * y)
    return y

# General Newton's method
# -----------------------
def newton_solve(func, deriv, start, tolerance):
    """Return x such that |FUNC(x)| < TOLERANCE, given initial
    estimate START and assuming DERIV is the derivatative of FUNC."""
    def close_enough(x):
        return abs(func(x)) < tolerance
    def newton_update(x):
        return x - func(x) / deriv(x) 

    return iter_solve(start, close_enough, newton_update, 1000000000)

def square_root(a):
    """Compute an approximation to the square root of A.
    >>> round(square_root(9), 10)   # round to 10 decimal places
    3.0
    """
    if a < 0:
        raise ValueError("square root of negative value")
    return newton_solve(lambda x: x*x - a, lambda x: 2 * x, 
                        a/2, a * 1e-10)

def cube_root(a):
    """Compute an approximation to the cube root of X.
    >>> round(cube_root(8), 10)   # round to 10 decimal places
    2.0
    """
    return newton_solve(lambda x: x**3 - a, lambda x: 3 * x ** 2,
                        a/3, a * 1e-10)

# Secant method
# -------------
def iter_solve2(guess, done, update, state=None):
    """Return the result of repeatedly applying UPDATE to GUESS
    and STATE, until DONE yields a true value when applied to
    GUESS and STATE.  UPDATE returns an updated guess and state."""
    while not done(guess, state):
        guess, state = update(guess, state)
    return guess

def secant_solve(func, start0, start1, tolerance):
    """An approximate solution to FUNC(x) == 0 for which
    |FUNC(x)|<TOLERANCE, as computed by the secant method
    beginning at points START0 and START1."""
    
    def close_enough(x, state):
        return abs(func(x)) < tolerance
    def secant_update(xk, xk1):
        return (xk - func(xk) * (xk - xk1) 
                                / (func(xk) - func(xk1)), 
                xk)
    return iter_solve2(start1, close_enough, secant_update, start0)

def square_root2(x):
    """An approximation to the square root of X, using the secant method.
    >>> round(square_root2(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    return secant_solve(lambda y: y*y - x, 1, 0.5 * (x + 1), x * 1.0e-10)


"""
mvdlib.misc

Miscellaneous utility functions that don't fit anywhere else.
"""

import numpy as np

def remove_offset(data):
    """Makes the minimum value of data be zero."""
    return data - np.min(data)

def normalize(data):
    """Normalizes data by dividing by the maximum value."""
    return data/np.max(data)

def fix_offset_and_normalize(data):
    """Removes dc offsets and normalizes data."""
    offset = remove_offset(data)
    return normalize(offset)

def rms(x):
    """Return the root mean square value of the array x."""
    return np.sqrt(np.sum(x**2)/len(x))


def super_root(number):
    divisor = 1
    hi = number + 0.001
    low = number - 0.001
    super_root = 1

    while True:
        current = super_root**super_root
        if low < current < hi:  # good to go!
            return super_root
        elif current > hi:      # time to backtrack
            divisor /= 2
            super_root -= divisor
        elif current < low:     # clearer than else?
            super_root += divisor

if __name__ == '__main__':
    def check_result(function, number):
        result = function(number)
        if not isinstance(result, (int, float)):
            print("The result should be a float or an integer.")
            return False
        p = result ** result
        if number - 0.001 < p < number + 0.001:
            return True
        return False
    assert check_result(super_root, 4), "Square"
    assert check_result(super_root, 9), "Cube"
    assert check_result(super_root, 81), "Eighty one"

"""Calculate the square root of a perfect square"""

__author__ = 'Nicola Moretto'
__license__ = "MIT"

def squareRootInt(x):
    '''
    Calculate the square root of a perfect square
    :param x: Positive integer
    :return: Square root of the integer (IF AND ONLY IF is a perfect square)
    '''
    # Negative numbers haven't square root
    if x < 0:
        return None

    # 0 <= square root <= x
    value = 0
    while value**2 < x:
        value += 1

    # value**2 >= x
    if value**2 == x:
        return value**2
    else:
        # value**2 > x
        return None
#!/usr/bin/python

import math

def is_square(apositiveint):
	if(apositiveint==1):
		return True
	x = apositiveint // 2
	seen = set([x])
	while x * x != apositiveint:
		x = (x + (apositiveint // x)) // 2
		if x in seen:
			return False
		seen.add(x)
	return True

def is_fair(num):
	number=list(str(num))
	length=len(number)
	for i in range(0,length/2+1):
		if(number[i]!=number[length-1-i]):
			return False
	return True

T = int(raw_input())

for case in xrange(1,T+1):
	split=raw_input().split(" ")
	A=long(split[0])
	B=long(split[1])
	count=0
	num=A
	while num<=B:
		if(is_fair(num)):
			if(is_square(num)):
				root = long(math.sqrt(num))
				if(is_fair(root)):
					count = count+1
		num=num+1
	print "Case #"+str(case)+": "+str(count)
		

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math
def mySqrt(n):
	"""
	newton's method for finding square root

	iterative method for finding value of f(x) = 0
	s' = s - f(s)/f'(s)
	"""
	delta = 1e-10
	s = n//2
	for i in range(100):
		s = 0.5 * ( s + n / s )
		if abs( s ** 2 - n ) < delta :
			break
	return s

def testMySqrt():
	print mySqrt(4.)
	print mySqrt(2.)
	print mySqrt(10001.)

testMySqrt()
import ImageChops
import math
import operator


def rmsdiff(im1, im2):
    "Calculate the root-mean-square difference between two images"

    h = ImageChops.difference(im1, im2).histogram()

    # calculate rms
    return math.sqrt(reduce(operator.add,
        map(lambda h, i: h*(i**2), h, range(256))) / (float(im1.size[0]) * im1.size[1]))


import ImageChops

def equal(im1, im2):
    return ImageChops.difference(im1, im2).getbbox() is None
import itertools
import bisect
import math

_primes = [2, 3, 5, 7]

def _grow_primes():
    n = _primes[-1] + 2
    while not all(n % p for p in _primes):
        n += 2
    _primes.append(n)

def is_prime(n):
    if _primes[-1] < n:
        next_prime(n)
    i = bisect.bisect(_primes, n)
    return _primes[i] is n

def next_prime(n):
    i = bisect.bisect(_primes, n+1)
    if i < len(_primes):
        return _primes[i]
    while _primes[-1] < n:
        _grow_primes()
    return _primes[-1]
    
def square_root_cf(s):
    a0 = int(math.sqrt(s))
    yield a0
    if a0 * a0 == s: return
    a = a0
    m = 0
    d = 1
    while a != 2*a0:
        m = d * a - m
        d = (s - m * m) // d
        a = (a0 + m) // d
        yield a

def convergents(cf_expansion):
    it = iter(cf_expansion)
    p = next(it)
    q = 1    
    p_ = 1
    q_ = 0
    for a in itertools.cycle(it):
        yield p, q
        p_, p = p, a * p + p_
        q_, q = q, a * q + q_

def solve_diophantine(d):
    for x, y in convergents(square_root_cf(d)):
        if x*x - d*y*y == 1:
            return x, y
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
def square_root(a):
    x = a/(2.0**(len(str(a))))
    
    while True:
        y = (x + (a/x))/2.0
        if abs(y-x)<=0.0000001:
            
            break
        else:
            x = y
            print x
        return x
        
    

def square_root(x, epsilon=0.0001):
    ans = x/2.0

    while abs(ans**2 - x) > epsilon:
        ans = ans - (((ans**2) - x)/(2*ans))
        
    if abs(ans**2 - x ) > epsilon:
        return None
    else:
        return ans

def cube_root(x, epsilon=0.0001):
    ans = 0

    while ans**3 < abs(x):
        ans += 1

    if ans**3 != abs(x):
        return None
    else:
        return ans;
import sys
from math import sqrt
import itertools as it

def flatten1(m):
    return sum(m, [])


def isNoComment(line):
    return not line.startswith('*')


def isLinearity(line):
    return line.startswith('linearity')
def getLinearity(line):
    return int(line.split()[1])

def getFacettes(flines):
    began = False
    for line in flines:
        if 'end' in line:
            return
#        print line
        if began:
            yield line
        if 'begin' in line:
            began = True



def squareRoot (n):

    a = int(sqrt(n - 1))
    if a*a + 1 != n:
        print "length %s not square" % (n-1)
    return a
def triRoot (n):
    a = -0.5 + sqrt(0.25 + 2*n)
    if a != int (a):
        print "warnin:", n, " not triangular"
    return int(a)
    


def squareIt (line):
#    print line
#    print line.split()
    numbers = map(int, line.split())
    n = len(numbers)
    a = triRoot(n)
    beta = numbers[0]
    m = [numbers[1:][y*a:(y+1)*a] for y in range(a)]
    s = ''.join([''.join(['% i '% num for num in line])+'\n' for line in m])
    return s, "% i" % beta

def squareTri(numbers):
    n = len(numbers)
    a = triRoot(n)
    numbers = ['% i '% num for num in numbers]
    m = [numbers[y*(y+1)/2:(y+1)*(y+2)/2]+(a-y-1)*[' . '] for y in range(a)]
    s = ''.join([''.join(line)+'\n' for line in m])
    return s



def triCo(numbers, x,y):
    c = y * (y+1)/2 + x
    if x <= y and c < len(numbers):
        return numbers [c]
    else:
        return None
#d = {0:'.', None: ' ', 1:'+', -1:'-'}

dd = {(0,0): '.  ', (1,1): '.++', (None,None): '   ',
      (1,0): '.+ ', (0,1): '. +',
      (-1,0):'.- ', (2,0): '.2 ', (-2,0): '-2 '}
def biSquareTri(num1, num2, n):
    return ''.join([''.join([dd[triCo(num1, x, y),triCo(num2, x, y)]
                             for x in range(n)])
                    +'\n'
                    for y in range(n)])

def squareItFromTri (line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    return squareTri(numbers), beta

def squareTri2 (line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    n = len (numbers)
    s = biSquareTri(numbers[:n/2], numbers[n/2:], triRoot(n/2))
    return s, beta

import threading
import _thread
import time
import math
import random


#Square Root Calculator
def mySqrt():
    print()
    print ('***Square Root Calculator***')
    print()
    print ('Please enter your number of choice:')

    x = int (input())

    time.sleep(2)
    
    """Returns the square root of x if x is a perfect square.
Prints an error message and returns none if otherwise."""
    ans = 0
    if x>=0:
        while ans*ans <x:
            ans = ans + 1
        if ans*ans == x:
            print(x, 'is a perfect square.')


            y = math.sqrt(x)
            a = (y, 'is the square root of' , x)
            print (a)

            f = open('sqrt.txt','w+')
            f.write(a)
            f.close()
            
            return ans
        
        else:
            print(x, 'is not a perfect square.')
            return None    
    else: 
            print(x, 'is a negative number.')
            
mySqrt()




#BMI Calculator
def BMI():
    print()
    print("***Body Mass Index(BMI) Calculator***")
    print()
    print("Please fill out the following:")
    print()
    x = eval(input("Your weight in Kilograms: "))
    y = eval(input("Your Height in Meters: "))

    '''BMI formula is mass(Kg) /(Height(m))* (Height(m))'''
    x = float(x)
    y = float(y)

    slp = random.randint(5,7)
    
    print('sleep time chosen is', slp , 'seconds')
    time.sleep(slp)

    c = (((x)/(y*y)))

    print (c , 'is your BMI')
    print()

    print('BMI CHART')
    print ('Below 18.5 = Underweight')
    print ('Between 18.5 and 24.9 = Normal')
    print ('Between 25 and 29.9 = Overweight')
    print ('Above 30.0 = Obese')
    
BMI()

m = random.randint(1,8)
print ()
print('integer generated is ',m)


if m % 2 == 0:
    print('--BMI calculator chosen:: The integer is even')
    _thread.start_new_thread(BMI, ())
else:
    print('Square root calculator chosen:: The integer is odd')
    _thread.start_new_thread(mySqrt, ())


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#! /usr/local/bin/python3.1

from math import sqrt

# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
# that the 6th prime is 13.
#
# What is the 10001st prime number?
#
# Answer:
#

def isPrime (candidate):
    """
    Determines if candidate is prime or not.
    """
    if ((candidate % 2) == 0):
        if (candidate == 2):
            return True
        else:
            return False

    squareRoot = sqrt(candidate)
    i = 3
    while (i <= squareRoot):
        if ((candidate % i) == 0):
            return False
        i += 2

    return True

def findNthPrime (n):
    """
    Find the nth prime
    """
    candidate = 3
    counter = 1
    while (counter < n):
        if isPrime(candidate):
            counter += 1
        candidate += 2

    candidate -= 2
    print(candidate)
    

def Problem7 (n):
    findNthPrime(n)

Problem7(10001)

from __future__ import absolute_import
import math as _pymath

from . import IntrinsicEmitter

pi = _pymath.pi
e = _pymath.e


def exp(T):
    """``exp(T)(x) -> y``

    Return e raised to the power of x.

    """
    def exp_(x):
        return IntrinsicEmitter("exp", (x,), (T,), T)
    return exp_


def pow(T):
    """``pow(T)(x, y) -> z``

    Return *x* raised to the power of *y*.

    """
    def pow_(x, y):
        return IntrinsicEmitter("pow", (x, y), (T,), T)
    return pow_


def log(T):
    """``log(T)(x) -> y``

    Return the natural logarithm of *x*.

    """
    def log_(x):
        return IntrinsicEmitter("log", (x,), (T,), T)
    return log_


def sqrt(T):
    """``sqrt(T)(x) -> y``

    Return the square root of *x*.

    """
    def sqrt_(x):
        return IntrinsicEmitter("sqrt", (x,), (T,), T)
    return sqrt_



def isSquare(a):
	'''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''
	if 0 <= a <= 10**30:
		sr = int(a**(1/2))
		if sr**2 == a:
			return sr
	else:
		x = a
		y = (x + a // x) // 2
		while y < x:
			x = y
			y = (x + a // x) // 2
		if x**2 == a:
			return x

def isSquareFloat(a):
	'''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''
	sr = int(a**(1/2))
	if sr**2 == a:
		return sr

def isSquareInteger(a):
	x = a
	y = (x + a // x) // 2
	while y < x:
		x = y
		y = (x + a // x) // 2
	if x**2 == a:
		return x

import cProfile
cProfile.run("for n in range(1,10**7): isSquare(n)")
cProfile.run("for n in range(1,10**7): isSquareFloat(n)")
cProfile.run("for n in range(1,10**7): isSquareInteger(n)")
__author__ = 'matt'
import math
def isWholeNumber(x,y):
    val = x**2 + y**2
    if is_square(val):
        return True
    return False
def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True
    else:
        return False
found = False
for x in range (1, 1000):
    for y in range(1,1000):
        if isWholeNumber(x,y):
            val = math.sqrt(x**2+y**2)
            sum = x + y + val
            if(int(sum) == 1000):
                print x
                print y
                print val
                found = True
                break
    if(found):
        break
print (200*375*425)

def iterSqRt(number):
    for counter in range(1,number):
        if counter**2 == number:
            return "square root of" + str(number) + 'is' + str(number)
    return "Failed! Square root of" + str(number) + 'is not' + str(number)
    

def findsquareroot(number):
    low = 0.0
    high = number
    epsilon = 0.001
    guess = (low + high)/ 2
    
    while abs(guess**2 - number) > epsilon:
        print "guess:  " + str(guess**2)
        if guess**2 > number:
            high = guess
        elif guess**2 < number:
            low = guess
        elif guess**2 == number:
            return 'Found square root of' + str(number) 
        guess = (low + high) / 2 
    return 'Found approximate square root of ' + str(number)  + ":    " + str(guess) 
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""Calculate the square cube of a float number"""

__author__ = 'Nicola Moretto'
__license__ = "MIT"

def squareRootNR(x, precision):
    '''
    Calculate the square root of a float number through Newton-Raphson method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None

    # x>=0
    value = x/2.0
    while abs(value**2 - x) > precision:
        value = value - (value**2 - x)/(2*value)
    return value
#! /usr/bin/env python
# vim: set fileencoding=utf-8: set encoding=utf-8:

"""
Proposed solution for calculating root mean square of a set of values.
"""

#We need to import the `math` package in order to use the `sqrt` function it
#provides for doing square roots.
import math

def rms(values):
    """
    Returns the _root mean square_ of the given sequence of numerical values.

    :param values:  An iterable of numbers (ints, longs, or floats) for which to
        calculate and return the root mean square.

    :returns float: The root mean square of the given values.
    """

    #Get the squares of the values using a **list comprehension**.
    #
    #This says: for each element in `values`, call that element `v` and
    # multiply it by itself to get the square of the value.
    # Collect these squares as the elements of a new list, in order corresponding
    # to the order of `values`.
    squares = [v*v for v in values]

    #Calculate the sum of the squares.
    #This is easily done using the builtin `sum` function.
    sum_of_squares = sum(squares)

    #Calculate the average ("mean") of the squares.
    #This is simply the sum of the values divided by the number of values.
    #We need to make sure we don't divide by 0!
    if len(squares) == 0:
        raise ValueError('The root mean square is undefined for an empty set.')
    else:
        mean_square = sum_of_squares / float(len(squares))

    #Lastly, take the square root of the mean.
    # Square roots are provided by the `sqrt` function in the `math` package.
    root_mean_square = math.sqrt(mean_square)

    return root_mean_square


if __name__ == '__main__':

    import sys
    
    #Read values from stdin, splitting up the string by whitespace.
    data = sys.stdin.read().split()

    #Convert the values to numbers.
    values = [float(d) for d in data]

    print rms(values)




import time


def numberSum(n):
    num_sum = 0
    for m in str(n):
        num_sum += int(m)
    print num_sum


def squareRootConvergentsOfE():
    numretor1, demenator1 = 8, 3
    numretor2, demenator2 = 11, 4
    out_put = 0
    p = 4
    for i in range(5, 101):
        if i % 3 == 0:
            numretor = numretor2 * p + numretor1
            demenator = demenator2 * p + demenator1
            p += 2
        else:
            numretor = numretor2 + numretor1
            demenator = demenator2 + demenator1
        numretor1, demenator1 = numretor2, demenator2
        numretor2, demenator2 = numretor, demenator
        # print numretor2, demenator2
    return numberSum(numretor)

if __name__ == "__main__":
    start_time = time.time()
    squareRootConvergentsOfE()
    print time.time() - start_time, 'Seconds'

"""
Log metrics to a [Cube](http://square.github.com/cube/) server.

"""
import os
from cloudly.metric import event

LOG_METRICS = os.environ.get("LOG_METRICS", False)


def evt(evt_type, data=None, request=None):
    if not LOG_METRICS:
        return

    if request:
        if not data:
            data = {}
        data['path'] = request.path
        data['root'] = request.url_root
        data['method'] = request.method
    event(evt_type, data)

'''
Created on May 13, 2015

@author: tekrei

Various square root approximations
Source: Introduction to Computation and Programming Using Python book
'''

def newton_raphson(y):
    '''
    Newton-Raphson for square root
    '''
    epsilon = 0.01
    ans = y / 2.0
    numGuesses = 0
    while abs(ans * ans - y) >= epsilon:
        numGuesses += 1
        ans = ans - (((ans ** 2) - y) / (2 * ans))
    return ans, numGuesses

def exhaustive_enumeration(x):
    '''
    Approximating the square root using exhaustive enumeration
    '''
    epsilon = 0.01
    step = epsilon ** 2
    numGuesses = 0
    ans = 0.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        ans += step
        numGuesses += 1
    if abs(ans ** 2 - x) >= epsilon:
        print 'Failed on square root of', x
    else:
        print ans, 'is close to square root of', x
    return ans, numGuesses

def bisection(x):
    '''
    Bisection search to approximate square root
    '''
    epsilon = 0.01
    numGuesses = 0
    low = 0.0
    high = max(1.0, x)
    ans = (high + low) / 2.0
    while abs(ans ** 2 - x) >= epsilon:
        # print 'low =', low, 'high =', high, 'ans =', ans
        numGuesses += 1
        if ans ** 2 < x:
            low = ans
        else:
            high = ans
        ans = (high + low) / 2.0
    return ans, numGuesses

if __name__ == '__main__':
    x = 144
    print exhaustive_enumeration(x)
    print bisection(x)
    print newton_raphson(x)

"""
Sqrt(x)

Implement int sqrt(int x).
Compute and return the square root of x.
"""


def sqrt(x, error_threshold = 1e-4):
    res=1.0
    error = error_threshold + 1
    while error > error_threshold:
        next_ = 0.5 * (res + (x+0.0)/(res+0.0))
        error = abs(next_ - res)
        res = next_
    return res

x = 10000000
sqrt(x)

<<<<<<< HEAD
def power(x):
	return x ** 2
def square_root(x):
	return np.sqrt(x)
=======
import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)
>>>>>>> origin

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math

def square_root(a):
    epsilon = 0.0000000000000001
    if a < 0:
        return 'a must be larger than 0'
    elif a < 1:
        x = 0
    else:
        x = 3**(int(math.log10(a))+1)

    while True:
        y = (x + a / x) / 2.0
        if abs(y-x) < epsilon:
            break
        x = y

    return y

def test_square_root():
    i = 1.0
    while i < 10:
        print i,
        first = square_root(i)
        print first,
        second = math.sqrt(i)
        print second,
        print abs(first-second)
        i = i + 1

test_square_root()
# Using bisection search to approximate square root
def squareRoot(x, epsilon):
    low = 0.0
    high = max(1.0, x)

    ans = low + (high-low)/2.0

    while abs(ans**2 - x) >= epsilon:
        if ans**2 < x:
            low = ans
        else:
            high = ans
        ans = low + (high-low)/2.0
    return ans

x = int(raw_input('Enter Integer: '))
epsilon = 0.001
sroot = squareRoot(x, epsilon)

print 'square root of {} is: {}'.format(x, round(sroot, 3))

from sympy import ntheory
import math

def count_prime_power_triples(threshold):
    primes = [p for p in ntheory.primerange(1, math.sqrt(threshold))]
    numbers = set()
    for fourth_root in primes:
        n4 = fourth_root ** 4
        if n4 >= threshold:
            break
        for cube_root in primes:
            n3 = cube_root ** 3
            if n4 + n3 >= threshold:
                break
            for square_root in primes:
                n2 = square_root ** 2
                s = n4 + n3 + n2
                if s >= threshold:
                    break
                # print "%d^2 + %d^3 + %d^4 = %d" % (square_root, cube_root, fourth_root, s)
                numbers.add(s)
    return len(numbers)

print count_prime_power_triples(50)
print count_prime_power_triples(50000000)


def testable(x):
    r"""
    The 'testable' function returns the square root of its
    parameter, or 3, whichever is larger..
    >>> testable(7)
    3.0
    >>> testable(16)
    4.0
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    return x ** 0.5

def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x    = 1
    xOld = 1
    while True:
        aux = ( x + ( n / x ) ) / 2
        if aux == x:
            return x
        if aux == xOld:
            return min(x, xOld)
        xOld = x
        x = aux

def sumSquares(n, m):
    r = n * (n + 1) * (2 * n + 1)
    r /= 6
    r = r % m
    return r

def solve():
    B = 10 ** 15
    k = iSqrt(B)
    m = 10 ** 9
    r = 0
    s = B
    for n in range(1, k+1):
        s2 = B / (n + 1)
        a1 = n * ( sumSquares(s, m) - sumSquares(s2, m) )
        r += a1
        r  = r % m
        a2 = n * n * s
        r += a2
        r  = r % m
        s  = s2
    return r

if __name__ == "__main__":
    result = solve()
    print "Result: %d" % result

"""
Implement int sqrt(int x).

Compute and return the square root of x.
"""


class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        if x <= 1:
            return x
        lo, hi = 0, 1 + x / 2
        while lo + 1 < hi:
            mid = lo + (hi - lo) / 2
            square = mid ** 2
            if square == x:
                return mid
            elif square < x:
                lo = mid
            else:
                hi = mid
        return lo


if __name__ == '__main__':
    s = Solution()
    print s.mySqrt(2)

#!/usr/bin/python
# encoding: utf-8
"""
project euler (projecteuler.net) problem 66
solution by Kevin Retzke, May 2012
"""
import math

#squares = set()

def isSquare(n):
    #if n in squares:
    #    return True
    root = math.sqrt(n)
    if int(root + 0.5)**2 == n:
        #squares.add(n)
        return True
    return False

def diophantine(d):
    """Determines the minimum solution of x for the equation
    x**2 - Dy**2 = 1"""
    x = 2
    while True:
        num = x*x-1
        if num%d == 0 and isSquare(num/d):
            return x
        x += 1

if __name__ == '__main__':
    assert map(diophantine, [2,3,5,6,7]) == [3,2,9,5,8]
    maxx = 0
    maxd = 0
    for d in xrange(2,62):
        if isSquare(d):
            continue
        x = diophantine(d)
        print d, x
        if x > maxx:
            maxx = x
            maxd = d
            #print maxd, maxx
    print maxd
            

def squareRoot(x): 
  epsilon = 0.001 
  low = 0
  high = max(x, 1)  
  bisection = (high+low)/2.0

  while abs((bisection**2)-x) >= epsilon and bisection <= x:
    if (bisection**2) > x: 
      high = bisection
    else:
      low = bisection
    bisection = (high+low)/2
  return bisection

print squareRoot(0.5)
#! /usr/bin/env python 
from fraction import *
from math import *

def getContinuedFraction(N):
   a = [int(sqrt(N)), int(1.0 / (sqrt(N) - int(sqrt(N))))]
   pnm2 = a[0]             # p[n - 2]
   pnm1 = a[1] * pnm2 + 1  # p[n - 1]
   qnm2 = 1                # q[n - 2]
   qnm1 = a[1]             # q[n - 1]
   Pnm2 = 0                # P[n - 2]
   Pnm1 = a[0]             # P[n - 1]
   Qnm1 = N - a[0] * a[0]  # Q[n - 1]
   n = 2
   while True:
      Pn = a[n - 1] * Qnm1 - Pnm1
      Qn = (N - Pn * Pn) / Qnm1
      a.append(int((a[0] + Pn) / Qn))
      pn = a[n] * pnm1 + pnm2
      qn = a[n] * qnm1 + qnm2
      if a[n] == 2 * a[0]:    # When a[n] == 2a0 we have the term where the continued fraction becomes periodic
         if a[n] == a[n - 1]:
            return a[:2]   # In case it repeats on the second element
         else:
            return a
      pnm2 = pnm1
      pnm1 = pn
      qnm2 = qnm1
      qnm1 = qn
      Pnm1 = Pn
      Qnm1 = Qn
      n = n + 1

if __name__ == "__main__":
   squareRootOfSquareNumber = 2
   sum = 0
   for N in range(2, 10001):
      if N != squareRootOfSquareNumber**2:
         a = getContinuedFraction(N)
         if len(a) % 2 == 0: # If even length, then period is of odd length
            sum += 1
      else:
         squareRootOfSquareNumber += 1

   print 'Answer:', sum

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""
Log metrics to a [Cube](http://square.github.com/cube/) server.

"""
import os
from cloudly.metric import event

LOG_METRICS = os.environ.get("LOG_METRICS", False)


def evt(evt_type, data=None, request=None):
    if not LOG_METRICS:
        return

    if request:
        if not data:
            data = {}
        data['path'] = request.path
        data['root'] = request.url_root
        data['method'] = request.method
    event(evt_type, data)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/python

# Solution for Project Euler problem 206, "Concealed Square".
# http://projecteuler.net/problem=206

import math

def solve():
  lower = int(math.sqrt(1020304050607080900))
  upper = int(math.ceil(math.sqrt(1929394959697989990)))

  # Root must end in 30 or 70 (see README). Skip iterating over other numbers.
  for x in xrange(lower - (lower % 100), upper + 100 - (upper % 100), 100):
    if attempt(x + 30): return x + 30
    if attempt(x + 70): return x + 70

def attempt(n):
  sq = n*n
  return odd_digits(sq) == '1234567890'

def odd_digits(n):
  return str(n)[0::2]

print solve()

import math
def strict_floor(f):
    if int(math.floor(f)) == f:
        return int(f - 1)
    else: 
        return int(math.floor(f))


def strict_ceil(f):
    if int(math.ceil(f)) == f:
        return int(f + 1)
    else:
        return int(math.ceil(f))

def is_square(n):
    root = int(math.sqrt(n))
    if root*root == n:
        return True
    else:
        return False

def count_in_right_triangle(s1,s2):
    n_in = 0
    for x in range(1,s1):
        #high = int(math.floor( -(s2/float(s1))*x + s2 )) + 1
        #print "argument: ", -(s2/float(s1))*x + s2
        #print "floor: ", high - 1
        for y in range(1,s2):
            if s1*y < -s2*x + s2*s1 :
                n_in += 1
    return n_in

print "in 3,9 triangle:", count_in_right_triangle(3,9)
print "in 1,100 triangle:", count_in_right_triangle(1,100)
def count_on_cross(a,b,c,d):
    counts =  a + b + c + d -3
    return counts

def count_square_quads(m):

    #pre-generate pairwise triangle counts
    triangle_count = {}
    for i in range(1,m+1):
        for j in range(1,m+1):
            triangle_count[i + j*(10**4)] = count_in_right_triangle(i,j)
    #print triangle_count[100 + 100*(10**4)]
    #print "triangle count: ", count_in_right_triangle(100,100)
    n_with_square = 0
    for a in range(1,m+1):
        if m==100: print "a = ", a
        for b in range(1,m+1):
            for c in range(1,m+1):
                for d in range(1,m+1):
                    n_pts = (count_on_cross(a,b,c,d) +
                             triangle_count[a+b*(10**4)] +
                             triangle_count[a+d*(10**4)] + 
                             triangle_count[d+c*(10**4)] + 
                             triangle_count[b+c*(10**4)])
                    if is_square(n_pts): n_with_square += 1
    print "number of squares for m = ", m, "is", n_with_square

count_square_quads(1)
count_square_quads(2)
count_square_quads(3)
count_square_quads(4)
count_square_quads(5)
count_square_quads(6)
count_square_quads(7)
count_square_quads(8)
count_square_quads(9)
count_square_quads(10)
count_square_quads(11)
count_square_quads(12)
count_square_quads(13)
count_square_quads(14)
count_square_quads(15)
count_square_quads(100)

from math import *


def square_root(a):
    """ calculates the square root of a number using Newton's algorithm

    a: a number
    """

    x = a / 4.0    # Providing an adequate estimate of x
    while True:
        y = (x + a/x) / 2.0
        if abs(y-x) < 0.0000001:
            break
        x = y
    return x


def test_square_root(a):
    """ Prints a table comparing the results of square_root and sqrt on a
    number a. It also provides the absolute difference between the two
    estimates
    """

    for i in range(9):
        print a, "\t",
        print square_root(a), "\t",
        print sqrt(a), "\t",
        print abs(square_root(a) - sqrt(a))
        a = a + 1


test_square_root(1.0)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline


def read(fn):
    # also look at readline() and readlines() functions
    return open(fn,'r').read()

def read_filter_split(fn):
    s = open(fn,'r').read()
    return [w for w in s.split() if w.isalnum()]

x = {'and':'of', 'square':'root', 'center':'point', 'microscope':'image'}


#! /usr/bin/env python
# coding: utf-8
"""
Copyright 2014 Tatsuro Yasukawa.

Distributed under the GNU General Public License at
gnu.org/licenses/gpl.html.
"""


def main():
    print(square_root(2))

def square_root(x):
    guess = 1.0
    while not is_good_enough(guess, x):
        guess = improve(guess, x)
        print(guess)
    return guess

def improve(guess, x):
    q = (x*1.0)/guess
    return average(q, guess)

def average(x, y):
    return (x+y)/2.0

def is_good_enough(guess, x):
    return abs(improve(guess, x) - guess) < 0.0001
    #return abs(guess**2 - x) < 0.0001

if __name__ == '__main__':
    main()


import math
import random

def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps # set up a suitable postcondition
    return y

for i in range(1, 1000):
    r = random.random() * 1000
    z = square_root(r)

print "Done!"

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/python

import heapq
import sys

LEFT=1
RIGHT=2
UP=3
DOWN=4
DIRS = [LEFT, RIGHT, UP, DOWN]

def display_dir(dir):
  if dir == LEFT:
    return "LEFT"
  elif dir == RIGHT:
    return "RIGHT"
  elif dir == UP:
    return "UP"
  elif dir == DOWN:
    return "DOWN"
  else:
    return "UNKNOWN"

# Coordinates and Squares

class Coord(object):
  @staticmethod
  def fromIndex(index):
    return Coord(index%3, index/3)

  def __init__(self, x=0, y=0):
    self.x = x
    self.y = y

  def __str__(self):
    return "(%d, %d)" % (self.x, self.y)

  def index(self):
    return self.x + self.y * 3

  def dist(self, other):
    return max(
        abs(self.x - other.x),
        abs(self.y - other.y))

  def move(self, dir):
    if dir == LEFT:
      if self.x == 0:
        return None
      return Coord(self.x-1, self.y)
    elif dir == RIGHT:
      if self.x == 2:
        return None
      return Coord(self.x+1, self.y)
    elif dir == UP:
      if self.y == 0:
        return None
      return Coord(self.x, self.y-1)
    elif dir == DOWN:
      if self.y == 2:
        return None
      return Coord(self.x, self.y+1)
    return None

class Square(object):
  @staticmethod
  def fromStr(str):
    data = []
    entries = str.split(" ")
    if len(entries) != 9:
      print "Invalid square format: %s" % str
      sys.exit(2)
    for entry in str.split(" "):
      if entry == '_':
        data.append(None)
      else:
        data.append(int(entry))
    return Square(data)

  def __init__(self, data):
    self.data = data

  def __key(self):
    return self.__str__()

  def __eq__(self, other):
    return self.__key() == other.__key()

  def __hash__(self):
    return hash(self.__key())

  def find(self, num):
    index = None
    for i in xrange(len(self.data)):
      if self.data[i] == num:
        index = i
        break
    if index == None:
      return None
    return Coord.fromIndex(index)

  def lookup(self, coord):
    return self.data[coord.index()]

  def dist(self, other):
    dist = 0
    for i in [None, 1, 2, 3, 4, 5, 6, 7, 8]:
      # find coords of i in self
      self_coords = self.find(i)
      other_coords = other.find(i)
      dist += self_coords.dist(other_coords)
    return dist

  # Return a new square with the given swap applied
  def swap(self, dir):
    blank = self.find(None)
    if blank == None:
      return None
    dest = blank.move(dir)
    if dest == None:
      return None

    # Get the number to swap
    value = self.lookup(dest)

    # Create the new square and set the new values
    data = []
    for i in xrange(len(self.data)):
      if i == blank.index():
        data.append(value)
      elif i == dest.index():
        data.append(None)
      else:
        data.append(self.data[i])
    
    return Square(data)

  def __str__(self):
    out = ""
    for i in xrange(3):
      for j in xrange(3):
        val = self.data[i*3+j]
        if val:
          out += "%d" % val
        else:
          out += "_"
      if i < 2:
        out += " "
    return out

  def display(self):
    out = ""
    for i in xrange(3):
      for j in xrange(3):
        val = self.data[i*3+j]
        if val:
          out += "%d" % val
        else:
          out += " "
      if i < 2:
        out += "\n"
    return out

# States and solving
curr_order = 1
class Node(object):
  def __init__(self, parent, action, square, path_cost, h_cost):
    self.parent = parent
    self.action = action
    self.square = square
    self.path_cost = path_cost
    self.h_cost = h_cost
    self.children = {}
    self.order = None

    if self.parent:
      self.parent.add_child(self)

  def set_order(self):
    global curr_order
    self.order = curr_order
    curr_order += 1

  def cost(self):
    return self.path_cost + self.h_cost

  def add_child(self, node):
    if node.parent != self:
      return
    self.children[node.action] = node

  def show_path(self):
    if self.parent:
      path = self.parent.show_path()
      path.append(self.action)
    else:
      path = []
    return path

  def __str__(self):
    return "Node for [%s]" % self.square

  def display_tree(self):
    display = ""
    display += str(self.square)

  def display(self):
    return "[%s] (c: %d, p:%d, h:%d, order: %s)" % (
        self.square, self.cost(), self.path_cost, self.h_cost, self.order)


def help_display(indent, node):
  # print node data with given indent to acc
  # then display children, indented further
  str =  "%sNode %s\n" % (indent * "  ", node.display())
  for action in node.children.keys():
    child = node.children[action]
    #acc += "%s%s: %s\n" % ((indent+1)*"  ", display_dir(action), child)
    str += help_display(indent+1, child)
  return str

def display_tree(root):
  return help_display(0, root)

class Solver(object):
  def __init__(self, start, goal):
    self.start = start
    self.goal = goal
    self.frontier = []
    self.frontier_seen = {}
    self.explored = {}

  def make_node(self, square, action=None, parent=None):
    if parent:
      path_cost = parent.path_cost + 1
    else:
      path_cost = 0
    h_cost = square.dist(self.goal)
    return Node(parent, action, square, path_cost, h_cost)

  def push(self, node):
    score = node.cost()
    heapq.heappush(self.frontier, (score, node))
    self.frontier_seen[node] = True

  def pop(self):
    (score, node) = heapq.heappop(self.frontier)
    del self.frontier_seen[node]
    return node

  def findGoalNode(self):
    root = self.make_node(self.start)
    self.push(root)

    while self.frontier:
      node = self.pop()
      #print "  Checking %s" % node
      if node.square == self.goal:
        return (root, node)
      self.explored[node.square] = True
      self.expand(node)

    return (root, None)

  def expand(self, node):
    node.set_order()
#    print "    Expanding node"
    for dir in DIRS:
      new_square = node.square.swap(dir)
      if not new_square:
#        print "      Can't expand to the %s" % display_dir(dir)
        continue
      if new_square in self.frontier_seen or new_square in self.explored:
#        print "      Node already in frontier or explored"
        continue
      new_node = self.make_node(new_square, dir, node)
#      print "      Made new node for square to the %s: %s" % (display_dir(dir),
#          new_node)
      self.push(new_node)

if __name__ == '__main__':
  if len(sys.argv) != 3:
    print "Usage: %s start_state goal_state" % sys.argv[0]
    print "  Each state is a string with 9 entries, where each entry"
    print "  is a number 1-8 or the _ to indicate an empty space."
    sys.exit(1)

  start = Square.fromStr(sys.argv[1])
  goal = Square.fromStr(sys.argv[2])

  print "Calculating path from start state:\n%s" % start.display()
  print "to goal state:\n%s" % goal.display()
#  print "Current goal distance is %d" % start.dist(goal)
#  print "Coords of blank in each: %s, %s" % (start.coords(None),
#      goal.coords(None))
#  for i in xrange(1,9):
#    print "Coords of %d in each: %s, %s" % (i, start.coords(i), goal.coords(i))
#  print "start shifted right:\n%s" % start.swap(RIGHT)

  solver = Solver(start, goal)
  (root, node) = solver.findGoalNode()
  if node == None:
    print "No path found from start to goal."
  else:
    print "Path from start to goal: %s" % ", ".join([display_dir(dir) for dir in
      node.show_path()])
    print "%s" % display_tree(root)


class Calculator(object):

	def __init__(self):
		self.result = 0
	
	def add(self, n):
		self.result = self.result + n

	def subtract(self, n):
		self.result = self.result - n

	def multiply(self, n):
		self.result = self.result * n

	def divide(self, n):
		self.result = self.result / n

	def square(self, n):
		self.result = n * n

	def squareRoot(self, n):
		while True:
			pass

	def clear(self):
		self.result = 0

	def switchOn(self):
		self.result = 0

	def switchOff(self):
		pass

	def getResult(self):
		return self.result

import tkinter as Tk

from functools import partial

def square(x):
    return x*x

def compute():
    value = var.get()
    result = square(value)
    list_of_results.append(result)

root = Tk.Tk()
var = Tk.IntVar(root, value=0) #the variable the gets passed to the class call
menu = Tk.OptionMenu(root, var, *[0,1,2,3,4,5]) #a drop-down list to choose a value for the variable
menu.pack()
list_of_results=[]
button = Tk.Button(root, text='click', command = compute) #a button that calls the class
button.pack()
root.mainloop()
from Tkinter import *

def draw_square(canvas, color, width, height, center):
  '''Does: Draws a square.
  Arguments: The canvas to draw on, the fill and outline color,
  the width and height of the square, and the center as a tuple.
  Returns: The square that is drawn.'''

  x1 = center[0] - width / 2
  x2 = center[0] + width / 2
  y1 = center[1] - height / 2
  y2 = center[1] + height / 2
  square = canvas.create_rectangle(x1, y1, x2, y2, fill = color, \
      outline = color)
  return square

if __name__ == '__main__':
  root = Tk()
  root.geometry('800x800')
  c = Canvas(root, width=800, height=800)
  c.pack()
  draw_square(c, 'red', 100, 100, (50, 50))
  draw_square(c, 'green', 100, 100, (750, 50))
  draw_square(c, 'blue', 100, 100, (50, 750))
  draw_square(c, 'yellow', 100, 100, (750, 750))

  root.mainloop()

#!/usr/bin/env python
# Comments come directly from the algorithm
# on http://en.wikipedia.org/wiki/Baby-step_giant-step

from collections import defaultdict
import math

def getPrivateKey(p, g, y):
	
	# m = Ceiling(sqrt(n))
	squareRootP = int(math.ceil(math.sqrt(p)))

	# Creating a dict as a hashmap.
	precomputedValues = defaultdict()
	

	# For all j where 0 <= j < m:
	for i in range(0, squareRootP):
		
		# Compute aj and store the pair (j, aj) in a table.
		precomputedValues[pow(g, i, p)]=i

	# Setting initial value as 0
	privateKey = 0
	
	# Compute a^-m
	minusRoot = (g**-(squareRootP))%p
	
	# y = b
	t = y
	
	# For i = 0 to (m-1)
	for i in range(0, squareRootP-1):

		# Check to see if y is the second component (aj) of any pair in the table.
		if(t in precomputedValues):
			
			#If so, return im + j
			computedKey = precomputedValues(t)
			privateKey = (i*squareRootP)+computedKey
			return privateKey

		else:
			
			# If not, y = y * a^-m (pre-computed)
			t = (t*minusRoot)%p

privateKey = getPrivateKey(85754635859,181673,34109547043)
print privateKey



# A slightly longer demo of usings class, that includes the use of a
# class attribute.  There's only one of these per class, and it's
# accessible to all the instances.
#
# In this example the class variable is used to count the number of
# cars that have been created.
#
# Also demonstrated is the dynamic addition of a method to the class.

import math
class car():                     # or car(vehicle) if car is subclass of vehicle
    count = 0
    def __init__(self, newColor):          # Constructor
        car.count +=1                      # Class variable, counts cars created
        self.id = car.count
        self.color = newColor
        
    def setColor(self, nowColor):          # Method
        self.color = nowColor

    def show(self):                        # Method
        print "ID=%d, colour=%6s, #cars=%d" % (self. id, self.color, self.count)

blueCar = car("blue")       # create and show two cars
blueCar.show()       

redCar  = car("red")
redCar.show()

blueCar.setColor("Black")   # update blueCar
blueCar.show()

blueCar.windows = False     # add an attribute
print "blueCar: windows=", blueCar.windows


# Dynamically add a method called SquareRoot to the class

def mySquareRoot(x):
    return math.sqrt(x)

redCar.SquareRoot = mySquareRoot     # add a method to redCar
print redCar.SquareRoot(49)

print "*"*60
print "call blueCar.SquareRoot(64) - should fail"
print blueCar.SquareRoot(64)   # This fails - SQRT added ONLY to redCar
print "*"*60

# import math

def closeEnough(num1,num2):
	if (abs(num1-num2) < 0.001):
		return True
	else:
		return False

def squareRoot(num,guess):
	# guess = 1
	if(closeEnough((num/guess),guess)):
		print round(guess,4)
	else:
		guess = ((num/guess)+guess)/2
		squareRoot(num,guess)

if __name__ == '__main__':
	
	num = input("Enter number:")
	
	squareRoot(float(num),1.0)

def factor(n):
        if n == 1: return [1]
        i = 2#Next lowest Prime
        limit = n**0.5#Limit is the square root, ie: perfect square
        while i <= limit:
                if n % i == 0:# Is the value divisible by our "prime"
                        ret = factor(n/i)
                        ret.append(i)
                        return ret
                i += 1

        return [n]


print factor(35)
print factor(600851475143)

#finds the first triangle number with more than x numbers of factors

def findFactors(n):
    x=[]
    #creates an array
    z=n
    x.append(z)
    x.append(1)
    y=z**.5+1
    p=2
    #makes a variable that is one more than the square root of z
    while p<y:
        #continues until y is 1
        if z%p==0:
            #if y is a factor of z it adds it and its opposite to the array
            x.append(p)
            x.append(z/p)
            p=p+1
        else:
            p=p+1
    x.sort()
    
    return x

def main():
    x=1
    i=2
    while len(findFactors(x))<500:
        x=x+i
        i=i+1
    print x
main()

import math

#this brute method will technically work
#but without any bounds on the answer
#it could theoretically take years or millenia for certain numbers.

def find_x(D):
	y = 1
	test = square_root(1+D*y**2)
	while test*test != (1+D*y**2):
		y+=1
		test = square_root(1+D*y**2)
	return test

#binary search for square roots
#exists due to the fact that for very large numbers,
#(which we won't ever get to, so this is a waste of time)
#the math.sqrt(x) == int(math.sqrt(x)) method won't work.
#however, by the time we get to that point, we're in 10**26
#land, which if we're incrementing by 1, we won't ever get to.
def square_root(x,hi=None,lo=0):
	if x <= 10**26:
		return int(math.floor(math.sqrt(x)))
	if hi == None:
		hi = x
	cur = (hi+lo)/2
	if cur*cur == x:
		return cur
	if hi <= lo:
		return cur
	if cur*cur > x:
		return square_root(x,cur-1,lo)
	if cur*cur < x:
		return square_root(x,hi,cur+1)

def not_square(x):
	root = square_root(x)
	if root * root != x:
		return True
	return False

results = []
for D in filter(not_square,range(1000+1)):
	result = find_x(D)
	results.append(result)
	print D,result
print max(results)
	

import numpy as np


class BaseTargetTransform(object):

    @classmethod
    def transform(cls, y):
        return np.array(y)

    @classmethod
    def transform_back(cls, y):
        return np.array(y)


class SquareRootTargetTransform(BaseTargetTransform):

    @classmethod
    def transform(cls, y):
        y = np.clip(y, 0, np.inf)
        return np.array([np.sqrt(yy) for yy in y])

    @classmethod
    def transform_back(cls, y):
        return np.array([yy**2 for yy in y])


class LogTargetTransform(BaseTargetTransform):

    @classmethod
    def transform(cls, y):
        y = np.clip(y, 0, np.inf)
        return np.array([np.log(yy+1) for yy in y])

    @classmethod
    def transform_back(cls, y):
        return np.array([np.exp(yy)-1 for yy in y])


class TrimOutliersTargetTransform(BaseTargetTransform):

    @classmethod
    def transform(cls, y):
        return np.clip(y, 0, 20)

    @classmethod
    def transform_back(cls, y):
        return np.array(y)


class TrimOutliersSquareRootTargetTransform(BaseTargetTransform):

    @classmethod
    def transform(cls, y):
        y = np.clip(y, 0, 20)
        return SquareRootTargetTransform.transform(y)

    @classmethod
    def transform_back(cls, y):
        return SquareRootTargetTransform.transform_back(y)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# Odd period square roots
# Problem 64
# All square roots are periodic when written as continued fractions and can be written in the form:


# It can be seen that the sequence is repeating. For conciseness, we use the notation v23 = [4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely.

# The first ten continued fraction representations of (irrational) square roots are:

# v2=[1;(2)], period=1
# v3=[1;(1,2)], period=2
# v5=[2;(4)], period=1
# v6=[2;(2,4)], period=2
# v7=[2;(1,1,1,4)], period=4
# v8=[2;(1,4)], period=2
# v10=[3;(6)], period=1
# v11=[3;(3,6)], period=2
# v12= [3;(2,6)], period=2
# v13=[3;(1,1,1,1,6)], period=5

# Exactly four continued fractions, for N = 13, have an odd period.

# How many continued fractions for N = 10000 have an odd period?

import time
import help
from math import sqrt

def solve(max):
    print(len(list(filter(hasOddRootPeriod, range(1,max+1)))))
    
def hasOddRootPeriod(a):
    return getRootPeriod(a) % 2 == 1

def getRootPeriod(a):
    l = help.conFraction(a)
    return len(l)-1
#a program to determine prime numbers

from math import sqrt

def divide(n):
	return n % 2

def question():
	#var for natural number user inputs
	return eval(input("Please provide a natural number: "))

def division(n):
	#creates the square root
	squareRoot = sqrt(n)
	#create the var to use as a counter
	count = squareRoot

	#iterate until the count drops to two
	while count >= 2:
		#decide if the number is even
		if (n/count) % 2 == 0:
			return False #return False since n is not prime
		count = count - 1 #decrement the count by one
	return True #if n never evaluates as even then return True

def displayPrime(evenOdd):
	#decide if the evenOdd var is True
	if evenOdd == True:
		print("The number is prime") #print the evenOdd value is prime
	else:
		print("The number is even")

def main():

	#create var isPrime from the division function
	isPrime = division(question())

	#call the displayPrime function to show if the number is even or odd
	displayPrime(isPrime)

main()
def add(token):
    tot = 0
    for i in range(1,len(token)):
        tot = tot + float(token[i]) 
    return tot

def subtract(token):
    tot = float(token[1])
    for i in range(2,len(token)):
        tot = tot - float(token[i]) 
    return tot

def multiply(token):
    product = 1
    for i in range(1, len(token)):
        product = product * float(token[i])
    return product

def divide(token):
    quo = float(token[1])
    for i in range(2, len(token)):
        quo = quo / float(token[i])
    return quo

def square(token):
    return float(token[1])*float(token[1])

def cube(token):
    return float(token[1]) ** 3

def power(token):
    base = float(token[1])
    for i in range(2,len(token)):
        base = base ** float(token[i])
    return base

def mod(token):
    return float(token[1]) % float(token[2])

def root(token):
    return float(token[1])**(1/float(token[2]))

def square_root(a):
	x = a/2.0
	epsilon = 0.0000001
	while True:
		y = (x + a/x) / 2
		if abs(y-x) < epsilon:
			break
		x = y
	return x


from thumbnailer import _resizer
from unittest import TestCase, main
import os.path as path
from PIL import Image

class ThumbnailerTests(TestCase):

    def path(self, filename):
        return path.join(self.img_path, filename)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")
        self.img = Image.open(self.path("sample_image.jpg"))

    def testSquare(self):
        r = _resizer('square', '100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((100, 100), output.size)

    def testExact(self):
        r = _resizer('exact', '250x100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 100), output.size)

    def testWidth(self):
        r = _resizer('aspect', '250x?', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 166), output.size)

    def testHeight(self):
        r = _resizer('aspect', '?x250', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((375, 250), output.size)

class ThumbnailerFilenameTest(TestCase):

    def path(self, *parts):
        return path.join(self.img_path, *parts)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")

    def testRoot(self):
        """Test a file that is in the root of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testRootWithSlash(self):
        r = _resizer('square', '100', self.img_path + '/')
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testSubdir(self):
        """Test a file that is in a sub-directory of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('subdir', 'sample_image.jpg'))
        self.assertEqual('subdir/sample_image_square.jpg', new_name)

if __name__=="__main__":
    main()

# mdhandle,  http://github.com/dtlussier/mdhandle
# Copyright (c) 2008, Dan Lussier @ Oxford University, FBG Group
# Released under the GNU General Public License, v2
"""
Analyze fluctuations in time series stored in :class:`numpy.ndarray`.

"""

# TODO: Add function for square difference between two time series.

# -----------------------------------------------------------------------------

import sys

import numpy as np

# -----------------------------------------------------------------------------


def square_fluct(in1):
    """
    Calculates ``(in1 - <in1>)*(in1 - <in1>)``.

    ``<...>`` stands for the average over the whole vector.

    Parameters
    ----------
    in1: :class:`numpy.ndarray`
        (Nx1) NumPy array.

    Returns
    -------
    sq_fluct : :class:`numpy.ndarray`
    """

    sq_fluct = (in1 - in1.mean())**2
    return sq_fluct


def root_mean_square_fluct(in1):
    """
    Calculates mean squre fluctuation or root-mean-square (RMS) error.

    Parameters
    -----------
    in1 : :class:`numpy.ndarray`
        (Nx1) Numpy array

    Returns
    -------
    rms : :class:`numpy.ndarray`
        Mean square fluctuation.

    Notes
    -----

    RMS: Square-root of arithmetic mean of squares of original values.

    For an unbiased estimator, the RMSE is the square root of the variance,
    known as the standard error.

    References
    -----------
    * http://mathworld.wolfram.com/Root-Mean-Square.html
    * http://en.wikipedia.org/wiki/Root_mean_square_error

    """
    rms = np.sqrt(square_fluct(in1).sum() / in1.size)
    return rms


#=============================================================================


def main(argv=None):
    pass


if __name__ == "__main__":
    sys.exit(main())

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

"""Newton's method, applied to single term polynomials with coefficient 1 to
compute nth roots.
"""

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance

def square_root(a):
    """Return the square root of a, computed by Newton's method.

    >>> square_root(4)
    2.0000000929222947
    >>> square_root(64)
    8.000001655289593
    >>> square_root(2)
    1.4142156862745099
    """
    def f(x):
        return x * x - a
    def df(x):
        return 2 * x
    return find_zero(f, df)

def nth_root(n, a):
    return find_zero_of_x_to_the_n_minus_a(n, a)

def power(x, n):
    """Return x * x * x * ... * x for x repeated n times.

    >>> power(2, 3)
    8
    >>> power(4, 5)
    1024
    >>> power(6, 0)
    1
    """
    product, num_xs = 1, 0
    while num_xs < n:
        product, num_xs = product * x, num_xs + 1
    return product

def find_zero_of_x_to_the_n_minus_a(n, a):
    """Return x such that x^n - a = 0.

    >>> find_zero_of_x_to_the_n_minus_a(2, 64)
    8.000001655289593
    >>> find_zero_of_x_to_the_n_minus_a(3, 64)
    4.000017449510739
    >>> find_zero_of_x_to_the_n_minus_a(6, 64)
    2.000000032935665
    """
    def f(x):
        return power(x, n) - a
    def df(x):
        return n * power(x, n-1)
    return find_zero(f, df)

def newton_update(f, df):
    def update(x):
        return x - f(x) / df(x)
    return update

def find_zero(f, df):
    """Return a zero of differentiable f with derivative df."""
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

import numpy as np
from scipy import sparse


def square_root(x):
    return np.sqrt(x)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from math import sqrt


def is_prime(potential_prime, primes_so_far):
    square_root_of_prime = sqrt(potential_prime)

    for prime in primes_so_far:
        if prime > square_root_of_prime:
            return True
        if potential_prime % prime == 0:
            return False

    return True


def generate_primes_up_to(n):
    primes_so_far = [2]

    for potential_prime in range(3, n + 1, 2):
        if is_prime(potential_prime, primes_so_far):
            primes_so_far.append(potential_prime)

    return primes_so_far

if __name__ == '__main__':
    print(sum(generate_primes_up_to(2000000)))

"""When y == x, we can stop. Here is a loop that starts with an
initial estimate, x, and improves it until it stops changing:

while True:
    print x
    y = (x + a/x) / 2
    if y == x:
        break
    x = y

Encapsulate this loop in a function called square_root that takes a as a parameter,
chooses a reasonable value of x, and returns an estimate of the square root of a."""


def square_root(a):
    x = float(a/2)
    while True:
        y = (x + a/x) / 2
        if y == x:
            break
        x = y
    return x

import math

def square_root(a):
	x = 3.0
	epsilon = 0.00000001
	while True:
		y = (x + a/x) / 2.0
		if abs(y - x) < epsilon:
			break
		x = y
	return y

		
def test_square_root(i):
	while i <= 9.0:
		a = square_root(i)
		b = math.sqrt(i)
		c = abs(a-b)
		print i," ",a," ",b," ",c 
		print "\n"
		i = i + 1.0
		
		
test_square_root(1.0)
		
#finds the first triangle number with more than x numbers of factors

def findFactors(n):
    x=[]
    #creates an array
    z=n
    x.append(z)
    x.append(1)
    y=z**.5+1
    p=2
    #makes a variable that is one more than the square root of z
    while p<y:
        #continues until y is 1
        if z%p==0:
            #if y is a factor of z it adds it and its opposite to the array
            x.append(p)
            x.append(z/p)
            p=p+1
        else:
            p=p+1
    x.sort()
    
    return x

def main():
    x=1
    i=2
    while len(findFactors(x))<500:
        x=x+i
        i=i+1
    print x
main()

"""
Using your knowledge of square roots in addition to standard double precision 
accuracy with your language, what is the square root of the sum of the first 
10^5 square roots?

Enter the number rounded to the nearest whole number
"""
import math

def check_perfect(n):
    return math.floor(math.sqrt(n))**2 == n

res = 0.0

for i in xrange(2, 10**5):
    res += math.sqrt(i)

print res
print math.sqrt(res)
__author__ = 'jianxinsun'

import math


def check(n):
    square = str(n * n)
    return all(int(square[x * 2]) == x + 1 for x in range(9))


root_max = int(19293949596979899 ** 0.5 / 10)
root_min = int(10203040506070809 ** 0.5 / 10)

print root_max
print root_min

for i in range(root_min, root_max + 1):
    if check(i * 10 + 3):
        print i * 100 + 30
        break
    else:
        if check(i * 10 + 7):
            print i * 100 + 70
            break


# def match(n):
#     s = str(n)
#     return not all(int(s[x*2]) == x+1 for x in range(9))
#
#
# n = int(10203040506070809**0.5)    # sqrt(19293949596979899)
# while match(n*n): n += 2
#
# print "Project Euler 206 Solution =", n*10    #add the trailing zero
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

__Version__ = '0.0.1'
__Author__ = 'aQua'
__License__ = 'MIT'

# -----------------------------------------------------
# Date: 2015/4/12
# Description:
# -----------------------------------------------------
from sicp_p46_fixed_point import fixed_point


def average_damp(f):
    return lambda x: (x + f(x)) / 2


def square(x):
    return x * x


print(average_damp(square)(10))


def cube_root(x):
    return fixed_point(average_damp(lambda y: x / square(y)), 1)

print(cube_root(27))
from math import *

def square_root(a):
	x = a/2.0
	while True:
		y = (x + a/x) / 2.0
		if abs(y-x) < 0.000000001:
			break
		x = y
	return y
	
"""
To test the square root algorithm in this chapter, you could compare
it with math.sqrt. Write a function named test_square_root that prints
a table like this:

1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
"""
def test_square_root(a):
	for i in range(1,a+1):
		sr1 = square_root(i)
		sr2 = sqrt(i)
		print "{0}  {1:<15}{2:<15}{3}".format(i, sr1, sr2, abs(sr1-sr2))
		

"""
Write a function called eval_loop that iteratively prompts the
user, takes the resulting input and evaluates it using eval,
and prints the result.
It should continue until the user enters 'done', and then return
the value of the last expression it evaluated.
"""
def eval_loop():
	print "enter expression to evaluate. 'done' to stop"
	evaluated_exp = None
	while True:
		exp = raw_input(">>> ")
		if exp == "done":
			break
		evaluated_exp = eval(exp)
		print evaluated_exp
	return evaluated_exp
	
	
"""
The mathematician Srinivasa Ramanujan found an infinite series that
can be used to generate a numerical approximation of  
Write a function called estimate_pi that uses this formula to compute
and return an estimate of . It should use a while loop to compute
terms of the summation until the last term is smaller than 1e-15
(which is Python notation for 1015).
"""
def factorial(n):
    """Computes factorial of n."""
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result

def estimate_pi():
	factor = (2 * square_root(2) / 9801)
	total = 0
	k = 0
	while True:
		ex1 = factorial(4*k) * (1103+26390*k)
		ex2 = factorial(k)**4 * (396**(4*k))
		term = factor * ex1 / ex2
		total += term
		if abs(term) < 1e-15:
			break
		k += 1
		
	return 1 / total
		
def sqrt(x):
	''' Compute square roots using method of Heron of Alexandria.

		Args: 
			x: The number of which the square root is to be computed.

		Returns:
			The square root of x.
	'''

	guess = x
	i = 0
	try:
		while guess * guess != x and i < 20:
			guess = (guess + x / guess) / 2.0
			i += 1
	except ZeroDivisionError:
		raise ValueError("Cannot compute square root of negative number {}".format(x))
	return guess
import sys
def main():
	try:
		print(sqrt(9))
		print(sqrt(2))
		print(sqrt(-1))
		print("This is never printed")
	except ValueError as e:
		print(e,file=sys.stderr)
		#print("Cannot compute square root of a negative number.")

	print("Program excetion continues normally here.")

if __name__ == '__main__':
	main()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
Step by step to crack Programming Interview questions 2. 
Get square root of a number using binary search.
'''



def getSquareRoot_Wrapper(target, precision):
    return getSquareRoot_recur(0, target, target, precision)

#assume num is positive
def getSquareRoot_recur(left, right, target, precision):
    print("called")
    candidate = (left+right)/2
    
    if(target-candidate**2==0 or abs(target-candidate**2)<precision):
        return candidate
    elif(candidate**2>target):
        left = left
        right = candidate
        candidate = getSquareRoot_recur(left, right, target, precision)
        return candidate
    else:#(candidate**2 < target):
        left= candidate
        right = right
        candidate = getSquareRoot_recur(left, right, target, precision)    
        return candidate
        
print(getSquareRoot_Wrapper(100, 0.000001))

    

from piliko import *

############## square root 
### the square root of a rational number is often irrational. 
### we can find a rational approximation, thanks to the ancient Iraqis / 
### Babylonians / Mesopotamians.
### 
### there is also a 'is perfect square?' test function
###
### we ignore negative roots here. and imaginary roots.

# return [r1, r2] such that the sqrt(s) is guaranteed to be between them
def square_root_rough_bounds_int( s ):
	bitlength = int(Fraction(s.bit_length()-1,2))
	guess = 1
	for i in range(0,bitlength): guess *= 2
	return guess,guess*2

# return rational approximation of square root using Babylonian's method
# iterate for maxdepth iterations or until answer>maxbits. 
def babylonian_square_root_int( s, maxdepth=10, maxbits=2048, firstguess=1 ):
	guesses=[firstguess]
	breason = 'max depth reached'
	for i in range(1,maxdepth):
		lastguess = guesses[i-1]
		newguess = avg(lastguess,Fraction(s,lastguess))
		if lastguess==newguess: break
		if sqr(long(newguess))==s: # perfect square
			breason='found perfect square'
			guesses += [ long(newguess) ]
			break
		# prevent digit ballooning causing Big Int freezing
		if (newguess.numerator.bit_length()+newguess.denominator.bit_length())>maxbits:
			breason='bitlength too large:' + str(newguess.numerator.bit_length()+newguess.denominator.bit_length())
			break
		guesses += [newguess]
	debug=0
	if debug>0:
		print 'guesses for root of ',s,float(s)
		for g in guesses: print ' ',g,float(g),float(g*g)
		print 'break reason:',breason
	return guesses[-1]

def babylonian_square_root_for_fraction( s, maxdepth=10,maxbits=2048 ):
	lo_n,hi_n = square_root_rough_bounds_int( s.numerator )
	lo_d,hi_d = square_root_rough_bounds_int( s.denominator )
	numer=babylonian_square_root_int( s.numerator, maxdepth, maxbits, lo_n )
	denom=babylonian_square_root_int( s.denominator, maxdepth, maxbits, lo_d )
	return Fraction(numer,denom)

def is_perfect_square(s):
	x = babylonian_square_root(s)
	if x*x==s: return True
	return False

# return rational approximation of square root of s
def babylonian_square_root( s, maxdepth=10, maxbits=2048 ):
	if s<0: raise Exception('cant do sqrt(-1). try "complex" type')
	if checktype(int,s) or checktype(long,s):
		lo,hi = square_root_rough_bounds_int( s )
		return babylonian_square_root_int( s, maxdepth, maxbits,firstguess=lo )
	elif checktype(Fraction,s):
		return babylonian_square_root_for_fraction( Fraction(s),maxdepth,maxbits )
	else: raise Exception('bad type')

def quadratic_formula( a, b, c ):
	term1 = babylonian_square_root( sqr(b) - 4 * a * c )
	return Fraction(-b + term1,2*a), Fraction(-b - term1, 2*a )

def perfect_square_root( s, maxbits=4096 ):
	root = babylonian_square_root(s,maxdepth=20,maxbits=maxbits)
	if root*root==s: return root
	else: raise Exception('Cant find perfect root of '+str(s)+'. Please modify algorithm to guarantee perfect squares or to use less bits')


import math

def is_prime(N):
	square_root = math.sqrt(N)
	dividers = [ d for d in range(2,int(square_root)+1) ]
	for d in dividers:
		if N % d == 0:
			return False
	return True

counter = 10001
N = 2
while True:
	if is_prime(N):
		counter -= 1
	if counter == 0:
		break
	N +=1

f = open('p007.txt','w')
f.write(str(N))
f.close()
from chapter6Exercises import *

def squareRoot(a):
    if a > 1:
        x = a - 1.0
    else:
        x = 1.0
    y = (x + (a / x)) / 2
    epsilon = 0.00000001
    while abs(y-x) >= epsilon:
        x = y
        y = (x + (a / x)) / 2
    return y


def squareRootTest(n):
    a = 1.0
    while a < n:
        b = squareRoot(a)
        c = math.sqrt(a)
        d = abs(b - c)
        print a, " ", b, " " * (15 - len(str(b))), c, " " * (15 - len(str(c))),
        print d
        a = a + 1


def evalLoop():
    end = "done"
    n = raw_input()
    while n != end:
        print eval(n)
        n = raw_input()
    return eval(n)

def estimate_pi():
    k = 0.0
    last_term = 1.0
    sigma = 0
    while last_term > 1e-15:
        last_term = ((math.factorial(4.0 * k)) * (1103.0 + 26390.0 * (k))) \
        / ((math.factorial(k)**4.0) * (396.0**(4.0 * k)))
        k += 1.0
        sigma += last_term
    result = ((2 * math.sqrt(2)) / 9801) * sigma
    print 1 / result



# coding=utf-8
"""
Problem 57
21 November 2013

It is possible to show that the square root of two can be expressed as an infinite continued fraction.

 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...

By expanding this for the first four iterations, we get:

1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...

The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example 
where the number of digits in the numerator exceeds the number of digits in the denominator.

In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?
----------------------------------------------------------
Created on 19.02.2015

@author: ahallmann
"""
import unittest
import timeit
import sys
from fractions import Fraction

cache = {}

def converge_square_2(n, x=1):
    if n <= 0:
        return x
    if x == 2 and n in cache:
        return cache[n]
    result = x + Fraction(1, converge_square_2(n-1, 2))
    if x == 2:
        cache[n] = result
    return result


def solve(n=1000):
    cnt = 0
    for n in range(1, n+1):
        f = converge_square_2(n)
        if len(str(f.numerator)) > len(str(f.denominator)):
            cnt += 1
    return cnt


class Test(unittest.TestCase):
    def test_sample(self):
        self.assertEqual(Fraction(1, 1), converge_square_2(0))
        self.assertEqual(Fraction(3, 2), converge_square_2(1))
        self.assertEqual(Fraction(7, 5), converge_square_2(2))
        self.assertEqual(Fraction(17, 12), converge_square_2(3))
        self.assertEqual(Fraction(41, 29), converge_square_2(4))
        self.assertEqual(Fraction(99, 70), converge_square_2(5))
        self.assertEqual(Fraction(239, 169), converge_square_2(6))
        self.assertEqual(Fraction(577, 408), converge_square_2(7))
        self.assertEqual(Fraction(1393, 985), converge_square_2(8))
        
        self.assertEqual(1, solve(10))
        
    def test_answer(self):
        self.assertEqual(153, solve())


# -----------------------------------------


def run():
    return solve()


if __name__ == '__main__':
    unittest.main()

# if __name__ == '__main__':
# t = timeit.Timer("run()", "from __main__ import run")
# count = 1
# print(str(t.timeit(count)) + " seconds for " + str(count) + " runs")

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def is_prime(test):
    factors = factor(test)
    if len(factors) == 0:
        return True
    else:
        return False


def factor(test):
    #print("Factoring ", test)
    i = 2
    limit = test ** 0.5 # square root
    factors = []
    while i <= (limit):
        if (test % i) == 0:
            #print("\tFactor: ", i)
            factors.append(i)
        #print("\tTried: ", i)
        if i == 2:                      # Now we will only test 2 and odds
            i = i + 1
        else:
            i = i + 2
    return factors

from collections import Counter
from itertools import chain, combinations

def factor_to_primes(n):
    primfac = []
    d = 2
    while d*d <= n:            # This is like d < square_root(n)
        while (n % d) == 0:
            primfac.append(d)  # supposing you want multiple factors repeated
            n /= d
        d += 1
    if n > 1:
       primfac.append(n)
    return Counter(primfac)

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def subsets(s):
    return map(set, powerset(s))

# gcd and lcm of more than 2 numbers.  Am I terrible for doing it this way?
def gcd(*numbers):
    """Return the greatest common divisor of the given integers"""
    from fractions import gcd
    return reduce(gcd, numbers)
 
 
def lcm(*numbers):
    """Return lowest common multiple."""    
    def lcm(a, b):
        return (a * b) // gcd(a, b)
    return reduce(lcm, numbers, 1)
 
# Assuming numbers are positive integers...

# square_root()

def square_root(a):
    '''
    Use x(n+1) = [x(n) + a/x(n)]/2 to calculate square root of a
    '''
    e = 1
    x = a / 2
    while e >= 0.0000001:
        y = (x + a/x) / 2
        e = abs(y-x)
        x = y
    return y


# Test code
print(square_root(1))

def bmeth(x):
	a=x
	y=0
	while(y!=a):
		y=a
		a=(x/a+a)/2
	return a

print("Babylonian Method")
print("This program calculates the square root of a number using the Babylonian Method")
num=int(input("Give me a positive integer: "))
bab=bmeth(num)
print("The square root of {} is {}".format(num,bab))

'''
Implement int sqrt(int x).
.
Compute and return the square root of x.
'''

class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        l = 0;   h = x+1
        while l <= h:
            m = (l + h) / 2
            if m ** 2 <= x < (m + 1) ** 2:      return m
            elif x < m ** 2:   h = m - 1
            else:    l = m + 1
# Function handling on list.



lst_a = [1, 2, 3, 4]
lst_b = [5, 6, 7, 8]

func_list = ['square', 'add', 'root']

def list_function(list, function):
    '''(list, function) -> list
    Apply a function to the values of a list and returns a new list.
    >>> list_function([1, 2, 3, 4], add)
    [2, 4, 6, 8]
    >>> list_function([1, 2, 3, 4], square)
    [1, 4, 9, 16]
    list_function([1, 2, 3, 4], root)
    [1.0, 1.4142135623730951, 1.7320508075688772, 2.0]
    '''
    for i in range(len(list)):
        list[i] = function(list[i])
    print list

def square(x):
    '''(number) -> number
    Returns the square of a given number x.
    >>> square(3)
    9
    >>> square(-2)
    4
    >>> square(0)
    0
    '''
    return x ** 2

def add(x):
    '''(number) -> number
    Returns the number added with it self.
    >>> add(3)
    6
    >>> add(-1)
    -2
    '''
    return x + x

def root(x):
    try:
        return x ** 0.5
    except ValueError, e:
        print str(e) + '''.
        List contains negative numbers.'''
    finally:
        print "Remove negative numbers from list and try again."

def choose():
    func_choose = raw_input("Choose function: square = 1, add = 2, root = 3 : ")
    if 1 == int(func_choose):
        return list_function(lst_a, square)
    elif 2 == int(func_choose):
        return list_function(lst_a, add)
    elif 3 == int(func_choose):
        return list_function(lst_a, root)


choose()
def square_root(a, x):
    """returns the square root of the number using newton's method
       other parameter is a valid integer """
    for i in range(5):
        y = (x + a / x) / 2
        x = y
    return y
"""i imported it elsewhere so i made this test code execute
only when script is executed"""
if __name__ == '__main__':
    print "{0:.20f}" .format(square_root(9.0, 6))

#
# Problem 188
#
#
global basex

basex=1777

def mod_mult(x, y, mod):
    return (x * y) % mod
 
def mod_exp(x, y, mod):
    if y == 0:
        return 1
    print "*"
    root = mod_exp(x, y/2, mod)
    print "%"
    square = mod_mult(root, root, mod)
    print "root root mod", root, mod
    if y % 2 == 0:
        return square
    else:
        return mod_mult(x, square, mod)
 
DIGITS = 8
MOD = 10 ** DIGITS
 
a = 1777
ak = a
for k in range(2, 1856):
    aj = ak
    ak = mod_exp(a, ak, MOD)
    if aj == ak:
        print k, aj
        break



#!/usr/bin/python
# -*- coding: utf-8 -*-

from math import*
from decimal import Decimal
import numpy as np
from sklearn import preprocessing

def to_nomalized(a):
    return preprocessing.normalize(a)

def to_float(a):
    for i in range(len(a)):
        a[i] = float(a[i])
    return a
def dis_to_sim(d):
    return 1/(1+d)

def euclidean_distance(x,y):
    return sqrt(sum(pow(a-b,2) for a, b in zip(x, y)))

def manhattan_distance(x,y):
    return sum(abs(a-b) for a,b in zip(x,y))

def nth_root(value, n_root):
    root_value = 1/float(n_root)
    return round (Decimal(value) ** Decimal(root_value),3)

def minkowski_distance(x,y,p_value):
    return nth_root(sum(pow(abs(a-b),p_value) for a,b in zip(x, y)),p_value)

def square_rooted(x):
    return round(sqrt(sum([a*a for a in x])),3)

def cosine_similarity(x,y):
    numerator = sum(a*b for a,b in zip(x,y))
    denominator = square_rooted(x)*square_rooted(y)
    return round(numerator/float(denominator),3)

def jaccard_similarity(x,y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality/float(union_cardinality)


def loge(n,li,ls):
    if fabs(li-ls) <= 0.000001:
        return (li+ls)/2.0
    if (exp(li)-n)*(exp((li+ls)/2.0)-n) < 0:
        return loge(n,li,(li+ls)/2.0)
    else:
        return loge(n,(li+ls)/2.0,ls)
def ln(n):
    if n == 0 or n < 0:
        return "Math Domain Error"
    if n == 1:
        return 0
    if n > 0 and n < 1:
        return loge(n,0,-n-80)
    else:
        return loge(n,0,n)
def bhatta_distance(hist1, hist2, num):
    h1 = np.average(hist1)
    h2 = np.average(hist2)

    dis = 0;
    for i in range(num):
        dis += sqrt( hist1[i] * hist2[i])
    if h1 != h1:
        dis = sqrt( 1 - ( 1 / sqrt(h1*h2*num*num) ) * dis)
    return dis

#!/usr/bin/python
# coding=utf-8
#
# Project Euler.net Problem 173
#
# Using up to one million tiles how many different "hollow" square
# laminae can be formed?
#
# We shall define a square lamina to be a square outline with a square
# "hole" so that the shape possesses vertical and horizontal
# symmetry. For example, using exactly thirty-two square tiles we can
# form two different square laminae:
#
#     * * * * * *    * * * * * * * * *
#     * * * * * *    * . . . . . . . *
#     * * . . * *    * . . . . . . . *
#     * * . . * *    * . . . . . . . *
#     * * * * * *    * . . . . . . . *
#     * * * * * *    * . . . . . . . *
#                    * . . . . . . . *
#                    * . . . . . . . *
#                    * * * * * * * * *
#
# With one-hundred tiles, and not necessarily using all of the tiles
# at one time, it is possible to form forty-one different square
# laminae.
#
# Using up to one million tiles how many different square laminae can
# be formed?
#
# Solved 11/13/10
# 132 problems solved
# Position #373 on level 3

import time
import sys
import math

start_time = time.clock()

TILES = 1000000

def odd(n):
    if ((n % 2) == 1): return True
    else:              return False

def even(n):
    if ((n % 2) == 0): return True
    else:              return False

def int_sqrt(n):
    # return the integer square root of an integer
    ans = int(n**.5)
    if   ((ans**2) == n): return ans
    elif ((ans**2) <  n): return ans+1
    elif ((ans**2) >  n): return ans


max_o = (TILES/4)+1
ans = 0

for o in range(3, max_o+1):
    max_i = o-2

    # TILES >= o**2 - i**2
    # => i**2 >= o**2 - TILES
    inner_size = o**2 - TILES
    if (inner_size <= 0):
        min_i = 1
    else:
        min_i = int_sqrt(inner_size)
    if   (odd(max_i) & even(min_i)):  min_i += 1
    elif (even(max_i) & odd(min_i)):  min_i += 1

    ans += 1 + (max_i - min_i)/2
    #print "Outer = {0}: min_i = {1}, max_i = {2}, solutions = {3}".format(o, min_i, max_i, (1 + (max_i - min_i)/2))
    #for i in range(min_i,max_i+1,2):
    #    print "    Outer = {0}, inner = {1}, tiles used = {2}".format(o,i, (o**2-i**2))

print "With TILES =", TILES, "Answer =", ans
print "Time taken =", time.clock() - start_time, "seconds"
sys.exit()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

"""divisible_triangular.py: Problem 12 of project euler.
Finds the first triangular number to have > 500 divisors. """

import math

def count_divisors(number):
    """ Determines the number of divisors that the number
        specified has."""

    divisor_count = 0
    square_root = math.sqrt(number)

    counter = 1
    while counter <= square_root:
        if number % counter == 0:
            divisor_count += 2
        counter += 1

    if square_root * square_root is number:
        divisor_count -= 1

    return divisor_count

if __name__ == "__main__":
    CURRENT_NUMBER = 0
    COUNT = 1

    while count_divisors(CURRENT_NUMBER) < 500:
        CURRENT_NUMBER += COUNT
        COUNT += 1

    print "The first triangular number with over 500 divisors is " \
            "{0}".format(CURRENT_NUMBER)


import numpy as np

def power(x):
    return x**2

def f(x):
    return OctoCat

def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import math

T = int(input())


def is_square(n):
    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:
        return True
    else:
        return False


for i in range(T):
    N = int(input())
    pair = [5 * N ** 2 + 4, 5 * N ** 2 - 4]
    if is_square(pair[0]) or is_square(pair[1]):
        print("IsFibo")
    else:
        print("IsNotFibo")
#Think Python exercise .2
# estimating square root through newton's method

#The variable assignment is so ugly. maybe figure this out in the future? 
#Don't prematurely optimize. I thought hard already, time to move on
#and I can review later.

def square_root(n):
	"""
		epsilon_constant is used to determine how close the approximation needs to be

	"""
	epsilon_constant = .000001
	x = n
	y = n
	while True:
		x = y
		y = (float(x) + (float(n)/float(x)))/2
		if abs(y-x) < epsilon_constant:
			break
	return y

print (square_root(25))
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from math import sqrt

def add(a, b):
	print "ADDING %d + %d" % (a, b)
	return a + b

def subtract(a, b):
	print "SUBTRACTING %d - %d" % (a, b)
	return a - b

def multiply(a, b):
	print "MULTIPLYING %d * %d" % (a, b)
	return a * b


def divide(a, b):
	print "DIVING %d / %d" % (a, b)
	return a / b

def square_root(a, b):
	
	return sqrt(a)   

print "Let's do some math with just functions!"

age = add(30, 5)
height = subtract(78, 4)
weight = multiply(90, 2)
iq = divide (100, 2)


print "Age: %d, Height: %d, Weight: %d, IQ: %d. " % (age, height, weight, iq)

# A puzzle for the extra credit, type it in anyway.

print "Here is a puzzle."

what = add(age, subtract(height, multiply(weight, divide(iq, 2))))

print "That becomes: ", what, "Can you do it by hand?"

c = int(raw_input())
print "The square root of %d is %d." % (c, square_root(c, 2))




def distance(p, q):
	# Assume that v1 and v2 have the same number of elements
	dimension = len(v1)
	total = 0

	for i in range(0, dimension):
		total += (p[i] - q[i]) * (p[i] - q[i])

	return sqrt(total)

p = [0,1,5]
q = [7,8,3]
print "The Euclidean distance between v1 and v2 is: ", sqrt(sum( ((p[i] - q[i]) * (p[i] - q[i])) for i in range(0, len(p)) ))





#!/usr/bin/python

import sys

class Calculator:
    def square_root_bisection(self, num):
        epsilon = 0.01
        num_guesses = 0
        low = 0.0
        high = num
        ans = (high + low) / 2.0

        while abs(ans**2 - num) >= epsilon:
            num_guesses += 1
            if ans**2 < num:
                low = ans
            else:
                high = ans
            ans = (high + low) / 2.0

        return ans

calc = Calculator()
number = int(sys.argv[1])
print calc.square_root_bisection(number) 

def square_root(a):
    x = a/2
    epsilon = 0.00000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x

#aString = raw_input("What would you like to take the square root of?")
#a = float(aString)

#epString = raw_input("Define error tolerance:")
#epsilon = float(epString)

#print square_root(a, epsilon)

import math

def test_square_root():
    for a in range(1,10):
        a = float(a)
        sqrt = [a, square_root(a), math.sqrt(a), abs(square_root(a) - math.sqrt(a))]
        print '%g \t %g \t %g \t %g \n' %tuple(sqrt)

test_square_root()

__author__ = 'student'


import math

class Function:
    def __init__(self, key, header, explanation, compute):
        self.key = key
        self.header = header
        self.explanation = explanation
        self.compute = compute

def sqrt(x):
    return math.sqrt(x)

function_list = [
    Function('sqrt', 'SQRT', "Square root function", sqrt),
    Function('sqr', "Square", "Square of the argument", (lambda x : x*x)),
    Function('log2', "Log2", "Binary logarithm", (lambda x : math.log2(x))),
    Function('cube', "Cube", "Cube of the argument", (lambda x: x*x*x))
    ]

def getFunctionByKey(key):
    for func in function_list:
        if key == func.key:
            return func


def isFair(s):
    """ determine if n is a palindrome """
    if len(s) <= 1:
         return True
    else:
        return s[0] == s[-1] and isFair(s[1:-1])

def isFair2(s):
    return s == s [::-1]

        
def isSquare(n, listFairs):
    #print "In isSquare"
    for i in listFairs:
        #print n,i
        if n[0] == i[1]:
            return i[0]
    return 0

def isSquare2(n, listFairs):
    
    return 0

def initFairs(n):
    """ initialize an array of fairs up to our end point """
    print "In init fairs with n = " + str(n)
    fairList = []
    for i in xrange(1, n+1):
        if isFair(str(i)): 
            fairList.append((i, i*i))
    return fairList

        
#f = open("C-small-attempt0.in.txt", "r")
#f = open("C-large-1.in.txt", "r")
f = open("test_large.txt", "r")
numTest=f.readline()
#print numTest
case = 1
for line in f:
    line.rsplit()
    fairAndSquareCount = 0
    x, y = line.split(" ")
    x = int(x)
    y = int(y)
    fairs = initFairs(y)
    print len(fairs)
    for z in fairs:
       if z[0] < x :
            continue
       #print str(z) + " is fair"
       #fairs.append(z)
       root = isSquare(z, fairs)
       if root != 0:
          #print "Found fair and square: " + str(root)
          fairAndSquareCount += 1
    #   z += 1
    print "Case #" + str(case) + ": " + str(fairAndSquareCount)
    case +=1    
             
      
   

from __future__ import division
import sys
import os
import matplotlib.pyplot as plt

mydir = os.path.expanduser("~/")


def closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def WebsterLocey(x):
    y1 = closest_perfect_square(x)

    y2 = y1 + 1
    z1 = x - y1**2
    z2 = y1 + y2
    a = y + z1/z2

    return float(a)


fig = plt.figure()
ax = fig.add_subplot(2,2,1)

x = 1
xs = []
sqrts = []
WLs = []

for i in range(100):

    xs.append(x)
    y = x**0.5
    sqrts.append(y)
    a = WebsterLocey(x)
    WLs.append(a)
    x += 1
	
sqrts - WLs

plt.scatter(xs, sqrts, s=50, color='m', facecolors='none', label='square root')
plt.scatter(xs, WLs, color='c', alpha=0.9, label='W&L rule')
#plt.yscale('log')
#plt.xscale('log')
plt.xlabel('x', fontsize=8)
plt.ylabel('y', fontsize=8)
leg = plt.legend(loc=2,prop={'size':12})
leg.draw_frame(False)
plt.text(-50, 14, "How well does the Webster-Locey Rule approximate square roots?", fontsize=16)





def cube(x):
    return x*x*x

def square(x):
    return x * x

def cube_root_iter(guess, x):
    if is_good_enough(guess, x):
        return guess
    else:
        return cube_root_iter(improve(guess, x), x)

def improve(guess, x):
    return (x/square(guess) + (2 * guess)) / 3

def is_good_enough(guess, x):
    return abs(cube(guess) - x) < 0.001

def cube_root(x):
    return cube_root_iter(1.0, x)

#!/usr/bin/env python
#
# Project Euler 80

from math import sqrt

def bigger(root, base, offset):
    root = int(root)
    return (root * root) > (int(base) * (10 ** offset))

def root(n, digits):
     base = str(n)
     root = str(int(sqrt(n)))
     offset = 0
     while len(root) < digits:
         offset += 2             
         root += "9"
         for digit in "876543210":
             if bigger(root, base, offset):
                 root = root[:-1] + digit
     return root

def digital_sum(n):
    return sum([int(x) for x in str(n)])

def square(n):
    return n in [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

def solution():
    return sum([digital_sum(root(x,100))
                for x in [y for y in xrange(1,101) if not square(y)]])

if __name__ == "__main__":
    print solution()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#48) Given a integer, write code to check if it's a square of some integer, can't use sqrt()
def squareRootUsingBinarySearch(num):
	low = 0 
	high = num
	while (low<=high):
		mid = (low+high) / 2
		square = mid ** 2
		if square == num :
			return True
		elif square < num :
			low = mid + 1
		elif square > num:
			high = mid - 1
	return False


def main():
	num = input("Enter the number")
	if squareRootUsingBinarySearch(num) :
		print "%s is a perfect square"%num
	else:
		print "%s is not a perfect square"%num

main()
from math import *

def square_root(a):
	x = a/2.0
	while True:
		y = (x + a/x) / 2.0
		if abs(y-x) < 0.000000001:
			break
		x = y
	return y

"""
To test the square root algorithm in this chapter, you could compare
it with math.sqrt. Write a function named test_square_root that prints
a table like this:

1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
"""
def test_square_root(a):
	for i in range(1,a+1):
		sr1 = square_root(i)
		sr2 = sqrt(i)
		print("{0}  {1:<15}{2:<15}{3}".format(i, sr1, sr2, abs(sr1-sr2)))


"""
Write a function called eval_loop that iteratively prompts the
user, takes the resulting input and evaluates it using eval,
and prints the result.
It should continue until the user enters 'done', and then return
the value of the last expression it evaluated.
"""
def eval_loop():
	print("enter expression to evaluate. 'done' to stop")
	evaluated_exp = None
	while True:
		exp = input(">>> ")
		if exp == "done":
			break
		evaluated_exp = eval(exp)
		print(evaluated_exp)
	return evaluated_exp


"""
The mathematician Srinivasa Ramanujan found an infinite series that
can be used to generate a numerical approximation of 
Write a function called estimate_pi that uses this formula to compute
and return an estimate of . It should use a while loop to compute
terms of the summation until the last term is smaller than 1e-15
(which is Python notation for 1015).
"""
def factorial(n):
    """Computes factorial of n."""
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result

def estimate_pi():
	factor = (2 * square_root(2) / 9801)
	total = 0
	k = 0
	while True:
		ex1 = factorial(4*k) * (1103+26390*k)
		ex2 = factorial(k)**4 * (396**(4*k))
		term = factor * ex1 / ex2
		total += term
		if abs(term) < 1e-15:
			break
		k += 1

	return 1 / total

"""
olve the equation x2+4x+1=0 in Z23. Use the method described in lecture 9.3 using the quadratic formula.

############
Solution:

- see page 26

"""

def egcd(x, y):
    a,b, u,v = 0,1, 1,0
    while x != 0:
        q, r = y//x, y%x
        m, n = a-u*q, b-v*q
        y,x, a,b, u,v = x,r, u,v, m,n
    return y, a, b

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

a = 1 
b = 4
c = 1
p = 23

# Find (2a)^(-1) in Z_p using extended Euclid
inv = modinv(2*a, p)

# Find square root of b^2-4*a*c in Z_p using a square root algorithm
# p = 23  ---> 23 mod 4 = 3 mod 4, so we could use sqr(c) = c^((p+1)/4) in Z_p
sqr_term = pow(b,2) - 4 * a * c
root = pow(sqr_term, (p+1)/4)

x1 = ((-b + root) * inv) % p
x2 = ((-b - root) * inv) % p

print "x1 =", x1
print "x2 =", x2



 

#square root function

#import sqrt function of math module
from math import sqrt

#function definition
def sqroot(x):
    return sqrt(x)

x = input("Enter number x: ")                   #get user input
print "Square root of x: " + str(sqroot(x))     #output

from Tkinter import *

class Application(Frame):
    def say_hi(self):
        print "hi there, everyone!"

    def createWidgets(self):
        self.QUIT = Button(self)
        self.QUIT["text"] = "QUIT"
        self.QUIT["fg"]   = "red"
        self.QUIT["command"] =  self.quit

        self.QUIT.pack({"side": "left"})

        self.hi_there = Button(self)
        self.hi_there["text"] = "Hello",
        self.hi_there["command"] = self.say_hi

        self.hi_there.pack({"side": "left"})

    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()



#root = Tk()
# e = Entry(root)
# e.pack()
# e.focus_set()
# b = Button(root, text="regular", width=10)
# b.pack()
# c = Button(root, text="mini")
# c.pack()
# w = Button(root, text="word")
# w.pack()
# mainloop()
# root.destroy()

def cross_product(A, B):
    the_list = []
    for a in A:
        for b in B:
            the_list.append(a+b)
    return the_list


digits   = '123456789'
rows     = 'ABCDEFGHI'
cols = digits
square_list = cross_product(rows, digits)
unit_list = []
for c in cols:
    unit_list.append(cross_product(rows, c))
for r in rows:
    unit_list.append(cross_product(r, cols))
for x in ('ABC', 'DEF', 'GHI'):
    for y in('123', '456', '789'):
        unit_list.append(cross_product(x, y))
units = {}
peers = {}
for x in square_list:
    the_list = []
    for y in unit_list:
        if x in y:
            the_list.append(y)
    units[x] = the_list
peers = dict((s, set(sum(units[s],[]))-set([s]))
             for s in square_list)

def grid_values(grid):
    char_list = []
    for c in grid:
        if c in digits or c in '0.':
            char_list.append(c)
    result = dict(zip(square_list, char_list))
    return result

# def parse_grid(grid):
#     """Convert grid to a dict of possible values, {square: digits}, or
#     return False if a contradiction is detected."""
#     ## To start, every square can be any digit; then assign values from the grid.
#     values = dict((s, digits) for s in square_list)
#     for s,d in grid_values(grid).items():
#         if d in digits and not assign(values, s, d):
#             return False ## (Fail if we can't assign d to square s.)
#     return values


def newton_sq_rt(root_of):
    '''Finds square root to minimum precision of 0.01 using Newton's method
        of successive approximations'''

    # Start with initial guess of half the input value
    apxroot = root_of/2
    n = 0
    while abs(root_of - apxroot**2) > 0.01:
        if n == 0: # I like to be grammatically correct :smiley:
            print("{} iteration,  guess is {}".format(n+1, round(apxroot,2)))
        else:
            print("{} iterations, guess is {}".format(n+1, round(apxroot,2)))
        apxroot  = (apxroot + root_of/apxroot)/2
        n += 1
    return apxroot

def get_input():
    root_of = input("Enter a number: ")
    try:
        float(root_of)
    except:
        print("Non-numeric input.".format(end=''))
        return get_input()
    if float(root_of) < 0:
        print("Negative number; result is type 'complex'.")
        return abs(float(root_of)), True
    return float(root_of), False

root_of, complex_bool = get_input()
if complex_bool:
    print("The square root of -{} is {}j".format(root_of, round(newton_sq_rt(root_of),2)))
else:
    print("The square root of {} is {}".format(root_of, round(newton_sq_rt(root_of),2)))

# Fn. to get the square root of a given value, that takes a as a parameter ,
# that choose a reasonable value of x, and return s an estimate of the squar
# root of a.  
# abs(y - x) < epsilon , that determines how close enough, insteda of using y == x

def sqr_rt(a):
	epsilon = 0.0000001
	x = 3.0
	while True:
		y = (x + a/x) / 2
		if abs(y - x) < epsilon:
			break;
		else:
			x = y

	return y

a = input("Give a number :\n")
result = sqr_rt(a)
print result


#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The Euler Project: problem 57
#
# It is possible to show that the square root of two can be expressed as an infinite continued fraction.
#
#  2 = 1 + 1/(2 + 1/(2 + 1/(2 +  ))) = 1.414213
#
# By expanding this for the first four iterations, we get:
#
# 1 + 1/2 = 3/2 = 1.5
# 1 + 1/(2 + 1/2) = 7/5 = 1.4
# 1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666
# 1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379
#
# The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first 
# example where the number of digits in the numerator exceeds the number of digits in the denominator.
#
# In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?

from decorators import benchmark
from fractions import Fraction

def brute_force():
  # brute force recursion
  def two_square_root(expansion=1):
    def decimal_part(expansion):
      if expansion <= 1:
        return Fraction(1,2)
      return 1/Fraction(2 + decimal_part(expansion-1))
    return Fraction(1 + decimal_part(expansion))

  # good but breaks with two many recursion
  s = 0
  for i in xrange(1,1000):
    f = two_square_root(i)
    if len(str(f.numerator)) > len(str(f.denominator)):
      s += 1
  return s

# smart generator
@benchmark
def smart():
  def tw_square_root_gen(limit=100):
    i,r = 0, 1+Fraction(1,2)
    while i < limit:
      yield r
      r = 1+1/(1+r)
      i += 1

  s = 0
  for f in tw_square_root_gen(1001):
    if len(str(f.numerator)) > len(str(f.denominator)):
      s += 1
  return s

if __name__ == "__main__":
  smart()
    #The prime factors of 13195 are 5, 7, 13 and 29.
    #What is the largest prime factor of the number 600851475143 ?
import math

def isPrime(candidate):
    prime = True
    squareRoot = math.floor(math.sqrt(candidate))
    numbers = range(2, squareRoot)
    divisors = list(filter(lambda x: candidate % x == 0, numbers))
    if len(divisors) != 0 : prime = False

    return prime

max = 600851475143

for x in range(2, max):
    if max % x == 0:
        max /= x
        if isPrime(max):
            print(max)




def square_root(n):
	n=float(n)
	x=n/2
	i=0
	while i<10:
		x=((x+n)/x)/2
		i=i+1
	return x

print square_root(9)


def sequence(n):
    while n != 1:
        print n
        if n%2 == 0:
            n = n/2
        else:
            n = n*3+1

#print sequence(3)



#7.1
def print_n(s, n):
    while n <= 0:
        return
    print s
    print_n(s, n-1)
    
print_n("Hello",5)

#7.2  
def square_root(a):
    x = a / 2.0
    epsilon = 0.000000000001
    while True:
        y = (x + a/x) / 2.0
        if abs(y-x) < epsilon:
            break
        x = y
    return x
    
print square_root(49)

#!/bin/python

def squareRootBi(x, epsilon):  
  assert epsilon > 0, 'epsilon must be postive, not ' + str(epsilon) 
  low = 0 
  high = max(x, 1) 
  guess = (low + high)/2.0 
  ctr = 1 
  while abs(guess ** 2 - x) > epsilon: 
    #print 'low:', low, 'high:', high, 'guess:', guess
    if guess**2 < x: 
      low = guess 
    else: 
      high = guess 
    guess = (low + high) / 2.0 
    ctr += 1 
    assert ctr <= 1000, 'iteration count exceeded' 
  print 'iterations:', ctr, 'Estimate:', guess 
  return guess
 
x = int(raw_input('Enter a value for x: '))
epsilon = float(raw_input('Enter an epsilon value (accuracy): '))
print squareRootBi(x, epsilon)

# this program will attempt to find the square root of a number, using binary search

def squareroot(number):
    difference = 1
    number_guess = float(number/2)
    while difference > 0.01:
        square_root = number_guess - ((number_guess*number_guess - number) / (2*number_guess))
        difference = float(abs(number_guess - square_root))
        number_guess = square_root
    return round(square_root, 3)

def root(number, exp):
    i = exp - 1
    if i > 0:
        root1 = squareroot(number)
        return root(root1, exp - 1)
    else:
        return number

print(root(1012312, 1))
# lol I love python
#Implement int sqrt(int x).
#
#Compute and return the square root of x.

class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        return int(math.sqrt(x))
__author__ = 'eric'

import numpy as np
import theano.tensor as T


def sigmoid(x):
    # return 1. / (1 + numpy.exp(-x))
    # but, overflow because of exp(-x)
    # transfer to tanh, works!
    return 0.5 * (1 + np.tanh(x / 2))


def sigmoid_T(x):
    return 0.5 * (1 + T.tanh(x / 2))


def inv_sigmoid(x):
    """
    inverse sigmoid
    """
    return np.log(x / (1. - x))


def inv_sigmoid_T(x):
    return T.log(x / (1. - x))


def RMSE(a, b):
    """
    Root Mean Square Error
    """
    return np.sqrt(np.sum(np.square(a - b), axis=1))


def RMSE_T(a, b):
    return T.sqrt(T.sum(T.square(a - b), axis=1))


if __name__ == "__main__":
    lb = np.array([1, 2, 3, 4, 5])
    print sigmoid(lb)
### Calculator using OOP and Module and packages

'''Complete our previous calculator to make it really pro using modules and packages.
Create an object oriented design. DISCUSS the design first.
IMPORTANT: Keep it simple, this exercise should not take more than 20 minutes. The idea is to
focus on design (what classes will you have and in which packages and modules will they live on?).
'''
def subtract(x, y):
     return x - y
     
def add(x, y):
     return x + y

def power(x, y):
     return x ** y

def multiply(x,y):
     return x*y


def divide(x,y):
     return x/y

def square(x):
     return x ** 2

def sqr_root(x):
     return x ** 0.5






#newton square root

#function definition
def sqrt(n):
    approx = n/2.0
    better = (approx + n/approx)/2.0
    while better != approx:
        approx = better
        better = (approx + n/approx)/2.0
    return approx

x = input("Enter x: ")
print "Square Root: ", sqrt(x)

def squareroot(n):
	x=n/2
	y=x+1
	while(x!=y):
		z=n/x
		y=x
		x=(x+z)/2
	return x

n=float(input("Give me a number: "))
if (n==0):
	print("The square root is: 0")
elif (n<0):
	print("Error")
else:
	sqrt=squareroot(n)
	print("The square root is: ", sqrt)

# General iterative solving, recursive version I

def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    if done(guess):
        return guess
    else:
        return iter_solve(update(guess), done, update)


# General iterative solving, recursive version II

def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    def solution(guess):
        if done(guess):
            return guess
        else:
            return solution(update(guess))
    return solution(guess)


# General iterative solving, iterative version

def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""
    while not done(guess):
        guess = update(guess)
    return guess


# General iterative solving with iteration limit, recursive

def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    def solution(guess, iteration_limit):
        if done(guess):
            return guess
        elif iteration_limit <= 0:
            raise ValueError("failed to converge")
        else:
            return solution(update(guess), iteration_limit-1)
    return solution(guess, iteration_limit)

# General iterative solving with iteration limit, iterative

def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE, 
    starting at GUESS, until DONE yields a true value 
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    while not done(guess):
        if iteration_limit <= 0:
            raise ValueError("failed to converge")
        guess, iteration_limit = update(guess), iteration_limit-1
    return guess


# Direct implementation of square root using Newton's method

def square_root(x):
    """Compute an approximation to the square root of X.
    >>> round(square_root(9), 10)   # round to 10 decimal places
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    tol = abs(x) * 1.0e-10
    y = x * 0.5
    while abs(y*y - x) > tol:
        y -= (y * y - x) / (2.0 * y)    # y = y - (y*y - x)/ (2.0 * y)
    return y


# General Newton's method

def newton_solve(func, deriv, start, tolerance):
    """Return x such that |FUNC(x)| < TOLERANCE, given initial
    estimate START and assuming DERIV is the derivatative of FUNC."""
    def close_enough(x):
        return abs(func(x)) < tolerance
    def newton_update(x):
        return x - func(x) / deriv(x) 

    return iter_solve(start, close_enough, newton_update, 1000000000)

def square_root(a):
    """Compute an approximation to the square root of A.
    >>> round(square_root(9), 10)   # round to 10 decimal places
    3.0
    """
    if a < 0:
        raise ValueError("square root of negative value")
    return newton_solve(lambda x: x*x - a, lambda x: 2 * x, 
                        a/2, a * 1e-10)

def cube_root(a):
    """Compute an approximation to the cube root of X.
    >>> round(cube_root(8), 10)   # round to 10 decimal places
    2.0
    """
    return newton_solve(lambda x: x**3 - a, lambda x: 3 * x ** 2,
                        a/3, a * 1e-10)


# Secant method

def iter_solve2(guess, done, update, state=None):
    """Return the result of repeatedly applying UPDATE to GUESS
    and STATE, until DONE yields a true value when applied to
    GUESS and STATE.  UPDATE returns an updated guess and state."""
    while not done(guess, state):
        guess, state = update(guess, state)
    return guess

def secant_solve(func, start0, start1, tolerance):
    """An approximate solution to FUNC(x) == 0 for which
    |FUNC(x)|<TOLERANCE, as computed by the secant method
    beginning at points START0 and START1."""
    
    def close_enough(x, state):
        return abs(func(x)) < tolerance
    def secant_update(xk, xk1):
        return (xk - func(xk) * (xk - xk1) 
                                / (func(xk) - func(xk1)), 
                xk)
    return iter_solve2(start1, close_enough, secant_update, start0)

def square_root2(x):
    """An approximation to the square root of X, using the secant method.
    >>> round(square_root2(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    return secant_solve(lambda y: y*y - x, 1, 0.5 * (x + 1), x * 1.0e-10)

import math


def square_root_method(a,x):
    while True:
        #print x 
        y=(x+a/x)/2
        if y==x:
            break
        x=y
    return y
    
print(square_root_method(9,8))
print(type(square_root_method(9,10)))
        
        
def table():
    for i in range(1,10):
        tabelle=[]
        p=math.sqrt(i)
        #print(p)
        q=square_root_method(i,i+1)
        #print(q)
        r=abs(p-q)
        #print(r)
        tabelle.append([i, p, q, r])
        print(tabelle)
    return tabelle

print tabulate(table())


    
import math
def square_root (a):
	guess = 1
	while abs (guess * guess - a) >= 1e-12:
		guess  = (a/ guess + guess) *0.5
	return guess

def test_square_root():
	a = 1.0
	while (a < 10):
		print (a, square_root (a), math.sqrt(a), abs (square_root (a) - math.sqrt(a)))
		a += 1

test_square_root()
import math

@profile
def is_prime_slower(num):
    if num <= 1:
        return False
    
    square_root = int(math.sqrt(num))
    for i in range(2,square_root + 1):
        if num % i == 0:
            return False
    return True

@profile
def is_prime(num):
	if num == 1:
		return False

	if num < 4: # 2 and 3 are prime
		return True

	if num % 2 == 0:
		return False

	if num < 9: # We have already excluded 4,6 and 8.
		return True

	if num % 3 == 0:
		return False

	r = int(math.sqrt(num))
	f = 5

	while f <= r:
		if num % f == 0:
			return False
		if num % (f+2) == 0:
			return False
		f += 6

	return True

def main():
	for i in range(0,1000000000):
		is_prime(i)
		is_prime_slower(i)
	

if __name__ == '__main__':
	main()
import math
def strict_floor(f):
    if int(math.floor(f)) == f:
        return int(f - 1)
    else: 
        return int(math.floor(f))
    
def strict_ceil(f):
    if int(math.ceil(f)) == f:
        return int(f + 1)
    else:
        return int(math.ceil(f))

def is_square(n):
    root = int(math.sqrt(n))
    if root*root == n:
        return True
    else:
        return False

def count_square_quads(m):
    n_with_square = 0
    for a in range(1,m+1):
        if m==100: print "a = ", a
        for b in range(1,m+1):
            for c in range(1,m+1):
                for d in range(1,m+1):
                    n_pts = 0
                    for x in range(-c+1,0):
                        low = strict_ceil( -(d/float(c))*x -d )
                        high = strict_floor( (b/float(c))*x + b ) + 1
                        #print "1: x: ",x
                        #print "1: high, low: ", high, low
                        #print "1: inputs: ", -(d/float(c))*x -d , (b/float(c))*x + b 
                        for y in range(low,high):
                            n_pts +=1
                    for x in range(0,a):
                        low = strict_ceil( (d/float(a))*x -d )
                        high = strict_floor( -(b/float(a))*x + b ) + 1
                        for y in range(low,high):
                                n_pts += 1
                    if is_square(n_pts): n_with_square += 1
    print "number of squares for m = ", m, "is", n_with_square

count_square_quads(1)
count_square_quads(2)
count_square_quads(3)
count_square_quads(4)
count_square_quads(5)
count_square_quads(6)
count_square_quads(7)
count_square_quads(8)
count_square_quads(9)
count_square_quads(10)
count_square_quads(11)
count_square_quads(12)
count_square_quads(13)
count_square_quads(14)
count_square_quads(15)

#!/usr/bin/env python

"""Mathematical utilities"""

import math


#------------------------------------------------------------------------------
def isPrime(num):
    """Check if num is prime"""
    for idx in range(2, int(math.sqrt(num))):
        if not num % idx:
            return False
    return True


#------------------------------------------------------------------------------
def binomialCoeff(elements, combinations):
    """
    Calculate binomial coefficient for the given number of
    elements and combinations
    """
    fact = math.factorial
    return fact(elements) / fact(combinations) * fact(elements - combinations)


#------------------------------------------------------------------------------
def average(seq):
    """Calculate the average value of a sequence of values"""
    return sum(seq) / len(seq)


#------------------------------------------------------------------------------
def sqrt(num) -> float:
    """Calculate the square root of the given number"""
    # root = num / 2  # make a guess TODO improve first guess
    root = num / 2 if num > 0 else 1
    while abs((num / root) - root) > 0.000000001:
        root = average((root, num / root))
    return root

#------------------------------------------------------------------------------
# test
if __name__ == '__main__':
    print(0.1*0.1)
    print(sqrt(0.001))

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
P-069 - Sqrt(x)

Implementint sqrt(int x). Compute and return the square root ofx.

Tags: Math, Binary Search
'''

class Solution:
    # @param x, an integer
    # @return an integer
    def binary_search(self, x, y):
        m = (x + y) / 2
        if x > y:
            return y 
        if m * m > self.target:
            return self.binary_search(x, m - 1)
        elif m * m < self.target:
            return self.binary_search(m + 1, y)
        else:
            return m

    def sqrt(self, x):
        self.target = x
        return self.binary_search(0, x)

s = Solution()

print s.sqrt(100)
#!/usr/bin/env python3

from math import sqrt

def isSquare(n):
    root = int(sqrt(n))
    if root**2==n or (root+1)**2==n:
        return True
    else:
        return False

def checkSeq1(n):
    true = []
    for i in range(2,n+1,2):
        if isSquare((i+2)*(3*i+2)):
            true.append(i)
    return true

def checkSeq2(n):
    true = []
    for i in range(2,n+1,2):
        if isSquare((i-2)*(3*i-2)):
            true.append(i)
    return true

def sequence(bound, starter_values):
    values = [i for i in starter_values]
    if values[-1]>=bound:
        return values
    while values[-1]<bound:
        values.append(15*values[-1]-15*values[-2]+values[-3])
    return values



def subtract(x, y):
     return x - y
     
def add(x, y):
     return x + y

def power(x, y):
     return x ** y

def multiply(x,y):
     return x*y

def divide(x,y):
     return x/y

def square(x):
     return x ** 2

def sqr_root(x):
     return x ** 0.5


# Utilities related to the Fibonacci sequence, to be reused among problems

from math import sqrt

def fibonacci_generator():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b

# Returns the nth term of the Fibonacci sequence
def fibonacci_term(n):
    square_root_of_five = sqrt(5)
    phi = (1 + square_root_of_five)/2
    phi_2 = (1 - square_root_of_five)/2
    return int((phi**n - phi_2**n) / square_root_of_five)


import math

def is_prime(n):
    # Brute force testing of primality.  Test against every integer
    # less than a number's square root.
    for i in range(0, int(math.sqrt(n))+1):
        if n % i == 0:
            return False
    return True

"""Copyright 2013 Kawika Ohumukini.  All rights reserved.

Calculate square root of a number using Newtons method
"""

import math


def sqrt(x):
    x = float(x)
    for i in range(10):
        newtonX = x - (((x * x) - 2) / (2 * x))
        if (math.fabs(newtonX - x)) < 10**-10:
            return newtonX
        x = newtonX
    return x
def squareRoot(n):
	initialGuess = n/2;
	finalGuess = (initialGuess + (n/initialGuess)/2)
	while(abs(finalGuess - initialGuess	> 0.0001)):
		initialGuess = finalGuess
		finalGuess = (initialGuess + (n/initialGuess)/2)
	while finalGuess*finalGuess > n:
	    finalGuess -= 1
	return finalGuess

print squareRoot(9)
#!/usr/bin/python 
# Author LavaWong
# Date   7/13/2015 
# Find square root of spec number

#ans = 0
#n = raw_input('Enter a number: ')
#x = int(n)
#while ans*ans < x:
#     ans += 1
#print ans


def sqrt(x):
    if x < 0:
       return None
    ans = 0
    while ans*ans < x:
       ans += 1
    if ans*ans != x:
       print x, ' is not a perfect square root'
       return None
    else:
       print x, ' square root is ', ans
       return ans


n = raw_input('Enter a number: ')
sqrt(int(n))

# -*- coding: utf-8 -*-

__title__ = "Odd period square roots"

def solve():
    
    from math import sqrt
    n = 23

    def get_period(n):
        root = int(sqrt(n))
        m, d, a = 0, 1, root
        seq = [(0, 1, root)]
        while True:
            m = d*a - m
            d = (n - m*m)/d
            if d == 0:
                return 0
            a = int((root+m)/d)
            if seq.count((m, d, a)) > 0:
                return len(seq) - seq.index((m, d, a))
            else:
                seq.append((m, d, a))

    s = 0
    for n in xrange(2, 10001):
        d = get_period(n)

        if d % 2 != 0:
            s = s + 1

    return s




def squareRoot(x,power,eps):
    if x<0 and power %2 ==0:
        return None
    low = min(-1,x)
    high = max(1,x)
    ans=(low+high)/2.0
    while abs(ans**power-x) > eps:
        if ans**power <x:
            low = ans
        else:
            high = ans
        ans = (low+high)/2.0
    return ans

#!/usr/bin/python
import math

def square_root(a):
    x = a / 2.0
    epsilon = 0.00000001
    while True:
        y = (x + a/x) / 2.0
        if abs(x-y) <= epsilon:
            break
        x = y
    return x


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# Write a program to determine the sum of the first 1000 prime numbers. 
def square_root(num):
    initial_guess = 1
    while 1:    
        f_x = float(initial_guess*initial_guess - num)
        der_f_x = float(2 * initial_guess)
        new_guess = initial_guess - (f_x/der_f_x)*1.0
        if( abs(initial_guess-new_guess) < 0.001 or abs(initial_guess-new_guess)==0):
            break
        initial_guess = new_guess
    return "%.4f" %new_guess    
    
def is_prime(num):
    root = int(float(square_root(num)))
    for i in range(2,root+1):
        if( num%i == 0 ):
            return 1
    return 0    

counter = 0
i = 2
sum =0 
while counter < 1000:
    if(is_prime(i)==0):
        sum = sum + i
        counter=counter+1
        #print("counter = %d" %counter)
    i=i +1
    #print("i=%d" %i)
print(sum)
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from __future__ import division
import numpy as np


class Regression(object):

    def __init__(self, d_mat, t_vec):
        """
        prepends 1's onto each row in the design matrix, and runs regressions,
        to find w.

        :param d_mat (Design matric):
        :param t_vec (Target vector:
        """

        self.d_mat = np.array(map(lambda x: [1] + x, d_mat))
        self.t_vec = np.array(t_vec)

    def predict(self, x):
        raise Exception('Not yet implemented')

    def root_mean_square(self):
        """
        Find the root-dimension_means-square error for the given regression
        :return:
        """
        N = len(self.d_mat)

        guess_sum = 0
        for i in range(N):
            guess_sum += (self.t_vec[i][0] - self.predict(i))**2

        return np.sqrt((1/N) * guess_sum)
import math

def is_prime(number, primes=None):
    if number < 2:
        return False

    if primes and number in primes:
        return True

    start_at = 2

    #~ if reduce(lambda x, y: x or (number % y == 0), primes, False):
        #~ return False

    #~ for m in primes:
        #~ foobar = m

    square_root = int(math.sqrt(number))
    if not primes:
        start_at = 2
    else:
        for m in primes:
            if m > square_root:
                break

            if number % m == 0:
                return False

        start_at = m + 1


    for divisor in xrange(start_at, square_root + 1):
        if number % divisor == 0:
            return False

    #~ print "adding: %s" % number
    if primes:
        primes.append(number)
    return True

def gen_primes(max, primes):
    #~ n = 2
    for n in primes:
        if n > max:
            return
        yield n

    if n % 2 != 0:
        n += 1

    for m in xrange(n + 1, max, 2):
        #~ print "testing: %s" % m
        if is_prime(m, primes):
            yield m

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# encoding: utf-8
'''
Square root using Newton's method
recusive method example
'''

import math

PRECISION = 0.001
INITIAL_GUESS = 1.0

def __sqrt_iter(guess, x):
    if __good_enough(guess, x):        
        print guess        
    else:
        __sqrt_iter(__improve(guess, x), x)
        
def __improve(guess, x):
    return __average(guess, (x / guess))

def __average(x, y):
    return (x + y) / 2
    
def __good_enough(guess, x):
    return math.fabs((guess**2 - x)) < PRECISION
    
def nw_sqrt(x, initial_guess=INITIAL_GUESS):
    '''
    Return the square root of a number using the Newton's method based on proximity.
    
    #### needs some fixes ###
    >>> nw_sqrt(36, 1.0)
    6.00000000533    
    '''
    __sqrt_iter(initial_guess, x)   


if __name__ == '__main__':
    import doctest
    doctest.testmod()
import numpy as np


def root_mean_square(array):
    return (np.mean(array ** 2)) ** 0.5


def normalized(array):
    return array / max(array)


def spectrum(array):
    array *= np.hamming(len(array))  # window
    complex_array = np.fft.fft(array)  # fft
    complex_array = complex_array[:len(complex_array) // 2]  # del mirror part
    array = list(map(abs, complex_array))  # complex to float
    return array


def cepstrum(array):
    array *= np.hamming(len(array))
    complex_array = np.fft.fft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    complex_array = np.fft.ifft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    return array


def energy(array, size_chunk):
    list_energy = []
    for i in range(len(array) // size_chunk):
        l = array[i * size_chunk:i * size_chunk + size_chunk]
        list_energy.append(root_mean_square(l))
    l = []
    for i in range(len(list_energy) - 1):
        l.append(sum(list_energy[i:i + 2]) / 2)
    return l


def derivative(array):
    d = []
    for i in range(len(array) - 1):
        d.append(array[i + 1] - array[i])
    return d

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""
http://www.johndcook.com/blog/2012/05/08/a-knights-random-walk/
"""

import random
random.seed(12345)

import ROOT

def moves(square):
    N = dict((d for d in zip("abcdefgh", range(1, 9))))
    L = dict((d for d in zip(range(1, 9), "abcdefgh")))
    
    numbers = N[square[0]], int(square[1])
    #print "-", numbers[0], numbers[1]
    m = []
    for two in (-2, +2):
        for one in (-1, +1):
            h = numbers[0] + two
            v = numbers[1] + one

            #print ":", h,v
            if 1 <= h <= 8 and 1 <= v <= 8:
                #print h,v
                m.append((L[h], v))

            h = numbers[0] + one
            v = numbers[1] + two
            #print ":", h,v
            if 1 <= h <= 8 and 1 <= v <= 8:
                #print h,v
                m.append((L[h], v))
    
    return ["%s%i"%(a,n) for a,n in set(m)]

def random_walk(startingsq):
    sq = startingsq
    N = 0
    while True:
        N += 1
        sq = random.choice(moves(sq))

        if sq == startingsq:
            return N

h = ROOT.TH1F("", "", 1000, 0, 1000)
for n in xrange(10000):
    h.Fill(random_walk("a1"))

h.Draw()
raw_input("asf")

def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a/x) / 2
        print "x:" + str(x) + " y:" + str(y)
        if abs(y-x) < epsilon:
            return y
        x = y


print square_root(125.0)
def squareRootBi(x, epsilon=0.0001220703125):
    """Find the square root of x using successive approximation by bissection"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    low = 0
    # need for rational values, where the root is bigger than x
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while ctr < 100 and abs(guess**2 - x) > epsilon:
        #print("low:", low, "high:", high, "guess", guess)
        if guess**2 > x:
            high = guess
        else:
            low = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("Bi Method. Steps:", ctr)
    return guess

def testBi():
    for test in (4, 9, 2, 1024, 13, 0.25):
        print("Testing:", test)
        sq = squareRootBi(test)
        print("Result:", sq)
        print("Diff test - sq**2:", test - sq**2)
        print()

def squareRootNR(x, epsilon=0.0001220703125):
    """Find the square root of x using Newton/Raphson method"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    guess = 1
    diff = guess**2 - x
    ctr = 1
    while ctr < 100 and abs(diff) > epsilon:
        guess = guess - diff/(2.0 * guess)
        diff = guess**2 - x
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("NR Method. Steps:", ctr)
    return guess

def testNR():
    for test in (4, 9, 2, 1024, 13, 0.25):
        print("Testing:", test)
        sq = squareRootNR(test)
        print("Result:", sq)
        print("Diff test - sq**2:", test - sq**2)
        print()

def testBoth():
    for test in (4, 9, 2, 1024, 13, 0.25, 123456789):
        print("Testing:", test)
        sqNR = squareRootNR(test)
        sqBI = squareRootBi(test)
        print("Results NR:", sqNR, "BI:", sqBI)
        print()

#testBi()
#testNR()
testBoth()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

__author__ = 'andi'
import math
import re


def arithmetic(question):
    question = question[8:]
    question = question.replace("plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))


def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)


def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []
    for number in number_list:
        if __is_square(number) and __is_third_square(number):
            return_values.append(number)
    return_value = ", ".join(return_values)
    return return_value


def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False
    else:
        return True


def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)


def float_equals(a, b, tolerance=0.00000001):
    return abs(a-b) < tolerance

primes_under_100 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]


def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100
    if n % 2 == 0 or n % 3 == 0:
        return False

    for f in range(5, int(n ** .5), 6):
        if n % f == 0 or n % (f + 2) == 0:
            return False
    return True


def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)


def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))
    return question


def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a


# what is 13 to the power of 11
def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))

#Archana Bahuguna ---- Decorator fn ----- Jan 6th 2014

def accept_n_gt_zero(fnToCall):
   def wrapper(n, *args, **kwargs):
       if n <= 0:
           print 'From inside Decorator: n <=0 before raising exception'
           raise Exception("Exception raised: n must be > 0")
       else:
           print 'From inside Decorator: n > 0, before calling SquareRoot fn'
           return fnToCall(n, *args, **kwargs)
       return wrapper


# @accept_n_gt_zero
def square_root(n):
    result = n**(1/2)
    return result
# is same as ... SquareRoot = accept_n_gt_zero(SquareRoot)
# square_root(10)
print accept_n_gt_zero(square_root)(10) # <function wrapper>

def wrapper(n, *args, **kwargs):
    if n <= 0:
        print 'From inside Decorator: n <=0 before raising exception'
        raise Exception("Exception raised: n must be > 0")
    else:
        print 'From inside Decorator: n > 0, before calling SquareRoot fn'
        print n, args, kwargs

wrapper(10, 20, a=12)            
#Why do we need a wrapper fn if n is being passed through the fnToCall arg itself?
#Why does the code not work if we dont use the wrapper fn? It should work...
#How is n being passed?

def sqrt(x):
    """ Calculate the square root of a perfect square"""
    if x >= 0:
        ans = 0
        while ans * ans < x:
            ans += 1
        if ans * ans == x:
            return ans
        else:
            print(x, "is not a perfect square")
            return None
    else:
        print(x, "is a negative number")
        return None

for i in range (-10, 11):
    x = sqrt(i)
    if x != None:
        print("Square root of", i, "is", x)

from subtract_square_state import SubtractSquareState

class GameStateNode:
    '''
    A tree of possible states for a two-player, sequential move, zero-sum,
    perfect-information game.

    value: GameState -- the game state at the root of this tree
    children: list -- all possible game states that can be reached from this
 	game state via one legal move in the game.  children is None until grow
	is called.
    '''

    def __init__(self, game_state):
        ''' (GameStateNode, GameState) -> NoneType

        Initialize a new game state tree consisting of a single root node 
	that contains game_state.
        '''
        self.value = game_state
        self.children = []

    def __eq__(self, other):
        ''' (GameStateNode, object) -> bool

        Return whether this GameStateNode is equivalent to other, i.e., they
        contain equivalent GameStates, and equivalent children.  The order of
        their children does not matter.

        >>> s1 = SubtractSquareState('p1', current_total = 6)
        >>> s2 = SubtractSquareState('p2', current_total = 5)
        >>> s3 = SubtractSquareState('p1', current_total = 2)
        >>> leaf1 = GameStateNode(s1)
        >>> leaf2 = GameStateNode(s2)
        >>> leaf3 = GameStateNode(s3)
        >>> leaf1.__eq__(leaf2)
        False
        >>> root1 = GameStateNode(s1)
        >>> root1.children = [s2, s3]
        >>> root2 = GameStateNode(s1)
        >>> root1.__eq__(root2)
        False
        >>> root2.children = [s2, s3]
        >>> root1.__eq__(root2)
        True
        '''
        # Checking that the children lists have the same contents requires
        # checking that every element of one list is in the other, and vice
        # versa. Since checking "in" causes calls to the __eq__ method, we
        # end up recursing.
        return (type(self) == type(other) and
                self.value == other.value and        
                same_contents(self.children, other.children))

    def grow(self):
        ''' (GameStateNode) -> NoneType

        Grow the tree of all possible game state nodes that can be reached
	starting from this one.

        Assume that the game is finite (and so the tree will be finite).
        
        >>> a0 = SubtractSquareState('p1', current_total = 0)
        >>> b1 = SubtractSquareState('p2', current_total = 1)
        >>> a2 = SubtractSquareState('p1', current_total = 2)
        >>> b3 = SubtractSquareState('p2', current_total = 3)
        >>> a4 = SubtractSquareState('p1', current_total = 4)
        >>> b0 = SubtractSquareState('p2', current_total = 0)
        >>> a0_node = GameStateNode(a0)
        >>> b1_node = GameStateNode(b1)
        >>> b1_node.children = [a0_node]
        >>> a2_node = GameStateNode(a2)
        >>> a2_node.children = [b1_node]
        >>> b3_node = GameStateNode(b3)
        >>> b3_node.children = [a2_node]
        >>> b0_node = GameStateNode(b0)
        >>> a4_node = GameStateNode(a4)
        >>> a4_node.children = [b0_node, b3_node]
        >>> root = GameStateNode(SubtractSquareState('p1', current_total = 4))
        >>> root.grow()
        >>> root.__eq__(a4_node)
        True
        '''
        pass

def same_contents(L1, L2):
    ''' (list, list) -> bool
    
    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.
    
    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and 
            all([x in L2 for x in L1]) and 
            all([x in L1 for x in L2]))

def node_count(root):
    ''' (GameStateNode) -> int
    
    Return the number of nodes in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    pass

def leaf_count(root):
    '''(GameStateNode) -> int
    
    Return the number of leaves in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    pass

def distinct_node_count(root):
    '''(GameStateNode) -> int
    
    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    pass
                      
def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int
    
    Return the number of leaves representing distinct game states in the
    tree rooted at root.
       
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    pass

def branching_stats(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    pass       
            
def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]
    
    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    pass

def game_lengths(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    pass   

def game_descriptions(root):
    ''' (GameStateNode) -> list of str
    
    Return a list containing a str describing each complete game that is
    possible from the game stored at root.
    
    Assume root is the root of a game state tree specifically for the game
    Subtract Square.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    pass
            
def abbreviated(s):
    '''(GameState) -> str
    
    Return an abbreviated str representation of SubtractSquareState s.
    '''
    
    return "{}:{}".format(s.next_player, s.current_total)

if __name__ == '__main__':
    import doctest
    doctest.testmod()
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The Euler Project: problem 080
#

from decorators import benchmark

@benchmark
def solve():
  def root_decimal_expansion(n, limit=10):
    """
    http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation
    """
    n = str(int(n))
    if len(n)%2==1: n = '0'+n
    pairs = zip(n[::2], n[1::2])[::-1]
    c = 0
    p = 0
    while pairs or c:
      c *= 100
      if pairs: c += int(''.join(pairs.pop()))
      x = 0
      y = lambda x: x*(20*p + x)
      while y(x+1) <= c: x += 1
      c -= y(x)
      p = 10*p + x 
      if len(str(p)) >= limit:
        break
    return p

  def digital_sum(n, limit=100):
    return reduce(lambda x,y: x+int(y), list(str(root_decimal_expansion(n, limit))), 0)

  perfect_square = [i**2 for i in range(1,11)]
  return sum(digital_sum(i) for i in range(1,101) if i not in perfect_square)

if __name__ == "__main__":
  solve()
#!/usr/bin/python

#============================================================================
# Project Euler: http://wwww.projecteuler.net
# Problem 10:
# Find the sum of all the primes below two million
#     - modification of euler7
#============================================================================

#import libraries/modules
import sys
from math import sqrt, floor
import time

#constants
LIMIT = 2000000

#find square root of passed number
def squareRoot(x):
     root = int(floor(sqrt(x)))
     #make the root number odd
     if root % 2 == 0:
          root +=1
     return root

#checks to see if number is prime
def checkPrime(x):
     prime = True   #flag
     
     #basic simple check to see if number passed is even, if it is then it's not a prime number
     if x % 2 == 0: 
          return False
     
     checkedNumber = squareRoot(x)
     for i in range(3,checkedNumber+2,2):
          if x % i == 0:
               prime = False
               break
     return prime

count = 0
sum = 2
count = 3
t0 = time.clock()
#main 
while count < LIMIT:
     if checkPrime(count):
          print count
          sum += count
     count += 2
t1 = time.clock() - t0

#total time is:  13.1200178791
print "sum of primes below", LIMIT, "is", sum
print "total time is: ", t1
#Playing with math module and definition
#yen kha 6/6/2014"""

#example 1: import math module

#import math
#from math import *  #this imports all math modules from python library

"""import sqrt, exp #this imports only square root and exponential modules 
from math"""

#example 2: create a small program prompting user to enter a value with
#a defined square root function"""

x = raw_input ("enter a value to calculate square root of x")

print x

def square (x):
    return x*x






#!/usr/bin/python

#============================================================================
# Project Euler: http://wwww.projecteuler.net
# Problem 7: http://projecteuler.net/index.php?section=problems&id=7
# What is the 10001st prime number?
#============================================================================

#import libraries/modules
import sys
from math import sqrt, floor

#find square root of passed number
def squareRoot(x):
     root = int(floor(sqrt(x)))
     #make the root number odd
     if root % 2 == 0:
          root +=1
     return root

#checks to see if number is prime
def checkPrime(x):
     prime = True   #flag
     
     #basic simple check to see if number passed is even, if it is then it's not a prime number
     if x % 2 == 0: 
          return False
     
     checkedNumber = squareRoot(x)
     for i in range(3,checkedNumber+2,2):
          if x % i == 0:
               prime = False
               break
     return prime

count = 3
primeCount = 2

#main 
while primeCount < 10001:
     count += 2
     if checkPrime(count):
          primeCount +=1
 
print "The 10001 prime number is", count
import math
import random

############################
## Wiener's Attack module ##
############################

# Calculates bitlength
def bitlength(x):
  assert x >= 0
  n = 0
  while x > 0:
    n = n+1
    x = x>>1
  return n
  
# Squareroots an integer
def isqrt(n):
  if n < 0:
    raise ValueError('square root not defined for negative numbers')  
  if n == 0:
    return 0
  a, b = divmod(bitlength(n), 2)
  x = 2**(a+b)
  while True:
    y = (x + n//x)//2
    if y >= x:
      return x
    x = y

# Checks if an integer has a perfect square
def is_perfect_square(n):
  h = n & 0xF; #last hexadecimal "digit"    
  if h > 9:
    return -1 # return immediately in 6 cases out of 16.
  # Take advantage of Boolean short-circuit evaluation
  if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
    # take square root if you must
    t = isqrt(n)
    if t*t == n:
      return t
    else:
      return -1    
  return -1

# Calculate a sequence of continued fractions
def partial_quotiens(x, y):
  partials = []
  while x != 1:
    partials.append(x // y)
    a = y
    b = x % y
    x = a
    y = b
  #print partials
  return partials

# Helper function for convergents
def indexed_convergent(sequence):
  i = len(sequence) - 1
  num = sequence[i]
  denom = 1
  while i > 0:
    i -= 1
    a = (sequence[i] * num) + denom
    b = num
    num = a
    denom = b
  #print (num, denom)
  return (num, denom)

# Calculate convergents of a  sequence of continued fractions
def convergents(sequence):
  c = []
  for i in range(1, len(sequence)):
    c.append(indexed_convergent(sequence[0:i]))
  #print c
  return c

# Calculate `phi(N)` from `e`, `d` and `k`
def phiN(e, d, k):
  return ((e * d) - 1) / k

# Wiener's attack, see http://en.wikipedia.org/wiki/Wiener%27s_attack for more information
def wiener_attack(N,e):
  (p,q,d) = (0,0,0)
  conv=convergents(partial_quotiens(e,N))
  for frac in conv:
    (k,d)=frac
    if k == 0:
      continue
    y = -(N - phiN(e, d, k) + 1)
    discr = y*y - 4*N
    if(discr>=0):
      # since we need an integer for our roots we need a perfect squared discriminant
      sqr_discr = is_perfect_square(discr)
      # test if discr is positive and the roots are integers
      if sqr_discr!=-1 and (-y+sqr_discr)%2==0:
        p = ((-y+sqr_discr)/2)
        q = ((-y-sqr_discr)/2)
        return p, q, d
  return p, q, d

################################
## End Wiener's Attack module ##
################################
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

###		Graph Operations:

import numpy as np
from scipy import sparse

###############################################################################
# Diagonal Degree Matrix

"""  Function: Computes Diagonal Degree Matrix:
------------------------------------------------------
Parameters: W: N x N sparse matrix in csr format
				Affinity matrix
			inverse: boolean
				Compute inverse of diagonal degree matrix?
			square_root: boolean
				Compute square root of diagonal degree matrix?

Returns:	ddm: N x N sparse matrix in csr format
				Diagonal matrix.
----------------------------------------------------  """

def compute_diagonal_degree_matrix(W, inverse=False, square_root=False):
	
	ddm = sparse.lil_matrix((W.shape[0], W.shape[0]))
	
	if inverse:
		if not square_root:
			ddm.setdiag(1 / W.sum(axis=1))	
		else:
			ddm.setdiag(np.sqrt(1 / W.sum(axis=1)))
	
	else:
		ddm.setdiag(W.sum(axis=1))		
	
	return ddm.tocsr()
	
###############################################################################
# Graph laplacian

""" Function: Computes normalized and unnormalized graph laplacians
----------------------------------------------------------
Parameters: W: N x N sparse matrix
				Matrix in csr format, affinity matrix
			which: string
				basic - non-normalized Laplacian (Lap = D - W)
				norm1 - normalized Laplacian (Lap = ddmi_sq * L * ddmi_sq) - recovers definition
				norm2 - normalized Laplacian (Lap = ddmi_sq * W * ddmi_sq)
				norm3 - normalized Laplacian (Lap = inv(D) * L)
				random_walk - random walk Laplacian (Lap = inv(D) * W) 

Returns:	Laplacian: N x N sparse matrix
				Matrix in csr format, Graph Laplacian of affinity matrix 

---------------------------------------------------------- """

def graph_laplacian(W, which='norm1'):
	
	if which is 'basic':
		print 'Calculating Unnormalized Laplacian...'
		Laplacian = compute_diagonal_degree_matrix(W) - W	
		return Laplacian
	
	elif which is 'norm1':
		print "Normalizing the Laplacian..."
		ddmi_sq = compute_diagonal_degree_matrix(W, inverse=True, square_root=True)
		Laplacian = ddmi_sq * (compute_diagonal_degree_matrix(W, inverse=False, square_root=False) - W) * ddmi_sq
		return Laplacian
		
	elif which is 'norm2':
		print "Normalizing the Laplacian..."
		ddmi_sq = compute_diagonal_degree_matrix(W, inverse=True, square_root=True)
		Laplacian = ddmi_sq * W * ddmi_sq
		return Laplacian
		
	elif which is 'norm3':
		print "Normalizing the Laplacian..."
		ddmi = compute_diagonal_degree_matrix(W, inverse=True, square_root=False)
		Laplacian = ddmi * (compute_diagonal_degree_matrix(W, inverse=False, square_root=False) - W)
		return Laplacian
		
	elif which is 'random_walk':
		print "Computing Random Walk Laplacian..."
		ddmi = compute_diagonal_degree_matrix(W, inverse=True, square_root=False)
		Laplacian = ddmi * W
	
	else:
		print 'Option is not available'
		return 0


		
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""
Clifton Crosland
Project Euler 80 - Summing the digits of irrational square roots
Source of the square roots algorithm: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
"""

import math

def make_groups_of_two(n):
  str_n = str(n)
  if len(str_n) % 2 == 1:
    # Append leading zero if necessary
    str_n = "0" + str_n
  groups = []
  i = 0
  while i < len(str_n):
    groups.append(str_n[i:i+2])
    i += 2
  groups += ["00"] * (100 - len(groups)) # We want first 100 digits of square roots
  return groups

def sum_of_digits(n):
  total = 0
  while n != 0:
    total += n % 10
    n /= 10
  return total

# Guess and check
def get_best_x(c, p):
  for x in range(0, 11):
    if (20 * p + x) * x > c:
      return x-1
  print "ERROR! NO DIGITS WORK!"
  return -1 # ERROR

# Precondition: Square root of n is not an integer (hence, root is irrational)
def sum_of_100_digits_of_irr_root(n):
  n_groups = make_groups_of_two(n)
  result = 0
  remainder = 0
  for group in n_groups:
    c = remainder * 100 + int(group)
    x = get_best_x(c, result)
    remainder = c - (20*result + x) * x
    result = result * 10 + x
  return sum_of_digits(result)
  
def main():
  squares = [1,4,9,16,25,36,49,64,81,100]
  total = 0
  for i in range(1, 101):
    if i not in squares:
      total += sum_of_100_digits_of_irr_root(i)
  print total
  
if __name__ == "__main__":
  main()
def squareRoot(n):
	initialGuess = n/2;
	finalGuess = (initialGuess + (n/initialGuess)/2)
	while(abs(finalGuess - initialGuess	> 0.0001)):
		initialGuess = finalGuess
		finalGuess = (initialGuess + (n/initialGuess)/2)
	while finalGuess*finalGuess > n:
	    finalGuess -= 1
	return finalGuess

print squareRoot(9)
import numpy

def power(x,y=2):
    return x ** y

def square_root(x):
    return numpy.sqrt(x)

def junk(x):
    for i in range(x): print i+1


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import sys

def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for witch the square root is to be computed.

    Returns:
        The square root of x.
    """
    if x < 0:
        raise ValueError('Cannot compute square root of negative number {}'.format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess

def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print('This is never printed')
    except (ZeroDivisionError, ValueError) as e:
        print(e, file=sys.stderr)

    print('Program execution continues normally here.')

if __name__ == '__main__':
    main()
from Scientific.BSP import ParSequence, ParFunction, ParRootFunction
import operator

# The local computation function.
def square(numbers):
    return [x*x for x in numbers]

# The global computation function.
global_square = ParFunction(square)

# The local output function
def output(result):
    print result

# The global output function - active on processor 0 only.
global_output = ParRootFunction(output)

# A list of numbers distributed over the processors.
items = ParSequence(range(100))

# Computation.
results = global_square(items)

# Collect results on processor 0.
all_results = results.reduce(operator.add, [])

# Output from processor 0.
global_output(all_results)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# This program solves an n-puzzle

from time import time

# Takes in square size and initial configuration
square_size = int(input("Please input the side length of the square: \n"))
print("Please enter the numbers in the square in the following way (example below): ")
print("If you wanted to enter the following configuration for a side length of 3, ")
print("7 2 4")
print("5   6")
print("8 3 1")
print("then you would type in '7 2 4 5 0 6 8 3 1'")
print("Note that the blank spot is represented by the number 0.")
num_string = input("Now, input the properly formatted string for your configuration: \n")

square = []
for i in num_string.split():
  square.append(int(i))

dest = list(range(square_size**2))

N_HASH = {}
for i in range(square_size**2):
  N_HASH[i] = []

DISTANCE_HASH  = {}
for i in range(square_size**2):
  for j in range(i, square_size**2):
    z = j - i
    dy = z//square_size
    dx = z%square_size
    DISTANCE_HASH[(i, j)] = dx + dy
    DISTANCE_HASH[(j, i)] = dx + dy

    if DISTANCE_HASH[(i, j)] == 1:
      N_HASH[i].append(j)
      N_HASH[j].append(i)

def dist_to_dest(num, square_config):
  return DISTANCE_HASH[(num, square_config.index(num))]

def heuristic(square_config):
  d = 0
  for i in range(len(square_config)):
    d += dist_to_dest(i, square_config)

  return d

def neighbors(square_config):
  open_spot = square_config.index(0)
  n_list = []
  for i in N_HASH[open_spot]:
    new_config = list(square_config)
    new_config[open_spot] = square_config[i]
    new_config[i] = 0
    n_list.append(new_config)

  return n_list

def str_print(config):
  for i in range(square_size):
    x = ''
    for j in range(square_size):
      k = config[i*square_size+j]
      if k == 0:
        x += ' '.ljust(3) + ' '
      else:
        x += str(config[i*square_size+j]).ljust(3) + ' '
    print(x)
  print()

t1 = time()

dist_parent_hash = {tuple(square): [0, None]}

d_root = heuristic(square)
q = {d_root: square}

count = 0

max_q_length = len(q)

while len(q) > 0:
  if len(q) > max_q_length:
    max_q_length = len(q)

  m = min(q)
  x = q.pop(m)

  if x == dest:
    break
  count += 1

  nbors = neighbors(x)
  for config in nbors:
    distance = dist_parent_hash[tuple(x)][0] + 1
    if (tuple(config) in dist_parent_hash) == False:
      dist_parent_hash[tuple(config)] = [distance, tuple(x)]
      q[(dist_parent_hash[tuple(config)][0] + heuristic(config))] = config
    elif dist_parent_hash[tuple(config)][0] > distance:
      dist_parent_hash[tuple(config)] = [distance, tuple(x)]
      q[(dist_parent_hash[tuple(config)][0] + heuristic(config))] = config

t2 = time()

if tuple(dest) in dist_parent_hash:
  connection = []
  d = dist_parent_hash[tuple(dest)][0]
  config_to_add = dest
  while d > -1:
    connection.append(config_to_add)
    d -= 1
    config_to_add = dist_parent_hash[tuple(config_to_add)][1]
  print("The connection between the two configurations is: ")
  i = len(connection) - 1
  while i > -1:
    str_print(connection[i])
    i -= 1

  print("The connection is " + str(len(connection) -1) + " edges long.")
else:
  print('The configuration provided is not valid. It is impossible to reach the desired configuration from the given configuration.')
  
# Name: Dylan Jones
# Date: 24/1/2013
# File: fixed_point

import math

#global variable for the range of tolerance
tolerance_range = 0.000000001

def average( x, y ) :
  return ( x + y ) / 2.0

def average_damp( function ) :
  return lambda x : average( x, function( x ) )

#return if the tolerance range has been meet
def is_small_enough(neg_point, pos_point) :
  tolerance = abs(neg_point - pos_point) / 2.0
  return tolerance <= tolerance_range

def find_fixed_point( function, guess ) :
  next_guess = function( guess )
  if is_small_enough( guess, next_guess ) :
    return next_guess
  else :
    return find_fixed_point( function, next_guess )

def square_root( n ) :
  return find_fixed_point(lambda x: average( x, n / x), 1)

def cubic_root(n):
  return find_fixed_point( average_damp ( lambda x: n / ( x * x ) ), 1)

def golden_ratio():
  return find_fixed_point( lambda x: average( x, ( x + 1 ) / x ), 1 ) 

square_root_2 = square_root( 2 )
square_root_3 = square_root( 3 )
square_root_9 = square_root( 9 )

cubic_root_2 = cubic_root( 2 )
cubic_root_3 = cubic_root( 3 )
cubic_root_9 = cubic_root( 9 )

golden_ratio = golden_ratio()

print "square_root_2 : " + str( square_root_2 ) + "\n"
print "square_root_3 : " + str( square_root_3 ) + "\n"
print "square_root_9 : " + str( square_root_9 ) + "\n"
print "cubic_root_2 : " + str( cubic_root_2 ) + "\n"
print "cubic_root_3 : " + str( cubic_root_3 ) + "\n"
print "cubic_root_9 : " + str( cubic_root_9 ) + "\n"
print "golden_ratio : " + str( golden_ratio ) + "\n"


import math
import sys
def strict_floor(f):
    if int(math.floor(f)) == f:
        return int(f - 1)
    else: 
        return int(math.floor(f))
    
def strict_ceil(f):
    if int(math.ceil(f)) == f:
        return int(f + 1)
    else:
        return int(math.ceil(f))

def is_square(n):
    root = int(math.sqrt(n))
    if root*root == n:
        return True
    else:
        return False

def count_square_quads(m):
    n_with_square = 0
    primes = [1,2,3,5,7,11,13,17,19,23,29,
              31,37,41,43,47,53,59,61,67,71,
              73,79,83,89,97]
    been_counted = {}
    for i in range(1,m+1):
        for j in range(1,m+1):
            for k in range(1,m+1):
                for l in range(1,m+1):
                    been_counted[i + j*(10**3) + k*(10**6) + l*(10**9)] = False

    for a in range(1,m+1):
        if m==100: print "a = ", a
        for b in range(1,m+1):
            for c in range(1,m+1):
                for d in range(1,m+1):
                    if been_counted[a + b*(10**3) + c*(10**6) + d*(10**9)] == True: continue
                    n_pts = 0
                    for x in range(-c+1,0):
                        low = strict_ceil( -(d/float(c))*x -d )
                        high = strict_floor( (b/float(c))*x + b ) + 1
                        #print "1: x: ",x
                        #print "1: high, low: ", high, low
                        #print "1: inputs: ", -(d/float(c))*x -d , (b/float(c))*x + b 
                        for y in range(low,high):
                            n_pts +=1
                    for x in range(0,a):
                        low = strict_ceil( (d/float(a))*x -d )
                        high = strict_floor( -(b/float(a))*x + b ) + 1
                        for y in range(low,high):
                                n_pts += 1
                    if is_square(n_pts): 
                        n_with_square += 1
                        been_counted[a + b*(10**3) + c*(10**6) + d*(10**9)] == True
                        #print "values: ", a, b, c, d
                        #print "max int: ", sys.maxint
                        #check all symmetry solutions
                        #flip a->c
                        if a!=c and been_counted[c + b*(10**3) + a*(10**6) + d*(10**9)] == False:
                            n_with_square+=1
                            been_counted[c + b*(10**3) + a*(10**6) + d*(10**9)] =True
                        #flip b->d
                        if b!=d and been_counted[a + d*(10**3) + c*(10**6) + b*(10**9)] == False:
                            n_with_square+=1
                            been_counted[a + d*(10**3) + c*(10**6) + b*(10**9)] =True     
                        #flip both
                        if a!=c and b!=d and been_counted[c + d*(10**3) + a*(10**6) + b*(10**9)] == False:
                            n_with_square+=1
                            been_counted[c + d*(10**3) + a*(10**6) + b*(10**9)] =True
                        #permutes
                        if a!=b and b!=c and c!=d and d!=a and a!=c and b!=d:
                            #permute 1
                            if been_counted[b + c*(10**3) + d*(10**6) + a*(10**9)] == False:
                                n_with_square+=1
                                been_counted[b + c*(10**3) + d*(10**6) + a*(10**9)] =True
                            #permute 2
                            if been_counted[c + d*(10**3) + a*(10**6) + b*(10**9)] == False:
                                n_with_square+=1
                                been_counted[c + d*(10**3) + a*(10**6) + b*(10**9)] =True
                            #permute 3
                            if been_counted[d + a*(10**3) + b*(10**6) + c*(10**9)] == False:
                                n_with_square+=1
                                been_counted[d + a*(10**3) + b*(10**6) + c*(10**9)] =True
                                    
    print "number of squares for m = ", m, "is", n_with_square

count_square_quads(1)
count_square_quads(2)
count_square_quads(3)
count_square_quads(4)
count_square_quads(5)
count_square_quads(6)
count_square_quads(7)
count_square_quads(8)
count_square_quads(9)
count_square_quads(10)
count_square_quads(50)

def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x    = 1
    xOld = 1
    while True:
        aux = ( x + ( n / x ) ) / 2
        if aux == x:
            return x
        if aux == xOld:
            return min(x, xOld)
        xOld = x
        x = aux

def getSum(n):
    x = iSqrt(n)
    if x * x == n:
        return 0
    x = n * 10 ** 200
    y = iSqrt(x)
    y /= 10
    r = 0
    while y > 0:
        r += y % 10
        y /= 10
    return r

def solve():
    r = 0
    for k in range(1, 101):
        r += getSum(k)
    return r

if __name__ == "__main__":
    result = solve()
    print "Result: %d" % result

"""Calculate the square cube of a float number"""

__author__ = 'Nicola Moretto'
__license__ = "MIT"

def squareRootBisection(x, precision):
    '''
    Calculate the square root of a float number through bisection method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None

    # x>=0
    low = 0.0
    high = x
    value = (low+high)/2
    while abs(value**2-x) > precision:
        if value**2 < x:
            low = value
        else: # value**2 > x
            high = value
        value = (low+high)/2

    return value
def square_root(n):
	n=float(n)
	x=n/2
	i=0
	while i<10:
		x=((x+n)/x)/2
		i=i+1
	return x

print square_root(9)

"""
Odd period square roots
Problem 64

For conciseness, we use the notation 23 = [4;(1,3,1,8)], to indicate that the
block (1,3,1,8) repeats indefinitely.

The first ten continued fraction representations of (irrational) square roots
are:

2=[1;(2)], period=1
3=[1;(1,2)], period=2
5=[2;(4)], period=1
6=[2;(2,4)], period=2
7=[2;(1,1,1,4)], period=4
8=[2;(1,4)], period=2
10=[3;(6)], period=1
11=[3;(3,6)], period=2
12= [3;(2,6)], period=2
13=[3;(1,1,1,1,6)], period=5

Exactly four continued fractions, for N  13, have an odd period.

How many continued fractions for N  10000 have an odd period?
"""
import time

__date__ = '14-4-1'
__author__ = 'SUN'

def get_square_root(n):
    root = []
    period = []
    cache = []
    x, y = 0, 1
    while (x + 1) ** 2 <= n:
        x += 1
    root.append(x)
    if x ** 2 != n:
        while (x, y) not in cache:
            cache.append((x, y))
            k = 0
            d = (n - x ** 2) // y
            while ((k + 1) * d - x) ** 2 <= n:
                k += 1
            period.append(k)
            x, y = k * d - x, d
    root.append(period)
    return root

if __name__ == '__main__':
    start = time.clock()
    N = 10000
    count = 0
    for i in range(N + 1):
        if len(get_square_root(i)[-1]) % 2 == 1:
            count += 1
    print(count)
    print('Runtime is ', time.clock() - start)
import math
'''
I wrote my own square root function because I thought Decimal.sqrt() was not precise....
it turns out it was just a logic problem, but i'm keeping the function!
'''
def square_root(n, digits):
	limit = math.pow(10, digits+1) 
	a = 5*n
	b = 5
	while b < limit+1:
		if a >= b:
			a -= b
			b += 10
		else:
			a *= 100
			b = (b/10) * 100 + 5
	return b/100


sum = 0
for x in range(2, 101):
	if not math.sqrt(x).is_integer():
		digits = square_root(x, 100)
		if digits > 10:
			while digits >= 1:
				digit = digits % 10
				sum += digit
				digits /= 10

print(sum)
		

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

##def squareRootBi(x, epsilon):
##    """Return y s.t. y*y is within epsilon of x"""
##    assert epsilon > 0, 'epsilon must be postive, not' + str(epsilon)
##    low = 0
##    high = max(x,1)
##    guess = (low + high)/2.0
##    ctr = 1
##    while abs(guess**2 - x) > epsilon and ctr <= 100:
##        #print 'low:', low, 'high:', high, 'guess:', guess
##        if guess**2 < x:
##            low = guess
##        else:
##            high = guess
##        guess = (low + high)/2.0
##        ctr += 1
##        assert ctr <= 100, 'Iteration count exceeded'
##    print 'Bi method. Num. iterations:', ctr, 'Estimate:', guess
##    return guess
##
##def TestBi():
##    print 'square root with 4 and 0.001'
##    squareRootBi(4,0.001)
##    print 'square root with 2 and 0.001'
##    squareRootBi(2,0.001)
##    print 'square root with 0.25 and 0.001'
##    squareRootBi(0.25,0.001)
##
##    return None
##
##def TestNR():
##    print 'square root with 4 and 0.001'
##    squareRootNR(4,0.001)
##    print 'square root with 2 and 0.001'
##    squareRootNR(2,0.001)
##    print 'square root with 0.25 and 0.001'
##    squareRootNR(0.25,0.001)
##
##    return None
##
##def squareRootNR(x, epsilon):
##    """Assumes x >= 0 and epsilon > 0
##    Return y s.t. y*y is within epsilon of x"""
##    assert x >= 0, 'x must be non-negative, not' + str(x)
##    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
##    x = float(x)
##    guess = x/2.0
##    guess = 0.001
##    diff = guess**2 -x
##    ctr = 1
##    while abs(diff) > epsilon and ctr <= 100:
##        #print 'Error:', diff, 'guess:', guess
##        guess = guess - diff/(2.0*guess)
##        diff = guess**2 -x
##        ctr += 1
##    assert ctr <= 100, 'Iteration count exceeded'
##    print 'NR method. Num. iterations:', ctr, 'Estimate:', guess
##    return guess
##
##def compareMethods():
##    print 'square root with 4 and 0.001'
##    squareRootBi(4,0.001)
##    squareRootNR(4,0.001)
##    
##
##    print 'square root with 9 and 0.001'
##    squareRootBi(9,0.001)
##    squareRootNR(9,0.001)
##
##    
##    print 'square root with 2 and 0.001'
##    squareRootBi(2,0.001)
##    squareRootNR(2,0.001)
##    
##
##    print 'square root with 2 and 0.0001'
##    squareRootBi(2,0.0001)
##    squareRootNR(2,0.0001)
##    
##
##    print 'square root with 2 and 0.000001'
##    squareRootBi(2,0.000001)
##    squareRootNR(2,0.000001)
##    
##
##    print 'square root with 0.25 and 0.001'
##    squareRootBi(0.25,0.001)
##    squareRootNR(0.25,0.001)
##
##    print 'square root with 123456789 and 0.0001'
##    squareRootBi(123456789,0.0001)
##    squareRootNR(123456789,0.0001)
##
##    print 'square root with 123456789 and 0.000001'
##    squareRootBi(123456789,0.0000001)
##    squareRootNR(123456789,0.000001)
##
##compareMethods()
##
Techs = ['MIT', 'Cal Tech']
##print Techs

Ivys = ['Harvard', 'Yale', 'Brown']
##print Ivys
##Univs = []
##Univs.append(Techs)
##print Univs
##Univs.append(Ivys)
##raw_input()
##print Univs
##raw_input()
##for e in Univs:
##    print e
##    for c in e: print c
##raw_input()
##Univs = Techs + Ivys
##print Univs
##
##Ivys.remove('Harvard')
##print Univs ##univs will not have changed
##
## this shows that lists can show mutation
####
####

def gcd(a,b):
    while b != 0:
        a,b = b,a % b
    return a


def int_root(n):
	a = 2**(n.bit_length()/2)
	b = 1
	while True:
		ea,eb =a**2 - n*b**2,2*a*b
		a,b = 2*a**2 -ea,eb
		if abs(ea) < abs(eb):
			x = a/b
			return x,x**2==n

def is_perfect_square(n):
	x = int_root(n)
	return x**2 == n


output = []
for m in range(2,10**5):
	x,sp= int_root(16*m**2 - 4*(m**2 -1))
	if sp:
		n = (4*m - x)/2
		output.append((4*m*n, m**2+ n**2))

	x,sp= int_root(12*(m**2-1))
	if sp:
		n = x/6
		output.append((2*(m**2 - n**2), m**2+ n**2))

total = 0
for x in output:
	total += 2*x[1] + x[0]
	if 2*x[1] + x[0] > 10**9:
		break
	print x,total
import math

def problem10(n = 2000000):
	assert(n > 0)
	return sum(generate_primes_upto_number(n))

# generate up to a number or get the first prime
def generate_primes_upto_number(n):
        primes = [2, 3] # first primes
        n -= 1
        current_number = primes[1]
        while current_number < n:
                current_number += 2
                square_root = math.floor(math.sqrt(current_number))
                prime = True
                for p in primes:
                        if p > square_root: break
                        elif current_number % p == 0:
                                prime = False
                                break
 
                if prime: primes.append(current_number)
        return primes
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
__author__ = 'andi'
import math
import re


def arithmetic(question):
    question = question[8:]
    question = question.replace("plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))


def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)


def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []
    for number in number_list:
        if __is_square(number) and __is_third_square(number):
            return_values.append(number)
    return_value = ", ".join(return_values)
    return return_value


def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False
    else:
        return True


def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)


def float_equals(a, b, tolerance=0.00000001):
    return abs(a-b) < tolerance

primes_under_100 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]


def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100
    if n % 2 == 0 or n % 3 == 0:
        return False

    for f in range(5, int(n ** .5), 6):
        if n % f == 0 or n % (f + 2) == 0:
            return False
    return True


def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)


def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))
    return question


def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a


# what is 13 to the power of 11
def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))




#!/usr/bin/python

def largest_prime_factor(number):
    result = prime_factors(number)
    if result: result[-1]
    return result

def prime_factors(number):
    factors = []
    for n in xrange(2,number/2):
        if number % n == 0 and is_prime(n):
            factors.append(n)
    return factors

def is_prime(number):
    # Use the trial division with square root technique to figure out if a
    # number is prime
    if number % 2 == 0: return False

    for n in xrange(2, int(number**0.5)+1):
        if number % n == 0:
            return False
    return True

def main():
    print largest_prime_factor(600851475143)

if __name__ == "__main__": main()

#Basic calculator project
import math
def cube(n):
    """
    Returns the cube of the number n
    """
    "REPLACE THIS CODE WITH YOUR CUBE METHOD"
    return n**3

def squareroot(n):
    """
    Returns the square root of the number n. If n < 0, 
    then return the string "NAN" (not a number)
    """
    "REPLACE THIS CODE WITH YOUR SQUAREROOT METHOD"
    return math.sqrt(n)

def negate(n):
    """ Return negative n
    """
    "REPLACE THIS CODE WITH YOUR NEGATE METHOD"
    return (-n)

def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    "REPLACE THIS CODE WITH YOUR FACTORIAL METHOD"
    return math.factorial(n)
    


from itertools import izip

def sqrt(x):
    """
    Trivial square root implementation.
    """
    return x ** 0.5


def dot(x, y):
    """
    Compute the dot product of two equal length vectors, `x`, and `y`.
    """
    return sum(n * m for n, m in izip(x, y))


alldigits = [1,2,3,4,5,6,7,8,9,0]
subdigits = [alldigits[len(alldigits) - index - 1:] for index in range(len(alldigits))]

def isSquare(a):
    '''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''
    # If a is a small number, then we can do this quick version
    if 0 <= a <= 2 ** 50:
        sr = int(a ** (1 / 2.0))
        if sr ** 2 == a:
            return sr
    else:
        raise ValueError("get a better function")
    	
def eq(n, upto):
	print(str(n)[::-1])
	l = [int(b) for index,b in enumerate(str(n)[::-1]) if index%2 == 0][::-1]
	m = alldigits[len(alldigits) - upto:]
	print('l', l)
	print('m', m)
	return l == m
	

start = 102030405060708090**(1/2.0) # 319421985.8755939
end = 192939495969798999**(1/2.0) # 439248785

def candidates(endings):
	newendings = []
	for ending in endings:
		upto = (len(str(ending)) - 1)//2 + 1
		start = alldigits[len(alldigits) - upto] * 10**(upto) + ending
		end = start + 9*10**(upto-1)
		step = 10**(upto-1)
		print(start, end, step)
		for a in range(start,end, step):
			print('a', a)
			if isSquare(a):
				newendings.append(a)
		return newendings

print(candidates([0]))
print(candidates([900]))

import math

def getContinuedFractionOfSquareRoot(val):
	m = [0]
	d = [1]
	a = [int(math.sqrt(val))]
	yield a[0]
	
	while True:
		mm = d[-1]*a[-1] - m[-1]
		dd = (val - mm*mm) / d[-1]
		aa= int( (a[0] + mm)/dd )
		m.append(mm)
		d.append(dd)
		a.append(aa)
		yield aa


def checkPellSolution(x,y,n):
	return x*x - n*y*y == 1


def solve(D):
	if int(math.sqrt(D))**2 == D:
		return
	
	continuedFractionGenerator = getContinuedFractionOfSquareRoot(D)
	a = continuedFractionGenerator.next()
	p = [1, a]
	q = [0, 1]
	
	for a in continuedFractionGenerator:
		if checkPellSolution(p[-1], q[-1], D):
			return (p[-1], q[-1])
			
		p.append(a*p[-1] + p[-2])
		q.append(a*q[-1] + q[-2])


for D in xrange(1,1001):
	result = solve(D)
	if result is None:
		print 'No solution for D= %d' % D
		continue
		
	print 'Solution for D= %d: x= %d, y=%d' % (D, result[0], result[1])
	


from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def square_root(n,d = 100):
    nstr = str(n)
    if len(nstr) % 2 == 1: nstr = '0' + nstr
        
    vals = [int(nstr[i:i+2]) for i in range(0, len(nstr), 2)]
    ans = [-1 for i in range(d)]

    p = 0
    r = 0
    vcnt = 0
    vmax = len(vals)
    for i in range(d):
        if vcnt < vmax:
            c = 100*r + vals[vcnt]
            vcnt += 1
        else: c = 100*r
        x = get_max_x(p,c)
        y = x*(20*p + x)
        r = c - y
        p = 10*p + x
        ans[i] = x
    dec = len(vals)
    ans = ans[:dec] + ["."] + ans[dec:]
    return(ans)
def get_max_x(p,c):
    for x in range(1,10):
        if x*(20*p + x) > c:
            break
    return(x-1)
def get_sum(n):
    start = n.index(".") + 1
    return(sum(n[start:]))
    
square_root(2,100)
    
__author__ = 'skebix'

'''
Encapsulate this loop in a function called square_root that takes a as a parameter, chooses a reasonable value of x, and
returns an estimate of the square root of a.
'''

def square_root(a):
    epsilon = 0.00000000001
    x = float(a / 2.0)
    while True:
        #print x
        if abs(x - 0) < epsilon:
            y = a / 2.0
        else:
            y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x

#root = square_root(175)
import os
import gc
import sys

from Perception import perception
from Models import ILModel


rootdir = "C:/Users/Ryan/Documents/Workspace/Raven-s-AI/Training/Objects/"

def loadObjects(root,folder):
    print "\nLoading: " + folder
    n = 0
    objects = []
    for subdir, dirs, files in os.walk(root+folder):
        for file in files:
            objects += perception(os.path.join(subdir, file),show=False)
            print str(file)+", "+str(len(objects[-1]))
            gc.collect()
    return objects

squares = loadObjects(rootdir,"Square")
triangles = loadObjects(rootdir,"Triangle")

square = ILModel()
for s in squares[0:len(squares)-5]:
    square.add(s.getData(),isCase=True)
for t in triangles[0:len(triangles)-5]:
    square.add(t.getData(),isCase=False)

print "Making Square"
square.make()

print "Checking Outputs"
print "Squares..."
for s in squares[len(squares)-5:len(squares)]:
    print square.check(s.getData())

print "Triangles..."
for t in triangles[len(triangles)-5:len(triangles)]:
    print square.check(t.getData())

'''
Solving the third code jam problem

'''
def isPalindrome(number):
	original = number
	reverse = 0
	while number != 0:
		reverse = reverse * 10 + number % 10
		number /= 10
	return reverse == original

				
# main program
import os, math
full_path = os.path.realpath(__file__)
path, file = os.path.split(full_path)

f = open(path + '\\' + 'C-small-attempt0.in')
numOfTests = int(f.readline())

results = []
for test in range(numOfTests):
	a, b = [int(x) for x in f.readline().split()] # read a line
	counter = 0
	root = int(math.sqrt(a))
	square = int(root**2)
	#in case it's truncated
	if square < a:
		root += 1
		square = root**2
	
	while square <= b:
		if isPalindrome(root) and isPalindrome(square):
			counter += 1 
		square += root * 2 + 1 # (x+1)^2 = x^2 + 2x + 1
		root += 1

	results.append(counter)

outFile = open(path + '\\' + 'output.txt', 'w')

for i in range(0, len(results)):
	caseNumber = i+1
	outFile.write("Case #%d: %d\n" % (caseNumber, results[i] ))

#!/usr/bin/python
# -*- coding: utf-8 -*-
#Title: Square root digital expansion

from decimal import *

getcontext().prec = 110
squares = (1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
squareRootDigitSum = 0

def squareRoot(n):
	x = (Decimal(1) + n) / Decimal(2)
	old = Decimal(-1)
	while True:
		x = Decimal('0.5') * (x + n / x)
		if old == x:
			break
		else:
			old = x
	return x

def digitSum(n):
	#print(n)
	c = 0
	tmp = n
	s = 0
	while tmp != Decimal(0) and c < 100:
		digit = int(tmp)
		s += digit
		tmp -= Decimal(digit)
		tmp *= Decimal(10)
		c += 1
	return s

for i in range(1, 100):
	if i not in squares:
		ds = digitSum(squareRoot(Decimal(i)))
		squareRootDigitSum += ds

print(squareRootDigitSum)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/env python

import itertools
import math
import unittest

def divisible_by(dividend, divisor):
    return dividend % divisor == 0

def is_even(n):
    return divisible_by(n, 2)

def take_while_less_than(n, xs):
    def less_than_n(x):
        return x < n
    return itertools.takewhile(less_than_n, xs)

def take_while_less_than_or_equal(n, xs):
    def less_than_or_equal_to_n(x):
        return x <= n

    return itertools.takewhile(less_than_or_equal_to_n, xs)

def fibonacci():
    previous = 1
    current = 1

    while True:
        yield current
        temporary = previous + current
        previous = current
        current = temporary

def fibonacci_less_than(n):
    return take_while_less_than(n, fibonacci())

class FibonacciTestCase(unittest.TestCase):
    def test_fibonacci_less_than_ten(self):
        expected = [1, 2, 3, 5, 8]
        actual = list(fibonacci_less_than(10))
        self.assertEqual(expected, actual)

def evens(xs):
    return itertools.ifilter(is_even, xs)

class EvensTestCase(unittest.TestCase):
    def test_evens(self):
        expected = [0, 2, 4, 6, 8]
        actual = list(evens(range(10)))
        self.assertEqual(expected, actual)

def any(predicate, xs):
    for x in xs:
        if predicate(x):
            return True
    
    return False

def primes():
    composites_to_witnesses = {}

    for n in itertools.count(2):
        if n in composites_to_witnesses:
            for witness in composites_to_witnesses[n]:
                composites_to_witnesses.setdefault(n + witness, []).append(witness)
        else:
            yield n
            composites_to_witnesses[n * n] = [n]

def primes_less_than(n):
    return take_while_less_than(n, primes())

def n_primes(n):
    return itertools.islice(primes(), n)

def factors(n):
    remaining = n

    for prime in primes():
        while divisible_by(remaining, prime):
            yield prime
            remaining = remaining / prime

        if remaining == 1:
            break

def product(xs):
    result = 1
    
    for x in xs:
        result = result * x

    return result

class PrimesTestCase(unittest.TestCase):
    def test_primes(self):
        expected = [2, 3, 5, 7, 11, 13, 17, 19]
        actual = list(primes_less_than(20))
        self.assertEqual(expected, actual)

    def test_factors(self):
        expected = [2, 3, 7, 19, 31]
        actual = list(factors(product(expected)))
        self.assertEqual(expected, actual)

def first(xs, predicate = lambda x : True):
    for x in xs:
        if predicate(x):
            return x

def last(xs):
    return list(xs)[-1]

def is_palindromic(n):
    n = str(n)
    return n[:] == n[::-1]

class PalindromicTestCase(unittest.TestCase):
    def test_is_palindromic(self):
        self.assertTrue(is_palindromic(505))
        self.assertTrue(is_palindromic(2002))
        self.assertFalse(is_palindromic(8675309))

def numbers_with_digits(digits, radix = 10):
    start = pow(radix, digits - 1)
    end = pow(radix, digits)
    return range(start, end)

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b / gcd(a, b)

def count_to(n):
    return range(1, n + 1)

def square(n):
    return n * n

def squares(start = 0):
    return itertools.imap(square, itertools.count(start))

def is_perfect_square(n):
    root = math.sqrt(n)
    return root == int(root)

def pythagorean_triplets():
    for square in squares(5):
        for i in range(9, square / 2):
            if is_perfect_square(i):
                j = square - i
                if is_perfect_square(j):
                    yield (int(math.sqrt(i)), int(math.sqrt(j)), int(math.sqrt(square)))

if __name__ == '__main__':
    unittest.main()

'''
exercise:7.2 Computes the square root of a number using Newtons approximation method

'''

def sqrt(num):
  epsilon = 0.000001
  rt=num/2
  while True:
    newrt=(rt+num/rt)/2
    if abs(newrt-rt) < epsilon :
      return newrt   
    rt=newrt
    
def get_input(prompt):
  num=raw_input(prompt)
  return num
  
def main():
  prompt="enter the number :  "
  num=float(get_input(prompt))
  print "The square root of {0} is : ".format(num),sqrt(num)

if __name__=='__main__':
  print '*'*30,'\n'
  main()
  print '\n','*'*30

#!/usr/bin/python3

from tkinter import *
from tkinter import ttk
import colorsys
import cubes
import random
import time
import math

# Size of window
SIZE = 512
# Size of squares
SCALE = 16

# Derived info about window and grid
GSIZE = int(SIZE/SCALE)-1
GCENTER = int(GSIZE/2)
X_SCALE = SCALE
Y_SCALE = SCALE

DRAW = 1
# Display grid points
GRID = 1
# Width of grid points
DASHWIDTH = 2

CW = 1
CCW = -1
X = 0
Y = 1
# Make this a dictionary
N 	= 0
NE 	= 1
E 	= 2
SE 	= 3
S 	= 4
SW 	= 5
W 	= 6
NW 	= 7

# Lists of directions for iteration
DA = [N,E,S,W]
DB = [N,NE,E,SE,S,SW,W,NW]
DC = [(0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1)]

OUTLINE = "#000000"
FILL = "#0047AB"

drawings = {}
squares = []

def inGroup(p):
	n = 0
	group = {p.connections[x] for x in p.connections}
	while len(group) > n:
		n = len(group)
		for s in cubes.squaresList:
			if s in group:
				for d in DA:
					if d in s.connections:
						group.add(s.connections[d])


	if len(group) == len(cubes.squaresList):
		return 1
	else:
		return 0


def adjTo(coord):
	a = 0
	for d in DA:
		if coord + d in cubes.squaresCoords:
			a = a+1
	return a

def pivotTo(dest):
	for n in range(10):
		s = random.choice(squares)
		while s.adjNum > 2:
			s = random.choice(squares)

		c1 = s.coord

		d = random.choice([CW, CCW])

		p = s.getPivot(d)

		if p:
			c2 = p[0]
			if adjTo(c2) > 1 and (abs(c2[X]-dest[X]) + abs(c2[Y]-dest[Y]) <= abs(c1[Y]-dest[Y]) + abs(c1[X]-dest[X])) :
				s.pivot(p = p)
				if inGroup(s):
					moveDrawing(s, c1, c2)
					root.update()
				else:
					s.move(c1)
				return


# Pivot a random square in a random location
def randPivot():
	while True:
		s = random.choice(squares)
		while s.adjNum > 2:
			s = random.choice(squares)
		c1 = s.coord

		d = random.choice([CW, CCW])
		if s.pivot(d):			
			c2 = s.coord
			if inGroup(s):
				moveDrawing(s, c1, c2)
				root.update()
			else:
				s.move(c1)
			return
								

# Create a new square in a random location
# 	Favors spread and long paths
def randNewSquare(event = None):
	opens = []
	picks = {0:[], 1:[], 2:[], 3:[]}
	shuffled = list(squares)
	random.shuffle(shuffled)
	for n in (0,1,2,3):
		[picks[n].append(q) for q in shuffled if q.adjNum == n]
	while(len(squares) < GSIZE*GSIZE):
		for n in (0,1,2,3):
			if picks[n]:
				for s in picks[n]:
					opens = []
					for d in DA:
						if d not in s.connections:
							opens.append(d)
					random.shuffle(opens)
					for d in opens:
						m = cubes.Square(s, d)
						if m:
							return m

# Create a new square in a random location
def randNewSquareFast():
	shuffledSquares = list(squares)
	random.shuffle(shuffledSquares)
	for s in shuffledSquares:
		if s:
			if s.adjNum < 4:
				parent = s
				break

	shuffledDirs = list(DA)
	random.shuffle(shuffledDirs)
	
	for d in shuffledDirs:
		if d not in parent.connections.keys():
			parentDir = d
			break

	return cubes.Square(parent, parentDir)

def drawSquare(square):
	x1 = ((square.coord[X]+GCENTER+1)*SCALE)
	y1 = ((-square.coord[Y]+GCENTER+1)*SCALE)
	x2 = ((square.coord[X]+GCENTER+1)*SCALE)+SCALE
	y2 = ((-square.coord[Y]+GCENTER+1)*SCALE)+SCALE
	drawing = (canvas.create_rectangle(x1, y1, x2, y2,  fill = FILL, outline = OUTLINE, width=2))
	canvas.tag_bind(drawing, '<Button-3>', lambda event, arg=square: rClick(event, arg))
	canvas.tag_bind(drawing, '<Button-1>', lambda event, arg=square: lClick(event, arg))
	drawings[square] = drawing
	root.update()




def mClick(event):
	new = randNewSquareFast()
	squares.append(new)
	drawSquare(new)
	for s in new.connections.values():
		drawSquare(s)

def lClick(event, square):
	c1 = square.coord
	square.pivot(CCW)
	c2 = square.coord
	if inGroup(square):
		moveDrawing(square, c1, c2)
		root.update()
	else:
		print("a")
		square.move(c1)
		print("b")

	# moveDrawing(square, c1, c2)

def rClick(event, square):
	c1 = square.coord
	square.pivot(CW)
	c2 = square.coord
	if inGroup(square):
		moveDrawing(square, c1, c2)
		root.update()
	else:
		print("a")

		square.move(c1)
		print("b")

	# moveDrawing(square, c1, c2)


def moveDrawing(square, c1, c2):
	x1 = c1[X]
	y1 = -c1[Y]
	x2 = c2[X]
	y2 = -c2[Y]
	dx = (x2-x1)*SCALE
	dy = (y2-y1)*SCALE
	
	canvas.move(drawings[square], dx, dy)
	root.update()


# Initialize tkinter ------------------------------------------

if DRAW:
	root = Tk()
	root.minsize(SIZE, SIZE)
	root.geometry(str(int(SIZE+SCALE)) + 'x' + str(int(SIZE+SCALE)))

	canvas = Canvas(root, width=SIZE+SCALE, height=SIZE+SCALE)
	canvas.place(relx=.5, rely=.5, anchor=CENTER)
	canvas.bind('<Button-2>', mClick)

	# Draw Grid ---------------------------------------------------

	if(GRID):
		i=SCALE
		while(i <= SIZE):
			canvas.create_line(i, SCALE, i, SIZE+DASHWIDTH, dash=(DASHWIDTH, SCALE-DASHWIDTH), width=DASHWIDTH)
			i += SCALE

# -------------------------------------------------------------


m = cubes.Square(master = 1)
squares.append(m)

while len(squares) < 50:
	new = randNewSquareFast()
	squares.append(new)


if DRAW:	
	for s in squares:
		drawSquare(s)

def rp():
	randPivot()
	# for n in range(10):
	# 	pivotTo((10,10))
	root.after(0, rp)


try:
	# root.after(0, rp)
	root.mainloop()
except:
	pass


#!/usr/bin/env python
# encoding: utf-8
"""
exercise-7.2.py

Created by Terry Bates on 2012-08-27.
Copyright (c) 2012 http://the-awesome-python-blog.posterous.com.
All rights reserved."""

def square_root(a):
    # we will guess that x will be 1/2 of a, to start
    x =  0.75 * float(a)
    epsilon = 0.000001
    while True:
        y = (x + a/x) / 2
        if abs(y-x) < epsilon:
            break
        x = y
    return x
    

if __name__ == '__main__':
    print square_root(144)
    print square_root(121)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# This program solves an n-puzzle

from time import time

# Takes in square size and initial configuration
square_size = int(input("Please input the side length of the square: \n"))
print("Please enter the numbers in the square in the following way (example below): ")
print("If you wanted to enter the following configuration for a side length of 3, ")
print("7 2 4")
print("5   6")
print("8 3 1")
print("then you would type in '7 2 4 5 0 6 8 3 1'")
print("Note that the blank spot is represented by the number 0.")
num_string = input("Now, input the properly formatted string for your configuration: \n")

square = []
for i in num_string.split():
  square.append(int(i))

dest = list(range(square_size**2))

N_HASH = {}
for i in range(square_size**2):
  N_HASH[i] = []

DISTANCE_HASH  = {}
for i in range(square_size**2):
  for j in range(i, square_size**2):
    z = j - i
    dy = z//square_size
    dx = z%square_size
    DISTANCE_HASH[(i, j)] = dx + dy
    DISTANCE_HASH[(j, i)] = dx + dy

    if DISTANCE_HASH[(i, j)] == 1:
      N_HASH[i].append(j)
      N_HASH[j].append(i)

def dist_to_dest(num, square_config):
  return DISTANCE_HASH[(num, square_config.index(num))]

def heuristic(square_config):
  d = 0
  for i in range(len(square_config)):
    d += dist_to_dest(i, square_config)

  return d

def neighbors(square_config):
  open_spot = square_config.index(0)
  n_list = []
  for i in N_HASH[open_spot]:
    new_config = list(square_config)
    new_config[open_spot] = square_config[i]
    new_config[i] = 0
    n_list.append(new_config)

  return n_list

def str_print(config):
  for i in range(square_size):
    x = ''
    for j in range(square_size):
      k = config[i*square_size+j]
      if k == 0:
        x += ' '.ljust(3) + ' '
      else:
        x += str(config[i*square_size+j]).ljust(3) + ' '
    print(x)
  print()

t1 = time()

dist_parent_hash = {tuple(square): [0, None]}

d_root = heuristic(square)
q = {d_root: square}

count = 0

max_q_length = len(q)

while len(q) > 0:
  if len(q) > max_q_length:
    max_q_length = len(q)

  m = min(q)
  x = q.pop(m)

  if x == dest:
    break
  count += 1

  nbors = neighbors(x)
  for config in nbors:
    distance = dist_parent_hash[tuple(x)][0] + 1
    if (tuple(config) in dist_parent_hash) == False:
      dist_parent_hash[tuple(config)] = [distance, tuple(x)]
      q[(dist_parent_hash[tuple(config)][0] + heuristic(config))] = config
    elif dist_parent_hash[tuple(config)][0] > distance:
      dist_parent_hash[tuple(config)] = [distance, tuple(x)]
      q[(dist_parent_hash[tuple(config)][0] + heuristic(config))] = config

t2 = time()

if tuple(dest) in dist_parent_hash:
  connection = []
  d = dist_parent_hash[tuple(dest)][0]
  config_to_add = dest
  while d > -1:
    connection.append(config_to_add)
    d -= 1
    config_to_add = dist_parent_hash[tuple(config_to_add)][1]
  print("The connection between the two configurations is: ")
  i = len(connection) - 1
  while i > -1:
    str_print(connection[i])
    i -= 1

  print("The connection is " + str(len(connection) -1) + " edges long.")
else:
  print('The configuration provided is not valid. It is impossible to reach the desired configuration from the given configuration.')
  
def square_root(n):
	n=float(n)
	x=n/2
	i=0
	while i<10:
		x=((x+n)/x)/2
		i=i+1
	return x

print square_root(9)

__author__ = 'jeremy.sandbergtobel'

def add(term1, term2):
    result = term1 + term2
    return result

def subtract(term1, term2):
    result = term1 - term2
    return result

def multiply(factor1, factor2):
    product = factor1 * factor2
    return product

def square(value):
    product = value * value
    return product

def square_of_square_root(value):
    import math
    root = value ** 2
    product = math.sqrt(root)
    return product

print square_of_square_root(value=(-16))

def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0
    a, b = divmod(n.bit_length(), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y

def isfib(n):
  sq = 5*(n*n)+4

	if isqrt(sq)**2-sq==0:
		return True
	else:
		sq = sq-8 
		if isqrt(sq)**2-sq==0:
			return True
		else:
			return False

__author__ = 'VadymT'
__date__ = '19th Apr 2015'
import math

def test_square_root(s1,s2):
    for i in range(s1,s2):
        a = i ** 0.5
        b = math.sqrt(i)
        if (a).is_integer():
            print ("%1.1f\t %1.1f \t\t\t%1.1f \t\t\t%1.1f" % (i, a, b, a - b ))
        else:
            print ("%1.1f\t %13.11f\t%13.11f\t%16.13e" % (i, a, b, a - b))
    return True

test_square_root(1, 10)

import numpy as np
from scipy import sparse


def square_root(x):
    return np.sqrt(x)

#!/usr/bin/python

"""Problem 80: Square root digital expansion"""

from utils import isqrt


def main():

    total = 0

    for num in range(2, 100):
        if num not in {4, 9, 16, 25, 36, 49, 64, 81}:
            root = isqrt(num * (10**2)**99)
            total += sum([int(x) for x in str(root)])
    return total

if __name__ == "__main__":
    print(main())

__author__ = 'Eutimio'
print(" Eutimio MAchuca Parra A01630244")
def raiz(n):
    x=n
    y=0
    while(x!= y):
        y=x
        x=(n/x + x)/2
    return x
print(" this program returns you he square root of a number")
num= float(input("give me a number"))
if(num== 0 ):
    print("The square root is:", num)
elif( num < 0):
    print(" there are not square root for negative numbers")
else:
    sqrt= raiz(num)
    print (" the square root is:", sqrt)


def newtonSqrt(n):
    '''Calculates the square root of n'''
    
    i = 0
    approx = n / 2
    better_approx = 0.5 * (approx + (n / approx))

    while better_approx != approx:
        
        approx = better_approx
        better_approx = 0.5 * (approx + (n / approx))
        i = i + 1
        print(better_approx, "number of iterations: ", i)

    return approx

number = float(input("Enter the number: "))

print("Square root of the number is: ", newtonSqrt(number))

def squareRoot(a,b):
    for counter in range(1,squareRoot):
        if counter**2 == squareRoot:
            return 'square root of' + str(squareRoot) + " is " + str(counter)
        return 'FAILED square root' + str(squareRoot) + " isnt " + str(counter)
        
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def exSqrRt(number):
    
    float(number)
    counter = 1.0
    
    while counter**2 == number:
        return str(counter) + 'is the square root of' + number
    else:
        counter += 0.0001
        exSqrRt(number)
#!/usr/bin/env python2.6
"""
The Babylonian method of estimating a square root.
"""


def sqrt(x, eps=1e-6):
    r = x * 1.
    while abs(x - r * r) > eps:
        r = 0.5 * (r + x / r)
    return r


print sqrt(256)

##Solve the equation x2+4x+1=0 in Z23. 
## using the quadratic formula

import sys

def ig(x, y):
    a,b, u,v = 0,1, 1,0
    while x != 0:
        q, r = y//x, y%x
        m, n = a-u*q, b-v*q
        y,x, a,b, u,v = x,r, u,v, m,n
    return y, a, b

def ig_mod(a, m):
    g, x, y = ig(a, m)
    if g != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

a = 1 
b = 4
c = 1
p = 23

# Find (2a)^(-1) in Z_p using extended Euclid
inv = ig_mod(2*a, p)

# Find square root of b^2-4*a*c in Z_p using a square root algorithm
# p = 23  ---> 23 mod 4 = 3 mod 4, 
## so we could use sqr(c) = c^((p+1)/4) in Z_p
sqr_term = pow(b,2) - 4 * a * c
root = pow(sqr_term, (p+1)/4)

x1 = ((-b + root) * inv) % p
x2 = ((-b - root) * inv) % p

print "x1 =", x1
print "x2 =", x2

## Related link
## https://github.com/ashumeow/cryptography-I/tree/master/week-5/notes/2-Intro-to-Number-Theory

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def squareRoot(a):
    for number in range (1,a):
        if a**2 == a:
            return "square root of" + str(a) + "would be" + str(number)
        return "Square root "+ str(a) + " isn't " + str(number)

#!/usr/bin/python3
# -*- coding: utf-8 -*-
import argparse
import math
import sys
__author__="great"

def create_parser():
    parser = argparse.ArgumentParser(description="Square or root of number")
    parser.add_argument('-r',type = int, dest="ROOT", nargs=1, help="Root of number")
    parser.add_argument('-s',type = int, dest="SQUARE",nargs=1, help="Square of number")
    return parser

if __name__=="__main__":
    arg_parse = create_parser()
    args = arg_parse.parse_args()
    if args.ROOT != None:
        buf = args.ROOT.pop()
        answer_root = math.sqrt(buf + 0.0)
        print("Root of number " + str(buf) + " is",end=' ')
        print(answer_root)
        sys.exit(0)
    elif args.SQUARE != None:
        buf = args.SQUARE.pop()
        answer_square = buf ** 2
        print("Square of number " + str(buf) + " is",end=' ')
        print(answer_square)
        sys.exit(0)
    else:
        print("Error in parse argument")


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

if connection.features.uses_case_insensitive_names:
    t_convert = lambda x: x.upper()
else:
    t_convert = lambda x: x
qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (t_convert(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), t_convert(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# Michael Coomey - Lab #2

Answers = """


"""

def GetANumber (PromptMessage):
    Num = -1
    while (Num < 1):
        Num = requestNumber(PromptMessage)
        if (Num <1):
            showError("Input can not be negative!")
    return Num

def Process (N):
    print "The Number is " + str(N)
    print "The Square is " + str(N)
    print "The Square root is " + str(math.sqrt(N))
    return

def Run():
    Process(GetANumber("Please enter a positive number, " + requestString("Enter your name")))
    return 
# Implement int sqrt(int x).

# Compute and return the square root of x.

class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        i, j = 0, x / 2 + 1
        while i <= j:
            mid = (i + j) / 2
            cur = mid ** 2
            if cur == x:
                return mid
            elif cur < x:
                i = mid + 1
            else:
                j = mid - 1

        return (i + j) / 2

import sys

def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns: The square root of x

    Raises:
        ValueError: If x is negative
    '''

    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess !=x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess

def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
    except ValueError as e:
        print(e)


if __name__ == '__main__':
    main()

def square_root(x, eps):
    ''' (float, float) -> float
    Return the square root of x to within "the accuracy" of eps.
    '''
    counter = 0
    this_guess = 1.0
    next_guess = 0.5 * (this_guess + (x / this_guess))
    error = next_guess - this_guess
    while abs(error) > eps and counter <= 10:
        this_guess = next_guess
        next_guess = 0.5 * (this_guess + (x / this_guess))
        error = next_guess - this_guess
        counter += 1
    if counter <= 10:
        return next_guess
    else:
        return -1

def square_root(a):
    x = 1
    while x * x != a:
        print(x)
        x = square_root_update(x, a)
    return x

def square_root_update(x, a):
    return (x + a/x) / 2

#! /usr/bin/env python3

def pe57(limit=1000):
    """
    Investigate the expansion of the continued fraction
    for the square root of two.
    """
    n, d = 3, 2
    cnt = 0
    for a in range(limit + 1):
        # n, d = n + (d << 1), n + d
        nn = n
        n += d << 1
        d += nn
        if len(str(n)) > len(str(d)):
            cnt += 1
    return cnt

def calc(n):
    nd13 = n // 13
    return (nd13 << 1) + ((n - nd13 * 13) >> 3)

def pe57a(n=1000):
    return calc(n)

if __name__ == "__main__":
    # print(pe57())
    print(pe57a())

from math import *

def print_n(s,n):
	while n > 0:
		print s
		n = n -1

def square_root(a):
	float(a)
	x = a / 2.0
	epsilon = 0.0000000001
	while True:
		y = (x+a/x)/2
		if abs(y-x) < epsilon:
			break
		else: x = y
	return y

def test_square_root(a=10):
	n = []
	for i in range(a):
		m = []
		m.append(float(i+1)) # the square number i
		m.append(square_root(m[0])) #the output o square_root(i)
		m.append(sqrt(m[0])) #the output of sqrt(i)
		m.append(abs(m[2]-m[1])) #the absolute difference of the results
		n.append(m) #list of all tests.

	#print the table

	for i in range(a):
		for j in range(4):
			d = 13 - len(str(n[i][j]))
			print n[i][j],' ' * d,
		print '\n'

def eval_loop():
	'''This needs some kind of exception handling. For the moment it only works with python-legal expressions, crashes otherwise.'''
	b = "Did nothing."
	while True:
		a = raw_input('> ')
		if a == 'done':
			print b
			break
		b = eval(a)
		print b

def estimate_pi():
	'''Function to estimate pi with Ramanujan's series, accurate to 13 decimal places.'''
	k = 0.0
	a = 0.0
	b = 0.0
	while True:
		b = (factorial(4.0*k)*(1103.0+ 26390.0*k))/(factorial(k)**4.0 * 396.0**(4.0*k))
		a += b
		if b < 1e-15: #set the accuracy
			c = ((2.0*(sqrt(2.0)))/9801.0)*a
			pi = 1.0/c
			return pi
		k += 1


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# Implement int sqrt(int x).

# Compute and return the square root of x.


class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        
        # Just an initial guess
        n = max(1, 10*(len(str(x))/2))

        # Newton iteration
        while not (pow(int(n), 2) <= x and x < pow(int(n)+1, 2)):
            n = (n + x/n)/2

        return int(n)
#a new python file
def square_root(x):
    return np.sqrt(x)


def solve(fvals, x0, debug = False):
    
    x = x0
    n_iter = 0
    tol = 1.e-14
    for h in range(100):
       
        """evaluate function and its derivative:
            """
        fx, fpx = fvals(x)

        if (abs(fx)< tol):
            break
        """update x
            """
        x = x - fx/fpx

    return x, h

def fvals_sqrt(x):
    """
        Return f(x) and f'(x) for applying Newton to find a square root.
        """
    f = x**2 - 4.
    fp = 2.*x
    return f, fp

def test1(debug_solve=False):
    """
        Test Newton iteration for the square root with different initial
        conditions.
        """
    from numpy import sqrt
    for x0 in [1., 2., 100.]:
        print " "  # blank line
        x,iters = solve(fvals_sqrt, x0, debug=debug_solve)
        print "solve returns x = %22.15e after %i iterations " % (x,iters)
        fx,fpx = fvals_sqrt(x)
        print "the value of f(x) is %22.15e" % fx
        assert abs(x-2.) < 1e-14, "*** Unexpected result: x = %22.15e"  % x

    
    
	
# -*- coding: utf-8 -*-

from copy import deepcopy

import pydash as _

from .fixtures import parametrize


pydash_methods = _.filter_(dir(_), lambda m: callable(getattr(_, m, None)))


def test_chaining_methods():
    chain = _.chain([])

    for method in dir(_):
        if not callable(method):
            continue

        chained = getattr(chain, method)
        assert chained.method is getattr(_, method)


@parametrize('value,methods', [
    ([1, 2, 3, 4], [('without', (2, 3)),
                    ('reject', (lambda x: x > 1,))])
])
def test_chaining(value, methods):
    expected = deepcopy(value)
    actual = _.chain(deepcopy(value))

    for method, args in methods:
        expected = getattr(_, method)(expected, *args)
        actual = getattr(actual, method)(*args)

    assert actual.value() == expected


def test_chaining_invalid_method():
    raised = False

    try:
        _.chain([]).foobar
    except _.InvalidMethod:
        raised = True

    assert raised


@parametrize('case', [
    'value_of',
    'run'
])
def test_chaining_value_alias(case):
    chain = _.chain([])
    assert chain.value == getattr(chain, case)


def test_chaining_lazy():
    tracker = {'called': False}

    def interceptor(value):
        tracker['called'] = True
        return value.pop()

    chain = _.chain([1, 2, 3, 4, 5]).initial().tap(interceptor)

    assert not tracker['called']

    chain = chain.last()

    assert not tracker['called']

    result = chain.value()

    assert tracker['called']
    assert result == 3


def test_chaining_late_value():
    square_sum = _.chain().power(2).sum()
    assert square_sum([1, 2, 3, 4]) == 30


def test_chaining_late_value_reuse():
    square_sum = _.chain().power(2).sum()
    assert square_sum([1, 2, 3, 4]) == 30
    assert square_sum([2]) == 4


def test_chaining_late_value_override():
    square_sum = _.chain([1, 2, 3, 4]).power(2).sum()
    assert square_sum([5, 6, 7, 8]) == 174


def test_chaining_plant():
    value = [1, 2, 3, 4]
    square_sum1 = _.chain(value).power(2).sum()

    def root_value(wrapper):
        if isinstance(wrapper._value, _.chaining.ChainWrapper):
            return root_value(wrapper._value)
        return wrapper._value

    assert root_value(square_sum1._value) == value

    test_value = [5, 6, 7, 8]
    square_sum2 = square_sum1.plant(test_value)

    assert root_value(square_sum1._value) == value
    assert root_value(square_sum2._value) == test_value

    assert square_sum1.value() == 30
    assert square_sum2.value() == 174


def test_chaining_commit():
    chain = _.chain([1, 2, 3, 4]).power(2).sum()
    committed = chain.commit()

    assert chain is not committed
    assert chain.value() == committed.value()


def test_dash_instance_chaining():
    value = [1, 2, 3, 4]
    from__ = _._(value).without(2, 3).reject(lambda x: x > 1)
    from_chain = _.chain(value).without(2, 3).reject(lambda x: x > 1)

    assert from__.value() == from_chain.value()


def test_dash_instance_methods():
    assert pydash_methods

    for method in pydash_methods:
        assert getattr(_._, method) is getattr(_, method)


def test_dash_suffixed_method_aliases():
    methods = _.filter_(pydash_methods, lambda m: m.endswith('_'))
    assert methods

    for method in methods:
        assert getattr(_._, method[:-1]) is getattr(_, method)


def test_dash_method_call():
    value = [1, 2, 3, 4, 5]
    assert _._.initial(value) == _.initial(value)


def test_dash_alias():
    assert _.py_ is _._


@parametrize('case,expected', [
    ([1, 2, 3], '[1, 2, 3]'),
])
def test_chaining_value_to_string(case, expected):
    assert _.chain(case).to_string() == expected


@parametrize('value,interceptor,expected', [
    ([1, 2, 3, 4, 5], lambda value: value.pop(), 3)
])
def test_tap(value, interceptor, expected):
    actual = _.chain(value).initial().tap(interceptor).last().value()
    assert actual == expected


@parametrize('value,func,expected', [
    ([1, 2, 3, 4, 5], lambda value: [sum(value)], 10)
])
def test_thru(value, func, expected):
    assert _.chain(value).initial().thru(func).last().value()


def primesByMaxValue(MAX):
    
    primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    root_index = 3
    root = 7
    square = 49
    r = range(1,root_index)
    
    for n in range(41,MAX,2):
        
        if square <= n:
            r.append(root_index)
            root_index += 1
            root = primes[root_index]
            square = root * root
        
        for i in r:
            p = primes[i]
            if n % p == 0:
                break
        else:
            primes.append(n)
    
    return primes


from sys import argv
from math import sqrt

def prime_search(maximum):
		primes = [2, 3]
		for num in range(5,maximum,2):
			squareRoot = sqrt(num)
			for prime in primes:
				if num % prime == 0:
					break
				elif prime > squareRoot:
					primes.append(num)
					break
		return primes

def save_primes(primeNumbers ,pathName = "prime.txt"):
		with open(pathName,'w') as f:
			for number in primeNumbers:
				f.write(str(number) + "\n")
def main():
		argue = len(argv)

		if argue <= 1 or argue > 3:
			print("Usage: primeSearch.py Length_of_Search <filename>")
			quit()
		elif argue == 2:
			primeFound = prime_search(int(argv[1]))
			save_primes(primeFound)
		elif argue == 3:
			primeFound = [prime_search(int(argv[1]))]
			save_primes(primeFound, argv[3])

if __name__ == '__main__':
	main()
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline


def print_square_root():
    y = input("Enter a number: ")
    
    y = float(y)
    
    if y <= 0:
        print("Positive numbers only, please.")
        return

    result = y**0.5
    print("The square root of", y, "is", result)

print_square_root()

import math 

def triangular(p):
    return (p * (p+1)) / 2

def divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p))) 
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num    

for x in range(100000):
    t = triangular(x)
    n = divisors(t)
    if n >= 500:
        print t, n
        break

# Square root digital expansion
"""
It is well known that if the square root of a natural number 
is not an integer, then it is irrational. The decimal
expansion of such square roots is infinite without 
any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and 
the digital sum of the first one hundred decimal digits is 475.

For the first one hundred natural numbers, find the total of 
the digital sums of the first one hundred decimal digits
for all the irrational square roots.
"""


def digit_sum_sqrt(n):
    square_root = str(int(n ** 0.5))
    for i in range(1, 100):
        for j in range(10):
            if (int(square_root) * 10 + j) ** 2 > n * 10 ** (2 * i):
                square_root += str(j - 1)
                break
            if j == 9:
                square_root += str(j)

    s = sum(map(int, square_root))
    # print(n, s)
    return s


def main():
    non_perfect_square = [i for i in range(1, 101) if int(i ** 0.5) ** 2 != i]
    print(sum(map(digit_sum_sqrt, non_perfect_square)))


if __name__ == '__main__':
    from time import time
    starting_time = time()
    main()
    print("Time elapsed:", time() - starting_time, "seconds")

import numpy as np
from scipy import sparse


def square_root(x):
    return np.sqrt(x)

from Scientific.BSP import ParFunction, ParRootFunction, ParMessages, \
                           ParConstant, ParIterator, ParIndexIterator, \
                           numberOfProcessors
import operator, string

# The local and global input functions.
def input():
    data = open('numbers').readlines()
    numbers = map(string.atoi, map(string.strip, data))
    chunk_size = (len(numbers)+numberOfProcessors-1)/numberOfProcessors
    chunks = []
    for i in range(numberOfProcessors):
        chunks.append((i, numbers[i*chunk_size:(i+1)*chunk_size]))
    return chunks
def empty():
    return []
global_input = ParRootFunction(input, empty)

# The local and global computation functions.
def square(x):
    return x*x
global_square = ParFunction(square)

# The local and global output functions.
def output(results):
    file = open('results', 'a')
    for value in results:
        file.write(`value` + '\n')
    file.close()
global_output = ParRootFunction(output)

# Read input data.
data = global_input()

# Distribute input data.
items = ParMessages(data).exchange()[0]

# Computation and output loop.
for item in ParIterator(items):
    result = global_square(item)
    collected_results = result.put(ParConstant([0]))
    global_output(collected_results)

##It is well known that if the square root of a natural number is not an integer,
##then it is irrational. The decimal expansion of such square roots is infinite
##without any repeating pattern at all.
##
##The square root of two is 1.41421356237309504880..., and the digital sum of the
##first one hundred decimal digits is 475.
##
##For the first one hundred natural numbers, find the total of the digital sums of
##the first one hundred decimal digits for all the irrational square roots.

def sumdicemal(a,b):
    result,a=str(a//b),a%b
    while len(result)<100:
        a=a*10
        result+=str(a//b)
        a=a%b
    return sum(int(i) for i in result)
def decimal(p,l):
    if l==[]:
        return 0
    a,b=0,1
    while b<10**101:
        for i in range(len(l)):
            a,b=b,l[len(l)-1-i]*b+a
    return sumdicemal(a+p*b,b)
def HCF(a,b):
    if a<b:
        return HCF(b,a)
    if b==0:
        return a
    return HCF(b,a%b)
def H(m,n):
    k=HCF(m,n)
    return m//k,n//k
def ContinuedFraction(x):
    y=x**0.5
    p=int(y)
    if p*p==x:
        return p,[]
    c,a,d,L=1,p,1,[]
    while True:
        m=int(d*d*x-a*a)
        c,m=H(c,m)
        l=int(c*(d*y+a))
        k=l//m
        L.append(k)
        c,a,d=m,k*m-c*a,c*d
        if c==1 and a==p:
            break
    return p,L
def S(x):
    p,L=ContinuedFraction(x)
    return decimal(p,L)
def p80():
    return sum(S(i) for i in range(2,100))
print(p80())

#Find square root of an input

def sqrt(num):
    if num < 0:
        return ValueError
    if num == 1:
        return 1
    low = 0
    high = 1+(num/2)

    while low+1 < high:
        mid = low+(high-low)/2
        square = mid ** 2
        if square == num:
            return mid
        elif square < num:
            low = mid
        elif square > num:
            high = mid
    return low

#!/bin/python
#
# Author     :  Ye Jinchang
# Date       :  2015-04-29 23:57:23
# Title      :  69 sqrtx

# Implement int sqrt(int x).
#
# Compute and return the square root of x.

class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        def isGood(val):
            return abs(val * val - x) / x < 0.00001
            
        def improve(val):
            return (val + x / val) / 2
            
        def iter(val):
            if isGood(val):
                return val
            else:
                return iter(improve(val))
        if x == 0 or x == 1:
            return x
        
        result = int(iter(1.0))
        if result * result > x:
            return result - 1
        return result

# -*- coding: utf-8 -*-
"""
Created on Mon Feb 17 21:02:08 2014

@author: ventilator
"""

import profile
from fractions import Fraction
        
def create_continued_fraction(layers):
    if layers == 0:
        half = Fraction(1,2)
        half = 2
        return half
    else:       
        next_layer = Fraction(2 + Fraction(1, create_continued_fraction(layers - 1)))        
        return next_layer


def square_root_two(layers):
    # this intermediate layer is to fix for leading 1 instead of 2
    return Fraction(1 + Fraction(1, create_continued_fraction(layers)))
    
    


def solve_problem():  

    max_range = 1000
    count = 0

    for i in range(max_range):
        current_square_root = square_root_two(i)
        numerator = len(str(current_square_root.numerator))
        denominator = len(str(current_square_root.denominator))
        if numerator > denominator:
            count += 1
            #print(current_square_root)
        if i % 10 == 0: print("progress: " + str(i/max_range*100))    
        
    print("Condition fulfilled by:")    
    print(count)    
    
    return 0
    
solve_problem()    
# profile.run('solve_problem()')   
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/python
import math

def print_n(s,n):
    for i in range(n):
        print s

print_n('pants',5)

epsilon = 0.0000001

new_root = 0.0

def square_root(a):
    new_root = a/3.0
    old_root = 0.0
    while abs(old_root-new_root) > epsilon:
        old_root = new_root
        new_root = (new_root+a/new_root)/2.0

    return new_root

square_root(100)

def test_square_root(a):
    newton = square_root(a)
    official = math.sqrt(a)
    print '%s\t%s\t%s\t%s' % (a,newton,official,abs(newton-official))

test_square_root(345)   

import unittest
import math


def closest_square_root(number):
    if number == 1:
        return number

    low = 0
    high = number

    while True:
        mid = (low + high) / 2
        mid_squared = mid ** 2

        if mid_squared == number:
            return mid
        elif low + 1 == high:
            return get_closest_number(low, high, number)
        elif mid_squared > number:
            high = mid
        else:
            low = mid


def get_closest_number(low, high, number):
    difference_from_low_sauared = math.fabs((low ** 2) - number)
    difference_from_high_squared = math.fabs((high ** 2) - number)
    if difference_from_low_sauared > difference_from_high_squared:
        return high
    else:
        return low


class ClosestSquareRootTest(unittest.TestCase):

    def test_square_root_of_one(self):
        self.assertEqual(closest_square_root(1), 1)

    def test_square_root_of_four(self):
        self.assertEqual(closest_square_root(4), 2)

    def test_square_root_of_five(self):
        self.assertEqual(closest_square_root(5), 2)

    def test_large_squares(self):
        self.assertEqual(closest_square_root(33), 6)
        self.assertEqual(closest_square_root(63), 8)
        self.assertEqual(closest_square_root(65), 8)
        self.assertEqual(closest_square_root(72), 8)
        self.assertEqual(closest_square_root(73), 9)
        self.assertEqual(closest_square_root(80), 9)


if __name__ == '__main__':
    unittest.main()

"""
David Schonberger
Project Euler - problem 57
Square root convergents
"""

def addn(l, n):
    return [l[0] + n * l[1], l[1]]
    
def flip(l):
    return [l[1], l[0]]

upper = 1000
curr_lst = [1,2]
bigger_numerator_count = 0
for i in range(2 , upper + 1):
    curr_lst = flip(addn(curr_lst,2))
    curr_conv = addn(curr_lst,1)
    if(len(str(curr_conv[0])) > len(str(curr_conv[1]))):
        bigger_numerator_count += 1
        
print "in first ", upper, "convergents", bigger_numerator_count, "have bigger numerator"

# -*- coding: utf-8 -*-
"""
Created on Thu Nov  1 14:40:51 2012

@author: esteban
"""
import numpy as np
from scipy.signal import lfilter

def trajVelocity(traj):
    "Compute trajectory velocities"
    data = np.array(traj.pointData)
    return data[1:,:] - data[:-1,:]

def trajEnergy(traj):
    "Compute trajectory energy by taking square of velocity vector length."
    vel = trajVelocity(traj)
    return np.sum(vel**2, 1)
    
def trajSpeed(traj):
    "Compute trajectory speed by taking square root of energy"
    e = trajEnergy(traj)
    return e**.5
    
def smooth(data, alpha):
    return  lfilter([alpha], [1.0, 1.0-alpha], data)
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/python

# Implement int sqrt(int x).

# Compute and return the square root of x.

import sys

# Binary search in range from 1 to x / 2. O(log(n)).
def sqrt(x):
    if x == 0 or x == 1:
        return x
    i, j = 1, x / 2
    while i <= j:
        m = (i + j) / 2
        if m * m > x:
            j = m - 1
        elif m * m < x:
            i = m + 1
        else:
            return m
    return i - 1

def main():
    print sqrt(int(sys.argv[1]))

main()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Reference: http://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/
"""

import os
import numpy as np
from math import sqrt
from decimal import Decimal


def euclid_dist(x, y):
    return sqrt(sum(
        [(x[n] - y[n]) ** 2 for n in range(len(x))]
    ))


def manhattan_dist(x, y):
    return sum(
        [abs(xx - yy) for xx, yy in zip(x, y)]
    )


def nth_root(value, n_root):
    root_value = 1/float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)


def minkowski_dist(x, y, p_value):
    return nth_root(sum(pow(abs(a-b), p_value) for a, b in zip(x, y)),
                    p_value)


def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)


def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)


def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)


def main():
    print euclid_dist([0, 3, 4, 5], [7, 6, 3, -1])
    print manhattan_dist([10, 20, 10], [10, 20, 20])
    print minkowski_dist([0, 3, 4, 5], [7, 6, 3, -1], 3)
    print cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15])
    print jaccard_similarity([0, 1, 2, 5, 6], [0, 2, 3, 5, 7, 9])


if __name__ == '__main__':
    main()

import numpy
from PIL import Image
from random import randrange

class World:
	def __init__(self, the_size):
		global size
		global points
		size = (2**the_size)+1
		points = []
		points = self.createPoints()

	def diamondSquareAlgorithm(self, root_square):
		count = 0
		root_square.modCenter()
		c_squares = root_square.getSquareChildren()
		c_diamonds = root_square.getDiamondChildren()

		while(True):
			#Mod children diamonds
			for di in c_diamonds:
				di.modCenter()

			#Mod children squares
			for sq in c_squares:
				if(sq.tooSmall()):
					return
				sq.modCenter()

			#Get new children
			temp_squares = []
			temp_diamonds = []
			for sq in c_squares:
				temp_diamonds.extend(sq.getDiamondChildren())
				temp_squares.extend(sq.getSquareChildren())

			c_diamonds = temp_diamonds
			c_squares = temp_squares
			
			count = count + 1

	def printPoints(self):
		count = 0
		for p in points:
			print(p.h),
			count+=1
			if(count == size):
				print("")
				count = 0

	def normalizePoints(self, shades):
		shades = shades-1
		section = 255/shades
		bot = 0
		top = section
		
		while(top < 255):
			for point in points:
				if(point.h > bot and point.h <= top):
					point.h = top

			bot = top
			top = top + section

	def writePoints(self, name):
		f = open(str(name)+".txt", "w+")
		count = 0
		for p in points:
			f.write(str(p.h)+"\t")
			count+=1
			if(count == size):
				f.write("\n")
				count = 0

	def writeImage(self, name):
		im = Image.new("RGB", (size,size))
		for y in range(im.size[1]):
			for x in range(im.size[0]):
				point = self.getPoint(x,y)
				amt = point.h
				if(amt < 100):
					im.putpixel((x,y), (0,0,amt+200))
				else:
					im.putpixel((x,y), (0,amt-60,0))

		im.save(str(name)+".png")

	def createPoints(self):
		points = []

		for y in range(size):
			for x in range(size):
				points_x = []
				points_x.append(Point(x, y, 150))
				points.extend(points_x)

		return points

	@staticmethod
	def getPoint(x, y):
		if(x < 0 or x >= size or y < 0 or y >= size):
			return Point(x,y,0)

		point = points[(size * y) + x]
		return point

	@staticmethod
	def getMidpoint(point1, point2):
		return World.getPoint((point2.x+point1.x)/2, (point2.y+point1.y)/2)

	def getSize(self):
		return size


class Point:
	def __init__(self, x, y, h=0.0):
		self.x = x
		self.y = y
		self.h = h

	def setHeight(self, new_h):
		self.h = new_h

	def __str__(self):
		return str(self.x)+","+str(self.y)

class Quad:
	def __init__(self, p1, p2, p3, p4):
		self.mod = 4
		self.tl = p1
		self.tr = p2
		self.bl = p3
		self.br = p4

		self.top = p1
		self.bot = p2
		self.lef = p3
		self.rig = p4

	def getAverageHeight(self):
		return (self.tl.h+self.tr.h+self.bl.h+self.br.h)/4

	def getCenter(self):
		return World.getMidpoint(self.tl,self.br)

	def getSize(self):
		size_x = self.br.x-self.tl.x
		size_y = self.br.y-self.tl.y
		return size_x*size_y

	def modCenter(self):
		center = self.getCenter()
		avg = self.getAverageHeight()
		center.setHeight(avg+randrange(-avg/self.mod,avg/self.mod,1))
		self.mod = self.mod*2

	def tooSmall(self):
		return self.getSize()<=1

class Square (Quad):
	def getDiamondChildren(self):
		center = self.getCenter()

		top_d = Diamond(World.getPoint(center.x, self.tl.y+(self.tl.y-center.y)), center, self.tl, self.tr)
		bot_d = Diamond(center, World.getPoint(center.x, self.bl.y+(self.bl.y-center.y)), self.bl, self.br)
		left_d = Diamond(self.tl, self.bl, World.getPoint(self.tl.x+(self.tl.x-center.x), center.y), center)
		right_d = Diamond(self.tr, self.br, center, World.getPoint(self.tr.x+(self.tr.x-center.x), center.y))

		return [top_d, bot_d, left_d, right_d]

	def getSquareChildren(self):
		top = World.getMidpoint(self.tl,self.tr)
		bot = World.getMidpoint(self.bl,self.br)
		left = World.getMidpoint(self.tl,self.bl)
		right = World.getMidpoint(self.tr,self.br)
		center = World.getMidpoint(self.tl, self.br)
		
		square_tl = Square(self.tl, top, left, center)
		square_tr = Square(top, self.tr, center, right)
		square_bl = Square(left, center, self.bl, bot)
		square_br = Square(center, right, bot, self.br)

		return [square_tl, square_tr, square_bl, square_br]

	def __str__(self):
		return "TopLeft: \n"+str(self.tl)+"\nTopRight: \n"+str(self.tr)+"\nBotLeft: \n"+str(self.bl)+"\nBotRight:\n "+str(self.br)

class Diamond (Quad):
	def getCenter(self):
		return World.getMidpoint(self.top, self.bot)

	def getSquare(self):
		tl = Worldn.getMidpoint(self.top, self.lef)
		tr = World.getMidpoint(self.top, self.rig)
		bl = World.getMidpoint(self.bot, self.lef)
		br = World.getMidpoint(self.bot, self.rig)

		return Square(tl, tr, bl, br)

	def __str__(self):
		return "Top: \n"+str(self.top)+"\nBot: \n"+str(self.bot)+"\nLeft: \n"+str(self.lef)+"\nRight: \n"+str(self.rig)

class Main:
	def __init__(self):
		seed = 150
		count = 1
		world = World(9)
		size = world.getSize()-1

		tl = world.getPoint(0,0)
		tr = world.getPoint(size,0)
		bl = world.getPoint(0,size)
		br = world.getPoint(size,size)

		tl.setHeight(seed)
		tr.setHeight(seed)
		bl.setHeight(seed)
		br.setHeight(seed)

		root_square = Square(tl, tr, bl, br)

		#Recursion
		world.diamondSquareAlgorithm(root_square)

		#Normalization
		world.normalizePoints(6)

		#Print Points
		#world.printPoints()

		#Write Image
		world.writeImage("img")

main = Main()
'''
Created on Jan 17, 2013

@author: PaymahnMoghadasian
'''
from numpy.ma.core import floor

number = 600851475143
primes = []
factors = []

def find_primes(n):
    '''Find all primes <= n'''
    for i in range(20, n):
        if is_prime(i):
            primes.append(i)

def is_prime(n):
    '''Checks to see if n is prime'''
    root = n ** 0.5
    for i in primes:
    # for i in range(2, int(root) + 1):
        if n % i == 0:
            return False
        if i > root:
            return True
        
    return True

def find_largest_prime_factor(n):
    while n > 2:
        for i in primes:
            if n % i == 0 and i not in factors:
                factors.append(i)
                n /= i
                break

square_root = number ** 0.5
find_primes(int(square_root) + 1)
find_largest_prime_factor(number)

print factors[-1]



'''
Find the square root of n.

    Input: A number
    Output: The square root or the integers closest to the square root
    Assume: positive n

 Newton's method is a popular solution for square root, but not implemented here.
'''

def sqrt(n):
    for number in range(0, n):
        if isSqrt(number,n):
            return number
        else:
            if n < number * number:
                return number, number - 1


def isSqrt(a,b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True
    else:
        return False


# Test Section
if __name__ == '__main__':
    print "sqrt(25) = 5: %s" % (sqrt(25) == 5)
    print "sqrt(30) = (6, 5): %s" % (sqrt(30) == (6,5))


##It is well known that if the square root of a natural number is not an integer,
##then it is irrational. The decimal expansion of such square roots is infinite
##without any repeating pattern at all.
##
##The square root of two is 1.41421356237309504880..., and the digital sum of the
##first one hundred decimal digits is 475.
##
##For the first one hundred natural numbers, find the total of the digital sums of
##the first one hundred decimal digits for all the irrational square roots.

def sumdicemal(a,b):
    result,a=str(a//b),a%b
    while len(result)<100:
        a=a*10
        result+=str(a//b)
        a=a%b
    return sum(int(i) for i in result)
def decimal(p,l):
    if l==[]:
        return 0
    a,b=0,1
    while b<10**101:
        for i in range(len(l)):
            a,b=b,l[len(l)-1-i]*b+a
    return sumdicemal(a+p*b,b)
def HCF(a,b):
    if a<b:
        return HCF(b,a)
    if b==0:
        return a
    return HCF(b,a%b)
def H(m,n):
    k=HCF(m,n)
    return m//k,n//k
def ContinuedFraction(x):
    y=x**0.5
    p=int(y)
    if p*p==x:
        return p,[]
    c,a,d,L=1,p,1,[]
    while True:
        m=int(d*d*x-a*a)
        c,m=H(c,m)
        l=int(c*(d*y+a))
        k=l//m
        L.append(k)
        c,a,d=m,k*m-c*a,c*d
        if c==1 and a==p:
            break
    return p,L
def S(x):
    p,L=ContinuedFraction(x)
    return decimal(p,L)
def p80():
    return sum(S(i) for i in range(2,100))
print(p80())

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from thumbnailer import _resizer
from unittest import TestCase, main
import os.path as path
from PIL import Image

class ThumbnailerTests(TestCase):

    def path(self, filename):
        return path.join(self.img_path, filename)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")
        self.img = Image.open(self.path("sample_image.jpg"))

    def testSquare(self):
        r = _resizer('square', '100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((100, 100), output.size)

    def testExact(self):
        r = _resizer('exact', '250x100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 100), output.size)

    def testWidth(self):
        r = _resizer('aspect', '250x?', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 166), output.size)

    def testHeight(self):
        r = _resizer('aspect', '?x250', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((375, 250), output.size)

class ThumbnailerFilenameTest(TestCase):

    def path(self, *parts):
        return path.join(self.img_path, *parts)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")

    def testRoot(self):
        """Test a file that is in the root of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testRootWithSlash(self):
        r = _resizer('square', '100', self.img_path + '/')
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testSubdir(self):
        """Test a file that is in a sub-directory of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('subdir', 'sample_image.jpg'))
        self.assertEqual('subdir/sample_image_square.jpg', new_name)

if __name__=="__main__":
    main()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def super_root(number):
    return 1

if __name__ == '__main__':
    #These "asserts" using only for self-checking and not necessary for auto-testing
    def check_result(function, number):
        result = function(number)
        if not isinstance(result, (int, float)):
            print("The result should be a float or an integer.")
            return False
        p = result ** result
        if number - 0.001 < p < number + 0.001:
            return True
        return False
    assert check_result(super_root, 4), "Square"
    assert check_result(super_root, 9), "Cube"
    assert check_result(super_root, 81), "Eighty one"

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from PyQt5.QtQml import QQmlApplicationEngine

#
# TODO:
# - update example movie while changing rule
# - close button
# - integrate with main UI
# - load rule from preferences when loading UI
# - save rule in preferences when it changes
#

class RenamingRuleWindowView:
    def __init__(self):
        self.__engine = QQmlApplicationEngine()
        self.__engine.load("ui/renaming_rule_window.qml")

    def __get_root_window(self):
        return self.__engine.rootObjects()[0]

    def __get_property(self, property_name: str):
        return self.__get_root_window().property(property_name)

    def __set_property(self, property_name: str, property_value):
        return self.__get_root_window().setProperty(property_name, property_value)

    def add_rule(self, rule: str):
        self.__get_root_window().addRule(rule)

    def remove_rule(self, index: int):
        self.__get_root_window().removeRule(index)

    def remove_all_rules(self):
        self.__get_root_window().removeAllRules()

    def get_rule_changed_signal(self):
        return self.__get_root_window().ruleChanged

    def get_remove_rule_clicked_signal(self):
        return self.__get_root_window().removeRuleClicked

    def get_remove_all_rules_clicked_signal(self):
        return self.__get_root_window().removeAllRulesClicked

    def get_add_title_clicked_signal(self):
        return self.__get_root_window().addTitleClicked

    def get_add_original_title_clicked_signal(self):
        return self.__get_root_window().addOriginalTitleClicked

    def get_add_year_clicked_signal(self):
        return self.__get_root_window().addYearClicked

    def get_add_directors_clicked_signal(self):
        return self.__get_root_window().addDirectorsClicked

    def get_add_duration_clicked_signal(self):
        return self.__get_root_window().addDurationClicked

    def get_add_language_clicked_signal(self):
        return self.__get_root_window().addLanguageClicked

    def get_add_round_brackets_clicked_signal(self):
        return self.__get_root_window().addRoundBracketsClicked

    def get_add_square_brackets_clicked_signal(self):
        return self.__get_root_window().addSquareBracketsClicked

    def get_add_curly_brackets_clicked_signal(self):
        return self.__get_root_window().addCurlyBracketsClicked

    def get_close_clicked_signal(self):
        return self.__get_root_window().closeClicked

# -*- coding: utf-8 -*-
"""
Created on Sun Mar 29 23:50:11 EDT 2015
@author: aaditya prakash
"""

import re
from time import clock

problem_number = '206'
problem_statement = """
Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0,
where each _ is a single digit.
"""

def concealed_square():
    """ solves problem 206"""
    pat = re.compile(r'1\d2\d3\d4\d5\d6\d7\d8\d9\d0')
    
    #smallest_integer possible given the requirement = 1020304050403020100 
    start = 1010101010 # square root of smallest integer 
    while True:
        if len(pat.findall(str(start**2))): return start
        start += 10


timeStart = clock()
print(concealed_square())
print('Time (sec):' + str(clock() - timeStart))
answer = '1389019170'




'''
Solving the third code jam problem

'''
def isPalindrome(number):
	original = number
	reverse = 0
	while number != 0:
		reverse = reverse * 10 + number % 10
		number /= 10
	return reverse == original

				
# main program
import os, math
full_path = os.path.realpath(__file__)
path, file = os.path.split(full_path)

f = open(path + '\\' + 'C-small-attempt0.in')
numOfTests = int(f.readline())

results = []
for test in range(numOfTests):
	a, b = [int(x) for x in f.readline().split()] # read a line
	counter = 0
	root = int(math.sqrt(a))
	square = int(root**2)
	#in case it's truncated
	if square < a:
		root += 1
		square = root**2
	
	while square <= b:
		if isPalindrome(root) and isPalindrome(square):
			counter += 1 
		square += root * 2 + 1 # (x+1)^2 = x^2 + 2x + 1
		root += 1

	results.append(counter)

outFile = open(path + '\\' + 'output.txt', 'w')

for i in range(0, len(results)):
	caseNumber = i+1
	outFile.write("Case #%d: %d\n" % (caseNumber, results[i] ))

# newton.py - solving square roots, Newton's way.

DX    = 0.0000001
ERROR = 0.0000001

def main():
    print("*** Newton's Method for Square Roots. ***")
    print("\tEnter '0' to quit.")
    while 1:
        n = float(input("Square Root of: "))
        if not n:
            break
        else:
            root = sqrt(n)
            print(try_as_int(root))

def sqrt(x):
    """Takes a number and returns (an estimate of) the square root.
    Passes a function to newton() and a guess of 1.
    If y is the square root of x then x-y*y = 0."""
    return newton(lambda y: x- y * y, 1) 

def newton(f, guess):
    """Takes a function and a guess.
    Returns the fixed point of Newton's square root method."""
    df = deriv(f)
    return fixed_point(lambda x: x - (f(x) / df(x)), guess)

def deriv(f):
    """Takes a function and returns its derivative."""
    return lambda x: (f(x + DX) - f(x)) / DX

def fixed_point(f, new):
    """Takes a function and a guess. Returns the fixed point of the function."""
    old = 0
    while not close_enough(old, new):
        old, new = new, f(new)
    return new

def try_as_int(x):
    """Takes a number and returns it as an int if it is a whole number."""
    if x % 1 == 0:
        return int(x)
    else:
        return x

def close_enough(u, v):
    """Takes two numbers and returns True if they differ by less than ERROR."""
    return abs(u - v) < ERROR

if __name__ == "__main__":
    main()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def solve(fvals, x0, debug = False):
    
    x = x0
    n_iter = 0
    tol = 1.e-14
    for h in range(100):
       
        """evaluate function and its derivative:
            """
        fx, fpx = fvals(x)

        if (abs(fx)< tol):
            break
        """update x
            """
        x = x - fx/fpx

    return x, h

def fvals_sqrt(x):
    """
        Return f(x) and f'(x) for applying Newton to find a square root.
        """
    f = x**2 - 4.
    fp = 2.*x
    return f, fp

def test1(debug_solve=False):
    """
        Test Newton iteration for the square root with different initial
        conditions.
        """
    from numpy import sqrt
    for x0 in [1., 2., 100.]:
        print " "  # blank line
        x,iters = solve(fvals_sqrt, x0, debug=debug_solve)
        print "solve returns x = %22.15e after %i iterations " % (x,iters)
        fx,fpx = fvals_sqrt(x)
        print "the value of f(x) is %22.15e" % fx
        assert abs(x-2.) < 1e-14, "*** Unexpected result: x = %22.15e"  % x

    
    
	
import sys

__author__ = 'johanvergeer'


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    """

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed")
    except ValueError as e:
        print(e, file=sys.stderr)


if __name__ == '__main__':
    main()

# encoding=utf-8
## SOLVED 2015/01/04
## 40886

# It is well known that if the square root of a natural number is not an
# integer, then it is irrational. The decimal expansion of such square roots is
# infinite without any repeating pattern at all.

# The square root of two is 1.41421356237309504880..., and the digital sum of
# the first one hundred decimal digits is 475.

# For the first one hundred natural numbers, find the total of the digital sums
# of the first one hundred decimal digits for all the irrational square roots.

MAX = 100

# uses the algorithm for digit-by-digit calculation, as described on Wikipedia:
# http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation
def euler():
  acc = 0
  # for each starting number
  for c in range(2, MAX):
      acc += square_root_digit_sum(c)
  return acc

# return the sum of the first 100 digits in the irrational square root sqrt(c)
#
# if sqrt(c) is rational, returns 0
def square_root_digit_sum(c):
  # number representing the digits of the root
  p = 0
  i = 0
  # True iff the root is rational
  rational = False
  # for each of the first 100 digits
  while i < 100:
    i += 1
    # calculate the current value for x and y
    x = guess_x(p, c)
    y = x * (20 * p + x)
    # add x as a digit to p
    p = 10 * p + x
    # subtract y from c, and move it two digits to the left
    c -= y
    c *= 100
    # if c is 0, it is rational; just return 0
    if c == 0:
      return 0
  # return the sum of the digits found
  return sum(int(d) for d in str(p))

# helper function for calculating the next digit of the square root
def guess_x(p, c):
  # guess the value of x by "brute force"
  # x is the highest integer that satisfies x(20p + x) <= c, and is going to be
  # the next digit to add to the square root
  x = 1
  while x * (20 * p + x) <= c:
    x += 1
  return x - 1

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from openerp.osv import orm, fields

class student_mark_main(orm.TransientModel):
    _name = "student.mark.main"
    _inherit = "student.info.student"
    def _square(self, cr, uid, ids, field_name, arg, context=None):
        res={}
        for record in self.browse(cr,uid,ids,context=context):
            b=record.num
            res[record.id] =  b ** 2
            print res
        return res
    
    def _square_root(self, cr, uid, id, name, value, args, context=None):
        return self.write(cr,uid,[id],{'num': value and value ** 0.5},context=context)
    _columns = {
        'aavgg':fields.char("Average Marks", size=15),
        'num':fields.float("Number 1"),
        'smp':fields.function(_square,fnct_inv=_square_root, string="Simple")
    }
        

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#What is the 10 001st prime number?

import math

def main():
    whichPrime = 1
    possiblePrime = 2
    
    while whichPrime < 10001:
        possiblePrime += 1
        
        if isPrime(possiblePrime):
            whichPrime += 1

    print(possiblePrime)


def isPrime(n):
    squareRoot = math.ceil(math.sqrt(n))
    for i in xrange(2, int(squareRoot) + 1):
        if n % i == 0:
            return False
    return True
        
if __name__ == "__main__":
    main()

import sys
import math
from datetime import datetime as dt

def timedelta_to_microseconds(td): # http://stackoverflow.com/a/2416049
	return td.microseconds + (td.seconds + td.days * 86400) * 1000000.0
	
def calculate_height(x, r):
	# we could use an integer square root algorithm, e.g.
	# http://code.activestate.com/recipes/577821-integer-square-root-function/
	# that method is slower but will work for very large values of r
	return math.floor(math.sqrt(r**2 - x**2))

def circle_area(r): # numerically integrate using the rectangle rule with delta = 1
	return sum(calculate_height(x, r) for x in xrange(r))
	
def square_area(r):
	return r**2
	
def calculate_pi(r):
	return (4.0 * circle_area(r)) / square_area(r)

radius = int(sys.argv[1])
before = dt.now()
pi = calculate_pi(radius)
elapsed = dt.now() - before
print 'pi = ' + str(pi)
print 'time elapsed: ' + str(elapsed)
print 'microseconds per operation: ' + str(timedelta_to_microseconds(elapsed)/(radius))
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
'''
Arranged probability

due to double's precision, solving the equation by square root does not work

'quadratic diophantine equation' helps

756872327473
'''
def solution():
    b = 15
    n = 21
    target = 1000000000000

    while n < target:
        btemp = 3 * b + 2 * n - 2
        ntemp = 4 * b + 3 * n - 3

        b = btemp
        n = ntemp
    return b

if __name__ == '__main__':
    print('Result: ', solution())


def bmet(x):
	z = x
	y=0
	while (z!=y):
		y=z
		z=((x/z)+z)/2
	return z

print("Babylonian Method.")
x=float(input("Give me the number you want to know the square root."))
print("Square Root: ", bmet(x))

def findSquareRoot(number):
    low= 0.0
    high = number
    epsilon =0.01
    guess = (low + high) / 2 
    
    while abs((number) - guess**2) >epsilon:
        if guess**2 < number:
            low = guess 
        elif guess**2 > number:
            high = guess 
        elif guess**2 == number:
            return "The square root of" + str(number) + "would be" +str(guess) 
        guess = (low + high)/2
    return "The aproximate square root of " + str(number) + " is " + str(guess)
        
#!/usr/bin/python
# -*- coding: utf-8 -*-
import gmpy2
import math

# using formula: area = base/2 * height
# and square check using gmpy2 library


def isPerfectRoot(n):
    return gmpy2.is_square(n)

SUM = 0
#for n in xrange(3, 1000**3 / 3 + 1, 2):
for n in xrange(3, 1000**3 / 3 + 1, 2):

#  if not isPerfectRoot(t0):
#    continue

#  if isPerfectRoot(areaN):
  if isPerfectRoot(n*n - (n*n-2*n+1)/4):
#     t0 = (n-1)*(n+1) >> 2
#     areaN = ((3*n - 1) * (n-1)*t0) >> 2#/ 16.0
     print (n, '-1')
     SUM = SUM + n*3-1
     print ('sum', SUM)
     
#  if isPerfectRoot(areaP):
  if isPerfectRoot(n*n - (n*n+2*n+1)/4):
#     t0 = (n-1)*(n+1) >> 2
#     areaP = ((3*n + 1) * (n+1)*t0) >> 2#/ 16.0
     print (n, '+1')
     SUM = SUM + n*3+1
     print ('sum', SUM)

print ('end',n)
print (SUM)
# sum for 1M = 716032

def root( num ):
    """
        not so newton root
        find square root of a number
    """
    def find_root( min, max ):
        guess = ( min + max ) / 2.0
        guess2 = guess * guess
        if ( abs( guess2 - num ) < delta ):
            return guess
        elif ( guess2 < num ):
            return find_root( guess, max )
        else:
            return find_root( min, guess )

    delta = 0.001*num
    return find_root( 0, max(1,num) )

def newtonroot( num ):
    """
        find square root of a number in newton's way
    """
    def find_root( whim ):
        guess = ( whim + num / whim ) / 2.0
        guess2 = guess**2
        if ( abs( guess2 - num ) < delta ):
            return guess
        else:
            return find_root( guess )

    delta = 0.001*num
    return find_root( 1 )

# Write a function called mySqrt that will approximate the square root of a number, call it n, by using Newtons 
# algorithm. Newtons approach is an iterative guessing algorithm where the initial guess is n/2 and each 
# subsequent guess is computed using the formula: newguess = (1/2) * (oldguess + (n/oldguess)).

def mySqrt(a):
	guess = 0
	guess = a/2
	for i in range(6):											# Use 5 guesses only 
		newguess = (guess + a/guess)/2
		guess = newguess
	return guess

stdin = input("Please enter a number: ")
n = float(stdin)
print("The estimated positive square root of", n, "is", mySqrt(n))
#!/usr/bin/env python 
# -*- coding: utf-8 -*-

 
############ EJEMPLO 1 ############ 
 
#Don't write what code is doing, this should be left for the code to explain and can be easily done by giving class, variable and method meaningful name. For example:
t=10
#calculates square root of given number 
#using Newton-Raphson method
def abc( a):

  r = a / 2
  while ( abs( r - (a/r) ) > t ):
    r = 0.5 * ( r + (a/r) )

  return r 
 
 
 
 
 
#Above code is calculating square root using Newton-Raphson method and instead of writing comment you can just rename your method and variable as follows:
 
def squareRoot( num):
  root = num/ 2

  while ( abs(root - (num/ root) ) > t ):
    r = 0.5 * (root + (num/ root))

  return root
    
    

if __name__ == "__main__":

  print " root abc = " + str(abc(10))
  print " root squareRoot = " + str(squareRoot(10))



import math

def newt_meth_while(s):
	"""
	Determines square root of value using Newton's
	method, using while loop.

	Values of 4 or greater are checked against an
	estimate of half their value.

	Values less than 4 are computed using built-in
	square root function from math module.
	"""
	if s >= 4:
		e = s / 2
	else:
		print math.sqrt(s)
		return
	while True:
		print e
		y = (e + s/e) / 2
		if y == e:
			break
		e = y

def newt_meth_recurse(s):
	"""
	Determines square root of value using Newton's
	method, using recursion.

	Values of 4 or greater are checked against an
	estimate of half their value.

	Values less than 4 are computed using built-in
	square root function from math module.
	"""
	if s >= 4:
		e = s / 2
	else:
		print math.sqrt(s)
		return
	y = (e + s/e) / 2
	print y
	if e != y:
		e = y
		newt_meth(s, e)
	else:
		return

# Problem 3: https://projecteuler.net/problem=3
# TODO: this could be cleaned up and checked for correctness even though it gives the correct answer
import math

def IsSquare(apositiveint):
    squareRoot = int(math.sqrt(apositiveint))
    return apositiveint == (squareRoot * squareRoot)

def FermatFactor(N):
    if N % 2 == 0:
        return None

    a = math.ceil(math.sqrt(N))
    b2 = a * a - N

    while b2 > 1 and IsSquare(b2) == False:
        a += 1
        b2 = a*a - N
    return a - math.sqrt(b2), a + math.sqrt(b2)

def largestPrimeFactor(N):
    result = FermatFactor(N)
    if (result != None):
        if result[0] == 1 or result[1] == 1:
            return N

        A = largestPrimeFactor(result[0])
        B = largestPrimeFactor(result[1])

        return max(A, B)

def main():
    print int(largestPrimeFactor(600851475143))

main()

square = lambda x: x * x

# Direct implementations of iterative improvement

def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x

def square_root_update(x, a):
    return (x + a/x) / 2

def cube_root(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    x = 1
    while pow(x, 3) != a:
        x = cube_root_update(x, a)
    return x

def cube_root_update(x, a):
    return (2*x + a/(x*x)) / 3

# General iterative improvement

def improve(update, close, guess=1):
    """Iteratively improve guess with update until close(guess) is true."""
    while not close(guess):
        guess = update(guess)
    return guess

def improve(update, close, guess=1, max_updates=100):
    """Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied."""
    k = 0
    while not close(guess) and k < max_updates:
        guess = update(guess)
        k = k + 1
    return guess

def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance

def square_root_improve(a):
    """Return the square root of a.

    >>> square_root_improve(9)
    3.0
    """
    def update(x):
        return square_root_update(x, a)
    def close(x):
        return approx_eq(x * x, a)
    return improve(update, close)

def cube_root_improve(a):
    """Return the cube root of a.

    >>> cube_root_improve(27)
    3.0
    """
    return improve(lambda x: cube_root_update(x, a),
                   lambda x: approx_eq(x*x*x, a))

# Newton's method

def find_zero(f, df):
    """Return a zero of the function f with derivative df."""
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

def newton_update(f, df):
    """Return an update function for f with derivative df,
    using Newton's method."""
    def update(x):
        return x - f(x) / df(x)
    return update

def square_root_newton(a):
    """Return the square root of a.

    >>> square_root_newton(9)
    3.0
    """
    def f(x):
        return x*x - a
    def df(x):
        return 2*x
    return find_zero(f, df)

def cube_root_newton(a):
    """Return the cube root of a.

    >>> cube_root_newton(27)
    3.0
    """
    return find_zero(lambda x: x*x*x - a, lambda x: 3*x*x)

def nth_root_of_a(n, a):
    """Return the nth root of a.

    >>> nth_root_of_a(2, 64)
    8.0
    >>> nth_root_of_a(3, 64)
    4.0
    >>> nth_root_of_a(6, 64)
    2.0
    """
    def f(x):
        return pow(x, n) - a
    def df(x):
        return n * pow(x, n-1)
    return find_zero(f, df)

# Extra examples

def slope(f, x, a=1e-10):
    """Return the approximate slope of f at x.

    >>> f = lambda x: x * x - 16
    >>> slope_at_two = 4
    >>> abs(slope(f, 2) - slope_at_two) < 1e-3
    True
    """
    return (f(x+a) - f(x)) / a

def approx_zero(f):
    """Find a zero of f using approximate differentiation.
    
    >>> approx_zero(lambda x: x*x*x - 27)
    3.0
    """
    return find_zero(f, lambda x: slope(f, x))

derive = lambda f: lambda x: slope(f, x, 1e-5)

def critical(f):
    """Find a critical value of f, such as a minimum.

    >>> min = critical(lambda x: x*x + 4*x + 1)
    >>> round(min, 7)
    -3.0
    """
    return f(approx_zero(derive(f)))

def inverse(f):
    """Return the inverse function of f.

    >>> square_root = inverse(square)
    >>> square_root(16)
    4.0
    """
    return lambda y: approx_zero(lambda x: f(x)-y)

def testable(x):
    r"""

    The `testable` function returns the square root of its parameter,
    or 3, whichever is larger.

    >>> testable(7)
    3.0

    >>> testable(16)
    4.0

    >>> testable(9)
    3.0

    >>> testable(10) == 10 ** 0.5
    True

    """

    if x < 9:
        return 3.0
    return x ** 0.5

#!/usr/bin/python
# -*- coding: utf-8 -*-

#It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.

#The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.

#For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.

#Answer:
	#40886

from time import time; t=time()
from mathplus import isqrt

M = 100

def get_root(n, m):
    #assert 0 < n < 100
    root = [0]*m
    root[0] = isqrt(n)
    n -= root[0]**2
    if n == 0: return [root[0]]
    a2 = root[0]*20
    for i in range(1, m):
        n *= 100
        for b in range(n//a2, -1, -1):
            k = (a2+b)*b
            if k < n:
                n -= k
                break
        root[i] = b
        a2 = 10*(a2+2*b)
    return root

print(sum(sum(get_root(n, 100)) for n in range(M) if n != isqrt(n)**2))#, time()-t

import math
#def print_n(n):
	#while n > 0:
		#print n;
		#n = n -1;
	#print 'Blastoff!!!'
#print_n(10)

#def test_square_root(a):
	#x=2
	#y = (x + a / x) / 2
	#s = math.sqrt(a)
	
	#while abs(y-s) < 0.0:
		#x = y
	
	#return y ,',', s

#print test_square_root(1)

def eval_loop():
	while True:
		line = raw_input('> ')
		if line == 'done':
			break
		else:
			print eval(line)

eval_loop()



	
		

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

'''Program to do basic vector calculations in 3 dimensions: addition, dot product and normalization.
23 April 2014
Luke Barker'''

vectorA =input('Enter vector A: \n').split(' ')
vectorB =input('Enter vector B: \n').split(' ')

def addvectors(a,b):
    iteration = 0    #create variable called iteration
    new_list = []    #create list
    for i in a:
        add = eval(i)+eval(b[iteration])   #adding vector a to b
        new_list.append(add)
        iteration += 1
    return new_list
        
print('A+B =', addvectors(vectorA,vectorB))
       
def productvectors(a,b):
    iteration = 0    #create variable called iteration
    product = 0    #create variable product
    for i in a:
        multiply = eval(i)*eval(b[iteration])   #times vector a to b
        product += multiply
        iteration += 1
    return product

print('A.B =', productvectors(vectorA,vectorB))

def normA(a):
    sum_squares = 0    #create variable for the sum of the squared numbers
    for i in a:
        squares = eval(i)**2   #square number
        sum_squares += squares      
    x = sum_squares**0.5     #square root sum of the squares
    
    return x

print('|A| =', "{0:4.2f}".format(normA(vectorA)))

def normB(b):
    sum_squares = 0    #create variable for the sum of the squared numbers
    for i in b:
        squares = eval(i)**2   #square number
        sum_squares += squares      
    x = sum_squares**0.5   #square root sum of the squares
    
    return x

print('|B| =', "{0:4.2f}".format(normA(vectorB)))

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# https://leetcode.com/problems/sqrtx/
'''
Implement int sqrt(int x).

Compute and return the square root of x.

Hide Tags Math Binary Search
'''
class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        if x < 0:
            return None
        if x == 0:
            return 0

        l = 0
        r = x
        while l <= r:
            m = (l + r) / 2
            if m * m == x:
                return m
            elif m * m < x and (m + 1) * (m + 1) > x:
                return m
            elif m * m < x:
                l = m + 1
            elif m * m > x:
                r = m - 1

"""
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
"""

import math

def solution(n):

    # use Sieve Theory, creating boolean dict indexed by 2 to n
    sieve = {}
    for i in range(2, n + 1):
        sieve[i] = True

    square_root = int(math.sqrt(n))
    primes = []

    for i in range(2, square_root + 1):
        if sieve[i] == True:
            for j in range(i*i, n + 1, i):
                sieve[j] = False

    for index in sieve:
        if sieve[index] == True:
            print index
            primes.append(index)

    return sum(primes)

print solution(2000000)
EPSILON = 0.000001

def square_root(num):
    low = 0.0
    high = 1.0 + (num / 2.0)

    while low < high:
        mid = (low + high) / 2
        sqr = mid ** 2
        diff = abs(num - sqr)

        if diff <= EPSILON:
            return mid

        if sqr < num:
            low = mid
        else:
            high = mid

    return -1

print square_root(256)

def RootBab(num):
    n = num
    r = 1
    acc = 0.0000001
    while (n - r) > acc:
        n = (n + r)/2
        r = num/n
    return n
 
x = float(input("Of which number should I calculate the square root? "))
print("The square root of",x,"is",RootBab(x))

# Investigate the expansion of the continued fraction for the square root of two.

def num(n):
	c = 0
	if n == 1:
		return 3
	if n == 2:
		return 7
	a = 3
	b = 7
	ct = 0
	while ct < n-2:
		c = 2*b + a
		a = b
		b = c
		ct += 1
	return c

def den(n):
	c = 0
	if n == 1:
		return 2
	if n == 2:
		return 5
	a = 2
	b = 5
	ct = 0
	while ct < n-2:
		c = 2*b + a
		a = b
		b = c
		ct += 1
	return c

def digits(n):
	a = n
	ct = 0
	while a > 1:
		a = a/10
		ct += 1
	return ct+1

ct = 0
for i in range(1001):
	if digits(num(i)) > digits(den(i)):
		ct+=1

print ct

import math
import sys


# class Button(QToolButton):
#     def __init__(self, text, parent=None):
#         super(Button, self).__init__(parent)
#         self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
#         self.setText(text)

#     def sizeHint(self):
#         size = super(Button, self).sizeHint()
#         size.setHeight(size.height() + 20)
#         size.setWidth(max(size.width(), size.height()))
#         return size


class Calculator(QWidget):
    NumberDigit = 10

    def __init__(self, parent=None):
        self.Pi = math.pi
        self.e = math.e
        self.factorial_memo = {0: 1, 1: 1}

    def add(self, a, b):
        return a + b

    def sub(self, a, b):
        return a - b

    def multiply(self, a, b):
        return a * b

    def divide(self, a, b):
        return a / b

    def mod(self, a, b):
        return a % b

    def power(self, a, b):
        return a ** b

    def factorial(self, a):
        if a not in self.factorial_memo:
            self.factorial_memo[a] = self.factorial(a-1) * a

        return self.factorial_memo[a]

    def log(self, number, base):
        return math.log(number, base)

    def square_root(self, number):
        return math.sqrt(number)

import math
import utils

def magnitude(v):
    return math.sqrt(sum(v[i]*v[i] for i in range(len(v))))


def add(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(x) for x in zip(u, v)] 
    else:
        utils.error('Vectors are of different length (utils_math: add)')
    return a


def sub(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [ u[i]-v[i] for i in range(len(u)) ]
    else:
        utils.error('Vectors are of different length (utils_math: sub)')
    return a


def dot(u, v):    
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [ sum(u[i]*v[i] for i in range(len(u))) ]
        print '\n', a, '\n'
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a


def normalize(v):
    vmag = magnitude(v)
    return [ v[i]/vmag  for i in range(len(v)) ]
    

def squareRoot(list):
    return map(lambda x: math.sqrt(x), list)    


def square(list):
    return map(lambda x: x ** 2.0, list)

def fft(signal):
   n = len(signal)
   if n == 1:
      return signal
   else:
      Feven = fft([signal[i] for i in xrange(0, n, 2)])
      Fodd = fft([signal[i] for i in xrange(1, n, 2)])
 
      combined = [0] * n
      for m in xrange(n/2):
         combined[m] = Feven[m] + omega(n, -m) * Fodd[m]
         combined[m + n/2] = Feven[m] - omega(n, -m) * Fodd[m]
 
      return combined

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def is_square(test):
    from math import sqrt
    root = sqrt(test)

    if int(root) == root: return True
    else: return False

from math import sqrt

def getSquareRoot (num):
    sq = float(sqrt(num))

    return sq

import unittest
from os.path import dirname, join, abspath
import sys

here = lambda *args: join(abspath(dirname(__file__)), *args)
root = here("..", "..")
sys.path.append(root)

from tvshowhelper.parallel import parallel_map


class TestParallel(unittest.TestCase):

    def test_map(self):
        def _square(x):
            return x + 1

        numbers = range(1000)
        squared_numbers = map(_square, numbers)
        results = parallel_map(_square, numbers, 500)
        self.assertTrue(results == squared_numbers)

if __name__ == '__main__':
    unittest.main()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# Currying

def curry2(f):
    """Returns a function g such that g(x)(y) == f(x, y).

    >>> from operator import add
    >>> add_three = curry2(add)(3)
    >>> add_three(4)
    7
    """
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g

# Direct implementations of iterative improvement

def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x

def square_root_update(x, a):
    return (x + a/x) / 2

def cube_root(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    x = 1
    while pow(x, 3) != a:
        x = cube_root_update(x, a)
    return x

def cube_root_update(x, a):
    return (2*x + a/(x*x)) / 3

# General iterative improvement

def improve(update, close, guess=1):
    """Iteratively improve guess with update until close(guess) is true."""
    while not close(guess):
        guess = update(guess)
    return guess

def improve(update, close, guess=1, max_updates=100):
    """Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied."""
    k = 0
    while not close(guess) and k < max_updates:
        guess = update(guess)
        k = k + 1
    return guess

def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance

def square_root_improve(a):
    """Return the square root of a.

    >>> square_root_improve(9)
    3.0
    """
    def update(x):
        return square_root_update(x, a)
    def close(x):
        return approx_eq(x * x, a)
    return improve(update, close)

def cube_root_improve(a):
    """Return the cube root of a.

    >>> cube_root_improve(27)
    3.0
    """
    return improve(lambda x: cube_root_update(x, a),
                   lambda x: approx_eq(x*x*x, a))

# Newton's method

def find_zero(f, df):
    """Return a zero of the function f with derivative df."""
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

def newton_update(f, df):
    """Return an update function for f with derivative df,
    using Newton's method."""
    def update(x):
        return x - f(x) / df(x)
    return update

def square_root_newton(a):
    """Return the square root of a.

    >>> square_root_newton(9)
    3.0
    """
    def f(x):
        return x*x - a
    def df(x):
        return 2*x
    return find_zero(f, df)

def cube_root_newton(a):
    """Return the cube root of a.

    >>> cube_root_newton(27)
    3.0
    """
    return find_zero(lambda x: x*x*x - a, lambda x: 3*x*x)

def power(x, n):
    """Return x * x * x * ... * x for x repeated n times."""
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product

def nth_root_of_a(n, a):
    """Return the nth root of a.

    >>> nth_root_of_a(2, 64)
    8.0
    >>> nth_root_of_a(3, 64)
    4.0
    >>> nth_root_of_a(6, 64)
    2.0
    """
    def f(x):
        return power(x, n) - a
    def df(x):
        return n * power(x, n-1)
    return find_zero(f, df)

__author__ = 'andi'
import math
import re


def arithmetic(question):
    question = question[8:]
    question = question.replace("plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))


def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)


def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []
    for number in number_list:
        if __is_square(number) and __is_third_square(number):
            return_values.append(number)
    return_value = ", ".join(return_values)
    return return_value


def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False
    else:
        return True


def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)


def float_equals(a, b, tolerance=0.00000001):
    return abs(a-b) < tolerance

primes_under_100 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]


def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100
    if n % 2 == 0 or n % 3 == 0:
        return False

    for f in range(5, int(n ** .5), 6):
        if n % f == 0 or n % (f + 2) == 0:
            return False
    return True


def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)


def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))
    return question


def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a


# what is 13 to the power of 11
def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))




#!/usr/bin/env python

from math import*
from decimal import Decimal

class Similarity():

	""" Five similarity measures function """

	def euclidean_distance(self,x,y):

		""" return euclidean distance between two lists """

		return sqrt(sum(pow(a-b,2) for a, b in zip(x, y)))

	def manhattan_distance(self,x,y):

		""" return manhattan distance between two lists """

		return sum(abs(a-b) for a,b in zip(x,y))


	def minkowski_distance(self,x,y,p_value):
		
		""" return minkowski distance between two lists """

		return self.nth_root(sum(pow(abs(a-b),p_value) for a,b in zip(x, y)),p_value)

	def nth_root(self,value, n_root):

		""" returns the n_root of an value """

		root_value  = 1/float(n_root)
		return round (Decimal(value) ** Decimal(root_value),3)

	def cosine_similarity(self,x,y):

		""" return cosine similarity between two lists """

		numerator = sum(a*b for a,b in zip(x,y))
		denominator = self.square_rooted(x)*self.square_rooted(y)
		return round(numerator/float(denominator),3)

	def square_rooted(self,x):

		""" return 3 rounded square rooted value """

		return round(sqrt(sum([a*a for a in x])),3)


	def jaccard_similarity(self,x,y):

		""" returns the jaccard similarity between two lists """

		intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
		union_cardinality = len(set.union(*[set(x), set(y)]))
		return intersection_cardinality/float(union_cardinality)
def power(x):

	return x**2

def square_root(x):

        return np.sqrt(x)
# Trial division of primes

# Only tests odd numbers from 3 to the square root of a 

def primes_trial(n):
    primes = [2]
    for x in range(2, n+1):
        if all(x % p for p in primes):
            primes.append(x)
    return primes

# Fibonacci golden nuggets
# Problem 137

import time
import math

def solve(max):
    tStart = time.time()
    counter = 0
    for i in range(1,max):
        if isNugget(i):
            counter += 1
            print(i, counter)
    print("Run Time = " + str(time.time() - tStart))
            
            
def isNugget(n):
    return isSquare(5*n*n+2*n+1)
    
def isSquare(n):
    root = int(math.sqrt(n))
    return root*root == n

def fib(n):
    a, b = 1, 1
    for i in range(1,n):
        a, b = a+b, a
    return a
def is_prime(i):
    """ function to determine whether an integer is a prime number or not"""
    if i == 1:
        return False
    for divisor in range (2, int(i**0.5)+1):
        if i % divisor == 0: 
            return False
    return True

def largestprime(x):
    factor = 0
    # check for prime number up till square root of x
    for i in range(1,int(x**0.5) +1):
        if x % i == 0 and is_prime(i):
            factor = i
    print(factor)

largestprime(600851475143)
    

#	calculate_square.py

from Tkinter import *
import ttk

def calculate_square(*args):
	value_in = float(number_in.get())
	number_out.set(value_in * value_in)

root = Tk()
root.title('Calculate square')

mainframe = ttk.Frame(root)
mainframe.grid(column=1, row=1, sticky=(N, E, S, W))
mainframe.columnconfigure(0, weight=1)
mainframe.rowconfigure(0, weight=1)

number_in = StringVar()
number_out = StringVar()

square_of_string_label = ttk.Label(mainframe, text='The square of')
square_of_string_label.grid(column=1, row=1, sticky=E)

number_in_entry = ttk.Entry(mainframe, width=5, textvariable=number_in)
number_in_entry.grid(column=2, row=1, sticky=(E, W))

is_string_label = ttk.Label(mainframe, text='is')
is_string_label.grid(column=1, row=2, sticky=E)

number_out_label = ttk.Label(mainframe, textvariable=number_out)
number_out_label.grid(column=2, row=2, sticky=W)

go_button = ttk.Button(mainframe, text='Go!', command=calculate_square)
go_button.grid(column=2, row=3, sticky=W)

for child in mainframe.winfo_children():
	child.grid_configure(padx=2, pady=2)

number_in_entry.focus()
root.bind('<Return>', calculate_square)

root.mainloop()

"""
It was proposed by Christian Goldbach that every odd composite number can be
written as the sum of a prime and twice a square.

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime
and twice a square?
"""

from math import sqrt

primes = [2,3,5,7]

def is_prime(maybe_p):
    root = int(sqrt(maybe_p))
    for prime in primes:
        if prime > root:
            primes.append(maybe_p)
            return True
        if maybe_p % prime == 0:
            return False


def square_generator():
    i = 1
    while True:
        yield i ** 2
        i += 1

def is_goldbach(candidate):
    for p in primes:
        squares = square_generator()

        while True:
            square = squares.next()
            sum = p + (2 * square)
            if sum == candidate:
                return True
            if sum > candidate:
                break

    return False

candidate = 9
while True:
    candidate += 2

    if is_prime(candidate):
        continue

    if not is_goldbach(candidate):
        print "%s violates Goldbach" % candidate
        break


import sys
#import ipdb

def get_ramanujan_squares():
    
    cx = 1
    cy = 1
    
    while True:
        d = abs((cx - cy) // 2)
        
        x = (cx + cy) // 2 if d % 2 == 0 else d
        y = abs((7 * cx - cy) // 2) if d % 2 == 0 else (7 * cx + cy) // 2
        
        cx = x
        cy = y
        
        yield [cx, cy]
        
def pow_seven(n):
    
    p = 0
    d = n
    
    while d % 7 == 0:
        d //= 7
        p += 1
    
    if p > 0:
        t, e = is_root(d, 2 * p + 1)
        
        if t:
            return [True, p, e]
    
    return [False, None, None]
    
def is_root(n, p):
        
    r = get_root(n, p)

    return [r**p == n, r]

def get_root(n, p):
    
    sj, ej = find_search_range(n, p)
    
    return root_binary_search(sj, ej, n, p)

def find_search_range(n, p):

    l = 1
    
    #establish limits of search for binary search for root(n)
    while (l**p < n):
        l *= 2
        
    s = l // 2
    e = l

    return [s, e]

#returns smallest integer whose square is greater than or equal to n
def root_binary_search(s, e, n, p):
    
    while (s <= e):
        m = (s + e) // 2
        
        if (m**p < n):
            s = m + 1
        elif (m**p > n):
            e = m - 1
        else:
            return m
    
    return s - 1
        

def get_all_ram_squares(all=False, nn=50):
    
    r = get_ramanujan_squares()
    x, y = r.__next__()
    
    c = to_n(start=3, end=nn, inf=all)
    
    for i in c:
        try:
            #print(i, ':', x, ',', y)
            
            x, y = r.__next__()
            
            t, p, e = pow_seven(x)
            
            if t:
                print("\t!!!!", x, ':', p, ',', e, "!!!!")
            
            #print(i, ':', x, ',', y, ',', e)
        except KeyboardInterrupt:
            print('\n' + str(i), ':', x, ',', y)
            
            sys.exit(0)
    
def to_n(start=0, end=0, inf=False):
    
    x = start
    
    while inf or x < end:
        yield x
        x += 1
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

class Solution:
   # Time: O(logx/esp)
   # Space: O(1)
   def squareRoot(self, x, esp):
      if self.compare(x, 1.0, esp) < 0:
         l, r = x, 1.0
      else:
         l, r = 1.0, x
      while self.compare(l, r, esp) == -1:
         mid = l + 0.5 * (r - l)
         if self.compare(mid * mid, x, esp) == 0:
            return mid
         elif self.compare(mid * mid, x, esp) == 1:
            r = mid
         else:
            l = mid
      return l

   def compare(self, a, b, esp):
      diff = (a - b) / b
      if diff < -esp: return -1
      return diff > esp

if __name__ == "__main__":
   t = Solution()
   for i in range(1, 10):
      print t.squareRoot(i * 1.0, 0.0001)

from math import sqrt

# The function square_root takes an integer, a, as a parameter,
# and returns an estimate of the square root of a.
def square_root(a):
    x = a / 2.0
    epsilon = 0.000001
    while True:
        y = (x + (a / x)) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x

# The function test_square_root compares the value returned from the above square_root
# function to that returned by the sqrt function in the math library.
def test_square_root():
    space = ' ' * 4
    print "%r %s %r %s %r %s %r" % (1.0, space, square_root(1.0), space, sqrt(1.0), space, square_root(1.0) - sqrt(1.0))
    print "%r %s %r %s %r %s %r" % (2.0, space, square_root(2.0), space, sqrt(2.0), space, square_root(2.0) - sqrt(2.0))
    print "%r %s %r %s %r %s %r" % (3.0, space, square_root(3.0), space, sqrt(3.0), space, square_root(3.0) - sqrt(3.0))
    print "%r %s %r %s %r %s %r" % (4.0, space, square_root(4.0), space, sqrt(4.0), space, square_root(4.0) - sqrt(4.0))
    print "%r %s %r %s %r %s %r" % (5.0, space, square_root(5.0), space, sqrt(5.0), space, square_root(5.0) - sqrt(5.0))
    print "%r %s %r %s %r %s %r" % (6.0, space, square_root(6.0), space, sqrt(6.0), space, square_root(6.0) - sqrt(6.0))
    print "%r %s %r %s %r %s %r" % (7.0, space, square_root(7.0), space, sqrt(7.0), space, square_root(7.0) - sqrt(7.0))
    print "%r %s %r %s %r %s %r" % (8.0, space, square_root(8.0), space, sqrt(8.0), space, square_root(8.0) - sqrt(8.0))
    print "%r %s %r %s %r %s %r" % (9.0, space, square_root(9.0), space, sqrt(9.0), space, square_root(9.0) - sqrt(9.0))


# http://mathworld.wolfram.com/SchinzelsTheorem.html
# http://en.wikipedia.org/wiki/Lattice_(group)
# http://mathworld.wolfram.com/CircleLatticePoints.html
# http://mathworld.wolfram.com/SquareNumber.html
# http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer

# http://www.mathpages.com/home/kmath265.htm

from math import sqrt

def f(n):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n/2)**2
    s = sqrt
    i = 1
    for x in range(1, w) :
        y = s(-x**2 + r)
        if int(y) == y :
            i+=1
            #print(str(x) + "," + str(y))
    return i*4

#print(f(10000))

def f420(n, p):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n/2)**2
    s = sqrt
    i = 1
    t = int
    for x in range(1, w) :
        y = s(r - x*x) # is perfect square????
        #y = (r - x*x) ** 0.5
        if t(y) == y :
        #if (r - x*x) % 2:
            i+=1
            #print(str(x) + "," + str(y))
            if i > p :
                return 0
    return i

def prob(d, p):
    p = p // 4
    x = 0
    for n in range(p, d+1):
        if f420(n, p) == p:
            #print(n)
            x+=n
    return x

print(prob(10**4, 420))

#! usr/bin/env python

"""
http://programmingpraxis.com/contents/themes/
UNFINISHED
"""

THRESHOLD = 0.000001

def within_threshold(val):
	return val <= THRESHOLD

def bisection(x):
	lower_limit = 1
	upper_limit = x
	prev_midpoint = 0
	midpoint = (upper_limit + lower_limit) / 2
	candidate_square = midpoint ** 2
	
	while not within_threshold(abs(candidate_square - x)) and \
			not within_threshold(abs(prev_midpoint - midpoint)):
		if candidate_square > x:
			upper_limit = midpoint
		else:
			lower_limit = midpoint
		
		prev_midpoint = midpoint
		midpoint = ((upper_limit + lower_limit) / 2)
		candidate_square = midpoint ** 2
	
	return midpoint

def hero(x):
	lower_limit = 1
	upper_limit = x
	prev_cand_root = 0
	candidate_root = (upper_limit + lower_limit) / 2
	candidate_square = candidate_root ** 2
	
	while not within_threshold(abs(candidate_square - x)) and \
			not within_threshold(abs(candidate_root - prev_cand_root)):
		if candidate_square > x:
			upper_limit = candidate_root
		else:
			lower_limit = candidate_root
		
		prev_cand_root = candidate_root
		candidate_root = (candidate_root + (x / candidate_root)) / 2
		candidate_square = candidate_root ** 2
	
	return candidate_root

def newtons_method(x):	
	candidate_root = ((x + 1) / 2)
	candidate_square = candidate_root ** 2
	prev_cand_root = 0
	
	while not within_threshold(abs(candidate_root - x)) and \
			not within_threshold(abs(candidate_root - prev_cand_root)):
		prev_cand_root = candidate_root
		candidate_root -= (candidate_root ** 2 - x) / (2 * x)
	
	return candidate_root

def reduce_to_range(x):
	"""
	Reduces a number x to a number in the range [1, 2) by repeated division
	or multiplication.
	
	An iterable with two elements: the first one being the reduced number and
	the next one being another iterable of True and False. The nth element of
	this iterable is True if for the nth iteration of this function,
	MULTIPLICATION was applied. Otherwise, it is False and DIVISION was applied.
	"""
	reduced_number = x
	reduction_path = []
	
	while reduced_number > 2 or reduced_number < 1:
		if reduced_number > 2:
			reduced_number /= 2
			reduction_path.append(False)
		elif reduced_number < 1:
			reduced_number *= 2
			reduction_path.append(True)
	
	return (reduced_number, reduction_path)

def optimized_newtons(x):
	reduction = reduce_to_range(x)
	sqrt_2 = newtons_method(2)
	sqrt_x = reduction[0]
	
	for step in reduction[1]:
		if step:
			sqrt_x *= sqrt_2
		else:
			sqrt_x /= sqrt_2
	
	return sqrt_x

if __name__ == "__main__":
	tests = [4, 5, 16, 23, 40, 2, 167, 125348]
	print("THRESHOLD: " + str(THRESHOLD))
	print("==========BISECTION==========")
	for test_case in tests:
		print("sqrt(" + str(test_case) + ") = " + str(bisection(test_case)))
	print("==========HERO'S==========")
	for test_case in tests:
		print("sqrt(" + str(test_case) + ") = " + str(hero(test_case)))
	print("==========NEWTON'S==========")
	for test_case in tests:
		print("sqrt(" + str(test_case) + ") = " + str(newtons_method(test_case)))
	print("==========OPTIMIZED==========")
	for test_case in tests:
		print("sqrt(" + str(test_case) + ") = " + str(optimized_newtons(test_case)))

def squareRoot(num, epsilon):
    iteration = 0
    result = 0.0
    while abs(result ** 2 - num) > epsilon and result < num:
        result += epsilon ** 2
        iteration += 1
    print iteration
    return result

print squareRoot(25, 0.1)

from sys import float_info as sfi

def square_root (n):
    '''Square root calculated using Netwton's method
    '''
    x = n/2.0
    while True:
        y = (x + n/x)/2
        # As equality in floating numbers can be elusive,
        # we check if the numbers are close to each other.
        if abs(y-x) < sfi.epsilon:
            break
        x = y

    return x

def factorial_new(n):
    '''Factorial using for loop
    '''
    result = 1
    if n < 0: return None
    if n == 0: return 1
    for i in range(1, n+1):
        result = result * i

    return result

def skipper01(end, start=0, step=1):
    for i in range(start, end, step):
        print(i, end=' ')

def skipper02(end, start=0, step=1):
    i = start
    while(i < end):
        print(i, end=' ')
        i = i + step

if __name__ == "__main__":
    print("The square root of 4 = " + str(square_root(4)))
    print("The square root of 9 = " + str(square_root(9)))
    print("The square root of 15 = %.4f " % square_root(14))
    print("The factorial of 4 = " + str(factorial_new(4)))
    print("The factorial of 7 = " + str(factorial_new(7)))
    print("The factorial of 10 = %d " % factorial_new(10))
    skipper01(10, 5, 2)
    print('\n')
    skipper02(13, 3, 3)
    print('\n')
    skipper01(8)
    print('\n')
    skipper02(7)

#!/usr/bin/python

def square_root(x):
	def update(guess):
		return average(guess,x/guess)
	def test(guess):
		return approx_eq(square(guess),x)
	return iter_improve(update,test)

def approx_eq(x,y,tol=1e-5):
	return abs(x-y) < tol

def square(x):
	return x*x

def average(x,y):
	return (x+y)/2

def iter_improve(update,test,guess=1):
	while not test(guess):
		guess = update(guess)
	return(guess)

#def sqrt_update(guess,x):
#	return average(guess,x/guess) 

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from fractions import Fraction
from numlib import is_square
def get_digit_square_root(n, num_digit = 2):
	if num_digit == 0:
		return Fraction(int(n**0.5))
	else:
		base = get_digit_square_root(n, num_digit - 1)
		denominator = 10**num_digit
		d = 1
		while (base + Fraction(d,denominator))**2 <= n:
			d += 1
		return base + Fraction(d - 1, denominator)

def count_first_n_digit(f, n = 100):
	denominator = f.denominator
	m = int(f) + n
	mult = 10**m / f.denominator
	numerator = str(f.numerator * mult)
	s = 0
	for i in range(n):
		s += int(numerator[i])
	return s

def main():
	s = 0
	for n in range(1, 101):
		if not(is_square(n)):
			f = get_digit_square_root(n, 100)
			print n, f
			s += count_first_n_digit(f)
			print count_first_n_digit(f), f
	print "count:", s

main()
#!/usr/bin/python

import sys

class Calculator:
    def square_root_bisection(self, num):
        epsilon = 0.01
        num_guesses = 0
        low = 0.0
        high = num
        ans = (high + low) / 2.0

        while abs(ans**2 - num) >= epsilon:
            num_guesses += 1
            if ans**2 < num:
                low = ans
            else:
                high = ans
            ans = (high + low) / 2.0

        return ans

calc = Calculator()
number = int(sys.argv[1])
print calc.square_root_bisection(number) 

# Project Euler problem 80
# cf. http://d.hatena.ne.jp/inamori/20100216/p1

from decimal import Decimal, getcontext
from projecteuler import cntfrac_sqrt, flatten, squares_below, time_func
from itertools import repeat, dropwhile, count
from math import sqrt


def cntfrac2float(fractions):
    """Calculate continued fraction and return a float type number.
    arrange the projecteuler.cntfrac2float"""
    getcontext().prec = 101
    f = Decimal("0.0")
    n = len(fractions)-1
    while n > 0:
        f = Decimal("1.0") / (fractions[n] + f)
        #print f
        n -= 1
    return f + fractions[0]

def sum_digits(numbers):
    """Return the sum of the first one hundred decimal digits
    for all the irrational square root."""
    numbers = list(str(numbers))
    numbers.remove(".")
    numbers = numbers[:100]
    return sum([int(x) for x in numbers])

def create_cntfrac(fraction):
    new_frac = [[fraction[0]]]
    for i in repeat(fraction[1:], 200/len(fraction[1:])):
        new_frac.append(i)
    new_frac = flatten(new_frac)
    return new_frac

def main1():
    """answer is wrong."""
    answer = 0
    squares = squares_below(101)
    for i in range(1, 101):
        if i in squares:
            #print int(sqrt(i))
            pass
        else:
            fractions = create_cntfrac(cntfrac_sqrt(i))
            num = cntfrac2float(fractions)
            #print num
            #print sum_digits(num)
            answer += sum_digits(num)
    #answer += 55
    print answer

def head(a):
    for e in a:
        return e

def take(n, a):
    counter = 0
    for e in a:
        yield e
        counter += 1
        if counter == n:
            break

def gen_digits(n):
    while n:
        yield n % 10
        n /= 10

def square_root(n, l, m = 0):
    if l == 0:
        return m
    
    d = head(dropwhile(lambda d: d * (d + 20 * m) <= n, count(1))) - 1
    n -= d * (d + 20 * m)
    m = m * 10 + d
    return square_root(n * 100, l - 1, m)

def main2():
    N = 100
    M = 100
    print sum(map(lambda n: sum(gen_digits(square_root(n, M))),
            filter(lambda n: square_root(n, 1) ** 2 != n, range(1, N + 1))))

if __name__ == '__main__':
    time_func(main2)

from decimal import Decimal, getcontext
import heapq
import sys

class Square():
    def __init__(self, x, y, sin_theta, cos_theta, edge):
        self.x = x
        self.y = y
        self.sin_theta = sin_theta
        self.cos_theta = cos_theta
        self.edge = edge

    def __str__(self):
        return str((self.x, self.y, self.sin_theta, self.cos_theta, self.edge))

    def __repr__(self):
        return self.__str__()

    def build_left_square(self):
        x = self.x - self.edge * self.sin_theta
        y = self.y + self.edge * self.cos_theta
        sin_theta = self.sin_theta * Decimal(0.8) + self.cos_theta * Decimal(0.6)  
        cos_theta = self.cos_theta * Decimal(0.8) - self.sin_theta * Decimal(0.6)
        edge = self.edge * Decimal(0.8)
        return Square(x, y, sin_theta, cos_theta, edge)

    def build_right_square(self):
        x = self.x - Decimal(1.48) * self.edge * self.sin_theta + Decimal(0.64) * self.edge * self.cos_theta
        y = self.y + Decimal(0.64) * self.edge * self.sin_theta + Decimal(1.48) * self.edge * self.cos_theta
        sin_theta = - self.cos_theta * Decimal(0.8) + self.sin_theta * Decimal(0.6)
        cos_theta = self.sin_theta * Decimal(0.8) + self.cos_theta * Decimal(0.6)
        edge = self.edge * Decimal(0.6)
        return Square(x, y, sin_theta, cos_theta, edge)

    def get_leftmost_coordinate(self):
        coordinates = [
            self.x,
            self.x + self.edge * self.cos_theta,
            self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
            self.x - self.edge * self.sin_theta,
        ]
        return sorted(coordinates)[0]

    def get_rightmost_coordinate(self):
        coordinates = [
            self.x,
            self.x + self.edge * self.cos_theta,
            self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
            self.x - self.edge * self.sin_theta,
        ]
        return sorted(coordinates)[-1]

    def get_topmost_coordinate(self):
        coordinates = [
            self.y,
            self.y + self.edge * self.sin_theta,
            self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
            self.y + self.edge * self.cos_theta,
        ]
        return sorted(coordinates)[-1]

    def get_bottommost_coordinate(self):
        coordinates = [
            self.y,
            self.y + self.edge * self.sin_theta,
            self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
            self.y + self.edge * self.cos_theta,
        ]
        return sorted(coordinates)[0]

class PythagoreanTree():
    def __init__(self, root_square):
        self.INF = 10**100
        self.root_square = root_square

    def get_boundary_coordinate(self):
        h = []
        index = 0
        heapq.heappush(h, (self.get_boundary(self.root_square), index, self.root_square))

        performance_counter = 0
        boundary_so_far = self.INF
        while performance_counter < 10**5:
            performance_counter += 1
            boundary, dummy_index, square = heapq.heappop(h)
            if square.edge < 1e-15:
                continue
            if boundary < boundary_so_far:
                boundary_so_far = boundary
            left_square = square.build_left_square()
            right_square = square.build_right_square()
            heapq.heappush(h, (self.get_boundary(left_square), index + 1, left_square))
            heapq.heappush(h, (self.get_boundary(right_square), index + 2, right_square))
            index += 2
        return boundary_so_far

class PythagoreanLeftmostTree(PythagoreanTree):
    def __init__(self):
        root_square = Square(Decimal(0), Decimal(0), Decimal(0), Decimal(1), Decimal(1))
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        super().__init__(root_square)

    def get_boundary(self, square):
        return square.get_leftmost_coordinate()

class PythagoreanRightmostTree(PythagoreanTree):
    def __init__(self):
        root_square = Square(Decimal(0), Decimal(0), Decimal(0), Decimal(1), Decimal(1))
        root_square = root_square.build_right_square()
        root_square = root_square.build_right_square()
        root_square = root_square.build_left_square()
        super().__init__(root_square)

    def get_boundary(self, square):
        return -square.get_rightmost_coordinate()

class PythagoreanTopmostTree(PythagoreanTree):
    def __init__(self):
        root_square = Square(Decimal(0), Decimal(0), Decimal(0), Decimal(1), Decimal(1))
        root_square = root_square.build_left_square()
        root_square = root_square.build_right_square()
        root_square = root_square.build_left_square()
        super().__init__(root_square)

    def get_boundary(self, square):
        return -square.get_topmost_coordinate()

class PythagoreanBottommostTree(PythagoreanTree):
    def __init__(self):
        root_square = Square(Decimal(0), Decimal(0), Decimal(0), Decimal(1), Decimal(1))
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        root_square = root_square.build_left_square()
        super().__init__(root_square)

    def get_boundary(self, square):
        return square.get_bottommost_coordinate()

class Problem():
    def solve(self):
        getcontext().prec = 20
        min_x = PythagoreanLeftmostTree().get_boundary_coordinate()
        max_x = -PythagoreanRightmostTree().get_boundary_coordinate()
        min_y = PythagoreanBottommostTree().get_boundary_coordinate()
        max_y = -PythagoreanTopmostTree().get_boundary_coordinate()
        print('min_x =>', min_x)
        print('max_x =>', max_x)
        print('min_y =>', min_y)
        print('max_y =>', max_y)
        print('area =>', (max_x - min_x) * (max_y - min_y))

def main():
    problem = Problem()
    problem.solve()

if __name__ == '__main__':
    sys.exit(main())

#!/usr/bin/env python
# Simple Daikon-style invariant checker
# Andreas Zeller, May 2012
# Complete the provided code around lines 28 and 44
# Do not modify the __repr__ functions.
# Modify only the classes Range and Invariants,
# if you need additional functions, make sure
# they are inside the classes.

import sys
import math
import random

#############
### DEBUG ###
#############
# debug #
#########

breakpoints = {118:True}
watchpoints = {'c': True}
stepping = False


def debug(command, my_arg, my_locals):
  global stepping
  global breakpoints
  global watchpoints
  
  if command.find(' ') > 0:
    arg = command.split(' ')[1]
  else:
    arg = None
    
  if command.startswith('s'):
    stepping = True
    return True
  elif command.startswith('c'):
    stepping = False
    return True
  elif command.startswith('p'):    # print 
    if (arg == None):
      print my_locals
    elif(arg in my_locals):
      print arg,' = ', repr(my_locals[arg])
    else:
      print 'No such variable:', arg
  elif command.startswith('b'):    # breakpoint         
    if(arg == None):
      print 'You must supply a line number'
    else:
      breakpoints[int(arg)] = True
  elif command.startswith('w'):    # watch variable
    if arg == None:
      print "You must supply a variable name"
    else:
      watchpoints[arg] = True 
  elif command.startswith('q'):
    sys.exit(0)
  else:
    print "No such command", repr(command)
  return False



############
### main ###
############


def square_root(x, eps = 0.00001):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(square(y) - x) <= eps
    return y
    
def square(x):
    return x * x

# The Range class tracks the types and value ranges for a single variable.
class Range:
    def __init__(self):
        self.min  = None  # Minimum value seen
        self.max  = None  # Maximum value seen
    
    # Invoke this for every value
    def track(self, value):
        # YOUR CODE
        if self.min == None and self.max == None:
            self.min = value
            self.max = value          
        if value <= self.min:
            self.min = value
        elif value > self.max:
            self.max = value
        
            
    def __repr__(self):
        return repr(self.min) + ".." + repr(self.max)




# The Invariants class tracks all Ranges for all variables seen.
class Invariants:
    def __init__(self):
        # Mapping (Function Name) -> (Event type) -> (Variable Name)
        # e.g. self.vars["sqrt"]["call"]["x"] = Range()
        # holds the range for the argument x when calling sqrt(x)
        self.vars = {}
        self.vars["square_root"]={}
        self.vars["square_root"]["call"]={}
        self.vars["square_root"]["call"]["x"]=Range()
        self.vars["square_root"]["call"]["eps"]=Range()
        self.vars["square_root"]["return"]={}
        self.vars["square_root"]["return"]["y"]=Range()
        self.vars["square_root"]["return"]["ret"]=Range()
        
        
    def track(self, frame, event, arg):
           
        # YOUR CODE HERE. 
        # MAKE SURE TO TRACK ALL VARIABLES AND THEIR VALUES
        # If the event is "return", the return value
        # is kept in the 'arg' argument to this function.
        # Use it to keep track of variable "ret" (return)
        if event == "call" and frame.f_code.co_name == "square_root":
            self.vars[frame.f_code.co_name][event]["x"].track(frame.f_locals["x"])
            self.vars[frame.f_code.co_name][event]["eps"].track(frame.f_locals["eps"])
        elif event == "return" and frame.f_code.co_name == "square_root": 
            self.vars[frame.f_code.co_name][event]["y"].track(frame.f_locals["y"])
            self.vars[frame.f_code.co_name][event]["ret"].track(arg)
    
    def __repr__(self):
        # Return the tracked invariants
        s = ""
        for function, events in self.vars.iteritems():
            for event, vars in events.iteritems():
                s += event + " " + function + ":\n"
                # continue
                
                for var, range in vars.iteritems():
                    s += "    assert "
                    if range.min == range.max:
                        s += var + " == " + repr(range.min)
                    else:
                        s += repr(range.min) + " <= " + var + " <= " + repr(range.max)
                    s += "\n"
                
        return s

invariants = Invariants()
    
def traceit(frame, event, arg):
    #print event, frame.f_lineno, frame.f_code.co_name, frame.f_locals
    invariants.track(frame, event, arg)
    return traceit

sys.settrace(traceit)
# Tester. Increase the range for more precise results when running locally
eps = 0.000001
testo = [3, 0, -10]
for i in range(1, 1000):
    r = int(random.random() * 1000) # An integer value between 0 and 999.99
    z = square_root(r, eps)
    z = square(z)
sys.settrace(None)
print invariants


# https://leetcode.com/problems/sqrtx/
'''
Implement int sqrt(int x).

Compute and return the square root of x.

Hide Tags Math Binary Search
'''
class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        if x < 0:
            return None
        if x == 0:
            return 0

        l = 0
        r = x
        while l <= r:
            m = (l + r) / 2
            if m * m == x:
                return m
            elif m * m < x and (m + 1) * (m + 1) > x:
                return m
            elif m * m < x:
                l = m + 1
            elif m * m > x:
                r = m - 1

#8.8.py
#Calculating the Square Root of a Number using Newton-Raphson Method 


#Function to return absolute value
def absoluteValue(x):        
        if(x<0):
           x=-x
        return x

#function to calculate square root
def squareRoot(x):
        epsilon=0.0001
        guess=1.0
        while(absoluteValue(guess*guess-x)>=epsilon):
                guess=(x/guess+guess)/2.0
        return guess

#Main()
def main():
        print("squareRoot (2.0) = {0}".format(squareRoot (2.0)));
        print("squareRoot (144.0) = {0}".format(squareRoot (144.0)));
        print("squareRoot (17.5) = {0}".format(squareRoot (17.5)));

#Setting top level conditional script
if __name__=='__main__':
        main()



import numpy

def power(x,y=2):
    return x ** y

def square_root(x):
    return numpy.sqrt(x)

import math

def square_root(a, x):
    while True:
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y-x) < epsilon:
            return y
            break
        x = y

def test_square_root(a, x):
    print a, ' ', square_root(a, x), ' ', math.sqrt(a), ' ', abs(square_root(a, x) - math.sqrt(a))

test_square_root(1.0, 1.0)
test_square_root(2.0, 2.0)
test_square_root(3.0, 3.0)
test_square_root(4.0, 3.0)
test_square_root(5.0, 3.0)
test_square_root(6.0, 3.0)
test_square_root(7.0, 4.0)
test_square_root(8.0, 4.0)
test_square_root(9.0, 4.0)


def square_root(a):
    x = a / 2.0

    while True:
        y = (x + a / x) / 2

        # You've reached Python's max float precision
        if x == y:
            return x

        x = y

print square_root(32)
#Program for Mathy Stuffs

"""def f(x):
    return x + 3

def g(x):
    return x ** 2

def squareRoot(x):
    return x ** .5

print(f(5))
print(f(8))
print(f(-22))

print()

print(g(8))
print(g(-6))

print()

print(squareRoot(64))
print(squareRoot(100))

from math import *

print()
print(sqrt(4))"""

#------------------------------------------

from math import *

def areaOfCircle(r):
    '''Computes and returns the are of the circle with radius p'''
    return pi*r**2

print(areaOfCircle(12))

### Compute square root without using the math module. Round down.

# from __future__ import division

# def compute_sqrt(n):
#     return (str(n ** (1/2))).split(".")[0]

# print compute_sqrt(17)



### Better solution:

def compute_sqrt(n):
    
    print int(n**0.5)

print compute_sqrt(17)
def int_rac(n, guess):
    """Integer Square Root of an Integer"""
    x = [guess]
    
    while (x[-1]+n/x[-1])/2 != x[-1]:
        x.append((x[-1]+n/x[-1])/2)
        
    return len(x)
#Potential uses of functions:
    
    def square(x):
    '''
    x: int or float.
    '''
    result = 1
    result = x*x
    return result
    
    #finds the square root
    
    
    def fourthPower(x):
    '''
    x: int or float.
    '''
    return square(square(x))
    
#Finds it to the fourth power
def testable(x):
    r"""
    The 'testable' function returns the square root of its
    parameter, or 3, whichever is larger.
    >>> testable(7)
    3.0
    >>> testable(16)
    4.0
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """

    if x < 9:
        return 3.0
    return x ** 0.5
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""Calculate the square cube of a float number"""

__author__ = 'Nicola Moretto'
__license__ = "MIT"

def squareRootBisection(x, precision):
    '''
    Calculate the square root of a float number through bisection method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None

    # x>=0
    low = 0.0
    high = x
    value = (low+high)/2
    while abs(value**2-x) > precision:
        if value**2 < x:
            low = value
        else: # value**2 > x
            high = value
        value = (low+high)/2

    return value
""" Comparing different ways of finding square root
1st column number a
2nd col square root from written function 
3rd col square root computed by math.sqrt
4th col absolute value of difference between the two estimates
"""

def findsquare(a):
    epsilon = 0.0000001
    x = a/2.0
    while True:
        y = (x + a/x) / 2.0
        if abs(y-x) < epsilon:
            return x
        x = y

def test_square(a):
    import math
    print a,
    print (10-len(str(a)))*' ',
    b = findsquare(a)
    print b,
    print (10-len(str(b)))*' ',
    c = math.sqrt(a)
    print c,
    print (10-len(str(c)))*' ',
    print abs(c - b)

test_square(35)
test_square(1001)
test_square(30000)
test_square(2)




def squareRootExhaustive(x, epsilon):
	step = epsilon * 2
	ans = 0.0
	while abs(ans ** 2 - x) >= epsilon and ans <= max(x, 1):
		ans += step
	return ans

def squareRootBinary(x, epsilon):
	low = 0.0
	high = max(1.0, x)
	ans = (low + high) / 2.0

	while abs(ans ** 2 - x) >= epsilon:

		if ans ** 2 < x:
			low = ans
		else:
			high = ans

		ans = (high + low) / 2.0

	return ans

print squareRootExhaustive(25, 0.0001)
print squareRootBinary(25, 0.0001)
import math
from flask import Flask, render_template, request
app = Flask(__name__)

@app.route('/api')
def index():
    q = request.args.get('q')
    try:
        result = str(api(request.args))
        print q, '=>', result
        return result
    except Exception, e:
        return str(0)

@app.route('/api2')
def index2():
    q = request.args.get('q')
    result = str(api(request.args))
    print q, '=>', result
    return result

def api(args):
    q = args['q']
    if "largest" in q or "primes" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        numbers = q.split(':')[2]
        numbers = map(int, numbers.split(', '))
        if "largest" in q:
            return largest(numbers)
        else:
            return ','.join(map(str, prime(numbers)))
    elif "anagram" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        text2 = q.split(':')[2]
        text = text.split(' ')
        text2 = text2.split(' ')
        check = text[9][1:-1]
        words = [x.replace(',', '') for x in text2[1:]]
        anagrams = filter(lambda x: is_anagram(check, x), words)
        return ','.join(anagrams)
    elif "plus" in q or "multiplied" in q or 'minus' in q:
        # 14 plus 19 multiplied by 19
        hash = q.split(':')[0]
        text = q.split(':')[1]
        text = text.replace(" what is ", '')
        text = text.replace("plus", '+')
        text = text.replace("multiplied by", '*')
        text = text.replace("multiplied", '*')
        text = text.replace("minus", '-')
        return eval(text)
    elif "plus" in q and "multiplied" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        text = text.split(' ')
        x = int(text[3])
        y = int(text[5])
        z = int(text[8])
        return x + (y*z)
    elif "plus" in q or "multiplied" in q or "minus" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        text = text.split(' ')
        x = int(text[3])
        y = int(text[5])
        if "plus" in q:
            return plus([x, y])
        elif "multiplied" in q:
            return x * y
        else:
            return x - y
    elif "Fibonacci" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        index = text.split(' ')[4][:-2]
        return fibo(int(index))
    elif "square and a cube" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        number_str = q.split(':')[2]
        numbers = map(int, number_str.split(','))
        return ','.join(map(str, square_and_cube(numbers)))
    elif "capital" in q and "USA" in q:
        return "Washington, D.C."
    elif "Eiffel tower in" in q:
        return "Paris"
    elif "James Bond" in q:
        return "Sean Connery"
    elif "currency" in q and "Spain":
        return "peseta"
    elif "power of" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        text = text.split(' ')
        x = int(text[3])
        y = int(text[8])
        return x ** y
    return -1

def largest(numbers):
    return max(numbers)

def plus(numbers):
    total = 0
    for n in numbers:
        total += n
    return total

def square_and_cube(numbers):
    return filter(is_square_and_cube, numbers)

def is_square_and_cube(number):
    square_root = number ** 0.5
    cube_root = number ** (1/3.0)
    return equal_float(square_root, int(square_root)) and equal_float(cube_root, int(cube_root))

def equal_float(a, b):
    return abs(a - b) < 0.00001

def prime(numbers):
    return filter(is_prime, numbers)

def is_prime(n):
    if n % 2 == 0 and n > 2:
        return False
    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))

def fibo(n):
    if n < 2:
        return n
    return fibo(n-2) + fibo(n-1)

def is_anagram(a, b):
    return sorted(list(a)) == sorted(list(b))

if __name__ == '__main__':
    app.run(debug=True)

#!/usr/bin/python3
import math

def square_root(n):
    s = int(math.sqrt(n))
    if s * s == n:
        return s
    else:
        return None

for a in range(1, 1000):
    for b in range(a + 1, 1000):
        c = square_root(a * a + b * b)
        if c and a + b + c == 1000:
            print(a * b * c)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

if connection.features.uses_case_insensitive_names:
    t_convert = lambda x: x.upper()
else:
    t_convert = lambda x: x
qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (t_convert(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), t_convert(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}



def root(x):
    epsilon = 0.01
    guess = x/2.0
    while abs(guess*guess - x) >= epsilon:
        guess = guess - (((guess**2) - x)/(2*guess))
        
    return guess
    #print('Square root of ' + str(x) + ' is about '+ str(guess))
    
def square(x):
    return x**2
  
z = square(3)  
print z
import math

def square_root(x):
    return math.sqrt(x)

sq_root = lambda x : math.sqrt(x)


print('square root of {} is {}'.format(64,square_root(64)))
print('square root of {} is {}'.format(64,sq_root(64)))

import scipy as sp
from handlerBlocchi import *
# get eigenvalue returns  an eigenvalue with imaginary part > 0

def gev(matrix):
    x = (matrix[0,0]+matrix[1,1])/2
    y = sp.sqrt(-sp.square(matrix[0,0]-matrix[1,1])-4*matrix[1,0]*matrix[0,1])/2
    return complex(x,y)


def csr0(complex_n):
    s = sp.sqrt(sp.square(complex_n.real)+sp.square(complex_n.imag)) # np.absolute()
    angle = sp.angle(complex_n)
    return sp.sqrt(s)*(complex((sp.cos(angle*0.5)), (sp.sin(angle*0.5))))


def csr1(complex_n):
    CMP0 = (sp.sqrt(sp.square(complex_n.real)+sp.square(complex_n.imag)))/2 #np.absolute()/2
    CMP1 = (complex_n.real/2)
    return complex(sp.sqrt(CMP0+CMP1),sp.sign(complex_n.imag)*(sp.sqrt(CMP0-CMP1)))


# From the book

def csr2(complex_n):
    t = sp.sqrt((sp.absolute(complex_n.real)+(sp.sqrt(sp.square(complex_n.real)+sp.square(complex_n.imag))))/2)
    if(complex_n.real >= 0):
        return complex(t,(complex_n.imag/(2*t)))
    else:
        return complex((complex_n.imag/(2*t)),t)

# De Moivre
    # -- square roots of a complex number are 2; n-roots of a square number are n
    # -- s^(1/n)* [cos((ang/2)+(2pi*k)/n) +i sin((ang/2)+(2pi*k)/n)] with k = [0...n-1]
    # http://www-thphys.physics.ox.ac.uk/people/FrancescoHautmann/Cp4/sl_clx_11_4_cls.pdf

def csr3(complex_n):
    ang = sp.angle(complex_n) # sp.arctan(a.imag/a.real) why it does not work?!?!
    r = sp.sqrt(sp.square(complex_n.real)+sp.square(complex_n.imag))
    if (sp.sin(ang/2)>=0): #sin>0
        return sp.sqrt(r)*(complex(sp.cos(ang/2),sp.sin(ang/2)))
    else:
        return sp.sqrt(r)*(complex(sp.cos((ang/2)+sp.pi),sp.sin((ang/2)+sp.pi)))

    #r1 = sp.sqrt(r)*(complex(sp.cos(ang/2),sp.sin(ang/2)))
    #r2 = sp.sqrt(r)*(complex(sp.cos((ang/2)+sp.pi),sp.sin((ang/2)+sp.pi)))
    #return r1,r2


def blockRoot(matrix):
    if (matrix.shape[0]==2):
        a = csr3(gev(matrix)).real
        ris=sp.ndarray(shape=(2,2))
        ris[0,0] = a + (1/(4*a))*(matrix[0,0] - matrix[1,1])
        ris[1,1] = a - (1/(4*a))*(matrix[0,0] - matrix[1,1])
        ris[0,1] = (1/(2*a))*matrix[0,1]
        ris[1,0] = (1/(2*a))*matrix[1,0]
    else:
        #print(sp.sqrt(matrix))
        return sp.sqrt(matrix)
    return ris

def diagRoots(matrix):
    ris = sp.zeros(shape=matrix.shape)
    bb,eb,dims,wb,i,j = findBlocks0(matrix)
    k=0
    for i in range (0,j):
        ris[k:k+dims[i],k:k+dims[i]] = blockRoot(matrix[k:k+dims[i],k:k+dims[i]])
        #print(matrix[k:k+dims[i],k:k+dims[i]])
        k += dims[i]
        #print k
        #print dims[i]; print '<--Dims'
    return ris

def square_root(s):
    i = 1
    j = s
    while (abs(j - i) > 0.001):
        print i, j
        j = (i + j) / 2.0
        i = s * 1.0/j
    return i

print square_root(100)

# Project Euler Problem 9: Find the product of a, b and c in the 
# pythagorean triplet a^2 + b^2 = c^2 and a + b + c = 1000
# 
# Judith Gammie
# 6th July 2015

import math
def pythag_triplets():
    for i in range (1,1000):
        for j in range (i,1000):
            k_squared = (i*i) + (j*j)
            if (is_square(k_squared) and i + j + math.sqrt(k_squared) == 1000):
                print i * j * math.sqrt(k_squared)
                break

def is_square(number):
    root = math.sqrt(number)
    if int(root + 0.5) ** 2 == number:
        return True
    else:
        return False

pythag_triplets()

#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Pyromaths
# Un programme en Python qui permet de crer des fiches d'exercices types de
# mathmatiques niveau collge ainsi que leur corrig en LaTeX.
# Copyright (C) 2006 -- Jrme Ortais (jerome.ortais@pyromaths.org)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#

'''
Created on 19 dc. 2014

@author: jerome
'''
from pyromaths.outils.Arithmetique import carrerise
from pyromaths.outils.decimaux import decimaux
from pyromaths.outils import Priorites3
# from pyromaths.classes.Fractions import Fraction

from math import sqrt
class SquareRoot():
    '''
    Dfinit la classe SquareRoot permettant de manipuler des racines carres.
    
    SquareRoot([a,b], [c, d], e) ou SquareRoot([a,b], [c, d], [e, None]) permet de dfinir a*sqrt(b)+c*sqrt(d)+e
    
    Cette dfinition permet d'utiliser pyromaths.outils.Priorites3
    
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot(-4,[-2,1],[3,45],[-1,7],8)
    SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])
    '''


    def __init__(self, *radicandes):
        '''
        Constructor
        '''
        #  print radicandes, len(radicandes), radicandes[0], len(radicandes[0])
        if len(radicandes) == 1 and len(radicandes[0]) == 2 and not isinstance(radicandes[0][0], list) and not isinstance(radicandes[0][1], list):
            # SquareRoot([3, 4]),
            self.racines = [radicandes[0]]
        else:
            if len(radicandes) == 1 and (len(radicandes[0]) != 2 or isinstance(radicandes[0][0], list) or isinstance(radicandes[0][1], list)):
                # SquareRoot([1, [3, 4]])
                radicandes = radicandes[0]
            self.racines = []
            for arg in radicandes:
                if isinstance(arg, list) and len(arg) == 2:
                    # On gre a*sqrt(b)
                    if isinstance(arg[1], (float, int))and arg[1] < 0:
                        raise ValueError(u'Le radicande doit tre un nombre positif.')
                    else:
                        self.racines.append(arg)
                elif isinstance(arg, (float, int)):
                    self.racines.append([arg, None])
                else:
                    raise ValueError(u'Not Implemented : SquareRoot(%s)' % arg)

    def __str__(self):
        r"""Renvoie une version LaTeX d'un objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> str(SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]]))
        '-4-2\\,\\sqrt{1}+3\\,\\sqrt{45}-\\sqrt{7}+8'

        :rtype: String
        """
        def print_coef(coef):
            """Gre le format du coef
            """
            if isinstance(coef, (float, int)):
                if coef > 0: return "+" + decimaux(coef)
                else: return decimaux(coef)
            if isinstance(coef, Fraction):
                if isinstance(coef.n, int) and isinstance(coef.d, int) and coef.n < 0 and coef.d > 0:
                    return "-" + str(Fraction(-coef.n, coef.d, coef.code))
                return "+" + str(coef)
            if isinstance(coef, str):
                texte = "(" + "".join(Priorites3.texify([Priorites3.splitting(coef)])) + ")"
                if texte[0] != "-": return "+" + texte
                else: return texte
        s = ""
        for m in self.racines:
            if m[1] == None:
                # pas de racine ici
                s = s + print_coef(m[0])
            else:
                # Racine carre
                if m[0] == 1:
                    s += r'+\sqrt{%s}' % m[1]
                elif m[0] == -1:
                    s += r'-\sqrt{%s}' % m[1]
                else:
                    s += print_coef(m[0]) + r'\,\sqrt{%s}' % m[1]
        # supprime le + en dbut de squence
        s = s.lstrip("+")
        if not s: s = "0"
        return s

    def __repr__(self):
        """Renvoie une chane de caractre reprsentant un :mod:`SquareRoot`
        valuable pour crer un :mod:`SquareRoot`.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> repr(SquareRoot(-4, [-2, 1], [3, 45], [-1, 7], 8))
        'SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])'
        
        :rtype: String
        """
        return "SquareRoot(%s)" % self.racines

    def __len__(self):
        """*object*\ .\ **__len__**\ ()

        Renvoie le nombre d'lments de l'objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> len(SquareRoot(3, [2, 2], [4, 5]))
        3

        :rtype: integer
        """
        return len(self.racines)

    def __getitem__(self, i):
        """*object*\ .\ **__getitem__**\ (*integer*)

        Renvoie le i me lment de l'objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot(3, [2, 2], [4, 5])[2]
        [4, 5]

        :rtype: list
        """
        return self.racines[i]


    def __add__(self, other):
        """Renvoie la somme d'un objet SquareRoot et d'un nombre.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([3,45],3)+SquareRoot([2,45])
        SquareRoot([[3, None], [5, 45]])
        
        :rtype: SquareRoot
        """

        if not isinstance(other, SquareRoot):
            other = SquareRoot([other, None])
        self.racines.extend(other.racines)
        return SquareRoot(self.racines).simplifie()

    def __radd__(self, other):
        """
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> 2+SquareRoot([3,45],3)
        SquareRoot([[5, None], [3, 45]])

        :rtype: SquareRoot
        """
        other = SquareRoot([other, None])
        other.racines.extend(self.racines)
        return SquareRoot(other.racines).simplifie()

    def __neg__(self):
        """*object*\ .\ **__neg__**\ ()

        ``p.__neg__()`` est quivalent  ``-p`` est quivalent  ``p = -p``

        Renvoie l'oppos d'un objet SquareRoot.

        :rtype: SquareRoot
        """
        if self.EstDecomposable() or self.EstReductible(): return '-%r' % self.simplifie()
        r = list(self.racines)
        for i in range(len(r)):
            r[i][0] = -r[i][0]
        return SquareRoot(r)

    def __abs__(self):
        """ Renvoie la valeur absolue d'un objet SquareRoot
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> abs(SquareRoot([5, 5], [-2, 7]))
        SquareRoot([[5, 5], [-2, 7]])
        >>> abs(SquareRoot([-5, 5], [2, 7]))
        SquareRoot([[5, 5], [-2, 7]])
       
        :rtype: SquareRoot
        """
        t = 0
        for e in self.racines:
            if e[1] == None: t += e[0]
            else: t += e[0] * sqrt(e[1])
        if t > 0: return self
        else: return -self


    def __mul__(self, other):
        """Multiplie un objet SquareRoot par un nombre.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([3,45],3)*SquareRoot([2,45],-1)
        SquareRoot([['6*45', None], [-3, 45], [6, 45], [-3, None]])
        """
        if not isinstance(other, SquareRoot):
            other = SquareRoot([other, None])
        reduction = False
        if self.EstReductible():
            self = self.simplifie()
            reduction = True
        if other.EstReductible():
            other = other.simplifie()
            reduction = True
        if reduction: return '%r*%r' % (self, other)
        lprod = []
        for e in self.racines:
            for f in other.racines:
                if e[1] == None or f[1] == None:
                    lprod.append([e[0] * f[0], max(e[1], f[1])])
                elif e[1] == f[1]:
                    lprod.append(['%r*%r' % (e[0] * f[0], e[1]), None])
                elif carrerise(e[1]) == 1 or carrerise(f[1]) == 1:
                    if carrerise(e[1]) == 1: e[0], e[1] = e[0] * int(sqrt(e[1])), 1
                    if carrerise(f[1]) == 1: f[0], f[1] = f[0] * int(sqrt(f[1])), 1
                    lprod.append([e[0] * f[0], e[1] * f[1]])
                else:
                    lprod.append([e[0] * f[0], e[1] * f[1]])
        return SquareRoot(lprod)

    def __rmul__(self, other):
        """
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> 5*SquareRoot([3,45],3)
        SquareRoot([[15, 45], [15, None]])

        :rtype: SquareRoot
        """
        return SquareRoot([other, None]) * self

    def  __floordiv__(self, other):
        """
        Division entire par un entier
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([10, 8], [15, 5])//5
        SquareRoot([[2, 8], [3, 5]])

        :rtype: SquareRoot
        """
        if isinstance(other, int):
            r = list(self.racines)
            for i in range(len(r)):
                r[i][0] = r[i][0] // other
            return SquareRoot(r)
        else:
            raise NotImplemented
    def EstDecomposable(self):
        """
        Renvoie True si une des racines est de la forme sqrt{a**2*b} avec a != 1
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8], [1, 7]).EstDecomposable()
        True
        >>> SquareRoot([5, 7], [1, 7]).EstDecomposable()
        False
     
        :rtype: Boolean
        """
        for e in self.racines:
            if e[1] != None and (carrerise(e[1]) != e[1] or e[1] == 1):
                return True
        return False

    def EstReductible(self):
        """
        Renvoie True si la somme de racines est rductible

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8], [1, 45]).EstReductible()
        False
        >>> SquareRoot([5, 8], [1, 8]).EstReductible()
        True

        :rtype: Boolean
        """
        lradicandes = []
        rationnel = False
        for e in self.racines:
            if e[1] != None:
                if e[1] in lradicandes:
                    return True
                else:
                    lradicandes.append(e[1])
            elif e[1] == None:
                if rationnel: return True
                else: rationnel = True
        return False

    def Decompose(self):
        """
        Dcompose une unique racine carre de la forme a*sqrt(b^2*c) en a*sqrt(b^2)*sqrt(c)
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8]).Decompose()
        'SquareRoot([[5, 4]])*SquareRoot([[1, 2]])'

        :rtype: string
        """
        racine = self.racines[0]
        if racine[1] == None: return repr(racine[0])
        if isinstance(racine[1], int):
            complement = carrerise(racine[1])
            if complement == 1:
                if racine[0] == 1:
                    return int(sqrt(racine[1]))
                if racine[0] == -1:
                    return -int(sqrt(racine[1]))
                if racine[1] == 1:
                    return str(racine[0])
                return '%r*%r' % (racine[0], int(sqrt(racine[1])))
            if complement == racine[1]:
                return repr(self)
            return '%r*%r' % (SquareRoot([racine[0], racine[1] / complement]), SquareRoot([1, complement]))
        raise ValueError(u'Not Implemented : SquareRoot(%s)' % racine)

    def simplifie(self):
        """
        Additionne les nombres rationnels et dcompose les racines carres.
         
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([[3, 9]]).simplifie()
        '3*3'
        >>> SquareRoot(-2, [-2, 1], [3, 1], [-1, 7], 8).simplifie()
        SquareRoot([[6, None], [1, 1], [-1, 7]])
        >>> SquareRoot(-2, [-2, 1], [3, 45], [-1, 7], 8).simplifie()
        SquareRoot([[6, None], [-2, 1], [3, 45], [-1, 7]])
        >>> SquareRoot([-2,1],[3,45]).simplifie()
        '-2+SquareRoot([[3, 9]])*SquareRoot([[1, 5]])'
        
        :rtype: SquareRoot ou String
        """
        decomposable = self.EstDecomposable()
        reductible = self.EstReductible()
        if not decomposable and not reductible:
            return self
        if reductible:
            racines = []
            # racines = [[sum([x[0] for i, x in enumerate(self.racines) if x[1] == None]), None]]
            # TODO: cas de fractions
            lsomme = [x[0] for i, x in enumerate(self.racines) if x[1] == None]
            s = ''
            for ls in lsomme:
                if isinstance(ls, str): s += '+%s' % ls
                else: s += '+%r' % ls
            s.lstrip('+')
            racines.append([eval(s), None])
            for pos in reversed([i for i, x in enumerate(self.racines) if x[1] == None]):
                    self.racines.__delitem__(pos)
            if racines[0][0] == 0: racines = []
            while len(self.racines) > 0:
                # racines.append([sum([x[0] for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]), self.racines[0][1]])
                # TODO: cas de fractions
                lsomme = [x[0] for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]
                s = ''
                for ls in lsomme:
                    if isinstance(ls, str): s += '+%s' % ls
                    else: s += '+%r' % ls
                s.lstrip('+')
                racines.append([eval(s), self.racines[0][1]])
                if racines[-1][0] == 0: racines.pop(-1)
                for pos in reversed([i for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]):
                    self.racines.__delitem__(pos)
            if racines:
                if len(racines) == 1 and racines[0][1] == None:
                    return racines[0][0]
                else:
                    return SquareRoot(racines)
            else: return 0
        # Dcomposable
        s = ''
        if len(self.racines) == 1 and isinstance(SquareRoot(self.racines).Decompose(), int):
            return SquareRoot(self.racines).Decompose()
        for e in self.racines:
            decomposee = SquareRoot(e).Decompose()
            if isinstance(decomposee, int): decomposee = str(decomposee)
            if decomposee[0]in'+-':
                s += decomposee
            else:
                s += '+' + decomposee
        s = s.lstrip('+')
        return s

def square(x):
    """Return the square of `x`.

    Parameters
    ----------
    x : int or float
        The input number.

    Returns
    -------
    x2 : same type as `x`
        The square of the input value.

    Examples
    --------
    >>> square(5)
    25
    """
    return x ** 2


def sqrt(x):
    """Return the square root of `x`.
    
    Examples
    --------
    >>> sqrt(4.0)
    2.0
    """
    return x * 0.5


import itertools
from fractions import Fraction

def sqrt_two_expansion():
    partial_sum = Fraction(3, 2)
    while True:
        yield partial_sum
        partial_sum = 1 + 1/(partial_sum+1)

def euler57():
    """http://projecteuler.net/index.php?section=problems&id=57
    
    Investigate the expansion of the continued fraction for the square root of
    two."""
    generator = sqrt_two_expansion()
    return len(filter(lambda x: len(str(x.numerator)) > len(str(x.denominator)),
        itertools.islice(generator, 1000)))


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

if connection.features.uses_case_insensitive_names:
    t_convert = lambda x: x.upper()
else:
    t_convert = lambda x: x
qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (t_convert(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), t_convert(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# MIT6002008
# 
# ocourse.org
# http://ocourse.org/bbs/forum.php?mod=forumdisplay&fid=29
# by yoeo24

def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    #x>=0>0yy*yx
    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    low = 0
    high = max(x,1.0)
    #high = max(x,1)
    guess = (low + high)/2.0
    ctr = 1
    while abs(guess**2 - x) > epsilon and ctr <= 100:
        #print 'low:', low, 'high:', high, 'guess:', guess
        if guess**2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high)/2.0
        ctr += 1
    assert ctr <=100, ''
    print 'Bi', ctr, '', guess
    return guess

def testBi():
    print '     squareRoot(4, 0.0001)'
    squareRootBi(4, 0.0001)
    print '     squareRoot(9, 0.0001)'
    squareRootBi(9, 0.0001)
    print '     squareRoot(2, 0.0001)'
    squareRootBi(2, 0.0001)
    print '     squareRoot(0.25, 0.0001)'
    squareRootBi(0.25, 0.0001)

def squareRootNR(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    #x>=0>0yy*yx
    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    x = float(x)
    guess = x/2.0
    #guess = 0.001
    diff = guess**2 -x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:
        #print ':', diff, ':', guess
        guess = guess - diff/(2.0*guess)
        diff = guess**2 - x
        ctr += 1
    assert ctr <=100, ''
    print 'NR', ctr, '', guess
    return guess

def compareMethods():
    print '     squareRoot(2, 0.01)'
    squareRootBi(2, 0.01)
    squareRootNR(2, 0.01)
    raw_input()
    print '     squareRoot(2, 0.0001)'
    squareRootBi(2, 0.0001)
    squareRootNR(2, 0.0001)
    raw_input()
    print '     squareRoot(2, 0.000001)'
    squareRootBi(2, 0.000001)
    squareRootNR(2, 0.000001)
    raw_input()
    print '     squareRoot(123456789, 0.0001)'
    #
    squareRootBi(123456789, 0.0001)
    squareRootNR(123456789, 0.0001)
    raw_input()
    print '     squareRoot(123456789, 0.0000001)'
    squareRootBi(123456789, 0.0000001)
    squareRootNR(123456789, 0.0000001)
    raw_input()
    print '     squareRoot(2736336100, 0.0001)'
    squareRootBi(2736336100, 0.0001)
    squareRootNR(2736336100, 0.0001)
    raw_input()

def showLists():
    Techs = ['MIT', 'Cal Tec']
    print Techs
    raw_input()
    Ivys = ['Harvard', 'Yale', 'Brown']
    print Ivys
    raw_input()
    Univs = []
    Univs.append(Techs)
    print Univs
    raw_input()
    Univs.append(Ivys)
    print Univs
    raw_input()
    for e in Univs:
        print e
        for c in e: print c
    raw_input()
    Univs = Techs + Ivys
    print Univs
    raw_input()
    Univs.remove('Harvard')
    print Univs

from problem_utils import *

class SquareOfDigits:
    def getMax(self, data):
        input_array = data
        # You are given a String[] data representing a rectangular grid where each cell contains a digit.
        # Find the largest square in this grid that contains the same digit in all of its corner cells.
        find(largest(square, that(contains(same(digit, all, corner)))))
        # The sides of the square must be parallel to the sides of the grid.
        # If there is more than one such largest square, pick any one of them.
        # Return the number of cells in the square.
        # ROOT-0(root=Return-1(dep=number-3(det=the-2, prep_of=cells-5(prep_in=square-8(det=the-7)))))
        return(number(cells(square)))
        # Note that a single cell is also considered a square, so there will always be an answer.



def example0():
	cls = SquareOfDigits()
	input0 = ["12", "34"]
	returns = 1
	result = cls.getMax(input0)
	return result == returns


def example1():
	cls = SquareOfDigits()
	input0 = ["1255", "3455"]
	returns = 4
	result = cls.getMax(input0)
	return result == returns


def example2():
	cls = SquareOfDigits()
	input0 = ["42101", "22100", "22101"]
	returns = 9
	result = cls.getMax(input0)
	return result == returns


def example3():
	cls = SquareOfDigits()
	input0 = ["1234567890"]
	returns = 1
	result = cls.getMax(input0)
	return result == returns


def example4():
	cls = SquareOfDigits()
	input0 = ["9785409507", "2055103694", "0861396761", "3073207669", "1233049493", "2300248968", "9769239548", "7984130001", "1670020095", "8894239889", "4053971072"]
	returns = 49
	result = cls.getMax(input0)
	return result == returns



if __name__ == '__main__':
	print(example0())
#!/usr/bin/env python

def r8_pi_sqrt ( ):

#*****************************************************************************80
#
## R8_PI_SQRT returns the square root of pi as an R8.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 June 2013
#
#  Author:
#
#    John Burkardt
#
#  Parameters:
#
#    Output, real VALUE, the square root of pi.
#
  value = 1.7724538509055160273

  return value


'''
Created on 24.08.2014

Problem 21 of Euler Problems

"Evaluate the sum of all the amicable numbers under 10000."
https://projecteuler.net/problem=21

@author: vls
'''

import numpy

def return_all_factors(n):
    """faster way to get all factors"""
    #primes=Problem_003.primesfrom2to(n)
    square_root = int(numpy.sqrt(n))
    if square_root*square_root!=n:
        return reduce(list.__add__, 
                ([i, n//i] for i in range(1,int(square_root)+1) if n % i == 0))
    else:
        factor_list = reduce(list.__add__,([i, n//i] for i in range(1,int(square_root)) if n % i == 0))
        factor_list.append(square_root)
    return factor_list

def is_amicable_pair(n):
    """tests if it is amicable pair, and returns the pair"""
    list_factors=return_all_factors(n)
    pair = sum(list_factors)-n
    if pair==1:
        return False
    
    list_factors_pair = return_all_factors(pair)
    
    if sum(list_factors_pair)-pair!= n:
        return False
    return pair


def find_all_amicable_numbers(n):
    """finds all amicable numbers until n"""
    list_pairs=[]
    for i in range(2,n+1):
        if i not in list_pairs:
            pair = is_amicable_pair(i)
            if pair==i: #perfect number
                continue
            if pair:
                list_pairs.append(i)
                list_pairs.append(pair)
    for item in list_pairs:
        if item>n:
            list_pairs.remove(item)
    return list_pairs
            


if __name__=='__main__':
    print sum(find_all_amicable_numbers(10000))
    #print is_amicable_pair(2)
    # return_all_factors(2)
    #print numpy.sqrt(9)
    '''for i in range(8,9):
        pair = is_amicable_pair(i)
        if pair:
            print str(pair)+', '+str(i)''' 
from turtle import *
import tkinter
from heap import *
from math import fabs

data = {}
data['globVisited'] = []


class Queue:
    def __init__(self):
        self.items = Heap()
    def enqueue(self, anitem):
        self.items.insert(anitem)
    def dequeue(self):
        return self.items.delMin()
    def isEmpty(self):
        return self.items.size()==0
    def size(self):
        return self.items.size()
    def empty(self):
        self.items = Heap()
        
def main():
    root = tkinter.Tk()
    root.title("A* Search")
    cv = ScrolledCanvas(root,600,600,600,600)
    cv.pack(side = tkinter.LEFT)
    frame = tkinter.Frame(root)
    frame.pack(side = tkinter.RIGHT)
    t = RawTurtle(cv)
    t.ht()
    m = RawTurtle(cv)
    screen = t.getscreen()
    screen.setworldcoordinates(0,0,600,600)
    mazeFile = open("maze.txt","r")
    rows = int(mazeFile.readline())
    cols = int(mazeFile.readline())
    maze = []
    for line in mazeFile:
        maze.append(line)
    Q = Queue()
    squareWidth = 600/cols
    squareHeight = 600/rows
    
    class Node:
        def __init__(self,col,row):
            self.row = row
            self.col = col
        def __str__(self):
            st = str(self.col) + ',' + str(self.row)
            return st
        def getCol(self):
            return self.col
        def getRow(self):
            return self.row
        def __lt__(self,other):
            if manhattenDistance(self) < manhattenDistance(other):
                return True
        def __eq__(self,other):
            if self.row == other.row and self.col == other.col:
                return True
            
    class Path:
        def __init__(self,turtle,visitedList):
            self.t = turtle
            self.visitedList = visitedList
        def getTurtle(self):
            return self.t
        def setTurtle(self,turtle):
            self.t = turtle
        def getPath(self):
            return self.visitedList
        def setPath(self,visitedList):
            self.visitedList = visitedList
        def __lt__(self,other):
            if manhattenDistance(self.getPath()[0]) + len(self.getPath()) < manhattenDistance(other.getPath()[0]) + len(other.getPath()):
                return True
        def __eq__(self,other):
            if manhattenDistance(self.getPath()[0]) + len(self.getPath()) == manhattenDistance(other.getPath()[0]) + len(other.getPath()):
                return True
    
    for c in range(cols):
        if maze[0][c] == ' ':
            startCol = c
    for c in range(cols):
        if maze[rows-1][c] == ' ':
            endCol = c
    startNode = Node(startCol,0)
    goalNode = Node(endCol,rows-1)
    
    def manhattenDistance(currentNode):
        curRow = currentNode.getRow()
        curCol = currentNode.getCol()
        goalRow = goalNode.getRow()
        goalCol = goalNode.getCol()
        rowDiff = goalRow - curRow
        colDiff = goalCol - curCol
        return fabs(colDiff) + fabs(rowDiff)
    
    def drawmaze():
        screen.tracer(0)
        mazeSquares = ((0,0),(squareHeight,0),(squareHeight,squareWidth),(0,squareWidth))
        screen.register_shape("square",mazeSquares)
        m.shape("square")
        m.ht()
        m.up()
        currentWidth = 0
        currentHeight = 600
        m.goto(300,300)
        for i in range(rows):
            screen.update()
            for j in range(cols):
                if maze[i][j] == "*":
                    m.goto(currentWidth,currentHeight)
                    m.stamp()
                currentWidth += squareWidth
                if currentWidth >= 600:
                    currentWidth = 0
                    currentHeight -= squareHeight
        screen.tracer(1)
        
    def adjacentNode(stackObject):
        turtle,visitedList = stackObject
        currentNode = visitedList[0]
        row = currentNode.getRow()
        col = currentNode.getCol()
        adjList = []
        if col != cols-1:
            if maze[row][col+1] == ' ':
                if data['globVisited'].count((col+1,row)) == 0:
                    data['globVisited'].append((col+1,row))
                    adjList.append(Node(col+1,row))
        if col != 0:
            if maze[row][col-1] == ' ':
                if data['globVisited'].count((col-1,row)) == 0:
                    data['globVisited'].append((col-1,row))
                    adjList.append(Node(col-1,row))
        if row != rows-1:
            if maze[row+1][col] == ' ':
                if data['globVisited'].count((col,row+1)) == 0:
                    data['globVisited'].append((col,row+1))
                    adjList.append(Node(col,row+1)) 
        if row != 0:
            if maze[row-1][col] == ' ':
                if data['globVisited'].count((col,row-1)) == 0:
                    data['globVisited'].append((col,row-1))
                    adjList.append(Node(col,row-1))
        if len(adjList) != 0:
            if len(adjList) > 1:
                temp = adjList.pop()
                newVisitedList = [temp] + visitedList
                turtle.goto((temp.getCol() * squareWidth) + (squareWidth/2),600 - (temp.getRow() * squareHeight) - (squareHeight/2))
                newStackObject = Path(turtle,newVisitedList)
                Q.enqueue(newStackObject)
                while adjList != []:
                    temp1 = adjList.pop()
                    newTurtle = RawTurtle(cv)
                    newTurtle.pu()
                    newTurtle.ht()
                    newTurtle.goto((temp1.getCol() * squareWidth) + (squareWidth/2),600 - (temp1.getRow() * squareHeight) - (squareHeight/2))
                    newTurtle.st()
                    newTurtle.pd()
                    newTurtle.pencolor("red")
                    newTurtle.pensize(7)
                    newVisitedList = [temp1] + visitedList
                    newStackObject = Path(newTurtle,newVisitedList)
                    Q.enqueue(newStackObject)
            else:
                temp = adjList.pop()
                newVisitedList = [temp] + visitedList
                newStackObject = Path(turtle,newVisitedList)
                turtle.goto((newVisitedList[0].getCol() * squareWidth) + (squareWidth/2),600 - (newVisitedList[0].getRow() * squareHeight) - (squareHeight/2))
                Q.enqueue(newStackObject)
            
    def bfs(startingNode,goalNode):
        visitedList = [startingNode]
        startRow = startingNode.getRow()
        startCol = startingNode.getCol()
        data['globVisited'].append((startCol,startRow))
        t.pu()
        t.ht()
        t.pensize(7)
        t.pencolor("red")
        t.goto((startCol * squareWidth) + (squareWidth/2),600 - (startRow * squareHeight) - (squareHeight/2))
        t.pd()
        t.st()
        Q.enqueue(Path(t,visitedList))
        while not Q.isEmpty():
            pathObject = Q.dequeue()
            turtle = pathObject.getTurtle()
            visitedList = pathObject.getPath()
            stackObject = (turtle,visitedList)
            if visitedList[0] == goalNode:
                drawFinishedPath(visitedList)
                Q.empty()
            else:
                adjacentNode(stackObject)
    
    def drawFinishedPath(finishedPath):
        t.pencolor("green")
        t.pensize(7)
        t.ht()
        t.pu()
        while finishedPath != []:
            nextNode = finishedPath.pop(0)
            c = nextNode.getCol()
            r = nextNode.getRow()
            prevc = nextNode.getCol()
            prevr = nextNode.getRow()
            t.goto((c * squareWidth) + (squareWidth/2),600 - (r * squareHeight) - (squareHeight/2))
            t.st()
            t.pd()
            
    drawmaze()
    bfs(startNode,goalNode)
    root.mainloop()
    
    
                
main() 
def isprime(n):
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    max_divisor = int(n ** 0.5) # square root of n
    divisor = 5
    while divisor <= max_divisor:
        if n % divisor == 0 or n % (divisor + 2) == 0:
            return False
        divisor += 6
    return True
#shortest path is always diagonal created by two shorter sides added together and longest side
#in a right triangle
#shortest path is integer if hypotenuse is a square


def is_square(n):
    root = float(n) ** .5
    root = int(root+.5)
    if root*root == n:
        return root
    else:
        return False
        
M = 10000
count = 0
#test function doing it naive way, used to verify next function on small values
for x in range(1,M+1):
    break
    for y in range(1,x+1):
        for z in range(1,y+1):
            if(is_square(x*x + (y+z)*(y+z))):
                count +=1
#print count
count  = 0


#for each possible sum of the shorter two sides I find the number of ways the sides can add up to that                
for x in range(1,M+1):
    for yz in range(2,2*x+1):
        if(is_square(x*x + yz*yz)):
            if yz <= x+1:
                count += yz/2
            else:
                count += yz/2 - (yz - x-1)
    if count > 1000000:
        print "M val", x
        break
print count
            

'''
Find the square root of n.

    Input: A number
    Output: The square root or the integers closest to the square root
    Assume: positive n

 Newton's method is a popular solution for square root, but not implemented here.
'''

def sqrt(n):
    for number in range(0, n):
        if isSqrt(number,n):
            return number
        else:
            if n < number * number:
                return number, number - 1


def isSqrt(a,b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True
    else:
        return False


# Test Section
if __name__ == '__main__':
    print "sqrt(25) = 5: %s" % (sqrt(25) == 5)
    print "sqrt(30) = (6, 5): %s" % (sqrt(30) == (6,5))


#https://github.com/AaronJiang/ProjectEuler/tree/master/py
"""
It is well known that if the square root of a natural number 
is not an integer, then it is irrational. The decimal expansion 
of such square roots is infinite without any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and the digital 
sum of the first one hundred decimal digits is 475.

For the first one hundred natural numbers, find the total of the digital 
sums of the first one hundred decimal digits for all the irrational square roots.
"""
from Helper import isSquare
from math import sqrt
from decimal import getcontext, Decimal

def sumStringNumbers(n):
	total = 0
	for number in n:
		total += int(number)
	return total

def main():
	total = 0
	getcontext().prec = 102
	for n in range(2, 101):
		if not isSquare(n):
			root = str(Decimal(n).sqrt())
			root = root.replace('.','')
			total += sumStringNumbers(root[:100])
	print total

if __name__ == "__main__":
    main()

from math import sqrt

def get_factors(num):
	count = 0
	root = int(sqrt(num)) + 1

	#run from i to the square root of num.  when we find a match, add by 2
	for i in xrange(1, root):
		if num % i == 0:
			count += 2

	#take 1 away because we counted too many when it's a perfect square
	if root * root == num:
		count -= 1
	return count

def triangular_number(divisors):
	count = 1
	triangle_num = 1
	factors = []

	while get_factors(triangle_num) < divisors:
		count += 1
		triangle_num += count
		factors = get_factors(triangle_num)
		
	return triangle_num

print triangular_number(500)
import math

def square_root(a,x):
    """
    a: find the sqrt of a
    x: estimate
    """
    y = (x + a/x)/2
    while abs(y-x)> 0.0000001:
        x = y
        y = (x + a/x)/2
        #print("sqrt:",y)
    return y

def square_root_2(a,x):
    #Using BREAK
    y = (x + a/x)/2
    while True:
        x = y
        y = (x + a/x)/2
        #print("sqrt2:",y)
        if abs(y-x)< 0.0000001:
            break
    return y


def test_square_root():
    a=1.0
    while a<10:
        m = square_root(a,3)
        n = math.sqrt(a)
        print(a,"\t",m,"\t",n,"\t",abs(n-m))
        a = a+1.0

test_square_root()
    

"""
Implement int sqrt(int x).
Compute and return the square root of x.
Problem found here:
http://oj.leetcode.com/problems/sqrtx/
"""

import math

"""
A fairly basic solution which implements the Babylonian method.
I have added in a few options to allow some control over the accuracy
and speed.
"""
class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x, blind_steps=0, accepted_error=1):
        if x < 0:
            print 'error, cannot compute square root of negative number'
            return -1
        if x == 0:
            return x
        root = x/2.0
        steps = -1
        while True:
            root = 0.5 * (root + x/root)
            steps += 1
            if steps >= blind_steps:
                steps = 0 
                if (root * root) - x < accepted_error:
                    return int(root)



#test
sol = Solution()
values = [25, 125, 1, 1234225]
for i in values:
    print 'for the value', i,
    print 'the actual square root is', math.sqrt(i)
    print 'the integer square root we find is', sol.sqrt(i)
    print '---'

def is_square(n):
    root = int(n**0.5)
    return root * root == n

def euler86():
    size = 0
    M = 1
    target = 1000000

    while True:
        for ab in range(2, 2*M+1):
                if is_square((ab)**2 + M**2):
                    if ab < M: size += ab/2
                    else: size += (ab/2-(ab-M)+1)
                    if size > target: return M
        M += 1

if __name__ == "__main__":
    print euler86()

from math import sqrt, factorial, pi
import sys


def square_root(a, x, iteration=0):
    a = float(a)
    if abs(x - sqrt(a)) > 0.000001:  # Checks how accurate the guess(x) is
        next_x = ((x + (a / x)) / 2)  # Newton's Method, readjusts guess(x) every time it's run
        iteration += 1
        return square_root(a, next_x, iteration)
    # print "Number of iterations: %i" % iteration
    return x


def table_print(a, calculated_square_root):
    internal_square_root = sqrt(a)
    difference = abs(calculated_square_root - internal_square_root)
    is_difference = difference < 0.000001
    sys.stdout.write("{:<3}{:<20}{:<20}{:<20}{:<20}\n".format(a, calculated_square_root,
                                                              calculated_square_root,
                                                              difference,
                                                              is_difference))



# result = square_root(9, 100)
sys.stdout.write("{:<3}{:<20}{:<20}{:<20}{:<20}\n".format('n', "square_root",
                 "math.sqrt", "difference", "is difference < 0.000001?"))

table_print(1, square_root(1, 1))
table_print(2, square_root(2, 2))
table_print(3, square_root(3, 2))
table_print(4, square_root(4, 2))
table_print(5, square_root(5, 2))
table_print(6, square_root(6, 3))
table_print(7, square_root(7, 3))
table_print(8, square_root(8, 3))
table_print(9, square_root(9, 3))

left = (2 * sqrt(2)) / 9801
answer = 0
k = 0
while not(abs(answer - (1 / pi)) < 0.000001):
    right_top = (factorial(4 * k)) * (1103 + (26390.0 * k))
    right_bottom = (factorial(k) ** 4) * (396 ** (4 * k))
    right = right_top / right_bottom
    answer = right * left
    k += 1

print answer
#!/usr/bin/python

def nextGuess(guess, x):
	next_guess = (guess + (x/guess)) / 2
	return next_guess
	
def main():
	guess = int(input("Enter a guess for what the square root might be: "))
	x = int(input("Enter the number you want the root of: "))
	print("The next guess is {}".format(nextGuess(guess, x)))
	
if __name__ == "__main__":
	main()
#!/usr/bin/env python

import sys
def square_root(num,guess):
    print 'Current guess: %f' % guess
    return 0.5*(guess + (num/guess))

def main(num,tolerance):
    first_guess = num/2.0
    approx_root = square_root(num,first_guess)
    while True:
        new_guess = square_root(num,approx_root)
        if abs(new_guess-approx_root) < tolerance:
            return new_guess
        else:
            approx_root = new_guess

if __name__ == '__main__':
    num = int(sys.argv[1])
    tol = float(sys.argv[2])
    print main(num, tol)

def findSquareRoot(number):
    low = 0.0
    high = number
    epsilon = 0.00000000001
    guess = (low + high) / 2
    
    while abs(number - guess**2) >epsilon:
        print "high:  " + str(high) + "  low:  " + str(low) + "  guess:   " +str(guess)
        if guess**2 < number:
            low = guess
        elif guess**2 > number:
            high = guess
        elif guess**2 == number:
            return "found square root of" + str(number) + 'would be' + str(guess)
        guess = (low + high)/2
    return "Approximate square root " + str(number) + ' is ' + str(guess)
    
from math import sqrt

def rms(a):
    """
    Computes the root mean square of *a*, which is a numpy array. The
    result is a double constant.
    """
    return sqrt((a**2).mean())

#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import math
import random
import time


# 1.1.1 The Elements of Programming - Expressions

print (486)
print (137 + 349)
print (1000 - 334)
print (5 * 99)
print (10 / 5)
print (2.7 + 10)
print (21 + 35 + 12 + 7)
print (25 * 4 * 12)
print (3 * 5 + 10 - 6)
print (3 * (2 * 4 + 3 + 5) + 10 - 7 + 6)


# 1.1.2 The Elements of Programming - Naming and the Environment

size = 2
print (size)
print (5 * size)
pi = 3.14159
radius = 10
print (pi * radius * radius)
circumference = 2 * pi * radius
print (circumference)


# 1.1.3 The Elements of Programming - Evaluating Combinations

print ((2 + (4 * 6)) * (3 + 5 + 7))


# 1.1.4 The Elements of Programming - Compound Procedures

def square(x): return x * x
print (square(21))
print (square(2 + 5))
print (square(square(3)))
def sum_of_squares(x, y): return square(x) + square(y)
print (sum_of_squares(3, 4))
def f(a): return sum_of_squares(a + 1, a * 2)
print (f(5))


# 1.1.5 The Elements of Programming - The Substitution Model for Procedure Application

print (f(5))
print (sum_of_squares(5 + 1, 5 * 2))
print (square(6) + square(10))
print ((6 * 6) + (10 * 10))
print (36 + 100)
print (f(5))
print (sum_of_squares(5 + 1, 5 * 2))
print (square(5 + 1) + square(5 * 2))

print (((5 + 1) * (5 + 1)) + ((5 * 2) * (5 * 2)))
print ((6 * 6) + (10 * 10))
print (36 + 100)
print (136)


# 1.1.6 The Elements of Programming - Conditional Expressions and Predicates

def abs(x):
   if x > 0:
      return x
   elif x == 0:
      return 0
   else:
      return -x
def abs(x):
   if x < 0:
      return -x
   else:
      return x
x = 6
print (x > 5 and x < 10)
def ge(x, y):
   return x > y or x == y
def ge(x, y):
   return not(x < y)

# Exercise 1.1
print (10)
print (5 + 3 + 4)
print (9 - 1)
print (6 / 2)
print (2 * 4 + 4 - 6)
a = 3
b = a + 1
print (a + b + a * b)
print (a == b)
print (b if b > a and b < a * b else a)
print (6 if a == 4 else 6 + 7 + a if b == 4 else 25)
print (2 + (b if b > a else a))
print ((a if a > b else b if a < b else -1) * (a + 1))

# Exercise 1.2
print (((5.0 + 4.0 + (2.0 - (3.0 - (6.0 + (4.0 / 5.0))))) /
         (3.0 * (6.0 - 2.0) * (2.0 - 7.0))))

# Exercise 1.3
def three_n(n1, n2, n3):
   if n1 > n2:
      if n1 > n3:
         if n2 > n3:
            return n1*n1 + n2*n2
         else:
            return n1*n1 + n3*n3
      else:
         return n1*n1 + n3*n3
   else:
      if n2 > n3:
         if n1 > n3:
            return n2*n2 + n1*n1
         else:
            return n2*n2 + n3*n3
      else:
         return n2*n2 + n3*n3

# Exercise 1.4
def a_plus_abs_b(a, b):
   if b > 0:
      return a + b
   else:
      return a - b

# Exercise 1.5
def p(): return p()
def test(x, y):
   if x == 0:
      return 0
   else:
      return y
# commented out as this is in infinite loop
# test(0, p())


# 1.1.7 The Elements of Programming - Example: Square Roots by Newton's Method

def square(x): return x * x

def good_enough(guess, x):
   return abs(square(guess) - x) < 0.001

def average(x, y):
   return (x + y) / 2.0

def improve(guess, x):
   return average(guess, float(x) / guess)

def sqrt_iter(guess, x):
   if good_enough(guess, x):
      return guess
   else:
      return sqrt_iter(improve(guess, x), x)

def sqrt(x):
   return sqrt_iter(1.0, float(x))

print (sqrt(9))
print (sqrt(100 + 37))
print (sqrt(sqrt(2)+sqrt(3)))
print (square(sqrt(1000)))

# Exercise 1.6
def new_if(predicate, then_clause, else_clause):
   if predicate:
      return then_clause
   else:
      return else_clause
print (new_if((2==3), 0, 5))
print (new_if((1==1), 0, 5))
def sqrt_iter(guess, x):
   return new_if(
      good_enough(guess, x),
      guess,
      sqrt_iter(improve(guess, x), x))

# Exercse 1.7
def good_enough_gp(guess, prev):
   return abs(guess - prev) / guess < 0.001
def sqrt_iter_gp(guess, prev, x):
   if good_enough_gp(guess, prev):
      return guess
   else:
      return sqrt_iter_gp(improve(guess, x), guess, x)
def sqrt_gp(x):
   return sqrt_iter_gp(4.0, 1.0, float(x))

# Exercise 1.8
def improve_cube(guess, x):
   return (2.0*guess + float(x)/(guess * guess)) / 3.0
def cube_iter(guess, prev, x):
   if good_enough_gp(guess, prev):
      return guess
   else:
      return cube_iter(improve_cube(guess, x), guess, x)
def cube_root_0(x):
   return cube_iter(27.0, 1.0, x)


# 1.1.8 The Elements of Programming - Procedures as Black-Box Abstractions

def square(x): return x * x

def double(x): return x + x

def square_real(x): return math.exp(double(math.log(x)))

def good_enough(guess, x):
   return abs(square(guess) - x) < 0.001

def improve(guess, x):
   return average(guess, float(x) / guess)

def sqrt_iter(guess, x):
   if good_enough(guess, x):
      return guess
   else:
      return sqrt_iter(improve(guess, x), x)

def sqrt(x):
   return sqrt_iter(1.0, x)

print (square(5))

# Block-structured
def sqrt(x):
   def good_enough(guess, x):
      return abs(square(guess) - x) < 0.001

   def improve(guess, x):
      return average(guess, float(x) / guess)

   def sqrt_iter(guess, x):
      if good_enough(guess, x):
         return guess
      else:
         return sqrt_iter(improve(guess, x), x)

   return sqrt_iter(1.0, x)

# Taking advantage of lexical scoping
def sqrt(x):
   def good_enough(guess):
      return abs(square(guess) - x) < 0.001

   def improve(guess):
      return average(guess, float(x) / guess)

   def sqrt_iter(guess):
      if good_enough(guess):
         return guess
      else:
         return sqrt_iter(improve(guess))

   return sqrt_iter(1.0)


# 1.2.1 Procedures and the Processes They Generate - Linear Recursion and Iteration

# Recursive
def factorial(n):
   if n == 1:
      return 1
   else:
      return n * factorial(n - 1)

print (factorial(6))

# Iterative
def fact_iter(product, counter, max_count):
   if counter > max_count:
      return product
   else:
      return fact_iter(counter * product, counter + 1, max_count)

def factorial(n):
   return fact_iter(1, 1, n)

# Iterative, block-structured (from footnote)
def factorial(n):
   def iter(product, counter):
      if counter > n:
         return product
      else:
         return iter(counter * product, counter + 1)
   return iter(1, 1)

# Exercise 1.9
def inc(a): return a + 1
def dec(a): return a - 1
def plus(a, b):
   if a == 0:
      return b
   else:
      return inc(plus(dec(a), b))
def plus(a, b):
   if a == 0:
      return b
   else:
      return plus(dec(a), inc(b))

# Exercise 1.10
def a(x, y):
   if y == 0:
      return 0
   elif x == 0:
      return 2 * y
   elif y == 1:
      return 2
   else:
      return a(x - 1, a(x, y - 1))
print (a(1, 10))
print (a(2, 4))
print (a(3, 3))
def f(n): return a(0, n)
def g(n): return a(1, n)
def h(n): return a(2, n)
def k(n): return 5 * n * n


# 1.2.2 Procedures and the Processes They Generate - Tree Recursion

# Recursive
def fib(n):
   if n == 0:
      return 0
   elif n == 1:
      return 1
   else:
      return fib(n - 1) + fib(n - 2)

# Iterative
def fib_iter(a, b, count):
   if count == 0:
      return b
   else:
      return fib_iter(a + b, a, count - 1)
def fib(n):
   return fib_iter(1, 0, n)

# Counting change
def first_denomination(x):
   if x == 1:
      return 1
   elif x == 2:
      return 5
   elif x == 3:
      return 10
   elif x == 4:
      return 25
   elif x == 5:
      return 50

def cc(amount, kinds_of_coins):
   if amount == 0:
      return 1
   elif amount < 0:
      return 0
   elif kinds_of_coins == 0:
      return 0
   else:
      return (cc(amount, kinds_of_coins - 1) +
              cc(amount - first_denomination(kinds_of_coins), kinds_of_coins))

def count_change(amount):
   return cc(amount, 5)

print (count_change(100))

# Exercise 1.11
def f(n):
   if n < 3:
      return n
   else:
      return f(n-1) + 2*f(n-2) + 3*f(n-3)
def f_iter(a, b, c, count):
   if count == 0:
      return c
   else:
      return f_iter(a + 2*b + 3*c, a, b, count-1)
def f(n):
   return f_iter(2, 1, 0, n)

# Exercise 1.12
def pascals_triangle(n, k):
   if n == 0:
      return 1
   elif n == k:
      return 1
   else:
      return pascals_triangle(n-1, k-1) + pascals_triangle(n-1, k)


# 1.2.3 Procedures and the Processes They Generate - Orders of Growth

# Exercise 1.15
def cube(x): return x * x * x
def p(x): return 3.0 * x - 4.0 * cube(x)
def sine(angle):
   if not(abs(angle) > 0.1):
      return angle
   else:
      return p(sine(angle / 3.0))


# 1.2.4 Procedures and the Processes They Generate - Exponentiation

# Linear recursion
def expt(b, n):
   if n == 0:
      return 1
   else:
      return b * expt(b, n - 1)

# Linear iteration
def expt_iter(b, counter, product):
   if counter == 0:
      return product
   else:
      return expt_iter(b, counter - 1, b * product)
def expt(b, n):
   return expt_iter(b, n, 1)

# Logarithmic iteration
def even(n): return (n % 2) == 0

def fast_expt(b, n):
   if n == 0:
      return 1
   else:
      if even(n):
         return square(fast_expt(b, n / 2))
      else:
         return b * fast_expt(b, n - 1)

# Exercise 1.17
def multiply(a, b):
   if b == 0:
      return 0
   else:
      return plus(a, multiply(a, dec(b)))

# Exercise 1.19
# exercise left to reader to solve for p' and q'
#def fib_iter(a, b, p, q, count):
#   if count == 0:
#      return b
#   else:
#      if even(count):
#         return fib_iter(a, b, p', q', count / 2)
#      else:
#         return fib_iter((b * q) + (a * q) + (a * p), (b * p) + (a * q), p, q, count - 1)
#def fib(n):
#   return fib_iter(1, 0, 0, 1, n)


# 1.2.5 Procedures and the Processes They Generate - Greatest Common Divisors

def gcd(a, b):
   if b == 0:
      return a
   else:
      return gcd(b, a % b)

print (gcd(40, 6))

# Exercise 1.20
print (gcd(206, 40))


# 1.2.6 Procedures and the Processes They Generate - Example: Testing for Primality

# prime
def divides(a, b): return (b % a) == 0

def find_divisor(n, test_divisor):
   if square(test_divisor) > n:
      return n
   elif divides(test_divisor, n):
      return test_divisor
   else:
      return find_divisor(n, test_divisor + 1)

def smallest_divisor(n): return find_divisor(n, 2)

def prime(n): return n == smallest_divisor(n)

# fast_prime
def expmod(nbase, nexp, m):
   if nexp == 0:
      return 1
   else:
      if even(nexp):
         return square(expmod(nbase, nexp / 2, m)) % m
      else:
         return (nbase * expmod(nbase, nexp - 1, m)) % m

def fermat_test(n):
   def try_it(a): return expmod(a, n, n) == a
   return try_it(random.randint(0, n-1))

def fast_prime(n, ntimes):
   if ntimes == 0:
      return True
   else:
      if fermat_test(n):
         return fast_prime(n, ntimes - 1)
      else:
         return False

# Exercise 1.21
print (smallest_divisor(199))
print (smallest_divisor(1999))
print (smallest_divisor(19999))

# Exercise 1.22
def report_prime(elapsed_time):
   print (" *** " + str(elapsed_time))
def start_prime_test(n, start_time):
   if prime(n):
      report_prime(time.time() - start_time)
def timed_prime_test(n):
   print ("\n" + str(n))
   start_prime_test(n, time.time())

# Exercise 1.25
def expmod(nbase, nexp, m):
   return fast_expt(nbase, nexp) % m

# Exercise 1.26
def expmod(nbase, nexp, m):
   if nexp == 0:
      return 1
   else:
      if even(nexp):
         return (expmod(nbase, (nexp / 2), m) * expmod(nbase, (nexp / 2), m)) % m
      else:
         return (nbase * expmod(nbase, nexp - 1, m)) % m

# Exercise 1.27
def carmichael(n):
   return fast_prime(n, 100) and not(prime(n))

print (carmichael(561))
print (carmichael(1105))
print (carmichael(1729))
print (carmichael(2465))
print (carmichael(2821))
print (carmichael(6601))


# 1.3 Formulating Abstractions with Higher-Order Procedures

def cube(x): return x * x * x


# 1.3.1 Formulating Abstractions with Higher-Order Procedures - Procedures as Arguments

def sum_integers(a, b):
   if a > b:
      return 0
   else:
      return a + sum_integers(a + 1, b)

def sum_cubes(a, b):
   if a > b:
      return 0
   else:
      return cube(a) + sum_cubes(a + 1, b)

def pi_sum(a, b):
   if a > b:
      return 0.0
   else:
      return (1.0 / (a * (a + 2.0))) + pi_sum(a + 4.0, b)

def sum(term, a, next, b):
   if a > b:
      return 0
   else:
      return term(a) + sum(term, next(a), next, b)

# Using sum
def inc(n): return n + 1

def sum_cubes(a, b):
   return sum(cube, a, inc, b)

print (sum_cubes(1, 10))

def identity(x): return x

def sum_integers(a, b):
   return sum(identity, a, inc, b)

print (sum_integers(1, 10))

def pi_sum(a, b):
   def pi_term(x): return 1.0 / (x * (x + 2.0))
   def pi_next(x): return x + 4.0
   return sum(pi_term, a, pi_next, b)

print (8.0 * pi_sum(1, 1000))

def integral(f, a, b, dx):
   def add_dx(x): return x + dx
   return sum(f, a + (dx / 2.0), add_dx, b) * dx

def cube(x): return x * x * x

print (integral(cube, 0.0, 1.0, 0.01))
# exceeds maximum recursion depth
# print (integral(cube, 0.0, 1.0, 0.001))

# Exercise 1.29
def simpson(f, a, b, n):
   h = float(abs(b-a)) / n
   def sum_iter(term, start, next, stop, acc):
      if start > stop:
         return acc
      else:
         return sum_iter(term, next(start), next, stop, acc + term(a + start*h))
   return h * sum_iter(f, 1, inc, n, 0)
print (simpson(cube, 0, 1, 100))

# Exercise 1.30
def sum_iter(term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return sum_iter(term, next(a), next, b, acc + term(a))
def sum_cubes(a, b):
   return sum_iter(cube, a, inc, b, 0)
print (sum_cubes(1, 10))

# Exercise 1.31
def product(term, a, next, b):
   if a > b:
      return 1
   else:
      return term(a) * product(term, next(a), next, b)
def factorial(n):
   return product(identity, 1, inc, n)
def product_iter(term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return product_iter(term, next(a), next, b, acc * term(a))

# Exercise 1.32
def accumulate(combiner, null_value, term, a, next, b):
   if a > b:
      return null_value
   else:
      return combiner(term(a), accumulate(combiner, null_value, term, next(a), next, b))
def sum(a, b):
   return accumulate(lambda x,y: x+y, 0, identity, a, inc, b)
def product(a, b):
   return accumulate(lambda x,y: x*y, 1, identity, a, inc, b)
def accumulate_iter(combiner, term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return accumulate_iter(combiner, term, next(a), next, b, combiner(acc, term(a)))
def sum(a, b):
   return accumulate_iter(lambda x,y: x+y, identity, a, inc, b, 0)
def product(a, b):
   return accumulate_iter(lambda x,y: x*y, identity, a, inc, b, 1)

# Exercise 1.33
def filtered_accumulate(combiner, null_value, term, a, next, b, pred):
   if a > b:
      return null_value
   else:
      if pred(a):
         return combiner(term(a), filtered_accumulate(combiner, null_value, term, next(a), next, b, pred))
      else:
         return filtered_accumulate(combiner, null_value, term, next(a), next, b, pred)
print (filtered_accumulate(lambda x,y: x+y, 0, square, 1, inc, 5, prime))


# 1.3.2 Formulating Abstractions with Higher-Order Procedures - Constructing Procedures Using Lambda

def pi_sum(a, b):
   return sum(lambda x: 1.0 / (x * (x + 2.0)), a, lambda x: x + 4.0, b)

def integral(f, a, b, dx):
   return sum(f, a + (dx / 2.0), lambda x: x + dx, b) * dx

def plus4(x): return x + 4

plus4 = lambda x: x + 4

print ((lambda x, y, z: x + y + square(z)) (1, 2, 3))

# Using let
def f(x, y):
   def f_helper(a, b):
      return x*square(a) + y*b + a*b
   return f_helper(1 + x*y, 1 - y)

def f(x, y):
   return (lambda a, b: x*square(a) + y*b + a*b) (1 + x*y, 1 - y)

def f(x, y):
   a = 1 + x*y
   b = 1 - y
   return x*square(a) + y*b + a*b

# python does not have let binding and lambdas are limited to an expression
# so we'll use default parameters to emulate (courtesy of Randy Hudson)
x = 5
print ((lambda x=3: x + x*10)() + x)

x = 2
print ((lambda x=3,y=x+2: x*y)())

def f(x, y):
   a = 1 + x*y
   b = 1 - y
   return x*square(a) + y*b + a*b

# Exercise 1.34
def f(g): return g(2)
print (f(square))
print (f(lambda z: z * (z + 1)))


# 1.3.3 Formulating Abstractions with Higher-Order Procedures - Procedures as General Methods

# Half-interval method
def close_enough(x, y):
   return abs(x - y) < 0.001

def positive(x): return x >= 0.0
def negative(x): return not(positive(x))

def search(f, neg_point, pos_point):
   midpoint = average(neg_point, pos_point)
   if close_enough(neg_point, pos_point):
      return midpoint
   else:
      test_value = f(midpoint)
      if positive(test_value):
         return search(f, neg_point, midpoint)
      elif negative(test_value):
         return search(f, midpoint, pos_point)
      else:
         return midpoint

def half_interval_method(f, a, b):
   a_value = f(a)
   b_value = f(b)
   if negative(a_value) and positive(b_value):
      return search(f, a, b)
   elif negative(b_value) and positive(a_value):
      return search(f, b, a)
   else:
      raise Exception("Values are not of opposite sign " + str(a) + " " + str(b))

print (half_interval_method(math.sin, 2.0, 4.0))

print (half_interval_method(lambda x: x*x*x - 2.0*x - 3.0, 1.0, 2.0))

# Fixed points
tolerance = 0.00001

def fixed_point(f, first_guess):
   def close_enough(v1, v2):
      return abs(v1 - v2) < tolerance
   def tryit(guess):
      next = f(guess)
      if close_enough(guess, next):
         return next
      else:
         return tryit(next)
   return tryit(first_guess)

print (fixed_point(math.cos, 1.0))

print (fixed_point(lambda y: math.sin(y) + math.cos(y), 1.0))

# note: this function does not converge
def sqrt(x):
   return fixed_point(lambda y: float(x) / y, 1.0)

def sqrt(x):
   return fixed_point(lambda y: average(y, float(x) / y), 1.0)

# Exercise 1.35
def golden_ratio():
   return fixed_point(lambda x: 1.0 + 1.0/x, 1.0)

# Exercise 1.36
# 35 guesses before convergence
print (fixed_point(lambda x: math.log(1000.0) / math.log(x), 1.5))
# 11 guesses before convergence (average_damp defined below)
# print (fixed_point(average_damp(lambda x: math.log(1000.0) / math.log(x)), 1.5))

# Exercise 1.37
# exercise left to reader to define cont_frac
# cont_frac(lambda i: return 1.0, lambda i: return 1.0, k)


# 1.3.4 Formulating Abstractions with Higher-Order Procedures - Procedures as Returned Values

def average_damp(f):
   return lambda x: average(float(x), f(x))

print ((average_damp(square)) (10.0))

def sqrt(x):
   return fixed_point(average_damp(lambda y: float(x) / y), 1.0)

def cube_root(x):
   return fixed_point(average_damp(lambda y: float(x) / square(y)), 1.0)

print (cube_root(8))

# Newton's method
dx = 0.00001
def deriv(g):
   return lambda x: float(g(x + dx) - g(x)) / dx

def cube(x): return x * x * x

print (deriv(cube) (5.0))

def newton_transform(g):
   return lambda x: x - float(g(x)) / (deriv(g) (x))

def newtons_method(g, guess):
   return fixed_point(newton_transform(g), guess)

def sqrt(x):
   return newtons_method(lambda y: square(y) - x, 1.0)

# Fixed point of transformed function
def fixed_point_of_transform(g, transform, guess):
   return fixed_point(transform(g), guess)

def sqrt(x):
   return fixed_point_of_transform(lambda y: x / y, average_damp, 1.0)

def sqrt(x):
   return fixed_point_of_transform(lambda y: square(y) - x, newton_transform, 1.0)

# Exercise 1.40
def cubic(a, b, c):
   return lambda x: cube(x) + a*x*x + b*x + c
print (newtons_method(cubic(5.0, 3.0, 2.5), 1.0))

# Exercise 1.41
def double(f):
   return lambda x: f(f(x))
print (double(inc)(5))
print (double(double)(inc)(5))
print (double(double)(double)(inc)(5))

# Exercise 1.42
def compose(f, g):
   return lambda x: f(g(x))
print (compose(square, inc)(6))

#Exercise 1.43
def repeated(f, n):
   def iterate(arg, i):
      if i > n:
         return arg
      else:
         return iterate(f(arg), i+1)
   return lambda x: iterate(x, 1)
print (repeated(square, 2)(5))

# Exercise 1.44
def smooth(f, dx):
   return lambda x: average(x, (f(x-dx) + f(x) + f(x+dx)) / 3.0)
print (fixed_point(smooth(lambda x: math.log(1000.0) / math.log(x), 0.05), 1.5))

#Exercise 1.46
def iterative_improve(good_enough, improve):
   def iterate(guess):
      next = improve(guess)
      if good_enough(guess, next):
         return next
      else:
         return iterate(next)
   return lambda x: iterate(x)
def fixed_point(f, first_guess):
   tolerance = 0.00001
   def good_enough(v1, v2):
      return abs(v1-v2) < tolerance
   return iterative_improve(good_enough, f)(first_guess)
print (fixed_point(average_damp(lambda x: math.log(1000.0) / math.log(x)), 1.5))



import math

def squareRootBisect (num, precise = 3):
    ''' Returns closest square-root of a number,
        using Bisection search algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1
    elif num == 0:
        return 0
    step = 0.1
    precission = step / ((10**precise))
    start = 0
    end = num
    while ( True ):
        mid = (start + end) / 2.0
        squareTillNow = mid*mid
        if abs(squareTillNow - num) < precission:
            break
        else:
            if squareTillNow > num:
                end = mid
            else :
                start = mid
        print "Mid : ", mid
    return mid
     

def squareRootNR (num, precise = 3):
    ''' Returns closest square-root of a number,
        using Newton-Rapson approximation algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1
    elif num == 0:
        return 0
    step = 0.1
    precission = step / ((10**precise))
    guess = num / 2.0
    while (True):
        squareTillNow = guess * guess
        if abs(squareTillNow - num) < precission:
            break
        else :
            guess = guess - ((squareTillNow - num) / (2*guess))
            ''' x(n+1) = f( x(n) ) - ( f( x(n) ) / f'( x(n) ) ) 
                Where f(x (n)) is (x(n) - num )^2 
                f (x) is approximate squared error 
            '''
        print "Guess : ", guess
    return guess


print squareRootBisect (10001, 4)
print squareRootNR (10001, 6)

'''
Square Root Convergents
'''
from fractions import Fraction

def frac_iter(n, v=Fraction(1,2)):
    '''Yield expression for n expansions'''
    while n > 0:
        yield Fraction(1,1) + v
        v = Fraction(1, Fraction(2,1) + v)
        n -= 1
    return

if __name__ == '__main__':
    print sum(1 if len(str(f.numerator)) > len(str(f.denominator)) else 0\
            for f in frac_iter(1000))

# -*- coding: utf-8 -*-
"""
Created on Mon Feb 17 21:02:08 2014

@author: ventilator
"""

import profile
from fractions import Fraction

lut_square_root = []
        
def create_continued_fraction(layers):
    if layers == 0:
        half = Fraction(1,2)
        half = 2
        return half
    else:       
        current_layer = Fraction(2 + Fraction(1, create_continued_fraction(0))) 
        lut_square_root.append(current_layer)
        
        next_layer = Fraction(2 + Fraction(1, create_continued_fraction(layers - 1)))                
        return next_layer

def square_root_two(layers):
    # this intermediate layer is to fix for leading 1 instead of 2
    return Fraction(1 + Fraction(1, create_continued_fraction(layers)))


def yield_square_root(layers):
    # manual generate the first two items
    yield Fraction (3, 2)
    yield Fraction (7, 5)
    
    # iterate all the others
    current_depth = 2
    half = Fraction(1,2)
    
    lowest_layer = Fraction(2 + half)
    current_root = Fraction(1, lowest_layer) + 2
    
    while current_depth < layers:        
        yield Fraction(1, current_root) + 1
        current_depth += 1
        current_root = Fraction(1, current_root) + 2


def check_if_numerator_larger_denominator(number_as_fraction):
        numerator = len(str(number_as_fraction.numerator))
        denominator = len(str(number_as_fraction.denominator))
        return numerator > denominator   

def solve_problem():  

    # check if yield function is same as recursive function   
     
#    for i,iterative in enumerate(yield_square_root(20)):        
#        recursive = square_root_two(i)
#        print(i, iterative == recursive, iterative,  recursive)        
      
        
    max_range = 1000
    count = 0

    for i, square_root in enumerate(yield_square_root(max_range)):
        if check_if_numerator_larger_denominator(square_root):
            count += 1
            # print(i+1)
        # if i % 10 == 0: print("progress: " + str(i/max_range*100))    
        
    print("Condition fullfilled by:")    
    print(count)    
    
    return 0
    
#solve_problem()    
profile.run('solve_problem()')   
import sys

def sqrt(x):
    """Compute square root using the Heron of Alexandria method

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError('Cannot compute square root '
                         'of negative number {}'.format(x))

    guess = x
    i = 0

    while guess * guess != x and i < 20:
        guess = (guess + x/guess) / 2.0
        i += 1
    return guess


def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print('this is never printed')
    except ValueError as e:
        print(e, file=sys.stderr)
    print('Execution continues normally...')


if __name__ == '__main__':
    main()
import math

## 7. 1

def print_n(s, n) :
    while n > 0 :
        print s
        n = n -1 
    return None


## 7. 2

def square_root(a, x) :
    """
    a : number to compute square root
    x : approximation guess
    """
    while True :
        #print x
        y = (x + a/x) / 2
        if abs(y - x) < 0.000000001 :
            break
        x = y
    return x

## 7. 3

def test_square_root(a, x) :
    result = square_root(a,x)
    right = math.sqrt(a)
    diff = abs(result - right)
    print a, result, right, diff

## 7.4

def eval_loop() :
    while True :
        a = raw_input('Give me a sting to evaluate : \n')
        if a == 'done' :
            break
        r = eval(a)
        print r
    return r


## 7. 5

def estimate_pi() :
    s = 0
    k = 0
    while True :
        time = 2*math.sqrt(2)/9810
        numer = math.factorial(4*k) * (1103 + 26390*k)
        denom = (math.factorial(k))**4 * 396**(4*k)
        if time * numer / denom < 1e-15 :
            break
        s = s + time * numer / denom
        k = k + 1
    pi = 1/s
    return pi
        

"""
This simple Python script embodies its namesake by acting as a
basic calculator. Currently, It can perform addition, subtraction,
division, multiplication, exponentiation, and square roots. More
functions may be added at a later date, or you could add your own!
"""

from __future__ import division # Importing the proper modules
from math import sqrt

print "Welcome to my basic calculator program!" # Welcome statement

def add(x, y): # Addition function
    s = x + y
    return "\n\t{} + {} = {}".format(x, y, s)
    
def minus(x, y): # Subtraction function
    s = x - y
    return "\n\t{} - {} = {}".format(x, y, s)
    
def division(x, y): # Division function
    s = x / y
    return "\n\t{} / {} = {}".format(x, y, s)
    
def multiplication(x, y): # Multiplication function
    s = x * y
    return "\n\t{} * {} = {}".format(x, y, s)
    
def exponentiation(x, y): # Exponentiation function
    s = x ** y
    return "\n\t{} ** {} = {}".format(x, y, s)
    
def squareRoot(x): # Square root function
    s = sqrt(x)
    return "\n\t{} = {}".format(x, s)
    
while True:
    c = raw_input("\nPlease pick an operation by number:\n\t1. Addition (+)" \
    "\n\t2. Subtraction (-) \n\t3. Division (/)\n\t4. Multiplication (*)" \
    "\n\t5. Exponentiation (**) \n\t6. Square Root ()")
    if c in ["1", "2", "3", "4", "5", "6"]: # Ensuring that only the listed options are inputted
        break
    else:
        print"\nChoose a number (1, 2, 3, 4, 5, 6) for your intended operation." # Error message
        continue

while True:
    try:
        a = raw_input("\nChoose your first number: ")
        ia  = float(a)
    except ValueError:
        print "\nNegative/positve integers or decimals only." # Only options allowed
        continue
    else:
        break
    
while True and c != "6":
    try:
        b = raw_input("\nChoose your second number: ")
        ib = float(b)
    except ValueError:
        print "\nNegative/positive integers or decimals only." # Only options allowed
        continue
    else:
        break

if c == "1": # Calling on the proper function
    print add(ia, ib)
elif c == "2":
    print minus(ia, ib)
elif c == "3":
    print division(ia, ib)
elif c == "4":
    print multiplication(ia, ib)
elif c == "5":
    print exponentiation(ia, ib)
elif c == "6":
    print squareRoot(ia)


alldigits = [1,2,3,4,5,6,7,8,9,0]
subdigits = [alldigits[len(alldigits) - index - 1:] for index in range(len(alldigits))]

def isSquare(a):
    '''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''
    # If a is a small number, then we can do this quick version
    if 0 <= a <= 2 ** 50:
        sr = int(a ** (1 / 2.0))
        if sr ** 2 == a:
            return sr
    else:
        raise ValueError("get a better function")
    	
def eq(n, upto):
	print(str(n)[::-1])
	l = [int(b) for index,b in enumerate(str(n)[::-1]) if index%2 == 0][::-1]
	m = alldigits[len(alldigits) - upto:]
	print('l', l)
	print('m', m)
	return l == m
	

start = 102030405060708090**(1/2.0) # 319421985.8755939
end = 192939495969798999**(1/2.0) # 439248785

def candidates(endings):
	newendings = []
	for ending in endings:
		upto = (len(str(ending)) - 1)//2 + 1
		start = alldigits[len(alldigits) - upto] * 10**(upto) + ending
		end = start + 9*10**(upto-1)
		step = 10**(upto-1)
		print(start, end, step)
		for a in range(start,end, step):
			print('a', a)
			if isSquare(a):
				newendings.append(a)
		return newendings

print(candidates([0]))
print(candidates([900]))

#!/usr/bin/env python3

def de_decimal(n):
    n=str(n)
    n="".join(n.split("."))
    return int(n)

def get_square_root(n,precision=100):
    """
    Used the square root by subtraction method by Frazer Jarvis
    """
    a=5*n
    b=5
    while len(str(b))<precision+2:
        if a>=b:
            a,b=a-b,b+10
        elif a<b:
            a,b=a*100,(b-5)*10+5
    return str(b)[:-2]

def main(upper=100, precision=100):
    a=0
    for i in range(1,upper+1):
        if not (i**0.5).is_integer():
            for j in get_square_root(i, precision):
                a+=int(j)
    return a

"""
Implement int sqrt(int x).

Compute and return the square root of x.

"""

def mySqrt(self, x):
    """
    :type x: int
    :rtype: int
    """
    # the root of x will not bigger than x/2 + 1
    if x == 0:
        return 0
    elif x == 1:
        return 1
    l = 0
    r = x/2 + 1
    while r >= l:
        mid = (r + l) /2
        temp = x / mid
        if temp == mid:
            return mid
        elif temp < mid:
            r = mid - 1
        else:
            l = mid + 1
    return r

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

'''
Implement int sqrt(int x).

Compute and return the square root of x.
'''


class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        if x < 0:
            return
        if x == 0 or x == 1:
            return x
        s, end, res = 1, x, 1
        while s <= end:
            mid = (s + end)/2
            if mid * mid == x:
                return mid
            if mid * mid < x:
                s = mid + 1
                res = mid
            if mid * mid > x:
                end = mid -1
        return res        

def Adder(N1,N2):
    MyResult = N1 + N2
    return MyResult

def Subtractor(N1,N2):
    MyResult = N1 - N2
    return MyResult
    
def Main():
    X = input("Enter a value for X ---")
    Y = input("Enter a value for Y ---")
    if (X >= Y):
        print "Subtraction happened"
        MyResult = Subtractor(X,Y)
    else:
        print "Addition happened"
        MyResult = Adder(X,Y)
    Result1 = math.sqrt(MyResult)
    print "the square root of ", MyResult, " is ", Result1
    return
    
def Frog():
    print "Yay!"
    return


#!/usr/bin/env python


def square_root(a):
    eps = 1e-8
    x = 1.0
    y = 2.0
    cnt = 1
    while abs(y - x) > eps:
        x = y
        y = (x + a / x) / 2
        print 'iter', cnt, '\ty=', y
        cnt = cnt + 1
    return y

print square_root(10)


import math

def getContinuedFractionOfSquareRoot(val):
	m = [0]
	d = [1]
	a = [int(math.sqrt(val))]
	yield a[0]
	
	while True:
		mm = d[-1]*a[-1] - m[-1]
		dd = (val - mm*mm) / d[-1]
		aa= int( (a[0] + mm)/dd )
		m.append(mm)
		d.append(dd)
		a.append(aa)
		yield aa


def checkPellSolution(x,y,n):
	return x*x - n*y*y == 1


def solve(D):
	if int(math.sqrt(D))**2 == D:
		return
	
	continuedFractionGenerator = getContinuedFractionOfSquareRoot(D)
	a = continuedFractionGenerator.next()
	p = [1, a]
	q = [0, 1]
	
	for a in continuedFractionGenerator:
		if checkPellSolution(p[-1], q[-1], D):
			return (p[-1], q[-1])
			
		p.append(a*p[-1] + p[-2])
		q.append(a*q[-1] + q[-2])


for D in xrange(1,1001):
	result = solve(D)
	if result is None:
		print 'No solution for D= %d' % D
		continue
		
	print 'Solution for D= %d: x= %d, y=%d' % (D, result[0], result[1])
	


import numpy as np 

def mse(actual, predicted):
	"""
	----------------------------------
	This function caluculates 
	mean square error between actual and predicted

	Takes: two lists / arrays
	Returns: mean square error
	----------------------------------
	"""

	return np.mean(np.abs(np.array(actual) - np.array(predicted)))


def rmse(actual, predicted):
	"""
	----------------------------------
	This function caluculates root
	mean square error between actual and predicted

	Takes: two lists / arrays
	Returns: root mean square error
	----------------------------------
	"""

	return np.sqrt(mse(actual, predicted))
	

def rmsle(actual, predicted):
	"""
	----------------------------------
	This function caluculates root mean
	square log error between actual and predicted

	Takes: two lists / arrays
	Returns: root mean square log error
	----------------------------------
	"""

	return np.sqrt(np.mean(np.power(np.log(np.array(actual) + 1) - np.log(np.array(predicted) + 1), 2)))

from __future__ import division
#import sys
import os
import matplotlib.pyplot as plt
import scipy
from scipy import special
import numpy as np

mydir = os.path.expanduser("~/")


def root_of_closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """

    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x



def iroot(k, n):
    """ http://stackoverflow.com/questions/15978781/how-to-find-integer-nth-roots"""

    u, s = n, n+1
    while u < s:
        s = u
        t = (k-1) * s + n // pow(s, k-1)
        u = t // k
    return s


def closest_perfect_kth_root(x, k): # x is the number of interest, k is the power
    """ naive method by KJL """

    y = 2
    while y <= x:
        y = y**k
        if y > x:
            return y**(1/k) - 1
        if y == x:
            y**(1/k)

        y = y**(1/k)
        y += 1



def WHL_kth(x, k):
    """ main computing function derived by Kevin Webster, Blane Hollingsworth,
    and Ken Locey """

    n = closest_perfect_kth_root(x, k) # x is the number of interest, k is the power
    i = 1
    a = 0
    while i <= k:
        b = scipy.special.binom(k, 1)
        a += (b*(n**(k-i)))
        i += 1

    a = (x - n**k)/a
    a += n

    return float(a)


def Guess(x, k):
    """ a function to guess the remainder of the root to reveal whether
    decreasing error in the WHL algorithm is meaningful """

    n = closest_perfect_kth_root(x, k) # x is the number of interest, k is the power
    a = np.random.uniform(0,1)
    #a = 0.5
    a += n

    return float(a)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from math import sqrt
from numpy import *
from utils.tools import convert2matrix

def root_mean_square(features, values, w, f=None):
    size = len(features[0])
    if f == None:
        v = dot(features, w) - values
    else:
        v = f(dot(features, w)) - values
    return sqrt(dot(v, v) / size)



#Archana Bahuguna ---- Decorator fn without the wrapper fn ----- Jan 6th 2014

def accept_n_gt_zero(fnToCall):
        if n <= 0:
            print 'From inside Decorator: n <=0 before raising exception'
           # raise Exception("Exception raised: n must be > 0")
            return 0
        else:
            print 'From inside Decorator: n > 0, before calling SquareRoot fn'
            return fnToCall(n, *args, **kwargs)


@accept_n_gt_zero
def SquareRoot(n):
    result = n**(1/2)
    return result

from fractions import Fraction

import sys
sys.setrecursionlimit(10000)

def squareRoot(expansions_count):
    if expansions_count == 1:
        return 2
    return 2 + Fraction(1, squareRoot(expansions_count-1))

"""
for i in range(1, 10):
    square2 = 1 + Fraction(1, squareRoot(i))
    print (repr(square2), float(square2))
"""

result = 0
for i in range(1, 1001):
    square2 = 1 + Fraction(1, squareRoot(i))
    if len(str(square2.numerator)) > len(str(square2.denominator)):
        result += 1

# answer is 153 (because of very tail recursion calculation tooks pretty long time)
print ("In 1000 expansions, %d fractions contain a numerator with more digits than denominator" % result)

import math
from pyspeedup.algorithms import jacobi_symbol

def powersInMod(n):
    ''' Computes all the squares in the integers mod n.
    '''
    return set((x*x)%n for x in range(0,n//2+1))

def isSquare(n):
    '''Checks for perfect squares by checking mod 64 to rule out 52/64 cases immediately.'''
    if n%isSquare.mod in isSquare.set:
        m=math.floor(math.sqrt(n))
        return m*m==n
    return False
isSquare.mod=64 #This can be changed if a different value is deemed better.
isSquare.set=powersInMod(isSquare.mod) #The set of all perfect squares mod the above number.

def tsSquareRoot(a,p): #Currently requires p to be prime.
    '''Calculates the square root mod p of a.'''
    jacobi=jacobi_symbol(a,p)
    if jacobi==-1:
        raise ValueError("No square root mod {0} exists.".format(p))
    s=p-1
    e=0
    while s%2==0: #Find p-1=s*2^e with odd s.
        e+=1
        s//=2
    n=findQuadraticNonresidue(p)
    x=pow(a,((s+1)/2),p) #first guess
    b=pow(a,s,p) #first guess correction
    g=pow(n,s,p) #quantity to modify x and b
    r=e
    while r>0:
        #ord_p(g)=ord_p(pow(n,s,p))
        #Note (n^s)^2^e=n^(2^e*s)=n^(p-1)=1 mod p
        #claim ord_p(g)=2^e, because
        #(n^s)^2^(e-1)=n^(s*2^e)/2=n^((p-1)/2)=jacobi_symbol=-1
        #Find m s.t. 0<=m<r and b^(2^m)==1
        m=0
        bp=b
        while m<r:
            if bp==1:
                break
            bp=(bp*bp)%p
            m+=1
        if m==0:
            break
        #Having found m, we update:
        g=pow(g,pow(2,(r-m-1),p),p)
        x=(x*g)%p
        g=(g*g)%p
        b=(b*g)%p
        r=m
    return x

def findQuadraticNonresidue(p):
    if p%8 in [3,5]:
        return 2
    elif p%8==7:
        return p-2
    n=2
    while jacobi_symbol(n,p)!=-1:
        n+=1 #Find an n s.t. (n/p)==-1
    return n
import sys
from math import sqrt

def pal(value):
	s = str(value)
	s = s.split(".")[0]
	return (s == s[::-1])

def is_square(integer):
	root = isqrt(integer)
	l = root*root
	if l == integer:
		return pal(root)
	else:
		return False

'''
def is_square(integer):
	root = sqrt(integer)
	if root.is_integer():
		return pal(root)
	else:
		return False
'''
def isqrt(n):  
	xn = 1  
	xn1 = (xn + n/xn)/2  
	while abs(xn1 - xn) > 1:  
		xn = xn1  
		xn1 = (xn + n/xn)/2  
	while xn1*xn1 > n:  
		xn1 -= 1  
	return xn1  


def sqrt1(n, precision=10e-8):
	prev, mid = 0, float(n)
	while abs(mid - prev) > precision:
		prev, mid = mid, (mid + (n / mid)) / 2.0
	return mid

def binsqrt(n):
	sgn = 0
	if n < 0:
		n = -n
		sgn = -1
	low = 0.0
	upp = n
	mid = (low + upp) * 0.5
	while True:
		if mid * mid > n:
			upp = mid
		else:
			low = mid
		last = mid
		mid = (upp + low) * 0.5
		if abs(mid - last) < 1e-9:
			break
	if sgn < 0:
		return complex(0, mid)
	return mid
 

def ntsqrt(n):
	if n < 10000000:
		return sqrt(n)
	sgn = 0
	if n < 0:
		sgn = -1
		n = -n
	val = n
	while True:
		last = val
		val = (val + n / val) * 0.5
		if abs(val - last) < 1e-9:
			break
		if sgn < 0:
			return complex(0, val)
	return val

my_file = open(sys.argv[1], 'r')

tests = int(my_file.readline())

for i in range(tests):
	tx = ((my_file.readline()).rstrip('\n')).split(" ")
	A=long(tx[0])
	B=long(tx[1])
	results = 0

	for v in range(A,B+1):
		if pal(v):
			if is_square(v):
				results +=1

	print "Case #{0}: {1}".format((i+1),results)



# # Finds the square root of a number using binary search
# # number - int

ROUND = 5


def square_root(number):
    left = 0
    right = number

    while left < right:
        middle = left + ((right - left) / 2.0)
        squared = middle ** 2

        if number - squared < 0.00001 and number - squared > 0:
            return round(middle, ROUND)
        elif squared > number:
            right = middle
        elif squared < number:
            left = middle


# def square_root(number):
#     left = 0
#     right = number
#     mid = left + ((right - left) / 2.0)

#     while True:
#         if mid**2 < number:
#             left = mid
#         if mid**2 > number:
#             right = mid
#         if abs(mid**2 - number) < 0.00001:
#             break
#         mid = left + ((right - left) / 2.0)

#     return round(mid, 5)


def main():
    num = int(input())
    print(square_root(num))


if __name__ == '__main__':
    main()

'''
Square root convergents

answer: 153
'''

def expansion(x):
	m = 2
	n = 1
	for i in xrange(0, x):
		m, n = n+2*m, m
	m, n = m+n, m
	return m, n


def solution():
	count = 0
	for i in xrange(0, 999):
		m, n = expansion(i)
		if len(str(m)) > len(str(n)):
			count += 1
	return count


if __name__ == '__main__':
    result = solution()
    print 'Result: ', result

# -*- coding: utf-8 -*-
"""
Created on Sun Mar 29 23:50:11 EDT 2015
@author: aaditya prakash
"""

import re
from time import clock

problem_number = '206'
problem_statement = """
Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0,
where each _ is a single digit.
"""

def concealed_square():
    """ solves problem 206"""
    pat = re.compile(r'1\d2\d3\d4\d5\d6\d7\d8\d9\d0')
    
    #smallest_integer possible given the requirement = 1020304050403020100 
    start = 1010101010 # square root of smallest integer 
    while True:
        if len(pat.findall(str(start**2))): return start
        start += 10


timeStart = clock()
print(concealed_square())
print('Time (sec):' + str(clock() - timeStart))
answer = '1389019170'




import math

def harmonic():
    total = 0
    for k in range (10, ((10**7)+1), 10):
        print (k, "= ",(1/(k**2)))
        total += (1/(k**2))
    print ("the square root of 6 * the sum =", math.sqrt(total * 6))
    #return total

def main():
    harmonic()

    #n = int(input("enter positive integer"))
    #print('The sum of 1/k**2 for k =1 to', n, "is ", harmonic(n))
    #print (the square root of 6 * the sum of 1/k**2)

main()
#SICP Chapter #01 Examples in Python
#!/usr/local/bin/python
# -*- coding: UTF-8 -*-
import math
import random
import time

# 1.1.1 The Elements of Programming - Expressions
print (486)
print (137 + 349)
print (1000 - 334)
print (5 * 99)
print (10 / 5)
print (2.7 + 10)
print (21 + 35 + 12 + 7)
print (25 * 4 * 12)
print (3 * 5 + 10 - 6)
print (3 * (2 * 4 + 3 + 5) + 10 - 7 + 6)

# 1.1.2 The Elements of Programming - Naming and the Environment
size = 2
print (size)
print (5 * size)
pi = 3.14159
radius = 10
print (pi * radius * radius)
circumference = 2 * pi * radius
print (circumference)

# 1.1.3 The Elements of Programming - Evaluating Combinations
print ((2 + (4 * 6)) * (3 + 5 + 7))

# 1.1.4 The Elements of Programming - Compound Procedures
def square(x): return x * x
print (square(21))
print (square(2 + 5))
print (square(square(3)))
def sum_of_squares(x, y): return square(x) + square(y)
print (sum_of_squares(3, 4))
def f(a): return sum_of_squares(a + 1, a * 2)
print (f(5))

# 1.1.5 The Elements of Programming - The Substitution Model for Procedure Application
print (f(5))
print (sum_of_squares(5 + 1, 5 * 2))
print (square(6) + square(10))
print ((6 * 6) + (10 * 10))
print (36 + 100)
print (f(5))
print (sum_of_squares(5 + 1, 5 * 2))
print (square(5 + 1) + square(5 * 2))

print (((5 + 1) * (5 + 1)) + ((5 * 2) * (5 * 2)))
print ((6 * 6) + (10 * 10))
print (36 + 100)
print (136)

# 1.1.6 The Elements of Programming - Conditional Expressions and Predicates
def abs(x):
   if x > 0:
      return x
   elif x == 0:
      return 0
   else:
      return -x
def abs(x):
   if x < 0:
      return -x
   else:
      return x
x = 6
print (x > 5 and x < 10)
def ge(x, y):
   return x > y or x == y
def ge(x, y):
   return not(x < y)

# Exercise 1.1
print (10)
print (5 + 3 + 4)
print (9 - 1)
print (6 / 2)
print (2 * 4 + 4 - 6)
a = 3
b = a + 1
print (a + b + a * b)
print (a == b)
print (b if b > a and b < a * b else a)
print (6 if a == 4 else 6 + 7 + a if b == 4 else 25)
print (2 + (b if b > a else a))
print ((a if a > b else b if a < b else -1) * (a + 1))

# Exercise 1.2
print (((5.0 + 4.0 + (2.0 - (3.0 - (6.0 + (4.0 / 5.0))))) /
         (3.0 * (6.0 - 2.0) * (2.0 - 7.0))))

# Exercise 1.3
def three_n(n1, n2, n3):
   if n1 > n2:
      if n1 > n3:
         if n2 > n3:
            return n1*n1 + n2*n2
         else:
            return n1*n1 + n3*n3
      else:
         return n1*n1 + n3*n3
   else:
      if n2 > n3:
         if n1 > n3:
            return n2*n2 + n1*n1
         else:
            return n2*n2 + n3*n3
      else:
         return n2*n2 + n3*n3

# Exercise 1.4
def a_plus_abs_b(a, b):
   if b > 0:
      return a + b
   else:
      return a - b

# Exercise 1.5
def p(): return p()
def test(x, y):
   if x == 0:
      return 0
   else:
      return y
# commented out as this is in infinite loop
# test(0, p())

# 1.1.7 The Elements of Programming - Example: Square Roots by Newton's Method
def square(x): return x * x

def good_enough(guess, x):
   return abs(square(guess) - x) < 0.001

def average(x, y):
   return (x + y) / 2.0

def improve(guess, x):
   return average(guess, float(x) / guess)

def sqrt_iter(guess, x):
   if good_enough(guess, x):
      return guess
   else:
      return sqrt_iter(improve(guess, x), x)

def sqrt(x):
   return sqrt_iter(1.0, float(x))

print (sqrt(9))
print (sqrt(100 + 37))
print (sqrt(sqrt(2)+sqrt(3)))
print (square(sqrt(1000)))

# Exercise 1.6
def new_if(predicate, then_clause, else_clause):
   if predicate:
      return then_clause
   else:
      return else_clause
print (new_if((2==3), 0, 5))
print (new_if((1==1), 0, 5))
def sqrt_iter(guess, x):
   return new_if(
      good_enough(guess, x),
      guess,
      sqrt_iter(improve(guess, x), x))

# Exercse 1.7
def good_enough_gp(guess, prev):
   return abs(guess - prev) / guess < 0.001
def sqrt_iter_gp(guess, prev, x):
   if good_enough_gp(guess, prev):
      return guess
   else:
      return sqrt_iter_gp(improve(guess, x), guess, x)
def sqrt_gp(x):
   return sqrt_iter_gp(4.0, 1.0, float(x))

# Exercise 1.8
def improve_cube(guess, x):
   return (2.0*guess + float(x)/(guess * guess)) / 3.0
def cube_iter(guess, prev, x):
   if good_enough_gp(guess, prev):
      return guess
   else:
      return cube_iter(improve_cube(guess, x), guess, x)
def cube_root_0(x):
   return cube_iter(27.0, 1.0, x)

# 1.1.8 The Elements of Programming - Procedures as Black-Box Abstractions
def square(x): return x * x

def double(x): return x + x

def square_real(x): return math.exp(double(math.log(x)))

def good_enough(guess, x):
   return abs(square(guess) - x) < 0.001

def improve(guess, x):
   return average(guess, float(x) / guess)

def sqrt_iter(guess, x):
   if good_enough(guess, x):
      return guess
   else:
      return sqrt_iter(improve(guess, x), x)

def sqrt(x):
   return sqrt_iter(1.0, x)

print (square(5))

# Block-structured
def sqrt(x):
   def good_enough(guess, x):
      return abs(square(guess) - x) < 0.001

   def improve(guess, x):
      return average(guess, float(x) / guess)

   def sqrt_iter(guess, x):
      if good_enough(guess, x):
         return guess
      else:
         return sqrt_iter(improve(guess, x), x)

   return sqrt_iter(1.0, x)

# Taking advantage of lexical scoping
def sqrt(x):
   def good_enough(guess):
      return abs(square(guess) - x) < 0.001

   def improve(guess):
      return average(guess, float(x) / guess)

   def sqrt_iter(guess):
      if good_enough(guess):
         return guess
      else:
         return sqrt_iter(improve(guess))

   return sqrt_iter(1.0)

# 1.2.1 Procedures and the Processes They Generate - Linear Recursion and Iteration

# Recursive
def factorial(n):
   if n == 1:
      return 1
   else:
      return n * factorial(n - 1)

print (factorial(6))

# Iterative
def fact_iter(product, counter, max_count):
   if counter > max_count:
      return product
   else:
      return fact_iter(counter * product, counter + 1, max_count)

def factorial(n):
   return fact_iter(1, 1, n)

# Iterative, block-structured (from footnote)
def factorial(n):
   def iter(product, counter):
      if counter > n:
         return product
      else:
         return iter(counter * product, counter + 1)
   return iter(1, 1)

# Exercise 1.9
def inc(a): return a + 1
def dec(a): return a - 1
def plus(a, b):
   if a == 0:
      return b
   else:
      return inc(plus(dec(a), b))
def plus(a, b):
   if a == 0:
      return b
   else:
      return plus(dec(a), inc(b))

# Exercise 1.10
def a(x, y):
   if y == 0:
      return 0
   elif x == 0:
      return 2 * y
   elif y == 1:
      return 2
   else:
      return a(x - 1, a(x, y - 1))
print (a(1, 10))
print (a(2, 4))
print (a(3, 3))
def f(n): return a(0, n)
def g(n): return a(1, n)
def h(n): return a(2, n)
def k(n): return 5 * n * n

# 1.2.2 Procedures and the Processes They Generate - Tree Recursion

# Recursive
def fib(n):
   if n == 0:
      return 0
   elif n == 1:
      return 1
   else:
      return fib(n - 1) + fib(n - 2)

# Iterative
def fib_iter(a, b, count):
   if count == 0:
      return b
   else:
      return fib_iter(a + b, a, count - 1)
def fib(n):
   return fib_iter(1, 0, n)

# Counting change
def first_denomination(x):
   if x == 1:
      return 1
   elif x == 2:
      return 5
   elif x == 3:
      return 10
   elif x == 4:
      return 25
   elif x == 5:
      return 50

def cc(amount, kinds_of_coins):
   if amount == 0:
      return 1
   elif amount < 0:
      return 0
   elif kinds_of_coins == 0:
      return 0
   else:
      return (cc(amount, kinds_of_coins - 1) +
              cc(amount - first_denomination(kinds_of_coins), kinds_of_coins))

def count_change(amount):
   return cc(amount, 5)

print (count_change(100))

# Exercise 1.11
def f(n):
   if n < 3:
      return n
   else:
      return f(n-1) + 2*f(n-2) + 3*f(n-3)
def f_iter(a, b, c, count):
   if count == 0:
      return c
   else:
      return f_iter(a + 2*b + 3*c, a, b, count-1)
def f(n):
   return f_iter(2, 1, 0, n)

# Exercise 1.12
def pascals_triangle(n, k):
   if n == 0:
      return 1
   elif n == k:
      return 1
   else:
      return pascals_triangle(n-1, k-1) + pascals_triangle(n-1, k)

# 1.2.3 Procedures and the Processes They Generate - Orders of Growth

# Exercise 1.15
def cube(x): return x * x * x
def p(x): return 3.0 * x - 4.0 * cube(x)
def sine(angle):
   if not(abs(angle) > 0.1):
      return angle
   else:
      return p(sine(angle / 3.0))

# 1.2.4 Procedures and the Processes They Generate - Exponentiation

# Linear recursion
def expt(b, n):
   if n == 0:
      return 1
   else:
      return b * expt(b, n - 1)

# Linear iteration
def expt_iter(b, counter, product):
   if counter == 0:
      return product
   else:
      return expt_iter(b, counter - 1, b * product)
def expt(b, n):
   return expt_iter(b, n, 1)

# Logarithmic iteration
def even(n): return (n % 2) == 0

def fast_expt(b, n):
   if n == 0:
      return 1
   else:
      if even(n):
         return square(fast_expt(b, n / 2))
      else:
         return b * fast_expt(b, n - 1)

# Exercise 1.17
def multiply(a, b):
   if b == 0:
      return 0
   else:
      return plus(a, multiply(a, dec(b)))

# Exercise 1.19
def fib_iter(a, b, p, q, count):
   if count == 0:
      return b
   else:
      if count % 2 == 0:
         return fib_iter(a, b, ((p * p) + (q * q)), ( (q * q ) + (2 * p * q)), count / 2)
      else:
         return fib_iter((b * q) + (a * q) + (a * p), (b * p) + (a * q), p, q, count - 1)
def fib_monster(n):
   return fib_iter(1, 0, 0, 1, n)

# 1.2.5 Procedures and the Processes They Generate - Greatest Common Divisors
def gcd(a, b):
   if b == 0:
      return a
   else:
      return gcd(b, a % b)

print (gcd(40, 6))

# Exercise 1.20
print (gcd(206, 40))

# 1.2.6 Procedures and the Processes They Generate - Example: Testing for Primality

# prime
def divides(a, b): return (b % a) == 0

def find_divisor(n, test_divisor):
   if square(test_divisor) > n:
      return n
   elif divides(test_divisor, n):
      return test_divisor
   else:
      return find_divisor(n, test_divisor + 1)

def smallest_divisor(n): return find_divisor(n, 2)

def prime(n): return n == smallest_divisor(n)

# fast_prime
def expmod(nbase, nexp, m):
   if nexp == 0:
      return 1
   else:
      if even(nexp):
         return square(expmod(nbase, nexp / 2, m)) % m
      else:
         return (nbase * expmod(nbase, nexp - 1, m)) % m

def fermat_test(n):
   def try_it(a): return expmod(a, n, n) == a
   return try_it(random.randint(0, n-1))

def fast_prime(n, ntimes):
   if ntimes == 0:
      return True
   else:
      if fermat_test(n):
         return fast_prime(n, ntimes - 1)
      else:
         return False

# Exercise 1.21
print (smallest_divisor(199))
print (smallest_divisor(1999))
print (smallest_divisor(19999))

# Exercise 1.22
def report_prime(elapsed_time):
   print (" *** " + str(elapsed_time))
def start_prime_test(n, start_time):
   if prime(n):
      report_prime(time.time() - start_time)
def timed_prime_test(n):
   print ("\n" + str(n))
   start_prime_test(n, time.time())

# Exercise 1.25
def expmod(nbase, nexp, m):
   return fast_expt(nbase, nexp) % m

# Exercise 1.26
def expmod(nbase, nexp, m):
   if nexp == 0:
      return 1
   else:
      if even(nexp):
         return (expmod(nbase, (nexp / 2), m) * expmod(nbase, (nexp / 2), m)) % m
      else:
         return (nbase * expmod(nbase, nexp - 1, m)) % m

# Exercise 1.27
def carmichael(n):
   return fast_prime(n, 100) and not(prime(n))

print (carmichael(561))
print (carmichael(1105))
print (carmichael(1729))
print (carmichael(2465))
print (carmichael(2821))
print (carmichael(6601))

# 1.3 Formulating Abstractions with Higher-Order Procedures
def cube(x): return x * x * x

# 1.3.1 Formulating Abstractions with Higher-Order Procedures - Procedures as Arguments
def sum_integers(a, b):
   if a > b:
      return 0
   else:
      return a + sum_integers(a + 1, b)

def sum_cubes(a, b):
   if a > b:
      return 0
   else:
      return cube(a) + sum_cubes(a + 1, b)

def pi_sum(a, b):
   if a > b:
      return 0.0
   else:
      return (1.0 / (a * (a + 2.0))) + pi_sum(a + 4.0, b)

def sum(term, a, next, b):
   if a > b:
      return 0
   else:
      return term(a) + sum(term, next(a), next, b)

# Using sum
def inc(n): return n + 1

def sum_cubes(a, b):
   return sum(cube, a, inc, b)

print (sum_cubes(1, 10))

def identity(x): return x

def sum_integers(a, b):
   return sum(identity, a, inc, b)

print (sum_integers(1, 10))

def pi_sum(a, b):
   def pi_term(x): return 1.0 / (x * (x + 2.0))
   def pi_next(x): return x + 4.0
   return sum(pi_term, a, pi_next, b)

print (8.0 * pi_sum(1, 1000))

def integral(f, a, b, dx):
   def add_dx(x): return x + dx
   return sum(f, a + (dx / 2.0), add_dx, b) * dx

def cube(x): return x * x * x

print (integral(cube, 0.0, 1.0, 0.01))
# exceeds maximum recursion depth
# print (integral(cube, 0.0, 1.0, 0.001))

# Exercise 1.29
def simpson(f, a, b, n):
   h = float(abs(b-a)) / n
   def sum_iter(term, start, next, stop, acc):
      if start > stop:
         return acc
      else:
         return sum_iter(term, next(start), next, stop, acc + term(a + start*h))
   return h * sum_iter(f, 1, inc, n, 0)
print (simpson(cube, 0, 1, 100))

# Exercise 1.30
def sum_iter(term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return sum_iter(term, next(a), next, b, acc + term(a))
def sum_cubes(a, b):
   return sum_iter(cube, a, inc, b, 0)
print (sum_cubes(1, 10))

# Exercise 1.31
def product(term, a, next, b):
   if a > b:
      return 1
   else:
      return term(a) * product(term, next(a), next, b)
def factorial(n):
   return product(identity, 1, inc, n)
def product_iter(term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return product_iter(term, next(a), next, b, acc * term(a))

# Exercise 1.32
def accumulate(combiner, null_value, term, a, next, b):
   if a > b:
      return null_value
   else:
      return combiner(term(a), accumulate(combiner, null_value, term, next(a), next, b))
def sum(a, b):
   return accumulate(lambda x,y: x+y, 0, identity, a, inc, b)
def product(a, b):
   return accumulate(lambda x,y: x*y, 1, identity, a, inc, b)
def accumulate_iter(combiner, term, a, next, b, acc):
   if a > b:
      return acc
   else:
      return accumulate_iter(combiner, term, next(a), next, b, combiner(acc, term(a)))
def sum(a, b):
   return accumulate_iter(lambda x,y: x+y, identity, a, inc, b, 0)
def product(a, b):
   return accumulate_iter(lambda x,y: x*y, identity, a, inc, b, 1)

# Exercise 1.33
def filtered_accumulate(combiner, null_value, term, a, next, b, pred):
   if a > b:
      return null_value
   else:
      if pred(a):
         return combiner(term(a), filtered_accumulate(combiner, null_value, term, next(a), next, b, pred))
      else:
         return filtered_accumulate(combiner, null_value, term, next(a), next, b, pred)
print (filtered_accumulate(lambda x,y: x+y, 0, square, 1, inc, 5, prime))

# 1.3.2 Formulating Abstractions with Higher-Order Procedures - Constructing Procedures Using Lambda
def pi_sum(a, b):
   return sum(lambda x: 1.0 / (x * (x + 2.0)), a, lambda x: x + 4.0, b)

def integral(f, a, b, dx):
   return sum(f, a + (dx / 2.0), lambda x: x + dx, b) * dx

def plus4(x): return x + 4

plus4 = lambda x: x + 4

print ((lambda x, y, z: x + y + square(z)) (1, 2, 3))

# Using let
def f(x, y):
   def f_helper(a, b):
      return x*square(a) + y*b + a*b
   return f_helper(1 + x*y, 1 - y)

def f(x, y):
   return (lambda a, b: x*square(a) + y*b + a*b) (1 + x*y, 1 - y)

def f(x, y):
   a = 1 + x*y
   b = 1 - y
   return x*square(a) + y*b + a*b

# python does not have let binding and lambdas are limited to an expression
# so we'll use default parameters to emulate (courtesy of Randy Hudson)
x = 5
print ((lambda x=3: x + x*10)() + x)

x = 2
print ((lambda x=3,y=x+2: x*y)())

def f(x, y):
   a = 1 + x*y
   b = 1 - y
   return x*square(a) + y*b + a*b

# Exercise 1.34
def f(g): return g(2)
print (f(square))
print (f(lambda z: z * (z + 1)))

# 1.3.3 Formulating Abstractions with Higher-Order Procedures - Procedures as General Methods

# Half-interval method
def close_enough(x, y):
   return abs(x - y) < 0.001

def positive(x): return x >= 0.0
def negative(x): return not(positive(x))

def search(f, neg_point, pos_point):
   midpoint = average(neg_point, pos_point)
   if close_enough(neg_point, pos_point):
      return midpoint
   else:
      test_value = f(midpoint)
      if positive(test_value):
         return search(f, neg_point, midpoint)
      elif negative(test_value):
         return search(f, midpoint, pos_point)
      else:
         return midpoint

def half_interval_method(f, a, b):
   a_value = f(a)
   b_value = f(b)
   if negative(a_value) and positive(b_value):
      return search(f, a, b)
   elif negative(b_value) and positive(a_value):
      return search(f, b, a)
   else:
      raise Exception("Values are not of opposite sign " + str(a) + " " + str(b))

print (half_interval_method(math.sin, 2.0, 4.0))

print (half_interval_method(lambda x: x*x*x - 2.0*x - 3.0, 1.0, 2.0))

# Fixed points
tolerance = 0.00001

def fixed_point(f, first_guess):
   def close_enough(v1, v2):
      return abs(v1 - v2) < tolerance
   def tryit(guess):
      next = f(guess)
      if close_enough(guess, next):
         return next
      else:
         return tryit(next)
   return tryit(first_guess)

print (fixed_point(math.cos, 1.0))

print (fixed_point(lambda y: math.sin(y) + math.cos(y), 1.0))

# note: this function does not converge
def sqrt(x):
   return fixed_point(lambda y: float(x) / y, 1.0)

def sqrt(x):
   return fixed_point(lambda y: average(y, float(x) / y), 1.0)

# Exercise 1.35
def golden_ratio():
   return fixed_point(lambda x: 1.0 + 1.0/x, 1.0)

# Exercise 1.36
# 35 guesses before convergence
print (fixed_point(lambda x: math.log(1000.0) / math.log(x), 1.5))
# 11 guesses before convergence (average_damp defined below)
# print (fixed_point(average_damp(lambda x: math.log(1000.0) / math.log(x)), 1.5))

# Exercise 1.37
# exercise left to reader to define cont_frac
# cont_frac(lambda i: return 1.0, lambda i: return 1.0, k)

# 1.3.4 Formulating Abstractions with Higher-Order Procedures - Procedures as Returned Values
def average_damp(f):
   return lambda x: average(float(x), f(x))

print ((average_damp(square)) (10.0))

def sqrt(x):
   return fixed_point(average_damp(lambda y: float(x) / y), 1.0)

def cube_root(x):
   return fixed_point(average_damp(lambda y: float(x) / square(y)), 1.0)

print (cube_root(8))

# Newton's method
dx = 0.00001
def deriv(g):
   return lambda x: float(g(x + dx) - g(x)) / dx

def cube(x): return x * x * x

print (deriv(cube) (5.0))

def newton_transform(g):
   return lambda x: x - float(g(x)) / (deriv(g) (x))

def newtons_method(g, guess):
   return fixed_point(newton_transform(g), guess)

def sqrt(x):
   return newtons_method(lambda y: square(y) - x, 1.0)

# Fixed point of transformed function
def fixed_point_of_transform(g, transform, guess):
   return fixed_point(transform(g), guess)

def sqrt(x):
   return fixed_point_of_transform(lambda y: x / y, average_damp, 1.0)

def sqrt(x):
   return fixed_point_of_transform(lambda y: square(y) - x, newton_transform, 1.0)

# Exercise 1.40
def cubic(a, b, c):
   return lambda x: cube(x) + a*x*x + b*x + c
print (newtons_method(cubic(5.0, 3.0, 2.5), 1.0))

# Exercise 1.41
def double(f):
   return lambda x: f(f(x))
print (double(inc)(5))
print (double(double)(inc)(5))
print (double(double)(double)(inc)(5))

# Exercise 1.42
def compose(f, g):
   return lambda x: f(g(x))
print (compose(square, inc)(6))

#Exercise 1.43
def repeated(f, n):
   def iterate(arg, i):
      if i > n:
         return arg
      else:
         return iterate(f(arg), i+1)
   return lambda x: iterate(x, 1)
print (repeated(square, 2)(5))

# Exercise 1.44
def smooth(f, dx):
   return lambda x: average(x, (f(x-dx) + f(x) + f(x+dx)) / 3.0)
print (fixed_point(smooth(lambda x: math.log(1000.0) / math.log(x), 0.05), 1.5))

#Exercise 1.46
def iterative_improve(good_enough, improve):
   def iterate(guess):
      next = improve(guess)
      if good_enough(guess, next):
         return next
      else:
         return iterate(next)
   return lambda x: iterate(x)
def fixed_point(f, first_guess):
   tolerance = 0.00001
   def good_enough(v1, v2):
      return abs(v1-v2) < tolerance
   return iterative_improve(good_enough, f)(first_guess)
print (fixed_point(average_damp(lambda x: math.log(1000.0) / math.log(x)), 1.5))

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

"""
Clifton Crosland
Project Euler 80 - Summing the digits of irrational square roots
Source of the square roots algorithm: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
"""

import math

def make_groups_of_two(n):
  str_n = str(n)
  if len(str_n) % 2 == 1:
    # Append leading zero if necessary
    str_n = "0" + str_n
  groups = []
  i = 0
  while i < len(str_n):
    groups.append(str_n[i:i+2])
    i += 2
  groups += ["00"] * (100 - len(groups)) # We want first 100 digits of square roots
  return groups

def sum_of_digits(n):
  total = 0
  while n != 0:
    total += n % 10
    n /= 10
  return total

# Guess and check
def get_best_x(c, p):
  for x in range(0, 11):
    if (20 * p + x) * x > c:
      return x-1
  print "ERROR! NO DIGITS WORK!"
  return -1 # ERROR

# Precondition: Square root of n is not an integer (hence, root is irrational)
def sum_of_100_digits_of_irr_root(n):
  n_groups = make_groups_of_two(n)
  result = 0
  remainder = 0
  for group in n_groups:
    c = remainder * 100 + int(group)
    x = get_best_x(c, result)
    remainder = c - (20*result + x) * x
    result = result * 10 + x
  return sum_of_digits(result)
  
def main():
  squares = [1,4,9,16,25,36,49,64,81,100]
  total = 0
  for i in range(1, 101):
    if i not in squares:
      total += sum_of_100_digits_of_irr_root(i)
  print total
  
if __name__ == "__main__":
  main()
#!/usr/bin/env python

import math

class SquareRoot(object):

    epsilon = 1e-12

    @staticmethod
    def sqrt(n):
        if n < 0:
            raise ValueError("sqrt can't be less than 0")

        upper = 1 if n < 1 else n
        lower = 0
        return SquareRoot._sqrt(n, lower, upper)

    @staticmethod
    def _sqrt(n, lower, upper):
        mid = (lower + upper) / 2.0
        midsq = mid * mid

        # base case:
        if abs(midsq - n) < SquareRoot.epsilon:
            return mid

        # recusive case
        if midsq < n:
            return SquareRoot._sqrt(n, mid, upper)
        else:
            return SquareRoot._sqrt(n, lower, mid)

def main():
    print SquareRoot.sqrt(100)
    print SquareRoot.sqrt(0.01)


if __name__ == "__main__":
    main()
import math
class Solution(object):
    def f(self, dict, n):                   #Solve the problem recursively.
        if n == 0:                          #If n is 0, return 0.
            return 0
        if n in dict:                       #If the result of n is already in the dict, return dict[n].
            return dict[n]
        m = 0x7fffffff                      #Use m to store the least number of perfect square numbers
        t = int(math.sqrt(n))               #The upper bound of squre root to traverse sqrt(n).
        k = max(int(math.sqrt(n / 3)), 1)   #The lower bound of squre root to traverse max(sqrt(n/3), 1).
        while t >= k:
            a = self.f(dict, n - t * t)     #Get the result of n - t^2.
            if a == 0:                      #If n - t^2 is a square number, return 1.
                return 1
            if a < m:
                m = a
            t -= 1
        dict[n] = m + 1                     #Store intermedia results in dict.
        return m + 1
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        dict = {}                           #Use dict to store intermedia results.
        return self.f(dict, n)

from nth_root import *

def sum_digs(n):
    s = 0
    while n > 0:
        s += n % 10
        n /= 10
    return s

s = 0
for n in xrange(2,101):
    if (n**.5) == int(n**.5):
        continue
    s += sum_digs(nth_root(n*(10**198),2))
print s

#def square_root_digs_sum(radicand, n, B):
#    x,y,r = 0,0,0
#    temp = radicand
#    digs = 0
#    while temp > 0:
#        digs += 1
#        temp /= 10
#    for i in xrange(0,100):
#        if (i*(n+1)) > digs:
#            a = 0
#        else:
#            a = (radicand / (10**(digs-(n*(i+1))))) % (10**n)
#        x_p = (B**n)*x + a
#        beta = 0
#        while (B * y + beta)**n <= (B ** n) * x + a:
#            beta += 1
#        beta -= 1
#        y_p = B * y + beta
#        r_p = (B ** n) * x + a - ((B * y + beta)**n)
        
        

    # if iterations*n > digs, automatically set a = 0

class QuadraticLaw(object):

    def getTime(self, d):
        def isqrt(x):
            if x < 0:
                raise ValueError('square root not defined for negative numbers')
            n = int(x)
            if n == 0:
                return 0
            a, b = divmod(n.bit_length(), 2)
            x = 2**(a+b)
            while True:
                y = (x + n//x)//2
                if y >= x:
                    return x
                x = y

        return (isqrt(1 + 4 * d) - 1) // 2

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math
import itertools

#Naive method.
def get_largest_prime_factor(number):
    possible_factors = itertools.count(2)
    square_root_num = math.sqrt(number)

    for num in possible_factors:

        if num > square_root_num:
            break

        if num >= number:
            break

        while number / num % 1 == 0:
            if number / num != 1:
                number /= num

    return number

#print(str(int(getLargestPrimeFactor(9007199254740992))))
print(str(int(get_largest_prime_factor(600851475143))))
'''
Functions to estimate square root values.

Created on Dec 16, 2014
@author: sql.sith
'''
from __builtin__ import False, True

_tolerance = 0.001

def square_root(target):
    guess = 0
    guesses = 0

    while (abs(guess * guess - target) > _tolerance and
           guess * guess < target):
        guess += 0.00001
        guesses += 1

    if abs(guess * guess - target) > _tolerance:
        raise(_NO_GOOD_SOLUTION_FOUND)

    if _debug: print(guesses)  # @IgnorePep8

    return(guess)

global _debug
_debug = False

global _NO_GOOD_SOLUTION_FOUND
_NO_GOOD_SOLUTION_FOUND = Exception(
    "Solution found is outside specified tolerance.")

if __name__ == '__main__':
    _debug = True

    square = 65535
    sqrt = square_root(square)

    print("The square root of {0} is {1}.".format(square, sqrt))
    print(sqrt * sqrt)

# Implement square root using binary search

def sqrt(n, error=0.1):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid

print sqrt(0.9, error=0.00001)


import math

#ex 7.1 rewrite a recursive function from ch 5 as a while loop
def print_n(s,n):
    while n > 0:
        print(s),
        n = n - 1

print_n('bok choy', 5)
print_n('boobs', 2)
print_n('palm trees are great!', 8)



#7.4 break example
while True:
    line = input('> ')
    if line == 'done':
        break
    print (line)

print('Done!')

#example 7.6 of newtons squareroot approximation algorithm
#ex7.2
def sqrt2(a):
    x = a/4
    while True:
        y = (x+a/x)/2
        if x == y:  
            return x
        x = y

print(sqrt2(4))
print(sqrt2(144))
print(sqrt2(14))
print(sqrt2(89))

#ex7.3

def tabs(x):   #function tries to format to string and right spacing for table but doesn't really do the spacing part
    return str(x) + 4*' '

def test_square_root(n,m):
    while n <= m:
        a = math.sqrt(n)
        b = sqrt2(n)       
        c = abs(a-b)
        nmbr = tabs(n)
        test1 = tabs(a)
        test2 = tabs(b)
        diff = tabs(c)
        print(nmbr + ' ' + test1 + ' ' + test2 + ' ' + diff)
        n = n + 1
        

test_square_root(1,9)


#ex7.4
def eval_loop ():
    while True:
        x = input('> ')
        if x == 'done':
            break 
        print(eval(x))
        
    print (x)

eval_loop()


#ex7.5
def factorial (n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
      
def estimate_pi ():
    const = (2*math.sqrt(2))/9801
    k = 1
    sumeval = 1103
    x = sumeval
    while x >= 1e-15:
        x = (factorial(4*k)*(1103+26390*k))/((factorial(k)**4)*(396**(4*k)))
        sumeval += x 
        k = k + 1
    return 1/(const*sumeval)

print(estimate_pi())



import math
import argparse
import sys

def sqrt(x):
    def avg(*args):
        return float(reduce(lambda x,y: x+y, args))/len(args)

    def improve(guess, x):
      return avg(x/guess, guess)

    def guess_change_is_small_fraction_of_guess(guess, x):
        return math.fabs(improve(guess, x) - guess) < guess * 0.0001

    def good_enough(guess, x):
        return guess_change_is_small_fraction_of_guess(guess, x)

    def sqrt_iter(guess, x, calls=0):
        if good_enough(guess, x):
            return guess
        else:
            return sqrt_iter(improve(guess, x), x, calls=calls)

    return sqrt_iter(1.0, x)

parser = argparse.ArgumentParser(description = 'Find square root of a number using\
                                 Newton\'s approximation method')
parser.add_argument('NUM')

if __name__ == "__main__":
    parsed = parser.parse_args(sys.argv[1:])
    print sqrt(parsed.NUM)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import sys


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """
    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed.")
    except ValueError as e:
        print(e, file=sys.stderr)

    print("Program execution continues normally.")


if __name__ == '__main__':
    main()
from fractions import Fraction
from numlib import is_square
def get_digit_square_root(n, num_digit = 2):
	if num_digit == 0:
		return Fraction(int(n**0.5))
	else:
		base = get_digit_square_root(n, num_digit - 1)
		denominator = 10**num_digit
		d = 1
		while (base + Fraction(d,denominator))**2 <= n:
			d += 1
		return base + Fraction(d - 1, denominator)

def count_first_n_digit(f, n = 100):
	denominator = f.denominator
	m = int(f) + n
	mult = 10**m / f.denominator
	numerator = str(f.numerator * mult)
	s = 0
	for i in range(n):
		s += int(numerator[i])
	return s

def main():
	s = 0
	for n in range(1, 101):
		if not(is_square(n)):
			f = get_digit_square_root(n, 100)
			print n, f
			s += count_first_n_digit(f)
			print count_first_n_digit(f), f
	print "count:", s

main()
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

from pl.edu.agh.neural.learning.backpropagation.error.RootMeanSquare import RootMeanSquare

class ErrorUtil(object):
    ROOT_MEAN_SQUARE = RootMeanSquare.NAME

    REGISTERED_FUNCTIONS = {
        ROOT_MEAN_SQUARE: RootMeanSquare
    }

    @staticmethod
    def registered_factors():
        return ErrorUtil.REGISTERED_FUNCTIONS.keys()

    @staticmethod
    def get_factor(name):
        if name == ErrorUtil.ROOT_MEAN_SQUARE:
            return ErrorUtil.REGISTERED_FUNCTIONS[name]

    @staticmethod
    def default_factor():
        return ErrorUtil.ROOT_MEAN_SQUARE

def squareRootBi(x,epsilon):
    assert x>=0, 'x must be non-negative,not'+str(x)
    assert epsilon>0, 'epsilon must be postive,not'+str(epsilon)
    low=0
    high=max(x,1.0)
    guess=(low+high)/2.0
    ctr=0
    while abs(guess**2-x) > epsilon and ctr <=100:
        #print 'low:',low,'high:',high, 'quess',guess
        if guess**2<x:
            low=guess
        else:
            high=guess
        guess = (low+high)/2.0
        ctr += 1
    assert ctr <= 100,  'Iteration count exceeded' 
    print 'Bi method. Num. iterations', ctr, 'Estimer',guess
    return guess

def testBi():
    print 'squareRootBi(4,0.0001)'
    squareRootBi(4,0.00001)
    print 'squareRootBi(2,0.0001)'
    squareRootBi(2,0.00001)
    print 'squareRootBi(0.25,0.0001)'
    squareRootBi(0.25,0.00001)

def iterSqRt(number):
    for counter in range(1, number):
        if counter**2 == number:
            return "square root of" + str(number)+ "is" + str(counter)
            return "Failed" + str(number) + "SqRt is not an interger"
#!/usr/bin/python

# Solution for Project Euler problem 206, "Concealed Square".
# http://projecteuler.net/problem=206

import math

def solve():
  lower = int(math.sqrt(1020304050607080900))
  upper = int(math.ceil(math.sqrt(1929394959697989990)))

  # Root must end in 30 or 70 (see README). Skip iterating over other numbers.
  for x in xrange(lower - (lower % 100), upper + 100 - (upper % 100), 100):
    if attempt(x + 30): return x + 30
    if attempt(x + 70): return x + 70

def attempt(n):
  sq = n*n
  return odd_digits(sq) == '1234567890'

def odd_digits(n):
  return str(n)[0::2]

print solve()

'''
Implement int sqrt(int x).

Compute and return the square root of x.

Example
sqrt(3) = 1

sqrt(4) = 2

sqrt(5) = 2

sqrt(10) = 3

Challenge
O(log(x))

'''

class Solution:
    """
    @param x: An integer
    @return: The sqrt of x
    """
    def sqrt(self, x):
        # write your code here
        return int(x**0.5)

import jsonpickle

from datetime import datetime
from django.conf import settings
from InstructableAuthor import InstructableAuthor


class InstructableBase(object):
    API_QUERY_TYPE = "id"
    API_ID_PARAM = "id"
    API_GET_ACTION = "showInstructable"
    
    def __init__(self,
                 siteid="",
                 url="",
                 title="",
                 author=InstructableAuthor(),
                 category="",
                 channel="",
                 squareThumb="",
                 rectangleThumb="",
                 views=0,
                 favorites=0,
                 type="",
                 date=None):
        self.siteid = siteid
        self.url = url
        self.title = title
        self.author = author
        self.category = category
        self.channel = channel
        self.bigSquareImage = squareThumb
        self.squareImage = squareThumb.replace("SQUARE3", "SQUARE")
        self.rectangleThumb = rectangleThumb
        self.views = views
        self.favorites = favorites
        cdnstring = "http://cdn.instructables.com"
        if settings.REMOTE_ROOT_URL not in self.rectangleThumb and cdnstring not in self.rectangleThumb:
            self.rectangleThumb = settings.REMOTE_ROOT_URL + self.rectangleThumb
        self.type = type
        self.date = date

    def json(self):
        return jsonpickle.encode(self)

    def __unicode__(self):
        return self.title + " by " + self.author

def babylonian(x):
	c=x
	y=0
	while(y!=c):
		y=c
		c=(x/c+c)/2
	return c

a= int(input("Write a number"))

b= babylonian(a)

print("The square root is", b)

def pseudo_bin_search(start, end, gap, number):
    left = start
    right = end
    curr = left + (right - left) / 2
    for i in range(120):

        doubled_curr = curr * curr
        if doubled_curr >= number and (curr - gap) * (curr - gap) <= number:
            return curr
        if doubled_curr < number:
            left = curr + gap
        if doubled_curr > number:
            right = curr - gap

        curr = left + (right - left) / 2


def bin_search(arr, number):
    left = 0
    right = len(arr) - 1
    curr = left + (right - left) // 2

    while left < right:
        if arr[curr + 1]**2 >= number and arr[curr - 1]**2 <= number:
            return arr[curr]

        if arr[curr]**2 < number:
            left = curr + 1

        if arr[curr]**2 > number:
            right = curr - 1

        curr = left + (right - left) // 2


def generate_range(number):
    left = 0
    right = number
    gap = 1
    return pseudo_bin_search(left, right, gap, number)


def square_root(number):
    max_item = generate_range(number)
    left = max_item - 1
    right = max_item + 1
    gap = 0.0000001

    return pseudo_bin_search(left, right, gap, number)

if __name__ == '__main__':
    number = int(input())
    # print("{}".format(square_root(number)))

    print("{0:.5f}".format(square_root(number)))

from __future__ import print_function
import pygame
import os


class Slicer(object):
    def __init__(
        self,
        screen,
        font_size=10,
        spacing=4,
        background_color=(255, 255, 255),
        header_color=(125, 175, 255)
    ):
        font_file = pygame.font.get_default_font()
        self.font = pygame.font.Font(font_file, font_size)
        self.square_size = {}
        self.square_pos = {}
        self.font_size = font_size
        self.screen = screen
        self.background_color = background_color
        self.header_color = header_color

    def start(self, path):
        self.draw_background(path)

        self.square_size = {
            path: list(self.screen.get_size())  # whole window
        }

        self.square_pos = {
            path: [0, 0]  # top left
        }

    def draw_background(self, path):
        self.screen.fill(self.background_color)
        text = self.font.render(path, True, self.header_color)
        text_width = text.get_width()
        screen_width = self.screen.get_width()
        self.screen.blit(text, ((screen_width - text_width) / 2, 2))

    def draw_level(
        self,
        root,
        root_size,
        directory_sizes,
        file_sizes,
        spacing=4,
        square_color=(200, 225, 255),
        font_color=(0, 0, 0),
        border_color=(0, 0, 0),
    ):
        # folders which would be smaller than this won't be drawn
        min_square_size = (2 * spacing + 3 * self.font_size, 3 * spacing + self.font_size)

        if root not in self.square_size:
            # need to know the details of the root directory to be able to draw in it
            return
        elif root not in self.square_pos:
            return

        # the position to draw the next square
        pos = self.square_pos[root]
        pos[0] += spacing
        pos[1] += self.font_size + 2 * spacing  # leave room for text

        horizontal = self.square_size[root][0] > self.square_size[root][1]

        for relpath, size in directory_sizes + file_sizes:
            fullpath = os.path.join(root, relpath)
            self.square_size[fullpath] = self.square_size[root][:]  # copy the size of the parent directory

            # work out the dimensions of the square (and store in dictionaries for later use)
            if horizontal:
                (self.square_size[fullpath])[0] = int(round((self.square_size[fullpath][0] - spacing) * (float(size) / float(root_size)))) - spacing  # use the foldersize to scale the remaining width
                (self.square_size[fullpath])[1] -= (self.font_size + 3 * spacing)  # the height is smaller than the parent due to spacing

                if self.square_size[fullpath][0] < min_square_size[0] or self.square_size[fullpath][1] < min_square_size[1]:  # too small
                    del self.square_size[fullpath]  # don't draw this directory
                    continue
                self.square_pos[fullpath] = pos[:]
                pos[0] = pos[0] + (self.square_size[fullpath])[0] + spacing  # the next square is to the right of this one
            else:
                (self.square_size[fullpath])[0] -= 2 * spacing
                (self.square_size[fullpath])[1] = int(round((self.square_size[fullpath][1] - self.font_size - (2 * spacing)) * (float(size) / float(root_size)))) - spacing  # scale the width, but subtract for spacing
                if self.square_size[fullpath][0] < min_square_size[0] or self.square_size[fullpath][1] < min_square_size[1]:  # too small
                    del self.square_size[fullpath]  # don't draw this directory
                    continue
                self.square_pos[fullpath] = pos[:]
                pos[1] = pos[1] + (self.square_size[fullpath])[1] + spacing  # the next square is to the right of this one

            # draw the square
            surface = pygame.Surface(tuple(self.square_size[fullpath]))
            surface.fill(square_color)
            pygame.draw.rect(surface, border_color, (0, 0, self.square_size[fullpath][0], self.square_size[fullpath][1]), 1)
            text = self.font.render(relpath, True, font_color)  # write the directory name
            surface.blit(text, (spacing, spacing))
            self.screen.blit(surface, tuple(self.square_pos[fullpath]))


def slice_and_dice(folder_size, directory, screen, fontsize=10):
    slicer = Slicer(screen)
    slicer.start(directory)
    pygame.display.flip()
    for root, dirs, files in os.walk(directory, topdown=True):
        directory_sizes = []
        file_sizes = []
        for filename in dirs:
            full_path = os.path.join(root, filename)
            size = folder_size[full_path]
            directory_sizes.append((filename, size))
        for filename in files:
            full_path = os.path.join(root, filename)
            try:
                size = folder_size[full_path]
            except KeyError:
                continue
            file_sizes.append((filename, size))

        slicer.draw_level(root, folder_size[root], directory_sizes, file_sizes)
    pygame.display.flip()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import sys
from math import sqrt

def pal(value):
	s = str(value)
	s = s.split(".")[0]
	return (s == s[::-1])

def is_square(integer):
	root = isqrt(integer)
	l = root*root
	if l == integer:
		return pal(root)
	else:
		return False

'''
def is_square(integer):
	root = sqrt(integer)
	if root.is_integer():
		return pal(root)
	else:
		return False
'''
def isqrt(n):  
	xn = 1  
	xn1 = (xn + n/xn)/2  
	while abs(xn1 - xn) > 1:  
		xn = xn1  
		xn1 = (xn + n/xn)/2  
	while xn1*xn1 > n:  
		xn1 -= 1  
	return xn1  


def sqrt1(n, precision=10e-8):
	prev, mid = 0, float(n)
	while abs(mid - prev) > precision:
		prev, mid = mid, (mid + (n / mid)) / 2.0
	return mid

def binsqrt(n):
	sgn = 0
	if n < 0:
		n = -n
		sgn = -1
	low = 0.0
	upp = n
	mid = (low + upp) * 0.5
	while True:
		if mid * mid > n:
			upp = mid
		else:
			low = mid
		last = mid
		mid = (upp + low) * 0.5
		if abs(mid - last) < 1e-9:
			break
	if sgn < 0:
		return complex(0, mid)
	return mid
 

def ntsqrt(n):
	if n < 10000000:
		return sqrt(n)
	sgn = 0
	if n < 0:
		sgn = -1
		n = -n
	val = n
	while True:
		last = val
		val = (val + n / val) * 0.5
		if abs(val - last) < 1e-9:
			break
		if sgn < 0:
			return complex(0, val)
	return val

my_file = open(sys.argv[1], 'r')

tests = int(my_file.readline())

for i in range(tests):
	tx = ((my_file.readline()).rstrip('\n')).split(" ")
	A=long(tx[0])
	B=long(tx[1])
	results = 0

	for v in range(A,B+1):
		if pal(v):
			if is_square(v):
				results +=1

	print "Case #{0}: {1}".format((i+1),results)



#  File: CalcSqrt.py

#  Description: Calculate the square root of a number and display it

#  Student Name: Collin Murphy

#  Student UT EID: cbm772

#  Course Name: CS 303E

#  Unique Number: 52680

#  Date Created: 15 Oct 2012

#  Date Last Modified: 15 Oct 2012

def sqrt(n):
  '''function to determine the square root of a given numebr n'''

  #set initial values
  error = 1
  oldGuess = n / 2
  newGuess = 0

  #perform computation
  while (error > 1e-6):
    newGuess = ((n / oldGuess) + oldGuess) / 2
    error = abs(oldGuess - newGuess)
    oldGuess= newGuess

  #return result
  return newGuess

def main():
  '''main function to test square root function'''

  #get user input until it is valid
  n = -1
  while (n <= 0):
    n = eval(input("Enter a positive number: "))
    print()

  #calculate square root
  result = sqrt(n)

  #print result
  print("Square root is: %s" %format(result, '0.12g'), end = '\n\n')
  print("Difference is: %s" %format((result - n ** 0.5), '0.1f'))

main()

# calculator.py
import math

def add(a,b):
	return a+b

def mult(a,b):
	return a*b
	
def square_root(a):
	return math.sqrt(a)

#from math import sqrt, ceil, pow
import gmpy2, math, time

def my_is_sqr(n):
	return math.sqrt(n) % 1 == 0

def my_fermat_factor(n):
	a = math.ceil(math.sqrt(n))
	b2 = (a*a-n)
	while not(my_is_sqr(b2)):
		a += 1
		b2 = a*a - n

	return int(a+math.sqrt(b2)), int(a-math.sqrt(b2))
	
# code from stack overflow to test gmpy2's performance
def fermat_factor(n):
    assert n % 2 != 0  # Odd integers only

    a = gmpy2.ceil(gmpy2.sqrt(n))
    b2 = gmpy2.square(a) - n
    while not is_square(b2):
        a += 1
        b2 = gmpy2.square(a) - n

    factor1 = a + gmpy2.sqrt(b2)
    factor2 = a - gmpy2.sqrt(b2)
    return int(factor1), int(factor2) 

def is_square(n):
    root = gmpy2.sqrt(n)
    return root % 1 == 0  # '4.0' will pass, '4.1212' won't

# Conclusion: gmpy2 (numerical precision library) slows things down by a lot, but
# the precision is necessary for factoring numbers that matter ...
 
start_time = time.time()
print "Mine:", my_fermat_factor(555555555555555555555555555555555), "with duration", time.time() - start_time
start_time = time.time()
print "Internet stranger:", fermat_factor(555555555555555555555555555555555), "with duration", time.time() - start_time

#!/usr/bin/python
def fact(n):
    if n >= 0:
        return fact2(n, 1)
    else:
        raise ValueError("Input must be more than or equal to 0")
def fact2(a, b):
    if a != 1:
        return fact2(a - 1, b * a)
    else:
        return b
    
def fib(n):
    if n >= 0:
        return fib2(n, 0, 1)
    else:
        raise ValueError("Input must be more than or equal to 0")
def fib2(a, b, c):
    if a != 1:
        return fib2(a - 1, c, b + c)
    else:
        return b

def sqrt(n):
    if n > 0:
        return sqrt2(n, 1)
    elif n == 0:
        return 0
    else:
        raise ValueError("Input must be more than or equal to 0")

def sqrt2(a, b):
    if abs(a - b * b) > .000000000000001:
        return sqrt2(a, (a/b + b)/2)
    else:
        return b

print("Factorial of 10")    
print(fact(10))
print("Fib of 20")
print(fib(20))
print("Square root of 625")
print(sqrt(625))

from openerp.osv import orm, fields

class student_mark_main(orm.TransientModel):
    _name = "student.mark.main"
    _inherit = "student.info.student"
    def _square(self, cr, uid, ids, field_name, arg, context=None):
        res={}
        for record in self.browse(cr,uid,ids,context=context):
            b=record.num
            res[record.id] =  b ** 2
            print res
        return res
    
    def _square_root(self, cr, uid, id, name, value, args, context=None):
        return self.write(cr,uid,[id],{'num': value and value ** 0.5},context=context)
    _columns = {
        'aavgg':fields.char("Average Marks", size=15),
        'num':fields.float("Number 1"),
        'smp':fields.function(_square,fnct_inv=_square_root, string="Simple")
    }
        

def my_sqrt(x):
    EPSILON = 1e-10
    done = False
    root = (x + 1) / 2

    while not done:
        root1 = (root + x / root) / 2
        done = abs(root - root1) < EPSILON
        root = root1

    return root

def test():
    print ('Eneter a non-negative number and a negative to end the program: ')
    answer = float(input('> '))
    
    while answer >= 0:
        root = my_sqrt(answer)
        print ('The square root of %f is %f' % (answer, root))
        answer = float(input('> '))

if __name__ == '__main__': test()

import math

def sieve_of_atkin(limit):
    primes = []

    sieve = [False] * limit

    square_root_of_limit = int(math.sqrt(limit))

    for x in range(1, square_root_of_limit + 1):
        for y in range(1, square_root_of_limit + 1):
            n = (4 * x * x) + (y * y)

            if n <= limit and (n % 12 == 1 or n % 12 == 5):
                sieve[n] = not sieve[n]

            n = (3 * x * x) + (y * y)

            if n <= limit and n % 12 == 7:
                sieve[n] = not sieve[n]

            n = (3 * x * x) - (y * y)

            if x > y and n <= limit and n % 12 == 11:
                sieve[n] = not sieve[n]

    sieve[2] = True

    sieve[3] = True

    primes.append(2)

    primes.append(3)

    n = 5

    while n <= square_root_of_limit:
        if sieve[n]:
            i = n * n

            while i < limit:
                sieve[i] = False

                i += n * n

            primes.append(n)

        n += 2

    while n < limit:
        if sieve[n]:
            primes.append(n)

        n += 2

    return primes

n = 10001

limit = int((n * math.log(n)) + (n * (math.log(math.log(n)))))

print(sieve_of_atkin(limit)[n - 1])

def power(x):
    return x**2

def square_root(x):
    return np.sqrt(x)


from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

if connection.features.uses_case_insensitive_names:
    t_convert = lambda x: x.upper()
else:
    t_convert = lambda x: x
qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (t_convert(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), t_convert(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def square_root(a):
    """Return the square root of a.
        
    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x

def square_root_update(x, a):
    return average(x, a/x)

def average(x, y):
    return  (x + y)/2


       
# Group 1: Team Jacob
# Members:
#	* Jared
#	* Josh
#	* Max
#	* Santiago
#	* Travis

def sqrt(x):
	"""
	Returns the square root of a given number
	"""
 	return (x**.5)

def root(x,y):
	return (x**(1/y))

#Find the largest prime factor of a composite number.

import math

def main():
    print largestPrimeFactor(600851475143)

def largestPrimeFactor(n):
    largest = 2
    sqrtN = int(round(math.sqrt(n)))
    for i in xrange(2, sqrtN):
        #print("--" + str(i))
        if n % i == 0 and isPrime(i) and i > largest:
            largest = i
            i = n / largest
    return largest

def isPrime(n):
    squareRoot = round(math.sqrt(n))
    for i in xrange(2, int(squareRoot)):
        if n % i == 0:
            return False
    return True



if __name__ == "__main__":
    main()

import math

def add(a, b):
    return a+b
add.num_args = 2
add.symbol = "+"

def subtract(a, b):
    return a-b
subtract.num_args = 2
subtract.symbol = "-"

def multiply(a, b):
    return a*b
multiply.num_args = 2
multiply.symbol = "*"

def divide(a, b):
    return a / b
divide.num_args = 2
divide.symbol = "/"

def square_root(a):
    return math.sqrt(abs(a))
square_root.num_args = 1
square_root.symbol = "sqrt"

def power(a, b):
    return math.pow(a, round(b))
power.num_args = 2
power.symbol = "^"

def greater_than(a, b, yes, no):
    if a > b:
        return yes
    else:
        return no
greater_than.num_args = 4
greater_than.symbol = ">"

def lesser_than(a, b, yes, no):
    if a < b:
        return yes
    else:
        return no
lesser_than.num_args = 4
lesser_than.symbol = "<"

func_list = [add, subtract, multiply, divide, square_root, power, greater_than, lesser_than]

"""
a set of cost functions for Neural Network layers.
"""

import theano.tensor as T


def l1_norm(w):
    """
    Returns L1 norm of the given matrix (w).
    L1 norm is simply sum of a matrix elements.

    @input: w, a theano shared variable.
    @output: L1 norm of w
    """

    return abs(w).sum()


def l2_norm(w):
    """
    Returns L2 norm of the given matrix (w).
    L2 norm of a matrix is simply square root of the sum of square of elements of the matrix.
    In an other word, it's length for a matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return T.sqrt((w ** 2).sum())


def l2_norm_sqr(w):
    """
    Returns square of L2 norm of the given matrix (w).
    square of L2 norm of a matrix is simply the sum of square of elements of the matrix.
       
    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return (w ** 2).sum()

# TODO
# add contractive cost function.

def square_root(x):
    def square(y):
        return y * y


    def average(x, y):
        return (x + y) / 2


    def improve(guess):
        return average(guess, (x / guess))


    def good_enough(guess):
        return abs(square(guess) - x) < 0.00001


    def square_root_iter(guess):
        if good_enough(guess):
            return guess
        else:
            return square_root_iter(improve(guess))


    return square_root_iter(1.0)

print(square_root(2))

# How to find the square root of 2?

f = lambda x: x*x - 2
df = lambda x: 2*x
# find_zero(f, df)

# How to find the cube root of 729?

g = lambda x: x*x*x - 729
dg = lambda x: 3*x*x
# find_zero(g, dg)

def find_zero(f, df):
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

def newton_update(f, df):
    def update(x):
        return x - f(x) / df(x)
    return update

def square_root(a):
    def f(x):
        return x*x - a
    def df(x):
        return 2*x
    return find_zero(f, df)

def cube_root(a):
    return find_zero(lambda x: x*x - a,
                     lambda x: 2*x)

def power(x, n):
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product

def root(n, a):
    def f(x):
        return power(x, n) - a
    def df(x):
        return n * power(x, n-1)
    return find_zero(f, df)



def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-15):
    return abs(x-y) < tolerance

def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    def update(x):
        return square_root_update(x ,a)
    def close(x):
        return approx_eq(x*x, a)
    return improve(update, close)

def square_root_update(x, a):
    return (x + a/x) / 2

def cube_root(a):
    return improve(lambda x: cube_root_update(x, a),
                   lambda x: approx_eq(pow(x, 3), a))

def cube_root_update(x, a):
    return (2*x + a/(x*x)) / 3

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

class Solution:
   # Time: O(logn)
   # Space: O(1)
   def squareRootInt(self, x):
      if x <= 1: return x
      l, r = 0, x
      while l + 1 < r:
         mid = l + ((r - l) >> 1)
         if mid * mid == x: return mid
         elif mid * mid < x: l = mid
         else: r = mid - 1
      return r if r * r <= x else l

if __name__ == "__main__":
   t = Solution()
   for i in range(10):
      print t.squareRootInt(i),

import genutil


def compute(dm, do):
    """ Computes rms"""
    if dm is None and do is None:  # just want the doc
        return {
            "Name": "Spatial Root Mean Square",
            "Abstract": "Compute Spatial Root Mean Square",
            "URI": "http://uvcdat.llnl.gov/documentation/" +
            "utilities/utilities-2.html",
            "Contact": "Peter Gleckler <gleckler1@llnl.gov>",
        }
    return float(genutil.statistics.rms(dm, do, axis='xy', weights='weighted'))

#56) Given a int number, write code to judge the number of all its factor is an even number or an odd number
import math

def isPerfectSquare(num):
	squareRoot = math.sqrt(num)
	return squareRoot**2 == num

def countEvenOrOddFactors(num):
	if isPerfectSquare(num):
		return "Odd number of factors"
	else:
		return "Even number of factors"


def main():
	num = input("Enter the number")
	print countEvenOrOddFactors(num)

main()
import time
from fractions import gcd
import math

start_time = time.time()


# def is_int_dist(a, b, c):
#     square = min(
#         a ** 2 + (b + c) ** 2,
#         b ** 2 + (a + c) ** 2,
#         c ** 2 + (b + a) ** 2
#     )
#     root = math.sqrt(square)
#     return root % 1 == 0

#
#
# def is_int_dist_2(a, b, c):
#     square = c ** 2 + (b + a) ** 2
#     root = math.sqrt(square)
#     return root % 1
#
# squares = {}
#
#
# assert is_int_dist(3, 5, 6)

LIMIT = 99
pyt = {}

for m in xrange(1, LIMIT):
    for n in xrange(m + 1, LIMIT):
        k = 1
        a = n ** 2 - m ** 2
        b = 2 * m * n
        if (m - n) % 2 == 0 or gcd(m, n) != 1:
            continue

        while True:
            temp_a = a * k
            temp_b = b * k
            max_pyt = max(temp_a, temp_b)
            min_pyt = min(temp_a, temp_b)
            if min_pyt > LIMIT:
                break
            pyt[min_pyt, max_pyt] = 1
            k += 1

counter = 0
print pyt
for a, b in pyt:
    temp = b // 2

    if temp >= LIMIT:
        continue
    elif b < LIMIT:
        counter += (a // 2)

    if temp <= a:
        counter += (a - temp)
        if (a - temp) % 2 == 0:
            counter += 1

    print a, b, counter


# for i in range(1, LIMIT):
#     for j in range(i, LIMIT):
#         for k in range(j, LIMIT):
#             if is_int_dist(i, j, k):
#                 counter += 1

print counter

print time.time() - start_time, "seconds"

'''
Problem:
  Given a positive integer n, determine whether it is prime using trial
  division by all primes not exceeding its square root.

Constraints:
  n - must be a positive integer
'''

def problem(n):
  if (n < 1):
    raise ValueError("n must be a positive integer")
  elif (n == 1):
    return True
  elif (n == 2):
    return False

  square_root = int(n ** .5)

  for i in xrange(0, square_root + 1):
    if (isPrime(i)):
      if (n % i == 0):
        return True

  return False

# Trivial prime checker
def isPrime(n):
  if (n <= 1):
    return False
  elif (n == 2):
    return True
  elif (n % 2 == 0):
    return False

  sqrt = int(n ** .5) + 1

  i = 3

  while i < sqrt:
    if (n % i == 0):
      return False

  return True

"""
square root using while
(c) @brupoon
Ch. 7, ex. 3 Thinkpython
"""

from math import sqrt
from prettytable import PrettyTable

def square_root(a):
    """Approximates the square root of input a to accuracy of 0.000001"""
    x = a/2
    while True:
        print(x)
        y = (x + a/x) / 2
        if abs(y-x) < 0.000001:
            break
        x = y
        
    return x

def test_square_root():
    """ Tests square_root against math.sqrt for int vals from 1-9 inclusive"""
    mytab = PrettyTable(["number", "est Sqrt", "math Sqrt", "abs diff"])
    mytab.padding_width = 1
    for x in range(1,10):
        math_val = sqrt(x)
        bp_val = square_root(x)
        difference = math_val - bp_val
        if difference < 0:
            difference = -difference
            #ghetto abs()
        mytab.add_row([x,math_val,bp_val,difference])
    print(mytab)

if __name__ == '__main__':
    test_square_root()
from kivy.app import App
from kivy.lang import Builder
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.clock import Clock

state = Object()
state.in_game = True
state.current_player = False
state.board = [None] * 9
state.root = None

players = ['X', 'O']
winning_directions = [
        [1, 3, 4],
        [3],
        [3, 2],
        [1],
        [],
        [],
        [1],
        [],
        [],
]

class TicTacToeApp(App):
    def build(self):
        state.root = Builder.load_file('main.kv')
        return state.root

def new_game(self, root):
    board_widget = root.ids.board
    for square_num in range(len(state.board)):
        state.board[square_num] = None
        board_widget.children[square_num].text = ''
        board_widget.children[square_num].background_color = [0.25, 0, 0.25, 1]
    state.in_game = True
    state.current_player = False
    root.ids.status.text = 'Turn: {}'.format(players[state.current_player])

def check_winner(root):
    open_squares = 0
    board_widget = root.ids.board
    for square in range(len(state.board)):
        player = state.board[square]
        if player is None:
            open_squares += 1
            continue
        for direction in winning_directions[square]:
            if (player == state.board[square + direction]
                    and player == state.board[square + 2 * direction]):
                state.in_game = False
                for button_number in (square,
                        square + direction,
                        square + 2 * direction):
                    # The next line is to work around the children being in
                    # reverse order from the .kv file.
                    # This is apparentnly deliberate behavior, optimized for
                    # touch dispatch?
                    kids = list(reversed(board_widget.children))
                    kids[button_number].background_color = [1, 0, 1, 1]
                root.ids.status.text = '{} wins!'.format(players[player])
    if open_squares < 1:
        root.ids.status.text = 'Tie!'
        state.in_game = False

def press(button, root):
    if not state.in_game:
        return
    square = button.square
    if state.board[square] is not None:
        return
    button.text = players[state.current_player]
    state.board[square] = state.current_player
    state.current_player = not state.current_player
    root.ids.status.text = 'Turn: {}'.format(players[state.current_player])
    check_winner(root)

if __name__ == '__main__':
    app = TicTacToeApp()
    app.run()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/bin/python
#AUTHOR: alexxa
#DATE: 25.12.2013
#SOURCE: Think Python: How to Think Like a Computer Scientist by Allen B. Downey
# http://www.greenteapress.com/thinkpython/html/index.html
#PURPOSE: Chapter 7. Iteration

# Exercise 7.2
# Encapsulate this loop in a function called square_root that 
# takes a as a parameter, chooses a reasonable value of x, and 
# returns an estimate of the square root of a.

def square_root(a):
    x = a
    while True:
        if x == 0:
            return 0
        
        y = (x + a/x) / 2        
        if y == x:
            return y
        x = y
            
print(square_root(0))
print(square_root(1))
print(square_root(2))
print(square_root(9))
print(square_root(225))
#END

def read(fn):
    # also look at readline() and readlines() functions
    return open(fn,'r').read()

x = {'and':'of', 'square':'root', 'center':'point', 'microscope':'image'}


import math

def is_prime(n):
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    max_divisor = int(n ** 0.5) # square root of n
    divisor = 5
    while divisor <= max_divisor:
        if n % divisor == 0 or n % (divisor + 2) == 0:
            return False
        divisor += 6
    return True

def factorize(n):
    factors = []

    for x in range(2, int(math.sqrt(n))+1):
        if n%x == 0:
            factors.append(x)
            factors.append(n/x)

    return factors

def chunker(lst, length):
    return (lst[pos:pos+length] for pos in xrange(0, len(lst)))


# Uppgift 4
[str(i) for i in range(4)]


# Uppgift 5
from math import sqrt # square root
list(filter(lambda x: sqrt(x).is_integer(), range(1000, 1200)))


# Uppgift 6
>>> def make_decrementor(n):
...     return lambda x: n - x
...
>>> f = make_decrementor(42)
>>> f(0)
42
>>> f(1)
41
>>> f(-3)

import math
import random

############################
## Wiener's Attack module ##
############################

# Calculates bitlength
def bitlength(x):
  assert x >= 0
  n = 0
  while x > 0:
    n = n+1
    x = x>>1
  return n
  
# Squareroots an integer
def isqrt(n):
  if n < 0:
    raise ValueError('square root not defined for negative numbers')  
  if n == 0:
    return 0
  a, b = divmod(bitlength(n), 2)
  x = 2**(a+b)
  while True:
    y = (x + n//x)//2
    if y >= x:
      return x
    x = y

# Checks if an integer has a perfect square
def is_perfect_square(n):
  h = n & 0xF; #last hexadecimal "digit"    
  if h > 9:
    return -1 # return immediately in 6 cases out of 16.
  # Take advantage of Boolean short-circuit evaluation
  if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
    # take square root if you must
    t = isqrt(n)
    if t*t == n:
      return t
    else:
      return -1    
  return -1

# Calculate a sequence of continued fractions
def partial_quotiens(x, y):
  partials = []
  while x != 1:
    partials.append(x // y)
    a = y
    b = x % y
    x = a
    y = b
  #print partials
  return partials

# Helper function for convergents
def indexed_convergent(sequence):
  i = len(sequence) - 1
  num = sequence[i]
  denom = 1
  while i > 0:
    i -= 1
    a = (sequence[i] * num) + denom
    b = num
    num = a
    denom = b
  #print (num, denom)
  return (num, denom)

# Calculate convergents of a  sequence of continued fractions
def convergents(sequence):
  c = []
  for i in range(1, len(sequence)):
    c.append(indexed_convergent(sequence[0:i]))
  #print c
  return c

# Calculate `phi(N)` from `e`, `d` and `k`
def phiN(e, d, k):
  return ((e * d) - 1) / k

# Wiener's attack, see http://en.wikipedia.org/wiki/Wiener%27s_attack for more information
def wiener_attack(N,e):
  (p,q,d) = (0,0,0)
  conv=convergents(partial_quotiens(e,N))
  for frac in conv:
    (k,d)=frac
    if k == 0:
      continue
    y = -(N - phiN(e, d, k) + 1)
    discr = y*y - 4*N
    if(discr>=0):
      # since we need an integer for our roots we need a perfect squared discriminant
      sqr_discr = is_perfect_square(discr)
      # test if discr is positive and the roots are integers
      if sqr_discr!=-1 and (-y+sqr_discr)%2==0:
        p = ((-y+sqr_discr)/2)
        q = ((-y-sqr_discr)/2)
        return p, q, d
  return p, q, d

################################
## End Wiener's Attack module ##
################################
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math

def sqrt(x):
    """Approximates the square root of the number x. 

    This function is provided for demonstration purposes, 
    you should use the provided math.sqrt(x) instead.
    
    """
    return sqrt_helper(1.0, x)     # We chose 1.0 as our arbitrary starting value.


def sqrt_helper(guess, x):
    """Helper function that actually performs the algorithm for sqrt(x)"""
    if good_enough(guess, x):    # We'll call it good if the square 
        return guess                            # of our guess is within 0.0001 of our number x
    return sqrt_helper(improve_guess(guess, x), x)

def good_enough(guess, x):
    """Return true if close enough, otherwise false."""
    if math.fabs(guess**2 - x) < 0.001:     # Good enough if absolute value of difference less than arbitrary amount 0.001
        return True
    return False

def improve_guess(guess, x):
    """Improves the guess by Heron's method

    That is, average the guess and the quotient of x and the guess.

    """
    return (guess + (x / guess)) / 2.0

def example_sqrt(x):
    """Prints example output in a string"""
    print("The square root of " + str(x) + " is " + str(sqrt(x)))
    return None

i = 1
while(i < 10):
    example_sqrt(i)
    i += 1

from __future__ import division
from random import random

def heron_square_root(x, guess=):
	g = random() * x
	print "Trying %d" % g
	print round(g**2, 4)

	if round(g**2, 2) == round(x, 2):
		return g
	else:
		return heron_square_root((g + x/g) / 2)

heron_square_root(25)
def square_root(number):
    left = 0
    right = number
    mid = left + (right - left) / 2.0
    while True:
        if mid**2 > number:
            right = mid
        if mid**2 < number:
            left = mid
        if abs(mid**2 - number) < 0.00001:
            break
        mid = left + (right - left) / 2.0
    return mid

def main():
    print(square_root(25))

if __name__ == '__main__':
    main()

'''
Created on Mar 5, 2015

@author: Massimiliano Mattetti
'''
import re
import json
import os

class Glob_Patterns():
    def __init__(self, glob_dict):
        self.__dict__ = glob_dict


glob_patterns = None
if not glob_patterns:
    rule_engine_dir = os.path.dirname(os.path.realpath(__file__))
    with open(rule_engine_dir + "/glob_patterns_rules.json") as gb_file:
        glob_dict = json.load(gb_file)
    glob_patterns = Glob_Patterns(glob_dict)
    
EXEC_PERMISSION = "ix"

MS_REC = 16384
MS_PRIVATE = (1 << 18)
MS_BIND = 4096
MS_REMOUNT = 32

MOUNT_FLAGS_LIST = [(1, "ro"), (2, "nosuid"), (4, "nodev"), (8, "noexec"), (16, "sync"),
                    (MS_REMOUNT, "remount"), (128, "dirsync"), (1024, "noatime"), (2048, "diratime"),
                    (MS_BIND, "bind"), (8192, "move"), (32768, "silent"), ((1 << 24), "strictatime"),
                    (MS_PRIVATE, "make-private")]


def get_layer(cgorup):
    if("docker" not in cgorup):
        return "host"
    return cgorup.split("/docker/")[1]


def replace_container_id(path):
    return re.sub(glob_patterns.container_id, "*", path)


def glob_paths(path):
    path = replace_container_id(path)
    for (regex, sub_value) in glob_patterns.glob_patterns_regex.iteritems():
        path = re.sub(regex, sub_value, path)
    return path


def glob_container_paths(path, cmd):
    full_access_paths = glob_patterns.container_full_access_paths
    if cmd == "build":
        full_access_paths += glob_patterns.container_build_full_access_paths
    
    if (path.startswith(glob_patterns.container_root)):
        for container_path in full_access_paths:
            if re.match(glob_patterns.container_root + "\*"  + container_path + ".+", path):
                return glob_patterns.container_root + "*" + container_path + "**"
    else:
        for container_path in full_access_paths:
            if re.match(container_path + ".+", path):
                return container_path + "**"
    return path


def open_permission_rule(args):
    args_list = args.split()
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(args_list[0])
    
    ''' FMODE_EXEC flag: File is opened for execution with sys_execve '''
    if(flags & 32):
        return ((replace_container_id(square_args[0]), EXEC_PERMISSION), square_args[-1])
    
    path = glob_paths(square_args[0])
    
    accmode = flags & 3
    
    ''' O_APPEND '''
    if(flags & 8192):
        new_permission = "a"
        if(accmode == 2 or accmode == 0):
            new_permission += "r"
    else:
        if(accmode == 2):
            new_permission = "rw"
        elif(accmode == 1):
            new_permission = "w"
        else:
            new_permission = "r"
    
    return ((path, new_permission), square_args[-1])


def memory_map_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path = replace_container_id(square_args[0])
    return ((path, "m"), square_args[-1]) 
 
        
def write_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "w"), square_args[1])


def read_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "r"), square_args[-1])


def rw_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "rw"), square_args[-1])


def lock_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "k"), square_args[-1])


def rename_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    old_path = glob_paths(square_args[0])
    new_path = glob_paths(square_args[1])
    return ((old_path, "rw", new_path, "rw"), square_args[-1])
        

def pivot_root_link_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path1 = glob_paths(square_args[0])
    path2 = glob_paths(square_args[1])
    return ((path1, path2), square_args[-1])


def mount_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(square_args[3])
    ftype = None
    source = None
    options = []
    
    if(flags > 0):
        options = [apparmor_mnt_flag for (mnt_flag, apparmor_mnt_flag) in MOUNT_FLAGS_LIST if(mnt_flag & flags)]
        
        if(MS_REC & flags):
            if(MS_PRIVATE & flags):
                options.remove("make-private") 
                options.append("make-rprivate")
            if(MS_BIND & flags):
                options.remove("bind")
                options.append("rbind")
    
    if((len(square_args[2]) > 0) and 
       (square_args[2] != "bind") and 
       (square_args[2] != "none") and
       (not (MS_REMOUNT & flags))):
        ftype = square_args[2]
        
    if((len(square_args[0]) > 0) and
       (not (MS_REMOUNT & flags))):
        source = glob_paths(square_args[0])
        if(source[0] == "/" and source[-1] != '/'):
            source = "%s/" % source
    
    target = glob_paths(square_args[1])
    if(target[-1] != '/'):
        target = "%s/" % target
    
    return ((ftype, options, source, target), square_args[-1])


def get_permission(line):
    args = line.split(" ", 2)
    probe_point = args[0]
    layer_id = get_layer(args[1])
    square_args = re.findall("\{(.*?)\}", args[2])
    executable_path = replace_container_id(square_args[0])
    if not probe_point_dispatcher.has_key(probe_point):
        return (None, None, None, None, None)
    other_args = line.split("{%s} " % square_args[0], 1)[1]
    (permission_tuple, root_mnt_point) = probe_point_dispatcher[probe_point](other_args)
    return (probe_point, layer_id, executable_path, permission_tuple, root_mnt_point)
    

probe_point_dispatcher = {
                "security_file_open" : open_permission_rule,
                "security_path_symlink" : write_permission_rule,
                "security_path_unlink" : write_permission_rule,
                "security_path_mkdir" : write_permission_rule,
                "security_path_rmdir" : write_permission_rule,
                "security_path_mknod" : rw_permission_rule,
                "security_sb_pivotroot" : pivot_root_link_permission_rule,
                "security_path_link" : pivot_root_link_permission_rule,
                "security_path_rename" : rename_permission_rule,
                "security_path_truncate" : write_permission_rule,
                "security_file_lock" : lock_permission_rule,
                "security_mmap_file" : memory_map_permission_rule,
                "security_file_mprotect" : memory_map_permission_rule,
                "do_mount" : mount_permission_rule,
                "security_path_chroot" : read_permission_rule,
                "security_path_chmod" : write_permission_rule,
                "security_path_chown" : write_permission_rule
                }

def square_root_continuous(x, epsilon=.01):
    step = epsilon**2
    num_guesses = 0
    ans = 0.0
    while abs(ans**2 - x) >= epsilon and ans <= x:
        ans += step
        num_guesses += 1
    print('Tried ' + str(num_guesses) + ' times')
    
    return(ans)

def square_root_bisect(x, epsilon=.01):
    num_guesses = 0
    low = 0.0
    high = float(x)
    ans = (low + high) / 2.0 
    while abs(ans**2 - x) >= epsilon and ans <= x:
        num_guesses += 1
        if ans**2 > x:
            high = ans
        else:
            low = ans
        ans = (low + high) / 2.0
    print('Tried ' + str(num_guesses) + ' times')
    
    return(ans)

n = 14234
print(square_root_continuous(n, .01))
print(square_root_bisect(n, .000000001))
import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)

def square(x):
    return x * x


def average(x, y):
    return (x + y) / 2


def improve(guess, x):
    return average(guess, (x / guess))


def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001


def square_root_iter(guess, x):
    if good_enough(guess, x):
        return guess
    else:
        return square_root_iter(improve(guess, x), x)


def square_root(x):
    return square_root_iter(1.0, x)

#It is found that adding two subsequent odd numbers give square of a number.
# 1+3=4 which is square of 2
#4+5=9 and so on.

# writing a program to compute a entered number square root using this method
#if we have to find square root of 6 we will add first six odds->1+3+5+7+9+11

from __future__ import print_function #to make print finction like print('hi',end=' ') work in python 2.6 and above, for compatibility
import sys

if sys.version_info[0]<3: 
        input=raw_input


def prime_finder(num):
	start_odd=1
	sum=0
	while(num>=1):
		sum=sum+start_odd
		start_odd=start_odd+2
		num=num-1

	return sum

number=input("Enter the number you want to find square of-->")
print("The square of "+number+" is "+ str(prime_finder(int(number))))	

# Highly divisible triangular number
# Problem 12
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?
from math import sqrt
def number_of_divisors(n):
  divisors = 0
  square_root = int(sqrt(n))
  for i in range(1, square_root + 1):
    if n % i == 0:
      divisors += 2

  # adjust for perfect squares
  if square_root * square_root == n:
    divisors -= 1

  return divisors

def triangular_number_with_n_divisors(n):
  # init triangular number
  triangular_number = 1

  # init natural number
  natural_number = 1

  while number_of_divisors(triangular_number) < n:
    natural_number += 1
    triangular_number += natural_number

  return triangular_number


print triangular_number_with_n_divisors(500)

from decimal import getcontext, Decimal


def solver(n=100, m=100):
    """ For the first n natural numbers, find the total of the digital sums
    of the first m decimal digits for all the irrational square roots.
        
    (solved 2014-11-26)
    """
    result = 0
    getcontext().prec = m + 2  # set precision
    for number in range(n + 1):
        square_root = Decimal(number).sqrt()  # compute square root
        if square_root % 1:  # if square_root is not a perfect square
            # Get m precision of decimal places and sum them up for each number
            decimal_places = str(square_root).replace(".", "")[:m]
            result += sum(int(digit) for digit in decimal_places)
    return result
    
solver()
#!/usr/bin/env python

def r8_pi_sqrt ( ):

#*****************************************************************************80
#
## R8_PI_SQRT returns the square root of pi as an R8.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 June 2013
#
#  Author:
#
#    John Burkardt
#
#  Parameters:
#
#    Output, real VALUE, the square root of pi.
#
  value = 1.7724538509055160273

  return value


#!/usr/bin/python3

"""
Square root digital expansion
Problem 80

https://projecteuler.net/problem=80
"""

from decimal import getcontext, Decimal

getcontext().prec = 102

def digital_sum(n):
    return sum([int(i) for i in str(n).split('.')[-1]])

# set of all numbers < 100 with an irrational square root
non_squares = set(range(100)).difference([i*i for i in range(10)])

s = 0
for i in non_squares:
    n = Decimal(str(Decimal(i).sqrt()).split('.')[-1][:-2])
    s += digital_sum(n) + int(str(Decimal(i).sqrt()).split('.')[0])

print(s)

def gcd(a, b):
    if a == b:
        return a
    if a < b:
        return gcd(b, a)
    if b == 0:
        return a
    return gcd(b, a%b)

def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x    = 1
    xOld = 1
    while True:
        aux = ( x + ( n / x ) ) / 2
        if aux == x:
            return x
        if aux == xOld:
            return min(x, xOld)
        xOld = x
        x = aux

def solve():
    B = 10 ** 12
    s = set()
    for a in range(2, 10**4):
        a3 = a ** 3
        for b in range(1, a):
            b2 = b ** 2
            if b2 * (a3 + 1) >= B:
                break
            c = 1
            n = a3 * b * c * c + c * b2
            while n <= B:
                r = iSqrt(n)
                if r * r == n:
                    s.add(n)
                c += 1
                n = a3 * b * c * c + c * b2
    return sum(s)

if __name__ == "__main__":
    result = solve()
    print "Result: %d" % result

def squareRootBi(x,epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' +str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    
    low = 0
    high = max(x, 1)
    guess = (low + high)/2.0
    ctr = 1

    while abs(guess**2 - x) > epsilon and ctr <= 100:
        #print 'low:', low, 'high:', high, 'guess:', guess

        if guess**2 < x:
            low = guess
        else:
            high = guess

        guess = (low + high)/2.0
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'
    #print 'Bi method. Num. iterations:', ctr, 'Estimate:', guess
    return guess

def testBi():
    print 'squareRootBi(4,0.0001) returns', squareRootBi(4,0.0001)
    print 'squareRootBi(9,0.0001) returns', squareRootBi(9,0.0001)
    print 'squareRootBi(2,0.0001) returns', squareRootBi(2,0.0001)
    print 'squareRootBi(0.25,0.0001) returns', squareRootBi(0.25,0.0001)

def squareRootNR(x, epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' +str(x)
    assert epsilon > 0, 'epsilon must be positive, not'+str(epsilon)

    x = float(x)
    guess = x/2.0
    #guess = 0.001
    diff = guess**2 - x
    ctr = 1

    while abs(diff) > epsilon and ctr <= 100:
        print 'Error:', diff, 'guess:', guess

        guess = guess - diff/(2.0*guess)
        diff = guess**2 - x
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR method. Num iterations:', ctr, 'Estimate:', guess
    return guess

##Techs = ['MIT', 'Cal Tech']
##print Techs
##Ivys = ['Harvard', 'Yale', 'Brown']
##print Ivys
##Univs = []
##Univs.append(Techs)
##print Univs
##Univs.append(Ivys)
##raw_input()
##print Univs
##raw_input()
##for e in Univs:
##    print e
##    for c in e: print c
##raw_input()
##Univs = Techs + Ivys
##print Univs
##Ivys.remove('Harvard')
##print Univs
##raw_input()
##Ivys[1] = -1
##print Ivys

##L1 = [1,2,3]
##L2 = L1
##L1[0] = 4
##print L2

##L1 = [1,2,3]
##L2 = L1[:] #makes a copy of L1
##L1[0] = 4
##print L2

##L = [['un', 'one'], ['deux', 'two']]
##
##def keySearch(L,k): #goes through nested list L and finds k, returns value adjacent to k
##    for elem in L:
##        if elem[0] == k: return elem[1]
##    return None


##EtoF = {'one':'un', 'soccer': 'football'}
##print EtoF['soccer']
##print EtoF
####print EtoF[0]

##NtoS = {1: 'one', 2: 'two', 'one': 1, 'two': 2}
##print NtoS.keys()
##print NtoS.keys
##del NtoS['one']
##print NtoS

import math
from helpers import helpers

MAX_RANGE = 10000

def is_square(num):
    root = math.sqrt(num)
    return root == int(root)

def get_smallest_not_satisfying_golbach():
    primes = []

    for candidate in range(3, MAX_RANGE, 2):
        # If it is a prime
        if helpers.is_prime(candidate):
            # Store it in the primes list
            primes.append(candidate)
        else:
            # If it cannot be written as the sum of a prime and a square
            if not any(is_square((candidate - prime) / 2) for prime in primes):
                return candidate

def main():
    answer = get_smallest_not_satisfying_golbach()
    print(answer)

if __name__ == '__main__':
    main()

def newtonSqrt(n):
    '''Calculates the square root of n'''
    
    i = 0
    approx = n / 2
    better_approx = 0.5 * (approx + (n / approx))

    while better_approx != approx:
        
        approx = better_approx
        better_approx = 0.5 * (approx + (n / approx))
        i = i + 1
        print(better_approx, "number of iterations: ", i)

    return approx

number = float(input("Enter the number: "))

print("Square root of the number is: ", newtonSqrt(number))

#Thinkpython chapter 7 exercise 7.3

#Test my sqrt estimating function against math.sqrt

import math


def square_root(n):
	"""
		epsilon_constant is used to determine how close the approximation needs to be
		x is initial estimate. y is the output of the formula, which is used as the 
		estimate for the next pass. loop runs until successive estimates
		are very close.

	"""
	epsilon_constant = .0000000000000001
	x = n
	y = n
	while True:
		x = y
		y = (float(x) + (float(n)/float(x)))/2
		if abs(y-x) < epsilon_constant:
			break
	return y


def test_square_root(n):
	for i in range(n):
		print str(i+1).rjust(4), 
		print str(square_root(i+1)).rjust(15),
		print str(math.sqrt(i+1)).rjust(15),
		print str(abs(square_root(i+1) - math.sqrt(i+1))).rjust(15)


test_square_root(10)
import math

def main():
	x = float(raw_input("Enter the number: "))
	guess = x / 2
	guess1 = nextGuess(guess,x)
    
	print "The square root is", guess1

def nextGuess(guess,x):
	g = int(raw_input("Enter the number of iterations: "))
	for i in range(g):
		guess = (guess + (x/guess))/2
	
	diff = math.sqrt(x)- guess
	print "The difference is", diff
	return guess
	

main()
def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess

def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed.")
    except ZeroDivisionError:
        print("Cannot compute square root of a negative number.")
    print("Program execution continues normally here.")

if __name__ == '__main__':
    main()

#!/usr/bin/python

########################################################
## fixed points of functions, ith roots of positive
## integers, the golden ratio as a fixed point
## 
## bugs to vladimir dot kulyukin at gmail dot com
######################################################

import math

def average(x, y): return (x + y)/2.0

## (x, f(x))/2.0
def average_damp(f): return lambda x: average(x, f(x))

error_tolerance = .00001

def find_fixed_point(f, guess):
    global error_tolerance
    def is_close_enough(x, y):
        return abs(x - y) <= error_tolerance

    next_guess = f(guess)
    if is_close_enough(guess, next_guess):
        return next_guess
    else:
        return find_fixed_point(f, next_guess)

## f(x): n/x^(i-1)
## the it-th root of a positive integer n can
## be computed as a fixed point of the average damp of
## lambda x: n / (x**(i-1))
def ith_root_lambda(n, i):
    return lambda x: n / (x**(i-1))

## sqrt(n) is a fixed point of the average damp
## of lambda x: n/x; 1.0 is the 1st guess
def square_root_01(n):
    return find_fixed_point(average_damp(lambda x: n/x),
			    1.0)

## sqrt(n) is a fixed point of the average damp
## of ith_root_lambda(n, 2) == lambda x: n / (x**1)
def square_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 2)),
			    1.0)

## n^(1/3) is a fixed point of the average damp
## of lambda x: n / (x * x); 1.0 is the 1st guess.
def cubic_root_01(n):
    return find_fixed_point(average_damp(lambda x: n / (x * x)),
			    1.0)

## n^(1/3) is a fixed point of the average damp
## of ith_root_lambda(n, 3) == lambda x: n / (x**2)
def cubic_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 3)),
			    1.0)

## the golden ratio is a fixed point of the average
## damp of the average damp of lambda x: 1 + 1/x; 1.0 is
## 1st guess.
def the_golden_ratio():
    return find_fixed_point(average_damp(lambda x: 1 + 1/x), 1.0)

print square_root_01(2), ' ', square_root_03(2), ' ',\
      2**0.5, "\n"
print square_root_01(3), ' ', square_root_03(3), ' ',\
      3**0.5, "\n""\n"
print square_root_01(9), ' ', square_root_03(9), ' ',\
      9**0.5, "\n""\n""\n"

print cubic_root_01(2), ' ', cubic_root_03(2), ' ',\
      2**(1/3.0), "\n"
print cubic_root_01(3), ' ', cubic_root_03(3), ' ',\
      3**(1/3.0), "\n"
print cubic_root_01(9), ' ', cubic_root_03(9), ' ',\
      9**(1/3.0), "\n"

print the_golden_ratio(), "\n"





from scipy import power
from amari import Amari


class RMSProp(Amari):
    """ Root-mean-square-normalized SGD (Hinton 2012). """    

    exponent = -0.5

    @property
    def learning_rate(self):
        return self.init_lr * power(self._acc_grad_var, self.exponent)

# Exercise 7-3.
# To test the square root algorithm in this chapter, you could compare it with
# math.sqrt . Write a function named  test_square_root that prints a table like this:
# 1.0 1.0 1.0 0.0
# 2.0 1.41421356237 1.41421356237 2.22044604925e-16
# 3.0 1.73205080757 1.73205080757 0.0
# 4.0 2.0 2.0 0.0
# 5.0 2.2360679775 2.2360679775 0.0
# 6.0 2.44948974278 2.44948974278 0.0
# 7.0 2.64575131106 2.64575131106 0.0
# 8.0 2.82842712475 2.82842712475 4.4408920985e-16
# 9.0 3.0 3.0 0.0
# The first column is a number, a; the second column is the square root of a computed
# with the function from Square Roots (page 79); the third column is the square root
# computed by  math.sqrt ; the fourth column is the absolute value of the difference be
# tween the two estimates.
import math

def square_root(a):
    epsilon = 10e-15
    x = a/2
    while True:
        y = (x + a/x)/2
        if abs(y-x) < epsilon:
            break
        x = y
    return x

print("n\tsqrt_hat\tsqrt\tdiff")

n=1
while (n<10):
    est_sqrt = square_root(n)
    real_sqrt = math.sqrt(n)
    print(n,est_sqrt,real_sqrt,abs(est_sqrt-real_sqrt),sep="\t")
    n=n+1

def add(token):
    tot = 0
    for i in range(1,len(token)):
        tot = tot + float(token[i]) 
    return tot

def subtract(token):
    tot = float(token[1])
    for i in range(2,len(token)):
        tot = tot - float(token[i]) 
    return tot

def multiply(token):
    product = 1
    for i in range(1, len(token)):
        product = product * float(token[i])
    return product

def divide(token):
    quo = float(token[1])
    for i in range(2, len(token)):
        quo = quo / float(token[i])
    return quo

def square(token):
    return float(token[1])*float(token[1])

def cube(token):
    return float(token[1]) ** 3

def power(token):
    base = float(token[1])
    for i in range(2,len(token)):
        base = base ** float(token[i])
    return base

def mod(token):
    return float(token[1]) % float(token[2])

def root(token):
    return float(token[1])**(1/float(token[2]))

import math

def eratosthenesSeive(limit):
	limit = limit+1
	notPrime = set()
	primes = []
	for i in range(2, limit):
		if i in notPrime:
			continue
		for f in range(i*2, limit, i):
			notPrime.add(f)
		primes.append(i)
	return primes

def checkSquare(n):
	root = int(math.pow(n, .5))
	if root*root == n:
		return True
	return False

primes = eratosthenesSeive(10000)
setOfPrimes = set()
for prime in primes:
	setOfPrimes.add(prime)

def main():
	found = False
	num = 1
	while not found:
		num += 2
		if num not in setOfPrimes:
			i = 0
			foundPrime = False
			while primes[i] < num:
				diff = num - primes[i]
				if checkSquare(diff/2):
					foundPrime = True
					break
				i += 1
			if not foundPrime:
				found = True
	print num

if __name__ == '__main__':
	main()

import sys
import math
import time


def main():
    case_num = raw_input("Please input your cases:\n")
    for i in range(1, int(case_num) + 1):
        detect_case(i)


def detect_case(case):
    num_range = (sys.stdin.readline()).split('\n')[0]
    min = int(num_range.split(" ")[0])
    max = int(num_range.split(" ")[1])
    result = get_num(min, max)
    sys.stdout.write("\nCase #{}: {}\n".format(case, result))


def get_num(min, max):
    result = 0
    for i in range(min, max + 1):
        if is_par_square(i):
            result += 1
    return result


def is_par_square(number):
    if is_par(str(number)) and is_square(number):
        if is_par(str(int(math.sqrt(number)))):
            return True
    return False


def is_par(number):
    reversed_number = ""
    if 1 == len(number):
        return True
    else:
        for i in range(len(number) - 1, -1, -1):
            reversed_number += number[i]
        if number == reversed_number:
            return True
    return False


def is_square(number):
    square_root = str(math.sqrt(number)).split('.')[1]
    if 1 == len(square_root) and '0' == square_root:
        return True
    return False


if __name__ == "__main__":
    startTime = time.clock()
    main()
    sys.stdout.write("The running time is {}(s)\n".format(time.clock() - startTime))

import math

def update_probabilities():
    """Based on the current scores, update the probability of gettings a 
    question."""
    pass

def increment_score(question_id, function):
    """Increment the score of a question based on the given function."""
    pass

def decrement_score(question_id, function):
    """Decrement the score of a question based on a given function."""
    pass

def update_alg_square(score):
    """Change the score by squaring."""
    return score * score

def update_alg_squarert(score):
    """Change the score by taking the square root."""
    return math.sqrt(score)

__author__ = 'nunoe'


def newton_raphson_root(value, power, epsilon):
    """ function used to find the root of a given value through the Newton-Raphson method

    :param value: int, number for which we want to find the root
    :param power: int, power that turns the root into the given value
    :param epsilon: float, tolerance used when testing the root
    :return: float, the root of the given value
    """
    result = value / 2.0

    while abs(result ** power - value) >= epsilon:
        result += (value - result ** power) / (power * result ** (power - 1))
    return result

if __name__ == '__main__':
    print 'The cubic root of 27 is ' + str(newton_raphson_root(27, 3, 0.001))
    print 'The square root of 9 is ' + str(newton_raphson_root(9, 2, 0.001))
from flask import Flask, request, url_for, jsonify, redirect
from functools import wraps

app = Flask(__name__)

####################

def check_auth(username, password):
    return username == 'admin' and password == 'secret'

def authenticate():
    message = {'message': "Authenticate."}
    resp = jsonify(message)

    resp.status_code = 401
    resp.headers['WWW-Authenticate'] = 'Basic realm="Example"'

    return resp

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth: 
            return authenticate()

        elif not check_auth(auth.username, auth.password):
            return authenticate()
        return f(*args, **kwargs)

    return decorated
####################

@app.route('/')
@requires_auth
def api_root():
	#return 'Welcome to WSGI python based server'
	data={'Hello':'world','I am':'testing'}
	resp = jsonify(data)
	resp.status_code = 200
	return resp

@app.route('/square/<num>/')
def api_square(num):
	return ' Square of ' + num + ' is: ' + str(int(num)*int(num))

@app.route('/secrets/')
@requires_auth
def api_hello():
    return redirect("http://www.google.com", code=302)



if __name__ == '__main__':
	app.run(debug=True, host='0.0.0.0')

def test_square_root():
	for i in range(1,10):
		sr=square_root(float(i))
		msr=math.sqrt(float(i))
		print '%f %f %ff %f %f %f'%(float(i),sr,msr,abs(sr-msr))

def square_root(a):
	x=3
	while True:
		y=(x+a/x)/2
		if abs(x-y)<epsilon:
			break
		x=y

	return x


import math
epsilon=0.0000000000001
test_square_root()

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-14):
    return abs(x - y) < tolerance
    
def average(x, y):
    return (x + y)/2
    
def sqrt(a):
    def sqrt_update(x):
        return average(x, a/x)
    def sqrt_close(x):
        return approx_eq(x * x, a)
    return improve(sqrt_update, sqrt_close)
    
def newton_update(f, df):
    return lambda x: x - f(x) / df(x)

def find_zero(f, df):
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

def square_root_newton(a):
    def f(x):
        return x * x - a
    def df(x):
        return 2 * x
    return find_zero(f, df)
    
def power(x, n):
    """Return x * x * x * ... * x for x repeated n times."""
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product
    
def nth_root_of_a(n, a):
    def f(x):
        return power(x, n) - a
    def df(x):
        return n * power(x, n - 1)
    return find_zero(f, df)
    
def curried_power(x):
    return lambda y: power(x, y)
    
def curried_nth_power(x):
    return lambda y: power(y, x)
    
def map_to_range(start, end, f):
    while start < end:
        print(f(start))
        start = start + 1
        
def curry2(f):
    """Return a curried version of the given two-argument function."""
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g
    
def uncurry2(g):
    """Return a two-argument version of the given curried function."""
    def f(x, y):
        return g(x)(y)
    return f
    
def trace(fn):
    def wrapped(x):
        print('-> ', fn, '(', x, ')')
        return fn(x)
    return wrapped
    
def tracetest(fn):
    return 5
    
@tracetest
def ftest():
    return 26
    
@trace
def quadruple(x):
    return 4 * x
    
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math
import random

############################
## Wiener's Attack module ##
############################

# Calculates bitlength
def bitlength(x):
  assert x >= 0
  n = 0
  while x > 0:
    n = n+1
    x = x>>1
  return n
  
# Squareroots an integer
def isqrt(n):
  if n < 0:
    raise ValueError('square root not defined for negative numbers')  
  if n == 0:
    return 0
  a, b = divmod(bitlength(n), 2)
  x = 2**(a+b)
  while True:
    y = (x + n//x)//2
    if y >= x:
      return x
    x = y

# Checks if an integer has a perfect square
def is_perfect_square(n):
  h = n & 0xF; #last hexadecimal "digit"    
  if h > 9:
    return -1 # return immediately in 6 cases out of 16.
  # Take advantage of Boolean short-circuit evaluation
  if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
    # take square root if you must
    t = isqrt(n)
    if t*t == n:
      return t
    else:
      return -1    
  return -1

# Calculate a sequence of continued fractions
def partial_quotiens(x, y):
  partials = []
  while x != 1:
    partials.append(x // y)
    a = y
    b = x % y
    x = a
    y = b
  #print partials
  return partials

# Helper function for convergents
def indexed_convergent(sequence):
  i = len(sequence) - 1
  num = sequence[i]
  denom = 1
  while i > 0:
    i -= 1
    a = (sequence[i] * num) + denom
    b = num
    num = a
    denom = b
  #print (num, denom)
  return (num, denom)

# Calculate convergents of a  sequence of continued fractions
def convergents(sequence):
  c = []
  for i in range(1, len(sequence)):
    c.append(indexed_convergent(sequence[0:i]))
  #print c
  return c

# Calculate `phi(N)` from `e`, `d` and `k`
def phiN(e, d, k):
  return ((e * d) - 1) / k

# Wiener's attack, see http://en.wikipedia.org/wiki/Wiener%27s_attack for more information
def wiener_attack(N,e):
  (p,q,d) = (0,0,0)
  conv=convergents(partial_quotiens(e,N))
  for frac in conv:
    (k,d)=frac
    if k == 0:
      continue
    y = -(N - phiN(e, d, k) + 1)
    discr = y*y - 4*N
    if(discr>=0):
      # since we need an integer for our roots we need a perfect squared discriminant
      sqr_discr = is_perfect_square(discr)
      # test if discr is positive and the roots are integers
      if sqr_discr!=-1 and (-y+sqr_discr)%2==0:
        p = ((-y+sqr_discr)/2)
        q = ((-y-sqr_discr)/2)
        return p, q, d
  return p, q, d

################################
## End Wiener's Attack module ##
################################
__author__ = 'eric'

import numpy as np
import theano.tensor as T


def sigmoid(x):
    # return 1. / (1 + numpy.exp(-x))
    # but, overflow because of exp(-x)
    # transfer to tanh, works!
    return 0.5 * (1 + np.tanh(x / 2))


def sigmoid_T(x):
    return 0.5 * (1 + T.tanh(x / 2))


def inv_sigmoid(x):
    """
    inverse sigmoid
    """
    return np.log(x / (1. - x))


def inv_sigmoid_T(x):
    return T.log(x / (1. - x))


def RMSE(a, b):
    """
    Root Mean Square Error
    """
    return np.sqrt(np.sum(np.square(a - b), axis=1))


def RMSE_T(a, b):
    return T.sqrt(T.sum(T.square(a - b), axis=1))


if __name__ == "__main__":
    lb = np.array([1, 2, 3, 4, 5])
    print sigmoid(lb)
# Exercise 7.3 To test the square root algorithm in this chapter, you could
# compare it with math.sqrt.
# Write a function named test_square_root that prints a table like this:
# [table]
# The first column is a number, a; the second column is the square root of a
# computed with the function from Exercise 7.2; the third column is the square
# root computed by math.sqrt; the fourth column is the absolute value of the
# difference between the two estimates.

# Current Status: Complete

import math


def newtons(n):
    n = float(n)  # convert input to float so printout() doesn't have to
    x = n / 2  # rough estimate
    i = 0
    while i < 10:
        y = (x + n / x) / 2  # newtons method
        x = y
        i += 1
    return y


def libmath(n):
    n = float(n)
    return math.sqrt(n)


def printout():
    print '{:<12}\t{:<12}\t{}'.format('newtons', 'libmath', 'delta')
    for i in range(1, 10):
        n = newtons(i)
        l = libmath(i)
        ab = abs(n - l)
        print '{:<12}\t{:<12}\t{}'.format(n, l, ab)

printout()
# Exercise 7.2 Encapsulate this loop in a function called square_root that
# takes a as a parameter, chooses a reasonable value of x, and returns an
# estimate of the square root of a.

# Current Status: Complete

n = raw_input('Square root of what?\n')


def square_root(n):
    n = float(n)
    x = n / 2
    i = 0
    while i < 10:
        y = (x + n / x) / 2
        x = y
        i += 1
    return x

print square_root(n)
import sys

def sqrt(x):
	'''Compute square roots using the method of Heron of Alexandria.

	Args:
		x: The numer for which the square root is to be computed.

	Returns:
		The square root of x.
	'''

	if x < 0:
		raise ValueError("Cannot compute square root "
						 "of negative number {}".format(x))

	guess = x
	i = 0
	while guess * guess != x and i < 20:
		guess = (guess + x / guess) / 2.0
		i += 1
	return guess


	def main():
		try:
			print(sqrt(9))
			print(sqrt(2))
			print(sqrt(-1))
			print("This is never printed")
		except ZeroDivisionError as e:
			print(e, file=sys.stderr)

		print("Program execution continues normally here.")


	if __name__ == '__main__':
		main()

def square_root(number):
    if number < 0.0:
        return -1

    if number == 0.0 or number == 1.0:
        return number

    precision = 0.00001
    start = 0
    end = number

    if number < 1.0:
        end = 1

    while end - start > precision:
        mid_point = make_mid_point(start, end)
        current_square = mid_point * mid_point
        if current_square == number:
            return print("{0:.5f}".format(mid_point))
        if current_square < number:
            start = mid_point
        else:
            end = mid_point

    print("{0:.5f}".format(make_mid_point(start, end)))


def make_mid_point(start, end):
    return start + (end - start) / 2


def main():
    number = int(input())
    square_root(number)


if __name__ == '__main__':
    main()

"""
Odd period square roots
Problem 64

For conciseness, we use the notation 23 = [4;(1,3,1,8)], to indicate that the
block (1,3,1,8) repeats indefinitely.

The first ten continued fraction representations of (irrational) square roots
are:

2=[1;(2)], period=1
3=[1;(1,2)], period=2
5=[2;(4)], period=1
6=[2;(2,4)], period=2
7=[2;(1,1,1,4)], period=4
8=[2;(1,4)], period=2
10=[3;(6)], period=1
11=[3;(3,6)], period=2
12= [3;(2,6)], period=2
13=[3;(1,1,1,1,6)], period=5

Exactly four continued fractions, for N  13, have an odd period.

How many continued fractions for N  10000 have an odd period?
"""
import time

__date__ = '14-4-1'
__author__ = 'SUN'

def get_square_root(n):
    root = []
    period = []
    cache = []
    x, y = 0, 1
    while (x + 1) ** 2 <= n:
        x += 1
    root.append(x)
    if x ** 2 != n:
        while (x, y) not in cache:
            cache.append((x, y))
            k = 0
            d = (n - x ** 2) // y
            while ((k + 1) * d - x) ** 2 <= n:
                k += 1
            period.append(k)
            x, y = k * d - x, d
    root.append(period)
    return root

if __name__ == '__main__':
    start = time.clock()
    N = 10000
    count = 0
    for i in range(N + 1):
        if len(get_square_root(i)[-1]) % 2 == 1:
            count += 1
    print(count)
    print('Runtime is ', time.clock() - start)
#shortest path is always diagonal created by two shorter sides added together and longest side
#in a right triangle
#shortest path is integer if hypotenuse is a square


def is_square(n):
    root = float(n) ** .5
    root = int(root+.5)
    if root*root == n:
        return root
    else:
        return False
        
M = 10000
count = 0
#test function doing it naive way, used to verify next function on small values
for x in range(1,M+1):
    break
    for y in range(1,x+1):
        for z in range(1,y+1):
            if(is_square(x*x + (y+z)*(y+z))):
                count +=1
#print count
count  = 0


#for each possible sum of the shorter two sides I find the number of ways the sides can add up to that                
for x in range(1,M+1):
    for yz in range(2,2*x+1):
        if(is_square(x*x + yz*yz)):
            if yz <= x+1:
                count += yz/2
            else:
                count += yz/2 - (yz - x-1)
    if count > 1000000:
        print "M val", x
        break
print count
            

import re
file = open('words.txt','r')
pattern = re.compile('[\\w]+') #matches alpha numeric in double quotes
word_list = re.findall(pattern, file.read())

sorted_word_list = sorted([sorted(word) for word in word_list])

#print [sorted_word_list[x] for x in range(0,20)]

valid_sorts = []

def equal_lists(list_a, list_b):
    if(len(list_a) != len(list_b)):
        return False
    for i in range(0, len(list_a)):
        if(list_a[i] != list_b[i]):
            return False
    return True
current_match = []
previous_word = []    
for i in range(0,len(sorted_word_list)):
    word = sorted_word_list[i]

    if not equal_lists(word, current_match):
        if equal_lists(word, previous_word):
            valid_sorts = valid_sorts + [word]
            current_match = word
    previous_word = [x for x in word]
    
print len(valid_sorts)
#print valid_sorts

anagram_groups = [[] for x in valid_sorts]
for word in word_list:
    sorted_word = sorted(word)
    for i in range(0,len(valid_sorts)):
        if equal_lists(sorted_word, valid_sorts[i]):
            anagram_groups[i] = anagram_groups[i] + [word]
            
for x in anagram_groups:
    if len(x) > 2:
        print x
        #only one anagram set has more than 2 words in it
        
def is_square(n):
    root = float(n) ** .5
    root = int(root+.5)
    if root*root == n:
        return root
    else:
        return False

def to_num(list):
    sum = 0
    for i in list:
        sum = sum*10
        sum +=i
    return sum        
        
def to_list(num):
    result = []
    val = num
    while(val >0):
        result = [val%10] + result
        val = val/10
    return result
    
best_square = 0
        
for group in anagram_groups:
    for a in range(0, len(group) - 1):
        for b in range(a+1,len(group)):
            word_a = group[a]
            word_b = group[b]
            min_x = int((10**(len(word_a)-1)) ** .5)
            man_x = int((10**len(word_a)) ** .5)
            for x in range(min_x,man_x):
                vals_used = [False]*10
                square = x*x
                valid = True
                square_list = to_list(square)
                if(len(square_list) == len(word_a)):
                    sub_a = [x for x in word_a]
                    sub_b = [x for x in word_b]
                    for i in range(0,len(square_list)):
                        if not valid:
                            break
                        letter_sub = sub_a[i]
                        if letter_sub > 10: #will always be true for characters never digits
                            sub_val = square_list[i]
                            if(vals_used[sub_val]):
                                valid = False
                                break
                            vals_used[sub_val] = True    
                            for j in range(0,len(square_list)):
                                if(sub_a[j] == letter_sub):
                                    #trying to replace something with wrong digit
                                    if(square_list[j] != sub_val): 
                                        valid = False
                                        break
                                    sub_a[j] = sub_val #so i don't repeat subbing digits
                                if(sub_b[j] == letter_sub):
                                    if(j == 0 and sub_val == 0):
                                        valid = False
                                        break
                                    sub_b[j] = sub_val
                    if(valid):
                        square_a = to_num(sub_a)
                        if(square_a != square):
                            print "assertion failed", square_a, "not", square
                        square_b = to_num(sub_b)
                        if is_square(square_b):
                            #print "found match"
                            found_square = max(square_a, square_b)
                            if(found_square > best_square):
                                best_square = found_square
                                print "new best", square_a, square_b, "with group ", group
                                
        
print "largest square is", best_square
# Find the unique positive integer whose square is 1_2_3_4_5_6_7_8_9_0, where each '_'
# is a single digit.

# First observe that this square number is divisible by 10, and since it is necessarily a 
# square, it must also be divisible by 100.  This follows from the fact that if a prime 
# p divides n^2, then so does p^2.  Thus, the last 3 digits of the square must be 900.

# Moreover, one calculates that the square root of 1929394959697989900 is 1389026623.11,
# which tells us that the desired integer must be a multiple of 10 less than 1389026623,
# and the square root of 1020304050607080900 is 1010101010.1, which tells us that the
# desired integer is greater than 1010101010.

# Answer: 1389019170, with 1389019170^2 = 1929374254627488900


def nice_digits(n):
	digits = []
	
	while (n>0):
		digits.append(n%10)
		n=n/10
	digits.reverse()
	
	nice = True
	for i in range(0,9):
		if(digits[2*i]!=i+1):
			nice = False
			break
	return nice


for i in range(101010101,138902663):
	i=10*i
	j=i*i
	if (nice_digits(j)):
		print i

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import math

raw_a = raw_input('a = ...\n') 
raw_b = raw_input('b = ...\n') 
a = int(raw_a)
b = int(raw_b)

# function outline (test the return statement)
#def hypotenuse(a,b):
#    return 0.0

# argument validation
#def hypotenuse(a,b):
#    print a
#    print b
#    return 0.0

# compute the sum of argument squares
#def hypotenuse(a,b):
#    print a
#    print b
#    sum = a**2 + b**2
#    print sum
#    return 0.0

# compute square root of the sum
#def hypotenuse(a,b):
#    print a
#    print b
#    sum = a**2 + b**2
#    print sum
#    hypotenuse = math.sqrt(sum)
#    return hypotenuse

# final version (remove scaffolding)
def hypotenuse(a,b):
    sum = a**2 + b**2
    hypotenuse = math.sqrt(sum)
    return hypotenuse

# final version 2 (simplified)
#def hypotenuse(a,b):
#    return math.sqrt(a**2 + b**2)

#print hypotenuse(3,4)
print hypotenuse(a,b)


#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Pyromaths
# Un programme en Python qui permet de crer des fiches d'exercices types de
# mathmatiques niveau collge ainsi que leur corrig en LaTeX.
# Copyright (C) 2006 -- Jrme Ortais (jerome.ortais@pyromaths.org)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#

'''
Created on 19 dc. 2014

@author: jerome
'''
from pyromaths.outils.Arithmetique import carrerise
from pyromaths.outils.decimaux import decimaux
from pyromaths.outils import Priorites3
# from pyromaths.classes.Fractions import Fraction

from math import sqrt
class SquareRoot():
    '''
    Dfinit la classe SquareRoot permettant de manipuler des racines carres.
    
    SquareRoot([a,b], [c, d], e) ou SquareRoot([a,b], [c, d], [e, None]) permet de dfinir a*sqrt(b)+c*sqrt(d)+e
    
    Cette dfinition permet d'utiliser pyromaths.outils.Priorites3
    
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot(-4,[-2,1],[3,45],[-1,7],8)
    SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])
    '''


    def __init__(self, *radicandes):
        '''
        Constructor
        '''
        #  print radicandes, len(radicandes), radicandes[0], len(radicandes[0])
        if len(radicandes) == 1 and len(radicandes[0]) == 2 and not isinstance(radicandes[0][0], list) and not isinstance(radicandes[0][1], list):
            # SquareRoot([3, 4]),
            self.racines = [radicandes[0]]
        else:
            if len(radicandes) == 1 and (len(radicandes[0]) != 2 or isinstance(radicandes[0][0], list) or isinstance(radicandes[0][1], list)):
                # SquareRoot([1, [3, 4]])
                radicandes = radicandes[0]
            self.racines = []
            for arg in radicandes:
                if isinstance(arg, list) and len(arg) == 2:
                    # On gre a*sqrt(b)
                    if isinstance(arg[1], (float, int))and arg[1] < 0:
                        raise ValueError(u'Le radicande doit tre un nombre positif.')
                    else:
                        self.racines.append(arg)
                elif isinstance(arg, (float, int)):
                    self.racines.append([arg, None])
                else:
                    raise ValueError(u'Not Implemented : SquareRoot(%s)' % arg)

    def __str__(self):
        r"""Renvoie une version LaTeX d'un objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> str(SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]]))
        '-4-2\\,\\sqrt{1}+3\\,\\sqrt{45}-\\sqrt{7}+8'

        :rtype: String
        """
        def print_coef(coef):
            """Gre le format du coef
            """
            if isinstance(coef, (float, int)):
                if coef > 0: return "+" + decimaux(coef)
                else: return decimaux(coef)
            if isinstance(coef, Fraction):
                if isinstance(coef.n, int) and isinstance(coef.d, int) and coef.n < 0 and coef.d > 0:
                    return "-" + str(Fraction(-coef.n, coef.d, coef.code))
                return "+" + str(coef)
            if isinstance(coef, str):
                texte = "(" + "".join(Priorites3.texify([Priorites3.splitting(coef)])) + ")"
                if texte[0] != "-": return "+" + texte
                else: return texte
        s = ""
        for m in self.racines:
            if m[1] == None:
                # pas de racine ici
                s = s + print_coef(m[0])
            else:
                # Racine carre
                if m[0] == 1:
                    s += r'+\sqrt{%s}' % m[1]
                elif m[0] == -1:
                    s += r'-\sqrt{%s}' % m[1]
                else:
                    s += print_coef(m[0]) + r'\,\sqrt{%s}' % m[1]
        # supprime le + en dbut de squence
        s = s.lstrip("+")
        if not s: s = "0"
        return s

    def __repr__(self):
        """Renvoie une chane de caractre reprsentant un :mod:`SquareRoot`
        valuable pour crer un :mod:`SquareRoot`.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> repr(SquareRoot(-4, [-2, 1], [3, 45], [-1, 7], 8))
        'SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])'
        
        :rtype: String
        """
        return "SquareRoot(%s)" % self.racines

    def __len__(self):
        """*object*\ .\ **__len__**\ ()

        Renvoie le nombre d'lments de l'objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> len(SquareRoot(3, [2, 2], [4, 5]))
        3

        :rtype: integer
        """
        return len(self.racines)

    def __getitem__(self, i):
        """*object*\ .\ **__getitem__**\ (*integer*)

        Renvoie le i me lment de l'objet SquareRoot.

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot(3, [2, 2], [4, 5])[2]
        [4, 5]

        :rtype: list
        """
        return self.racines[i]


    def __add__(self, other):
        """Renvoie la somme d'un objet SquareRoot et d'un nombre.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([3,45],3)+SquareRoot([2,45])
        SquareRoot([[3, None], [5, 45]])
        
        :rtype: SquareRoot
        """

        if not isinstance(other, SquareRoot):
            other = SquareRoot([other, None])
        self.racines.extend(other.racines)
        return SquareRoot(self.racines).simplifie()

    def __radd__(self, other):
        """
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> 2+SquareRoot([3,45],3)
        SquareRoot([[5, None], [3, 45]])

        :rtype: SquareRoot
        """
        other = SquareRoot([other, None])
        other.racines.extend(self.racines)
        return SquareRoot(other.racines).simplifie()

    def __neg__(self):
        """*object*\ .\ **__neg__**\ ()

        ``p.__neg__()`` est quivalent  ``-p`` est quivalent  ``p = -p``

        Renvoie l'oppos d'un objet SquareRoot.

        :rtype: SquareRoot
        """
        if self.EstDecomposable() or self.EstReductible(): return '-%r' % self.simplifie()
        r = list(self.racines)
        for i in range(len(r)):
            r[i][0] = -r[i][0]
        return SquareRoot(r)

    def __abs__(self):
        """ Renvoie la valeur absolue d'un objet SquareRoot
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> abs(SquareRoot([5, 5], [-2, 7]))
        SquareRoot([[5, 5], [-2, 7]])
        >>> abs(SquareRoot([-5, 5], [2, 7]))
        SquareRoot([[5, 5], [-2, 7]])
       
        :rtype: SquareRoot
        """
        t = 0
        for e in self.racines:
            if e[1] == None: t += e[0]
            else: t += e[0] * sqrt(e[1])
        if t > 0: return self
        else: return -self


    def __mul__(self, other):
        """Multiplie un objet SquareRoot par un nombre.
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([3,45],3)*SquareRoot([2,45],-1)
        SquareRoot([['6*45', None], [-3, 45], [6, 45], [-3, None]])
        """
        if not isinstance(other, SquareRoot):
            other = SquareRoot([other, None])
        reduction = False
        if self.EstReductible():
            self = self.simplifie()
            reduction = True
        if other.EstReductible():
            other = other.simplifie()
            reduction = True
        if reduction: return '%r*%r' % (self, other)
        lprod = []
        for e in self.racines:
            for f in other.racines:
                if e[1] == None or f[1] == None:
                    lprod.append([e[0] * f[0], max(e[1], f[1])])
                elif e[1] == f[1]:
                    lprod.append(['%r*%r' % (e[0] * f[0], e[1]), None])
                elif carrerise(e[1]) == 1 or carrerise(f[1]) == 1:
                    if carrerise(e[1]) == 1: e[0], e[1] = e[0] * int(sqrt(e[1])), 1
                    if carrerise(f[1]) == 1: f[0], f[1] = f[0] * int(sqrt(f[1])), 1
                    lprod.append([e[0] * f[0], e[1] * f[1]])
                else:
                    lprod.append([e[0] * f[0], e[1] * f[1]])
        return SquareRoot(lprod)

    def __rmul__(self, other):
        """
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> 5*SquareRoot([3,45],3)
        SquareRoot([[15, 45], [15, None]])

        :rtype: SquareRoot
        """
        return SquareRoot([other, None]) * self

    def  __floordiv__(self, other):
        """
        Division entire par un entier
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([10, 8], [15, 5])//5
        SquareRoot([[2, 8], [3, 5]])

        :rtype: SquareRoot
        """
        if isinstance(other, int):
            r = list(self.racines)
            for i in range(len(r)):
                r[i][0] = r[i][0] // other
            return SquareRoot(r)
        else:
            raise NotImplemented
    def EstDecomposable(self):
        """
        Renvoie True si une des racines est de la forme sqrt{a**2*b} avec a != 1
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8], [1, 7]).EstDecomposable()
        True
        >>> SquareRoot([5, 7], [1, 7]).EstDecomposable()
        False
     
        :rtype: Boolean
        """
        for e in self.racines:
            if e[1] != None and (carrerise(e[1]) != e[1] or e[1] == 1):
                return True
        return False

    def EstReductible(self):
        """
        Renvoie True si la somme de racines est rductible

        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8], [1, 45]).EstReductible()
        False
        >>> SquareRoot([5, 8], [1, 8]).EstReductible()
        True

        :rtype: Boolean
        """
        lradicandes = []
        rationnel = False
        for e in self.racines:
            if e[1] != None:
                if e[1] in lradicandes:
                    return True
                else:
                    lradicandes.append(e[1])
            elif e[1] == None:
                if rationnel: return True
                else: rationnel = True
        return False

    def Decompose(self):
        """
        Dcompose une unique racine carre de la forme a*sqrt(b^2*c) en a*sqrt(b^2)*sqrt(c)
        
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([5, 8]).Decompose()
        'SquareRoot([[5, 4]])*SquareRoot([[1, 2]])'

        :rtype: string
        """
        racine = self.racines[0]
        if racine[1] == None: return repr(racine[0])
        if isinstance(racine[1], int):
            complement = carrerise(racine[1])
            if complement == 1:
                if racine[0] == 1:
                    return int(sqrt(racine[1]))
                if racine[0] == -1:
                    return -int(sqrt(racine[1]))
                if racine[1] == 1:
                    return str(racine[0])
                return '%r*%r' % (racine[0], int(sqrt(racine[1])))
            if complement == racine[1]:
                return repr(self)
            return '%r*%r' % (SquareRoot([racine[0], racine[1] / complement]), SquareRoot([1, complement]))
        raise ValueError(u'Not Implemented : SquareRoot(%s)' % racine)

    def simplifie(self):
        """
        Additionne les nombres rationnels et dcompose les racines carres.
         
        >>> from pyromaths.classes.SquareRoot import SquareRoot
        >>> SquareRoot([[3, 9]]).simplifie()
        '3*3'
        >>> SquareRoot(-2, [-2, 1], [3, 1], [-1, 7], 8).simplifie()
        SquareRoot([[6, None], [1, 1], [-1, 7]])
        >>> SquareRoot(-2, [-2, 1], [3, 45], [-1, 7], 8).simplifie()
        SquareRoot([[6, None], [-2, 1], [3, 45], [-1, 7]])
        >>> SquareRoot([-2,1],[3,45]).simplifie()
        '-2+SquareRoot([[3, 9]])*SquareRoot([[1, 5]])'
        
        :rtype: SquareRoot ou String
        """
        decomposable = self.EstDecomposable()
        reductible = self.EstReductible()
        if not decomposable and not reductible:
            return self
        if reductible:
            racines = []
            # racines = [[sum([x[0] for i, x in enumerate(self.racines) if x[1] == None]), None]]
            # TODO: cas de fractions
            lsomme = [x[0] for i, x in enumerate(self.racines) if x[1] == None]
            s = ''
            for ls in lsomme:
                if isinstance(ls, str): s += '+%s' % ls
                else: s += '+%r' % ls
            s.lstrip('+')
            racines.append([eval(s), None])
            for pos in reversed([i for i, x in enumerate(self.racines) if x[1] == None]):
                    self.racines.__delitem__(pos)
            if racines[0][0] == 0: racines = []
            while len(self.racines) > 0:
                # racines.append([sum([x[0] for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]), self.racines[0][1]])
                # TODO: cas de fractions
                lsomme = [x[0] for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]
                s = ''
                for ls in lsomme:
                    if isinstance(ls, str): s += '+%s' % ls
                    else: s += '+%r' % ls
                s.lstrip('+')
                racines.append([eval(s), self.racines[0][1]])
                if racines[-1][0] == 0: racines.pop(-1)
                for pos in reversed([i for i, x in enumerate(self.racines) if x[1] == self.racines[0][1]]):
                    self.racines.__delitem__(pos)
            if racines:
                if len(racines) == 1 and racines[0][1] == None:
                    return racines[0][0]
                else:
                    return SquareRoot(racines)
            else: return 0
        # Dcomposable
        s = ''
        if len(self.racines) == 1 and isinstance(SquareRoot(self.racines).Decompose(), int):
            return SquareRoot(self.racines).Decompose()
        for e in self.racines:
            decomposee = SquareRoot(e).Decompose()
            if isinstance(decomposee, int): decomposee = str(decomposee)
            if decomposee[0]in'+-':
                s += decomposee
            else:
                s += '+' + decomposee
        s = s.lstrip('+')
        return s

# Square root digital expansion
# Problem 80

# It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.

# The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.

# For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.

from decimal import *
from math import *

def solve():
    return sum(list(map(digsum, range(2,100))))
    
    
def digsum(a):
    sum = 0
    if round(sqrt(a))**2 == a:
        return 0
    getcontext().prec = 110
    d = Decimal(a).sqrt()
    while d > 1:
        d = d / 10
    for i in range(0,100):
        d = d * 10
        sum += int(d) % 10
    return sum
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# the following program let the user play a game where he has to guess the square of
# a random number
# modify it as follow:
# print the square of an natural number and let the player guess the square root.
# the square root should be between 1 and 20

import random

def askForNumber():
    return int(raw_input("Enter square of x: "))

x = random.randint(1,10)

print "x =",x

inputValue = askForNumber()  
while inputValue!=x*x:
    print "Answer is wrong!"
    inputValue = askForNumber()

print "Right!"    
    
    





__author__ = 'fpena'


class RootMeanSquareError(object):
    def __init__(self):
        self.errors = []

    def add(self, expected, predicted):
        if expected is not None and predicted is not None:
            self.errors.append(abs(expected - predicted))

    def compute(self):
        return RootMeanSquareError.compute_list(self.errors)

    @staticmethod
    def compute_list(errors):
        """
        Calculates the mean average error for the predicted rating

        :param errors: a list
        :return: the mean average error after predicting all the overall ratings
        """
        num_ratings = 0.
        total_error = 0.

        for error in errors:
            if error is not None:
                total_error += error ** 2
                num_ratings += 1

        if num_ratings == 0:
            return None

        root_mean_square_error = (total_error / num_ratings) ** 0.5
        return root_mean_square_error


# sqrt.py (c) Mikhail Mezyakov <mihail265@gmail.com>
# Released under the GNU GPL v.3
# 
# Returns square root of the input int

from math import sqrt


def horo(channel, user, args):
    """Calculate square root. Usage: sqrt <number>"""

    result = sqrt(int(args[0]))

    return u'PRIVMSG {channel} :{result}'.format(user=user, result=result)

import math
import random

def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y*y - x) < eps # set up a suitable postcondition
    return y

for i in range(1, 1000):
    r = random.random() * 1000
    z = square_root(r)

print "Done!"

#7.1
def countdown(n):
    while n > 0:
        print(n)
        n = n-1
    print("Blastoff!")


#7.2
def square_root(a):
    if(a == 0 or a == 1):
        return a
    elif(a > 1):
        x = a/2
        epsilon = 0.0000001
        while True:
            y = (x + a/x)/2
            if abs(y-x) < epsilon:
                return y
                break
            x = y
    else:
        return "Invalid Input"
        

#7.3
import math
def square_root(a):
    x = a/2
    epsilon = 0.0000000001
    while True:
        y = (x + a/x) / 2
        if abs(x - y) < epsilon:
            return y
            break
        x = y

def test_square_root(a):
        print(a, square_root(a), math.sqrt(a), abs(square_root(a) - math.sqrt(a)))


#7.4
def eval_loop():
    x = ""
    result = 0
    while True:
        x = input("Give me math > ")
        if x == 'done':
            break
        result = eval(x)
        print(result)
    return result

#7.5
import math

def factorial(n):
    if n == 0:
        return 1
    else:
        value = factorial(n-1)
        return n*value

def estimate_pi():
    total = 0
    k = 0
    left_side = 2*math.sqrt(2)/9801
    while True:
        num = factorial(4*k) * (1103+26390*k)
        den = factorial(k)**4 * 396**(4*k)
        term = left_side * num / den
        total += term                
        if abs(term) < 1e-16:
            break
        k += 1
    return 1 / total
    
print(estimate_pi(), math.pi)



    





    


        
        


        

from bottle import request, route, run, static_file, post
import subprocess
import json

# OBS: For java interface:
# Another option would be,
#   A) embedding this server on java
#      Look at jepp JAVA library.
#
#   B) embedding java in this script.
#     Look at JPype PYTHON library
#     In my opinion, JPype  would be best/easier option
#
# Both would do it.
# Look this link for solutions:
#
# http://pt.slideshare.net/onyame/communication-between-java-and-python

ncalls = 0

@route('/static/<filename>')
def server_static(filename):
    return static_file(filename, root='./static')


@route('/')
def index():
    return static_file('index.html', root='./static')


@post('/api/square')
def api_square():
    global ncalls
    ncalls += 1
    n = request.json['data']
    return {'number': n*n, 'comments' : 'Using python. Called {} times'.format(ncalls)}


@post('/api/squareshell')
def api_square_shell():
    outstr = subprocess.check_output(['bash', './compute_square.sh', '5'])
    return json.loads(outstr)


run(host='localhost', port=8080, debug=True)

#Quinn Z Shen

import sys
import math

memo = dict()
memo_ana = dict()

def isFairAndSquare(num):
    square = math.sqrt(num)
    if square == int(square) and isFair(num) and isFair(int(square)):
        return 1
    return 0

def isFair(num):
    if num in memo_ana:
        return memo_ana[num]
    else:
        i = int(math.ceil(float(len(str(num)))/2))
        if str(num)[i:] == str(num)[:-i][::-1]:
            memo_ana[num] = True
        else:
            memo_ana[num] = False
        # print "ana: " + str(num) + " ana " + str(memo_ana[num]) + " num " + str(num) + " equals " + str(num)[i:] + " . " + str(num)[:-i][::-1]
        return memo_ana[num]

def solve(lower_limit, upper_limit):
    num_root = int(math.ceil(math.sqrt(lower_limit)))
    count = 0
    while num_root <= int(math.sqrt(upper_limit)):
        num = num_root ** 2
        if num in memo:
            count += memo[num]
        else:
            memo[num] = isFairAndSquare(num)
            count += memo[num]
            # print "num: " + str(num) + " FaS " + str(isFairAndSquare(num))
        num_root += 1 
    return count

def main():
    try:
        args = sys.argv[1:]
        if len(args) != 1:
            raise Exception("Error: Expected only 1 argument.")
        if args[0][-2:] != "in":
            raise Exception("Error: Expected .in file type.")
        input = open(args[0], 'r')
        output = open(args[0][:-2] + "out", 'w')

        total_cases = int(input.readline())

        for case in range(1, total_cases + 1):
            print "working on case#:" + str(case)
            line = (input.readline()).split()
            a, b = int(line[0]), int(line[1])

            output.write("Case #{0}: {1}".format(case, solve(a, b)) + "\n")
            
    except Exception as e:
        print e.args[0]

    print "DONE."

if __name__ == "__main__":
    main()
def babylon(num):
    n = num
    r = 1
    accuracy = 0.000001
    while (n - r) > accuracy:
        n = (n + r)/2
        r = num/n
    return n
a = float(input("Write the number you want the squareroot of: "))
print(("The square root of ")+str(a)+(" is: ")+str(babylon(a)))

def squareRootBi(x, epsilon):
	"""assume x>=0 and epsilon >0
	Return y if abs(y**2-x) < epsilon"""
	assert x>=0, "must be non-negative, not" +str(x)
	assert epsilon>0, "must be positive, not" +str(epsilon)
	low=0
	high=max(x, 1.0)
	guess=(low+high)/2.0
	ctr=1
	while abs(guess**2-x)>epsilon and ctr<=100:
		# print "low:", low, "high:", high, "guess:", guess
		if guess**2<x:
			low=guess
		else:
			high=guess
		guess=(low+high)/2.0
		ctr+=1
	assert ctr<=100, "count exceeded"
	print  "calculation cycle", ctr, "candidate", guess
	return guess



# x=float(raw_input("Enter x: "))
# epsilon=float(raw_input("Enter epsilon: "))
# squareRootBi(x, epsilon)

def squareRootNR(x, epsilon):
	ctr=0
	assert x>=0, "must be non-negative, not " +str(x)
	assert epsilon>0, "must be a positive, not "+str(epsilon)
	ans=x/2.0
	# ans=.0001
	while abs(ans**2 - x)>epsilon and ctr<=100: 
		ans=ans-(ans**2-x)/(2*ans)
		ctr+=1
	assert ctr<=100, "Iteration count exceeded"
	print "NR method: ctr: ", ctr,  "candidate", ans
	return ans	


def testbi():
	print "squareRootBi(4, 0.0001)"
	squareRootBi(4, 0.0001)
	print "squareRootBi(9, 0.0001)"
	squareRootBi(9, 0.0001)
	print "squareRootBi(2, 0.0001)"
	squareRootBi(2, 0.0001)
	print "squareRootBi(0.25, 0.0001)"
	squareRootBi(0.25, 0.0001)

def compareMethods():
	print "squareRoot (2, .01) "
	squareRootBi(2, .01)
	squareRootNR(2, .01)
	raw_input()
	print "squareRoot (2, .0001) "
	squareRootBi(2, .0001)
	squareRootNR(2, .0001)
	raw_input()
	print "squareRoot (2, .000001) "
	squareRootBi(2, .000001)
	squareRootNR(2, .000001)
	raw_input()


compareMethods()
import math
testcase=int(input())
def isSquare(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer: 
        return True
    else:
        return False
for i in range(1,testcase+1):
  n=int(input())
  n1=5*n*n-4
  n2=5*n*n+4
  if((isSquare(n1))or(isSquare(n2))):
    print("IsFibo")
  else:
    print("IsNotFibo")
from itertools import combinations

def is_square(n):
    root = int(n ** 0.5)
    return n == root*root

# returns dict of letter -> digit if n is a valid digital substitution of w,
#   otherwise returns None
def get_pandigital_mapping(w, n):
    str_n = str(n)

    if len(str_n) != len(w):
        return None

    mapping = {}
    used_digits = set()

    for i in xrange(len(w)):
        digit = int(str_n[i])
        if w[i] in mapping and mapping[w[i]] != digit:
            # one letter cannot have multiple mappings
            return None
        elif digit in used_digits:
            # multiple letters cannot map to the same digit
            return None
        else:
            used_digits.add(digit)
            mapping[w[i]] = digit

    return mapping

def apply_mapping(mapping, w):
    used = set()

    n = 0
    for c in w:
        if c not in mapping:
            return ValueError('Mapping does not contain a character in the word')
        n = n*10 + mapping[c]
        used.add(c)

    if len(used) != len(mapping):
        print "Not all the characters in the mapping were used -- did not use an anagram pair"

    return n

# returns largest square formed by pair if the pair is a square anagram word
#   pair. Otherwise returns 0
def pandigital_square_pair(w1, w2):
    if len(w1) != len(w2):
        return False

    max_square = 0

    i = int((10 ** (len(w1)-1)) ** 0.5 + 1)

    while i*i < 10 ** len(w1):
        mapping = get_pandigital_mapping(w1, i*i)
        if mapping:
            mapped = apply_mapping(mapping, w2)
            if len(str(mapped)) == len(str(i*i)) and is_square(mapped):
                # mapped is square and has no leading zeroes
                max_square = max(mapped, i*i, max_square)

        i += 1

    return max_square

with open('words.txt', 'r') as f:
    words = f.readlines()

assert(len(words) == 1)

words = words[0].split(',')
words = map(lambda w: w[1:-1], words) # strip quotation marks

anagrams = {}

for w in words:
    anagram_hash = ''.join(sorted(w))
    if anagram_hash not in anagrams:
        anagrams[anagram_hash] = [w]
    else:
        anagrams[anagram_hash].append(w)

max_square = 0

for k in anagrams:
    if len(anagrams[k]) > 1:
        for combo in (combinations(anagrams[k], 2)):
            max_square = max(pandigital_square_pair(combo[0], combo[1]), max_square)

print max_square

import math
import random

def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps # set up a suitable postcondition
    return y

for i in range(1, 1000):
    r = random.random() * 1000
    z = square_root(r)

print "Done!"

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
Implement int sqrt(int x).

Compute and return the square root of x.
'''

class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        y0, y1 = 0, 1
        while int(y0) != int(y1):
            y0 = y1
            y1 = 1.0/2.0 * (y0 + x / y0)
        return int(y0)
    

# File:    sqrt.py
# Date:    12/6/12
# Author:  Carl Stevenson
# Purpose: To calculate square roots using Newton's method

import math

def main():
    intro()
    number, diff = getInputs()
    calc, actDiff, tries = calcSqrt(number, diff)
    printResults(number, diff, calc, actDiff, tries)

def intro():
    print("This program will calculate the square root")
    print("of a number using Newton's Method.")
    print("You will enter the number and the size of the")
    print("difference between Newton's Method square root")
    print("and the real square root.")
    print("Written by Carl Stevenson")
    print()

def getInputs():
    number = eval(input("Enter the number to find its square root: "))
    print()  # for turnin
    # to prevent code wrap
    string="Enter the difference between the calculate and real square root: "
    diff = eval(input(string))
    print()  # for turnin
    return number, diff

def calcSqrt(number, diff):
    newguess = number / 2.0
    tries = 0
    oldguess = 1
    calc = 0
    while abs((newguess - oldguess)) > diff:
        oldguess = newguess
        newguess = (oldguess + number/oldguess)/2.0
        tries = tries + 1
        calc = newguess
    actDiff = abs((math.sqrt(number) - calc)) 
    return calc, actDiff, tries

def printResults(number, diff, calc, actDiff, tries):
    print("For the square root of", number, "after", tries, "tries")
    print("The calculated square root is {:0.11f}".format(calc))
    print("The real square root is       {:0.11f}".format(math.sqrt(number)))
    print("The difference is             {:0.11f}".format(actDiff))
    print("The delta was                 {:0.11f}".format(diff))
    print()


if(__name__=='__main__'): main()

"""
The root mean square (abbreviated RMS or rms), also known as the quadratic mean, in statistics is a statistical measure
defined as the square root of the mean of the squares of a sample. RMS can also be calculated for a continuously varying
function.
In physics it is a characteristic of a continuously varying quantity, such as a cyclically alternating electric current,
obtained by taking the mean of the squares of the instantaneous values during a cycle.
"""

import math

__author__ = "paulogp"
__copyright__ = "Copyright (C) 2015 Paulo G.P."
__date__ = "23/11/2015"


def sin_rms(a):
    """
    The root mean square of a sine wave.
    y = a sin(2 pi f t)
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(2)


def square_rms(a):
    """
    The root mean square of a square wave.
    y = a if ft < 0.5 V -a if ft > 0.5
    :param a: amplitude (peak value)
    :return: float
    """
    return a


def triangle_rms(a):
    """
    The root mean square of a triangle wave.
    y = |2 a ft - a|
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(3)


def eng_rms(rms_ac, rms_dc):
    """
    The root mean square of a non sine wave.
    y = |2 a ft - a|
    :param rms_ac: ac rms
    :param rms_dc: dc rms
    :return: float
    """
    return math.sqrt(math.pow(rms_dc, 2) + math.pow(rms_ac, 2))

if __name__ == "__main__":
    print("Sine Wave RMS: {0}.".format(round(sin_rms(500.00), 2)))
    print("Square Wave RMS: {0}.".format(round(square_rms(500.00), 2)))
    print("Triangle Wave RMS: {0}.".format(round(triangle_rms(500.00), 2)))
    print("RMS total: {0}.".format(round(eng_rms(220.00, 120.00), 2)))

 def approx_equal(a, b, limit):
    if abs(a-b) < limit:
        return True
    else:
        return False


def square_root (a):
    x = a / 2.0
    epsilon = 0.001
    while True:
        print x
        y = (x + a/x) / 2
        if approx_equal (y, x, epsilon):
            break
        x = y
    return x
    
print square_root(25)


__copyright__ = ''
__author__ = 'Son-Huy TRAN'
__email__ = "sonhuytran@gmail.com"
__doc__ = ''
__version__ = '1.0'


def square_root(number: int, n_step: int) -> float:
    r = 1

    for _ in range(n_step):
        d = number / r
        r = (r + d) / 2

    return r


def main() -> int:
    n = int(input())
    results = [''] * n

    for i in range(n):
        (number, steps) = map(int, input().split())
        results[i] = str(square_root(number, steps))

    print(' '.join(results))
    return 0


if __name__ == '__main__':
    exit(main())
'''
newton_root.py

Author: Patrick Rummage
        [patrickbrummage@gmail.com]

Objective:
    Define a function that runs in a loop calculating
    successive approximations of the square root of
    a number, using Newton's method. Returns a result
    within the range of one epsilon.
'''

def find_root(a, eps):
    appx = a / 2.0
    while True:
        root = (appx + a/appx) / 2

        if abs(appx - root) < eps:
            break
        appx = root
    return root

epsilon = 0.0000001
print find_root(25, epsilon)
print find_root(64, epsilon)
print find_root(2, epsilon)

def newton_update(f, df):
    def update(x):
        return x - f(x) / df(x)
    return update

def find_zero(f, df):
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)


def square_root_newton(a):
    # (, ?)
    def f(x):
        return x * x - a
    def df(x):
        return 2 * x
    return find_zero(f, df)

# >>> square_root_newton(64)
# 8.0

import Tkinter


def draw_square(canvas, color, size, position):
    """

    :param canvas:
    :param color:
    :param size:
    :param position:
    :return handle:

    Takes a Tkinter canvas, a color string, an integer size, and a tuple of
    x,y coordinates for the center of the rectangle.

    Returns the handle from the created rectangle.
    """
    upper_x = position[0] - size / 2
    upper_y = position[1] - size / 2

    lower_x = position[0] + size / 2
    lower_y = position[1] + size / 2

    return canvas.create_rectangle(upper_x,
                                   upper_y,
                                   lower_x,
                                   lower_y,
                                   fill=color,
                                   outline=color)


if __name__ == '__main__':
    root = Tkinter.Tk()
    root.geometry('800x800')

    c = Tkinter.Canvas(root, width=800, height=800)
    c.pack()

    draw_square(c, 'red', 100, (50, 50))
    draw_square(c, 'green', 100, (750, 50))
    draw_square(c, 'blue', 100, (50, 750))
    draw_square(c, 'yellow', 100, (750, 750))

    root.mainloop()

'''square,cube,root,and power.

Available functions:

square(number)
    returns the square of a number

cube(number)
    returns the cube of a number

root(number)
    returns the square root of a number

power(number, power)
    returns then number to the power'th power

Example Usage:
>>> import powerpractice
>>> powerpractice.square(2)
4
>>> powerpractice.cube(2)
8
>>> powerpractice.root(9)
3
>>> powerpractice.power(9,0.5)
3
>>> powerpractice.power(3,2)
9

'''

def square(number=1):
    '''Return the square of the number.'''
    return number * number

def root(number=1):
    '''Return the square root of the number.'''
    return number ** 0.5

def cube(number=1):
    '''Return the cube of the number.'''
    return number * number * number

def power(number=1,power=1):
    '''Return the number raised to the power.'''
    return number ** power

if __name__ == '__main__':
    print( 'square of 2' )
    print( square(2) )
    print( 'cube of 2' )
    print( cube(2) )
    print( '2 to the power of 16')
    print( power(2,16) )
    print( '81 to the power of 0.5')
    print( power(81,0.5) )
    print( 'square root of 81')
    print( root(81) )

def solver():
    """ Find the unique positive integer whose square has the form
    1_2_3_4_5_6_7_8_9_0 where _ is a single digit

    We can find the maximum and minimum boundary of square roots
    that satisfy 1020304050607080900 < n ** 2 < 1929394959697989990

    Note that a square ending in "0" has to end in at least "00",
    therefore we can simplify the problem to fnding the bounds of
    10203040506070809 < n ** 2 < 19293949596979899 and then multiplying
    the square root by 10
    
    (solved 2014-11-29)
    """
    min_bound = int(10203040506070809 ** 0.5)
    max_bound = int(19293949596979899 ** 0.5) + 1

    for number in xrange(min_bound, max_bound):
        if str(number ** 2)[::2] == "123456789":
            return number * 10  # multiply back by 10

solver()
""" using Newton's Method as a means of finding progressively more accurate roots of any real function
"""
from math import sqrt

error = 0.000001
number_of_iterations = 0

# Returns how far 'x' is from the square root of 'a' and the number
# of times iterated through to reach our margin of error.
def square_root(a, x):
    a = float(a)
    next_x = float(x + (a/x))/2
    global number_of_iterations
    number_of_iterations += 1

    if abs(next_x - sqrt(a)) < error:
        print "Number of iterations: %s" % number_of_iterations
        return float(next_x)
    else:
        return square_root(a, next_x)

# print square_root(10, 5)
print square_root(10, 3)














# 1.1 Elements of programming

# 1.1.1 Expressions

# Primitive number expression print(486) 
# Compound expression: numbers combined with primitive procedures
print(12 + 234)
print(1000 - 334)
print(5 * 99)
print(10 / 4.0)
print(2.7 + 10.1)

# Combinations
print((3 + 5) + (10 - 6))
print((3 *
       ((2 * 4) +
        (3 + 5)))
      +
      ((10 - 7) +
       6))
# A name identifies a variable, whose value is the object
pi     = 3.14159
radius = 3.33
print(pi * (radius * radius))

# Name-object associations can be created incrementally
# Here the 'circumference' association uses both 'pi' and 'radius' definitions
circumference = 2 * pi * radius
print(circumference)

# The posibility of associating values with symbols and retrieving them means
# that the interpreter must maintain a memory, that keeps track of
# the name-object pairs. It's called the 'global environment'.

# 1.1.4 Compound procedures

# Procedure definitions - an abstraction technique, by which a compound
# operation can be given a name and then referred to as a unit.
# Example procedure produces the square root of a given value
# The value to be multiplied is given a local name 'x'.
def square(x):
    return x*x
def cube(x):
    return x*x*x

# Square root aproximation

# Calculate average value of two
def average(x, y):
    return (x + y) / 2

# Is current square root aproximation 'good enough' ?
# e.g. differs from expected value with a tolerance level of 0.0001
def is_sqrt_good_enough(x, guess, tolerance=0.0001):
    return abs(square(guess) - x) < tolerance

# Improve current guess value of square root by taking the average of
# the guess and it's quotient with the squared number
def sqrt_improve(x, guess):
    return average(guess, (x / guess))

# Formalize the process of guessing a square root for given value
# Assume that a root guess for any value is 1.0
def sqrt_iter(x, guess = 1.0):
    return guess if is_sqrt_good_enough(x, guess) else sqrt_iter(x, sqrt_improve(x, guess))

print(sqrt_iter(9))

# 1.1.8 Procedures as black box abstractions

# A procedure can have internal definitions, that are local only to
# the procedure. This helps to break up large programs into tractable
# pieces. The 'sqrt' procedure can be rewritten as following
def sqrt_local(x, g=1.0):
    def local_average(x, y): return (x + y) / 2

    def local_good_enough(x, g, t=0.0001): return abs(square(g) - x) < t

    def local_improve(x, g): return local_average(g, (x / g))

    return g if local_good_enough(x, g) else sqrt_local(x, local_improve(x, g))

print(sqrt_local(27))

# File:    sqrt.py
# Date:    12/6/12
# Author:  Carl Stevenson
# Purpose: To calculate square roots using Newton's method

import math

def main():
    intro()
    number, diff = getInputs()
    calc, actDiff, tries = calcSqrt(number, diff)
    printResults(number, diff, calc, actDiff, tries)

def intro():
    print("This program will calculate the square root")
    print("of a number using Newton's Method.")
    print("You will enter the number and the size of the")
    print("difference between Newton's Method square root")
    print("and the real square root.")
    print("Written by Carl Stevenson")
    print()

def getInputs():
    number = eval(input("Enter the number to find its square root: "))
    print()  # for turnin
    # to prevent code wrap
    string="Enter the difference between the calculate and real square root: "
    diff = eval(input(string))
    print()  # for turnin
    return number, diff

def calcSqrt(number, diff):
    newguess = number / 2.0
    tries = 0
    oldguess = 1
    calc = 0
    while abs((newguess - oldguess)) > diff:
        oldguess = newguess
        newguess = (oldguess + number/oldguess)/2.0
        tries = tries + 1
        calc = newguess
    actDiff = abs((math.sqrt(number) - calc)) 
    return calc, actDiff, tries

def printResults(number, diff, calc, actDiff, tries):
    print("For the square root of", number, "after", tries, "tries")
    print("The calculated square root is {:0.11f}".format(calc))
    print("The real square root is       {:0.11f}".format(math.sqrt(number)))
    print("The difference is             {:0.11f}".format(actDiff))
    print("The delta was                 {:0.11f}".format(diff))
    print()


if(__name__=='__main__'): main()

# -*- coding: utf-8 -*-
"""Created on Mon Sep 21 10:08:02 2015
@author: CharlotteVDD
define a function sqrt(num), where num is a number and sqrt a funtion
that returns the square root of num.
"""


def sqrt(n):
    n = n ** .5
    return(n)

def sqrt(x):
    '''compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess

def main():
    print(sqrt(9))
    print(sqrt(2))
    try:
        print(sqrt(-1))
    except ZeroDivisionError:
        print("Cannot compute square root of a negative number.")

    print("Program execution continues normally here.")

if __name__ == '__main__':
    main()

# Newton's square root

import math

def square(number):
  return number*number

def average(x,y):
  return (x+y)/2


def sqrt(number):
  def closeEnough(guess):
    return (math.fabs((square(guess))- number) < 0.001)
  def improve(guess):
    return average(guess, (number/guess))
  def sqrtHelper(guess):
    if closeEnough(guess):
      return guess
    else:
      return sqrtHelper(improve(guess))
  return sqrtHelper(1.0)

def test(g,s):
    while g*g != s:
        print 'g is {0}'.format(g)
        g = new_g(g,s)
    print 'Found! square root of {0} is {1}'.format(s,g)

def new_g(g,s):
    g = ((g+(s/g))/2)
    return g

def main():
    # g is your best guess for the square root of s
    g = 30000000.00
    s = 25
    test(g,s)

if __name__ =='__main__':main()

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

# Define f(N) = the sum of squares of divisors of N (N >= 1)
# Find the sum of all n (0 < n < 64 x 10^6 such that f(n) is a perfect square

from math import sqrt, floor

LIMIT = 64000000

def findSumSpecialNum():
    mySum = 0

    sieve = computeSumSquareDivisor()
    print('Hi')
    for x in range(1, LIMIT):
       if isPerfectSquare(sieve[x]):
           mySum += x

    return mySum

def computeSumSquareDivisor():
    # sieve[i] = f(i) = sum of squares of divisors of N >= 1
    sieve = [1] * LIMIT

    sieve[0] = 0

    for x in range(2, LIMIT):
        currentNum = x
        square = x * x

        while currentNum < LIMIT:
            sieve[currentNum] += square
            currentNum += x
            
    return sieve

def isPerfectSquare(N):
    squareRoot = floor(sqrt(N))
    if squareRoot * squareRoot == N:
        return True
    return False


    

from subtract_square_state import SubtractSquareState

class GameStateNode:
    '''
    A tree of possible states for a two-player, sequential move, zero-sum,
    perfect-information game.

    value: GameState -- the game state at the root of this tree
    children: list -- all possible game states that can be reached from this
 	game state via one legal move in the game.  children is None until grow
	is called.
    '''

    def __init__(self, game_state):
        ''' (GameStateNode, GameState) -> NoneType

        Initialize a new game state tree consisting of a single root node 
	that contains game_state.
        '''
        self.value = game_state
        self.children = []

    def __eq__(self, other):
        ''' (GameStateNode, object) -> bool

        Return whether this GameStateNode is equivalent to other, i.e., they
        contain equivalent GameStates, and equivalent children.  The order of
        their children does not matter.

        >>> s1 = SubtractSquareState('p1', current_total = 6)
        >>> s2 = SubtractSquareState('p2', current_total = 5)
        >>> s3 = SubtractSquareState('p1', current_total = 2)
        >>> leaf1 = GameStateNode(s1)
        >>> leaf2 = GameStateNode(s2)
        >>> leaf3 = GameStateNode(s3)
        >>> leaf1.__eq__(leaf2)
        False
        >>> root1 = GameStateNode(s1)
        >>> root1.children = [s2, s3]
        >>> root2 = GameStateNode(s1)
        >>> root1.__eq__(root2)
        False
        >>> root2.children = [s2, s3]
        >>> root1.__eq__(root2)
        True
        '''
        # Checking that the children lists have the same contents requires
        # checking that every element of one list is in the other, and vice
        # versa. Since checking "in" causes calls to the __eq__ method, we
        # end up recursing.
        return (type(self) == type(other) and
                self.value == other.value and        
                same_contents(self.children, other.children))

    def grow(self):
        ''' (GameStateNode) -> NoneType

        Grow the tree of all possible game state nodes that can be reached
	starting from this one.

        Assume that the game is finite (and so the tree will be finite).
        
        >>> a0 = SubtractSquareState('p1', current_total = 0)
        >>> b1 = SubtractSquareState('p2', current_total = 1)
        >>> a2 = SubtractSquareState('p1', current_total = 2)
        >>> b3 = SubtractSquareState('p2', current_total = 3)
        >>> a4 = SubtractSquareState('p1', current_total = 4)
        >>> b0 = SubtractSquareState('p2', current_total = 0)
        >>> a0_node = GameStateNode(a0)
        >>> b1_node = GameStateNode(b1)
        >>> b1_node.children = [a0_node]
        >>> a2_node = GameStateNode(a2)
        >>> a2_node.children = [b1_node]
        >>> b3_node = GameStateNode(b3)
        >>> b3_node.children = [a2_node]
        >>> b0_node = GameStateNode(b0)
        >>> a4_node = GameStateNode(a4)
        >>> a4_node.children = [b0_node, b3_node]
        >>> root = GameStateNode(SubtractSquareState('p1', current_total = 4))
        >>> root.grow()
        >>> root.__eq__(a4_node)
        True
        '''
        pass

def same_contents(L1, L2):
    ''' (list, list) -> bool
    
    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.
    
    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and 
            all([x in L2 for x in L1]) and 
            all([x in L1 for x in L2]))

def node_count(root):
    ''' (GameStateNode) -> int
    
    Return the number of nodes in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    pass

def leaf_count(root):
    '''(GameStateNode) -> int
    
    Return the number of leaves in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    pass

def distinct_node_count(root):
    '''(GameStateNode) -> int
    
    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    # A prof's answer to helper function for these "distinct functions"..https://piazza.com/class/i4k2lgxvqvu2mc?cid=990
    pass
                      
def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int
    
    Return the number of leaves representing distinct game states in the
    tree rooted at root.
       
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    pass

def branching_stats(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    pass       
            
def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]
    
    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    pass

def game_lengths(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    pass   

def game_descriptions(root):
    ''' (GameStateNode) -> list of str
    
    Return a list containing a str describing each complete game that is
    possible from the game stored at root.
    
    Assume root is the root of a game state tree specifically for the game
    Subtract Square.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    pass
            
def abbreviated(s):
    '''(GameState) -> str
    
    Return an abbreviated str representation of SubtractSquareState s.
    '''
    
    return "{}:{}".format(s.next_player, s.current_total)

if __name__ == '__main__':
    import doctest
    doctest.testmod()

#!/usr/bin/python 
from math import sqrt 
def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5)**2 == integer:
        return True 
    else:
        return False 

if __name__ == '__main__':
    import sys 
    t = int(sys.stdin.readline())
    for _ in range(t):
        a, b = map(int, sys.stdin.readline().split())
        res = sum([ 1 for i in range(a,b+1) if is_square(i) ])
        print(res)

import sys

def sqrt(x):
    '''Computer square roots using the method of Heron of Alexandria.
    
    Args:
        x: The number for which the square root is to be computed.
        
    Returns:
        The square root of x
        
    Raises:
        ValueError: if x is negative
    '''
    if x < 0:
        raise ValueError('Cannot compute square root of negative number. {}'.format(x))
    
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    
    return guess
    
def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
    except ValueError as e:
        print(e,file=sys.stderr)
    
if __name__ == '__main__':
    main()
"""
a set of cost functions for Neural Network layers.
"""

import theano.tensor as T


def l1_norm(w):
    """
    Returns L1 norm of the given matrix (w).
    L1 norm is simply sum of a matrix elements.

    @input: w, a theano shared variable.
    @output: L1 norm of w
    """

    return abs(w).sum()


def l2_norm(w):
    """
    Returns L2 norm of the given matrix (w).
    L2 norm of a matrix is simply square root of the sum of square of elements of the matrix.
    In an other word, it's length for a matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return T.sqrt((w ** 2).sum())


def l2_norm_sqr(w):
    """
    Returns square of L2 norm of the given matrix (w).
    square of L2 norm of a matrix is simply the sum of square of elements of the matrix.
       
    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return (w ** 2).sum()

# TODO
# add contractive cost function.

import sys

def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))
    
    guess = x
    i = 0
    while guess*guess != x and i < 20:
        guess = (guess + x/guess)/2.0
        i += 1
    return guess

def main():
    try:
        print(sqrt(9))
        print(sqrt(25))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed.")
    except ValueError as e:
        print(e, file=sys.stderr)
    print("Program execution continues normally here.")
        

if __name__ == '__main__':
    main()
#! /usr/bin/python
#
# From http://greenteapress.com/thinkpython/html/thinkpython008.html
# Chapter 7 exercise 3
# Implement Newton's method to find square roots
#
import math

epsilon = 1.0E-12

def sqrt ( x ) :
    while True:
#        print x
        y = (x + a/x) / 2
        if abs(y-x) < epsilon :
            break
        x = y
    return y


def test_square_root( a ) :
    xt = sqrt(a)
    xc = math.sqrt(a)
    print "%10f %14f %14f %10.4e" % ( a, xt, xc, abs( xc-xt) ) 

for a in range(1,10) :
    test_square_root( float(a) )



import math

def squareRoot(a, precision=0.001):
    x = 4.0
    while True:
        y = (x + a/x) / 2
        if abs(y-x) < precision:
            break
        x = y
    
    return y

for i in range(1,10):
    print (str(i) + '\t' + str(squareRoot(i)) + '\t' + str(math.sqrt(i)) + '\t' + str(abs(squareRoot(i)-math.sqrt(i))))
'''
Complete soltion of Book 
"Python For Software Design by Allen B. Downey"
by Harsh Bhatia ( www.harshbhatia.net )
'''
'''
Exercise 7.2:Encapsulate loop in a function called square_root that takes a as a parameter,
chooses a reasonable value of x, and returns an estimate of the square root of a.
'''
import math
def square_root(a):
  x = 10
  while True:
    # print x
    y = (x + a/x) / 2
    if abs(y- x )< 0.000001:
      break
    x = y
  return x

print square_root(4)
import math

def M(n, count):
	# a > b > c
	for s in range(1, 2 * n + 1):
		if is_square(n, s):
			b_max = min(n, s - 1)
			b_min = max(1, (s + 1)//2) 
			count += 1 + b_max - b_min
	return count

def is_square(a, b):
	s = a * a + b * b
	root = math.sqrt(s)
	return root == int(root)

i = 1
count = 0
# print(M(100, 0))
while True:
	i += 1
	count = M(i, count)
	if (count > 1000000):
		print(i, count)
		break

# print(M(1000))
#!/usr/bin/python

"""
Notes:

(1)  Pre-optimized:
     
     It occurs to me, after writing this, that the function which searches for
     lower and upper bounds for the square root is not really necessary.  
     
     (a)  Using the same special case handling for numbers <= 1, we could just
          binary search bounds at [1, number) since, for any number > 1, that
          number's square root will be less than the number itself
     
     (b)  Even the special case handling for number <= 1 could be simplified.  
          The bounds could simply be [0, max(number, 1)].  It would be 
          worthwhile to write a "bare bones" implementation which omits many of
          the frills below and implements a simple binary search inwards.  
"""

import sys


FLOAT_EQUALS_DIFF = 0.0000001

def float_equals(a, b):
    """
    The greatest trick the devil ever played was not creating an "approximate equality" operator for floating point values
    
    Preconditions:  a, b must be floating point values
    
    Postconditions:  returns True if the a and b are "approximately equal"
    """
    
    return abs(a - b) < FLOAT_EQUALS_DIFF


def find_square_root_bounds(number, starting_lower_bound=2.0):
    """
    Given a search value and a starting lower bound, finds a lower and upper bound for the square root of that value
    
    Preconditions: number must be a positive floating point value
    
    Postconditions: returns a pair of floating point values whose squares are
                    respectively LTE and GTE the arg "number"
    """
    
    current_bound = starting_lower_bound
    while current_bound * current_bound < number:
        current_bound *= 2.0
    return (current_bound / 2.0, current_bound)


def estimate_square_root_fancy(number, accuracy):
    sqrt = None
    
    # special case: negative numbers or exact matches for 0 or 1
    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    elif float_equals(number, 1.0):
        sqrt = 1.0
    
    # let's actually compute an estimated square root
    else:
        if number < 1.0:
            lower_bound = 0.0
            upper_bound = 1.0
        else:
            lower_bound, upper_bound = find_square_root_bounds(number)
        
        # special case: early termination on exact matches
        if float_equals(lower_bound * lower_bound, number):
            sqrt = lower_bound
        elif float_equals(upper_bound * upper_bound, number):
            sqrt = upper_bound
        else:
            # binary search within bounds for an accurate estimate
            while upper_bound - lower_bound > accuracy:
                midpoint = (upper_bound + lower_bound) / 2.0
                
                # special case: early termination on exact matches
                if float_equals(midpoint * midpoint, number):
                    lower_bound = midpoint
                    upper_bound = midpoint
                    break
                elif midpoint * midpoint < number:
                    lower_bound = midpoint
                else:
                    upper_bound = midpoint
        
            sqrt = lower_bound

    return sqrt


def estimate_square_root_simple(number, accuracy):
    """
    Bare-bones square root estimator

    Set guaranteed lower and upper bounds on the solution and binary search until
    we find something close enough
    """

    sqrt = None
    
    # special case: negative numbers or exact matches for 0 or 1
    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    # let's actually compute an estimated square root
    else:
        lower_bound = 0
        upper_bound = max(number, 1.0)
        
        # binary search within bounds for an accurate estimate
        while upper_bound - lower_bound > accuracy:
            midpoint = (upper_bound + lower_bound) / 2.0
            
            if midpoint * midpoint < number:
                lower_bound = midpoint
            else:
                upper_bound = midpoint
            
            sqrt = lower_bound
    
    return sqrt


def main(argv):
    if len(argv) < 2:
        sys.stderr.write("Usage: %s <number>" % (argv[0],))
        return 1

    number = float(argv[1])
    accuracy = 0.001
    assert FLOAT_EQUALS_DIFF < accuracy

    print "Estimating square root of %g with minimum accuracy of %g" % (number, accuracy)

    sqrt_fancy = estimate_square_root_fancy(number, accuracy)
    sqrt_simple = estimate_square_root_simple(number, accuracy)

    print "Estimated square root (fancy):\n  %g" % (sqrt_fancy)
    print "Estimated square root (simple):\n  %g" % (sqrt_simple)

    diff = abs(sqrt_fancy - sqrt_simple)
    if diff > accuracy:
        print "[Warning]  Difference between square root estimations (%d) differs by more than accuracy (%d)" % (diff, accuracy)


if __name__ == "__main__":
    sys.exit(main(sys.argv))





import math

def square_root(a,x):
    y = (x + a/x) / 2
    return y

def math_squrt(a,x):
     m = math.sqrt(a)
     return m

def test_square_root(a,x):
     m = math_squrt(a,x)
     y = square_root(a,x)
     c = m - y 
     print a ,'		',  m ,'		', y,'		', c


test_square_root(2,3)

import numpy as np
class RootMeanSquareError:
    def compute(self, actual, predicted):
        N, D = actual.shape
        error = 0
        for d in range(D):
            error += (np.sum((actual[:N, d] - predicted[:N, d]) **2) / float(N)) ** 0.5
        error = error / float(D)
        return error

if __name__ == "__main__":
    error = RootMeanSquareError()
    error.compute(np.array([[1, 2],[3, 2]]), np.array([[4, 3],[3, 3]]))
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
Created on Mar 12, 2013

@author: ldevocht
'''
import math
import time
import numpy

def average(a, b):
    return (a + b) / 2.0
def improve(guess, x):
    return average(guess, x/guess)
def good_enough(guess, x):
    d = abs(guess*guess - x)
    return (d < 0.001)
def square_root(guess, x):
    while(not good_enough(guess, x)):
        guess = improve(guess, x)
    return guess
def my_sqrt(x):
    r = square_root(1, x)
    return r

def approximate_log(n):
    if n < 1.1:
        return n-1
    else:
        return approximate_log(math.sqrt(n)) + approximate_log(math.sqrt(n))
    
def approximate_log2(n):
    return (n**n - 1.0) / n

def timeit1(arg=approximate_log2):
    s = time.time()
    for i in range(1,75000):
        z=arg(i)
    print ("Took %f seconds" % (time.time() - s))

def timeit2(arg=math.log10):
    s = time.time()
    for i in range(1,75000):
        z=arg(i)
    print ("Took %f seconds" % (time.time() - s))
    
def timeit3(arg=numpy.log10):
    s = time.time()
    for i in range(1,75000):
        z=arg(i)
    print ("Took %f seconds" % (time.time() - s))

timeit1()
timeit2()
timeit3()

print (math.log10(100))
print (approximate_log(100))
#Basic calculator project
import math
def cube(n):
    """
    Returns the cube of the number n
    """
    return n**3

def squareroot(n):
    """
    Returns the square root of the number n. If n < 0, 
    then return the string "NAN" (not a number)
    """
    return math.sqrt(n)

def negate(n):
    """ Return negative n
    """
    return -n

def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    return math.factorial(n)


import re
file = open('words.txt','r')
pattern = re.compile('[\\w]+') #matches alpha numeric in double quotes
word_list = re.findall(pattern, file.read())

sorted_word_list = sorted([sorted(word) for word in word_list])

#print [sorted_word_list[x] for x in range(0,20)]

valid_sorts = []

def equal_lists(list_a, list_b):
    if(len(list_a) != len(list_b)):
        return False
    for i in range(0, len(list_a)):
        if(list_a[i] != list_b[i]):
            return False
    return True
current_match = []
previous_word = []    
for i in range(0,len(sorted_word_list)):
    word = sorted_word_list[i]

    if not equal_lists(word, current_match):
        if equal_lists(word, previous_word):
            valid_sorts = valid_sorts + [word]
            current_match = word
    previous_word = [x for x in word]
    
print len(valid_sorts)
#print valid_sorts

anagram_groups = [[] for x in valid_sorts]
for word in word_list:
    sorted_word = sorted(word)
    for i in range(0,len(valid_sorts)):
        if equal_lists(sorted_word, valid_sorts[i]):
            anagram_groups[i] = anagram_groups[i] + [word]
            
for x in anagram_groups:
    if len(x) > 2:
        print x
        #only one anagram set has more than 2 words in it
        
def is_square(n):
    root = float(n) ** .5
    root = int(root+.5)
    if root*root == n:
        return root
    else:
        return False

def to_num(list):
    sum = 0
    for i in list:
        sum = sum*10
        sum +=i
    return sum        
        
def to_list(num):
    result = []
    val = num
    while(val >0):
        result = [val%10] + result
        val = val/10
    return result
    
best_square = 0
        
for group in anagram_groups:
    for a in range(0, len(group) - 1):
        for b in range(a+1,len(group)):
            word_a = group[a]
            word_b = group[b]
            min_x = int((10**(len(word_a)-1)) ** .5)
            man_x = int((10**len(word_a)) ** .5)
            for x in range(min_x,man_x):
                vals_used = [False]*10
                square = x*x
                valid = True
                square_list = to_list(square)
                if(len(square_list) == len(word_a)):
                    sub_a = [x for x in word_a]
                    sub_b = [x for x in word_b]
                    for i in range(0,len(square_list)):
                        if not valid:
                            break
                        letter_sub = sub_a[i]
                        if letter_sub > 10: #will always be true for characters never digits
                            sub_val = square_list[i]
                            if(vals_used[sub_val]):
                                valid = False
                                break
                            vals_used[sub_val] = True    
                            for j in range(0,len(square_list)):
                                if(sub_a[j] == letter_sub):
                                    #trying to replace something with wrong digit
                                    if(square_list[j] != sub_val): 
                                        valid = False
                                        break
                                    sub_a[j] = sub_val #so i don't repeat subbing digits
                                if(sub_b[j] == letter_sub):
                                    if(j == 0 and sub_val == 0):
                                        valid = False
                                        break
                                    sub_b[j] = sub_val
                    if(valid):
                        square_a = to_num(sub_a)
                        if(square_a != square):
                            print "assertion failed", square_a, "not", square
                        square_b = to_num(sub_b)
                        if is_square(square_b):
                            #print "found match"
                            found_square = max(square_a, square_b)
                            if(found_square > best_square):
                                best_square = found_square
                                print "new best", square_a, square_b, "with group ", group
                                
        
print "largest square is", best_square
"""
Util module has functions to compute square of a number, square root of a
number and a variable pi with value 3.14.
"""
pi = 3.14

def sqrt(x):
	return x**0.5

def sqr(x):
	return x**2
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
"""
Implement int sqrt(int x).

Compute and return the square root of x.
"""
#O(n)
def sqrt1(x):
    i = 0
    while i*i != x:
        i = i+1
    return i

def sqrt(x):
    l = 0
    h = x
    while l<=h:
        m = l + h/2
        if m*m == x:
            return m
        elif m*m <x:
            l = m+1
        else:
            h= m-1
    return (l+h)/2
print sqrt(9)
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def sqrt(x):
    '''
    Compute square roots using the method of Heron of Alexandria.
    :param x: The number for which the square root is to be computed.
    :return: The square root of x.
    '''

    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def main():
    print(sqrt(9))
    print(sqrt(2))
    try:
        print(sqrt(-1))
    except ValueError:
        print("Cannot compute square root of negative number")
    finally:
        print("Finally called")

    print("Program execution continues normally here")


if __name__ == '__main__':
    main()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
# Find the largest interger whose square is less than or equal to the given integer. 
# Complexity = O(log n)

def square_root(val):
	l = 0
	u = val

	while (l<=u):
		m = l+(u-l)/2
		
		if (m * m <= val < (m+1)*(m+1)):
			return m
		if (m * m > val):
				u = m-1
		if (m * m < val):
				l = m+1
		
print square_root(81)
print square_root(18)
print square_root(1)
print square_root(0)


"""
Giving 2 quadratic equation, find the interception and graph out

"""


import numpy as np
from matplotlib.pyplot import *
 
np.set_printoptions(precision=2)
 
class intersect:
 
    def __init__(self, fun_1, fun_2):
 
        self.fun_1=fun_1
 
        self.fun_2=fun_2
 
        self.fun=np.array(self.fun_1 - self.fun_2)
 
        self.part_one=np.square(self.fun[1]) - 4* self.fun[0] *self.fun[2]
 
    def value_y(self, x):
 
        y=self.fun_1[0] * np.square(x) + self.fun_1[1] * x + self.fun_1[2]
 
        #   y=self.fun[0] * np.square(x) +self.fun[1] * x + self.fun[2]
 
        return y
 
    def single_root(self):
 
        x= -(self.fun[2]) / self.fun[1]
 
        return np.array([x, self.value_y(x)])
 
    def root_one(self):
 
        x=( -(self.fun[1]) + np.sqrt(self.part_one )) / (2 * self.fun[0])
 
        return np.array([x, self.value_y(x)])
 
    def root_two(self):
 
        x= (-(self.fun[1]) - np.sqrt(self.part_one ) )/ (2 * self.fun[0])
 
        return np.array([x, self.value_y(x)])   
 
    def final(self):
        x=linspace(-2,2, 200)
 
        y_1=self.fun_1[0]*np.square(x)+self.fun_1[1]*x+self.fun_1[2]
 
        y_2=self.fun_2[0]*np.square(x)+self.fun_2[1]*x+self.fun_2[2]
 
        figure()
        plot(x,y_1)
        plot(x,y_2)
        grid(True)
 
        if self.part_one < 0:
 
            print  "No Real Root"
 
        elif self.fun[0] == 0:
 
            print "Single Root: ", self.single_root()
 
        else:
 
            print "Root One: ", self.root_one() 
 
            print "Root Two: ", self.root_two()
 
if __name__ == '__main__':
 
#the equation will like y=x^2+4x+1
    y1=np.array([1,4,1])
 
    y2=np.array([-1,1,1])
 
    test=intersect(y1,y2) 
 
    test.final()

"""
Austin Jenchi
Intro to Game Programming - 8th Period
Squaring Things
"""

def square(base, root):
    number = base
    for x in range(1, root):
        number = number + base
    return number;

print(square(4, 4))

#square root function with check condition

#function definition
def sqroot(x):
    if x <= 0:
        print "Positive number only."
        return

    sqrt = x**0.5     #square root
    print "Square root of ", x, " is ", sqrt

#input
x = input("Enter x: ")

#function call
sqroot(x)

import math
import random

# self-mad #
############

def my_own_assert(cond):
  if not cond:
    raise AssertionError
    
#my_own_assert(2 + 2 == 5)


# built in #
############
#assert(2+2 == 5)


# Precondtion and Postconditon #
################################
def square_root(x, eps= 10e-7):
  # PREcondition
  assert x >= 0     
  y = math.sqrt(x)
  # POSTcondition
  #assert y*y == x   
  assert abs((y*y)-x) < eps   # includes rounding error             
  return y


for i in range(1,1000):
  r = random.random() * 10000
  try:
    z = square_root(r)
  except:
    print r, r - math.sqrt(r) * math.sqrt(r) # Rounding Error!
    break
  
print "Done!"

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/env python

"""
Exam 2: SOLUTION                                                      /25

For syntax help see:

  /Code/Python/test.py 
  /Code/Python/functions.py 
  /Solutions/lab08/lab08.py

  Note: Leave existing code in - your job is to add the function definitions 
  as specified

  Do not call existing functions in the python math library - write your 
  funtions from scratch.
"""

from sys import argv

"""
#1. Write a recursive function exp_2 that takes as arguments integer x, x >= 0,
    and returns 2^x. 
"""

def exp_2( x ):               # f(x) = 2^x, for x >= 0
  if x == 0:
     return 1 
  else:
     return 2 * exp_2(x-1) 

print exp_2(5)                # call the function

"""
#2. Write a function log_2 that takes as arguments integer x, where x is some
    value 2^k, k >= 0, and returns log base 2 of x. 
"""

def log_2( x ):               # g(x) = log_base_2(x), for x = 2^k, k >= 0
  if x == 1:
     return 0
  else:
     return 1 + log_2( x/2.0) 

print log_2(32)               # call the function

"""
#3. Write a function sq_rt that takes as arguments an integer x, where x is 
    some integer k*k, k >= 1, and returns the square root of x. 
"""

def sq_rt( x ):               # f(x) =  square_root(x), for x = k*k, k >= 1  
   tmp = 1
   while tmp < x / 2:
      if tmp * tmp == x:
         return tmp
      else:
         tmp = tmp + 1
   return 0

print sq_rt(25)               # call the function

def sq_rt2( x ):              # another version
   tmp = 1
   while x/tmp != tmp:
      tmp = tmp + 1
   return tmp

# print sq_rt2(25)              # call the function
"""
#4. Write a function square that takes as arguments integer x, x >= 1, and 
    returns x*x. 
"""
 
def square( x ):               # g(x) =  x*x, for x >= 1  
  return x * x

print square(5)                # call the function

"""
#5. Write a function inverse that takes as arguments two functions f and g and 
    an integer x, x >= 1. Function inverse returns true if f(g(x)) == x. 
"""

def inverse (f, g, x):           # return true if f(g(x)) = x
  return (f (g (x) ) == x)

print inverse(log_2, exp_2, 5)                  # should return true
print inverse(sq_rt, square, 5 )                # should return true
print inverse(lambda x: x*2, lambda x: x+2, 5)  # should return false

import math

def approx_equal(a, b, limit):
    if abs(a-b) < limit:
        return True
    else:
        return False


def square_root (a):
    x = a / 2.0
    epsilon = 0.001
    while True:
        #print x
        y = (x + a/x) / 2.0
        if approx_equal (y, x, epsilon):
            break
        x = y
    return x
    
def test_square_root(a):
    ex_sqrt = square_root(a)
    py_sqrt = math.sqrt(a)
    diff = abs(ex_sqrt-py_sqrt)
    print a, ex_sqrt, py_sqrt , diff
    
print test_square_root(1.0)
print test_square_root(2.0)
print test_square_root(3.0)

import math

def squareroot(n):
    x = n
    e = 0.0000001
    y = 1
    while (x - y > e):
        x = (x + y) / 2
        y = n / x
    return x


number = float(input("Enter the number that you want to know the square root please: " ))

calcul_squareroot = squareroot(number)
print (calcul_squareroot)

def PIECE___root_mean_square_error():
    """PIECE___root_mean_square_error:

    ROOT_MEAN_SQUARE_ERROR = sum of squared differences between items in PREDICTED_OUTPUTS multi-dimensional
    array and TARGET_OUTPUTS multi-dimensional array, divided by the number of cases, then square-rooted
    """

    forwards = {'root_mean_square_error':
                    [lambda a0, a1: sqrt(((a1 - a0) ** 2).sum() / a0.shape[0]),
                     {'a0': 'target_outputs',
                      'a1': 'predicted_outputs'}]}

    backwards = {('DOVERD', 'root_mean_square_error', 'predicted_outputs'):
                     [lambda a0, a1, rmse: ((a1 - a0) / a0.shape[0]) / rmse,
                      {'a0': 'target_outputs',
                       'a1': 'predicted_outputs',
                       'rmse': 'root_mean_square_error'}]}

    return Piece(forwards, backwards)
from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

import numpy as np
'''
This module has a hypotonuse functions
'''
def add(a,b):
    return a+b

def sub(a,b):
    return a-b

def square(a):
    return a*a

def root(a):
    return a**.5


import numpy as np
from math import sqrt

def loss(y_true, y_pred):
"""
Implementation of the Root Mean Square Percentage Error (RMSPE)
"""
	return sqrt(np.mean((y_true - y_pred)/y_true)**2)
user_input = float(input("Please enter a positive number...\n"))

def square_root(x):
     count = 0
     ballpark_num = 1
     while round(ballpark_num**2 - user_input,2) != 0:
         new_number = 0.5*(ballpark_num + (x/ballpark_num))
         ballpark_num = new_number
         count += 1
         print("Count is {} number is {}".format(count,ballpark_num))
     return new_number
print("The Square Root of {} is {}".format(user_input, square_root(user_input)))

#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Tuenti Challenge 3
#
# Challenge 11 - The escape from Pixel Island

# Look behind you, a Three-Headed Monkey!

import sys
import re
from PIL import Image, ImageDraw
from qrtools import QR

def parse_square(text):   
    if text[0] == 'w' or text[0] == 'b':
        return [ text[0], text[0], text[0], text[0] ]
        
    text = text[1:]
    square = []
    root = square
    pending = []
    
    while True:
        for c in text[0:4]:
            if c == 'p':
                square.append(None)
            else:
                square.append(c)
                
        text = text[4:]
        for i in range(len(square)):
            if square[i] is None:
                l = []
                square[i] = l
                pending.append(l)
        if len(pending) == 0:
            break
            
        square = pending[0]
        del pending[0]
    
    return root



    

def square_to_text(square):
    def square_to_text_inner(square):
        s = ''
        for elem in square:            
            if isinstance(elem, list):
                s += 'p'
            else:
                s += elem
                
        for elem in square:
            if isinstance(elem, list):
                s += square_to_text_inner(elem)
                
        return s
                
    text = square_to_text_inner(square)
    if text == 'wwww':
        return 'w'
    elif s == 'bbbb':
        return 'b'
    
    return 'p' + text
        

def add_squares(sq1, sq2):
    result = []
    for i in range(4):
        if not isinstance(sq1[i], list) and not isinstance(sq2[i], list):
            if sq1[i] == 'b' or sq2[i] == 'b':
                result.append('b')
            else:
                result.append('w')
        else:
            if not isinstance(sq1[i], list):
                c = sq1[i]
                sq1[i] = [ c, c, c, c ]
                
            if not isinstance(sq2[i], list):
                c = sq2[i]
                sq2[i] = [ c, c, c, c ]

            r = add_squares(sq1[i], sq2[i])
            if r == [ 'w', 'w', 'w', 'w' ]:
                r = 'w'
            elif r == [ 'b', 'b', 'b', 'b' ]:
                r = 'b'
            
            result.append(r)
            
    return result


def compress_square(square):
    result = []
    
    for elem in square:
        if isinstance(elem, list):
            if elem == [ 'w', 'w', 'w', 'w' ]:
                result.append('w')
            elif elem == [ 'b', 'b', 'b', 'b' ]:
                result.append('b')
            else:
                result.append(compress_square(elem))
        else:
            result.append(elem)

    return result
    

def get_square_depth(square, level):
    max_level = level
    
    for elem in square:
        if isinstance(elem, list):
            max_level = max(max_level, get_square_depth(elem, level + 1))
                
    return max_level


def get_square_size(square):
    
    depth = get_square_depth(square, 1)
    return 2**depth

   


def create_png(filename, square, max_level):
    
    def paint_png(draw, square, x0, y0, x1, y1, level, max_level):
        
        xh = (x0 + x1) // 2
        yh = (y0 + y1) // 2
        
        rects = [ ((xh, y0), (x1, yh)),
                  ((x0, y0), (xh, yh)),
                  ((x0, yh), (xh, y1)),
                  ((xh, yh), (x1, y1))]
                  
        
        for elem, rect in zip(square, rects):
            draw_rect = ((rect[0][0], rect[0][1]), (rect[1][0] - 1, rect[1][1] - 1))
            if not isinstance(elem, list):
                if elem == 'b':
                    color = 0
                else:
                    color = 1
                    
                draw.rectangle(draw_rect, fill = color)

            else:
                if level == max_level:
                    draw.rectangle(draw_rect, fill = 0)
                else:
                    paint_png(draw, elem, rect[0][0], rect[0][1], rect[1][0], rect[1][1], level + 1, max_level)
                                    
    
    max_level = min(get_square_depth(square, 1), max_level)
    size = 2**max_level
    
    im = Image.new('1', (size, size), 1)
    
    draw = ImageDraw.Draw(im)
    paint_png(draw, square, 0, 0, size, size, 1, max_level)
    
    # Resize the Image to avoid problems decoding
    im2 = im.resize((size * 3, size * 3))    
    im2.save(filename, "PNG")
    
    
import unicodedata

if __name__ == '__main__':
    resolution_level = 9
    
    num_cases = int(sys.stdin.readline())
    
    for num_case in range(num_cases):
        text_squares = sys.stdin.readline().rstrip('\r\n').split()

        squares = [ parse_square(s) for s in text_squares ]

        s = squares[0]
        
        for i in range(1, len(squares)):            
            s = add_squares(s, squares[i])       
               
        qrname = u'case%d_sum.png' % (num_case + 1)
        create_png(qrname, s, resolution_level)
        
        myCode = QR(filename=qrname)
        if myCode.decode():
            #m = md5.new()
            #m.update(myCode.data_to_string())
            #print m.hexdigest()
            secret = myCode.data_to_string()
            # Strip non iso-8859-1 characters
            secret = secret.decode('utf-8')
            secret = secret.encode('iso-8859-1', 'ignore')
            print secret
            
            


import math
import random

############################
## Wiener's Attack module ##
############################

# Calculates bitlength


def bitlength(x):
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n

# Squareroots an integer


def isqrt(n):
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a + b)
    while True:
        y = (x + n // x) // 2
        if y >= x:
            return x
        x = y

# Checks if an integer has a perfect square


def is_perfect_square(n):
    h = n & 0xF  # last hexadecimal "digit"
    if h > 9:
        return -1  # return immediately in 6 cases out of 16.
    # Take advantage of Boolean short-circuit evaluation
    if (h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8):
        # take square root if you must
        t = isqrt(n)
        if t * t == n:
            return t
        else:
            return -1
    return -1

# Calculate a sequence of continued fractions


def partial_quotiens(x, y):
    partials = []
    while x != 1:
        partials.append(x // y)
        a = y
        b = x % y
        x = a
        y = b
    # print partials
    return partials

# Helper function for convergents


def indexed_convergent(sequence):
    i = len(sequence) - 1
    num = sequence[i]
    denom = 1
    while i > 0:
        i -= 1
        a = (sequence[i] * num) + denom
        b = num
        num = a
        denom = b
    #print (num, denom)
    return (num, denom)

# Calculate convergents of a  sequence of continued fractions


def convergents(sequence):
    c = []
    for i in range(1, len(sequence)):
        c.append(indexed_convergent(sequence[0:i]))
    # print c
    return c

# Calculate `phi(N)` from `e`, `d` and `k`


def phiN(e, d, k):
    return ((e * d) - 1) / k

# Wiener's attack, see http://en.wikipedia.org/wiki/Wiener%27s_attack for
# more information


def wiener_attack(N, e):
    (p, q, d) = (0, 0, 0)
    conv = convergents(partial_quotiens(e, N))
    for frac in conv:
        (k, d) = frac
        if k == 0:
            continue
        y = -(N - phiN(e, d, k) + 1)
        discr = y * y - 4 * N
        if(discr >= 0):
            # since we need an integer for our roots we need a perfect squared
            # discriminant
            sqr_discr = is_perfect_square(discr)
            # test if discr is positive and the roots are integers
            if sqr_discr != -1 and (-y + sqr_discr) % 2 == 0:
                p = ((-y + sqr_discr) / 2)
                q = ((-y - sqr_discr) / 2)
                return p, q, d
    return p, q, d
e = 0x0285F8D4FE29CE11605EDF221868937C1B70AE376E34D67F9BB78C29A2D79CA46A60EA02A70FDB40E805B5D854255968B2B1F043963DCD61714CE4FC5C70ECC4D756AD1685D661DB39D15A801D1C382ED97A048F0F85D909C811691D3FFE262EB70CCD1FA7DBA1AA79139F21C14B3DFE95340491CFF3A5A6AE9604329578DB9F5BCC192E16AA62F687A8038E60C01518F8CCAA0BEFE569DADAE8E49310A7A3C3BDDCF637FC82E5340BEF4105B533B6A531895650B2EFA337D94C7A76447767B5129A04BCF3CD95BB60F6BFD1A12658530124AD8C6FD71652B8E0EB482FCC475043B410DFC4FE5FBC6BDA08CA61244284A4AB5B311BC669DF0C753526A79C1A57
n = 0x02AEB637F6152AFD4FB3A2DD165AEC9D5B45E70D2B82E78A353F7A1751859D196F56CB6D11700195F1069A73D9E5710950B814229AB4C5549383C2C87E0CD97F904748A1302400DC76B42591DA17DABAF946AAAF1640F1327AF16BE45B8830603947A9C3309CA4D6CC9F1A2BCFDACF285FBC2F730E515AE1D93591CCD98F5C4674EC4A5859264700F700A4F4DCF7C3C35BBC579F6EBF80DA33C6C11F68655092BBE670D5225B8E571D596FE426DB59A6A05AAF77B3917448B2CFBCB3BD647B46772B13133FC68FFABCB3752372B949A3704B8596DF4A44F085393EE2BF80F8F393719ED94AB348852F6A5E0C493EFA32DA5BF601063A033BEAF73BA47D8205DB
p, q, d = wiener_attack(n, e)
print p
print q
print d
################################
## End Wiener's Attack module ##
################################

def newsqrt(a):
    x=a/2
    e=0.0005
    while True:
        y=(x+a/x)/2
        if x==y and abs(y-x)<e:
              return y
              break
        else:
               x=y
n=float(raw_input('enter a\n'))
print "square_root of",n,"is",newsqrt(n)


from scipy import power
from amari import Amari


class RMSProp(Amari):
    """ Root-mean-square-normalized SGD (Hinton 2012). """    

    exponent = -0.5

    @property
    def learning_rate(self):
        return self.init_lr * power(self._acc_grad_var, self.exponent)

def babylonian(a):
    r = a
    while (p > q):
        p = (p + q)/2.0
        q = r/p
    return p

a = float(input("Introduce a number: "))
b = babylonian(a)

print ("The babylonian square root of ", a, " is ", b)

import operator, math

class memoize:
    def __init__(self, f):
        self.f = f
        self.memo = {}
    def __call__(self, *args):
        if not args in self.memo:
            self.memo[args] = self.f(*args)
        return self.memo[args]

@memoize
def factorial(n):
    return reduce(operator.mul, range(2,n+1), 1)

def choose(n, k):
    return reduce(operator.mul, range(n-k+1, n+1), 1) / factorial(k)

def triangular(p):
    return (p * (p+1)) / 2

def num_divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num

def divisors(p):
    div = set()
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root+1):
        if p % x == 0:
            div.add(p/x)
            div.add(x)
    if p > 1: div.remove(p)
    return div

def word_score(word):
    return sum( (ord(x) - ord('A')+1) for x in word)

def get_primes(limit):
    numbers = [True] * limit
    numbers[0] = False
    numbers[1] = False

    for sieve in range(2, limit):
        if not numbers[sieve]:
            # find next prime
            continue

        yield sieve

        for x in range(sieve+sieve, limit, sieve):
            numbers[x] = False

_primes = set()
_non_primes = set()
_prime_limit = 1000000
def is_prime(x):
    if len(_primes) == 0:
        _primes.update(get_primes(_prime_limit))
    if x in _primes:
        return True
    if x in _non_primes or x < _prime_limit:
        return False

    if x % 3 == 0 or x % 2 == 0:
        _non_primes.add(x)
        return False

    for d in range(6, int(math.sqrt(x)), 6):
        if x % (d+1) == 0 or x % (d-1) == 0:
            _non_primes.add(x)
            return False

    _primes.add(x)
    return True

def gcd(a, b):
    if a > b:
        a, b = b, a
    while b != 0:
        a, b = b, a % b
    return a

def lcd(a, b):
    return a * b / gcd(a, b)

def permute(seq, pred=cmp):
    """Like C++ std::next_permutation() but implemented as
    generator. Yields copies of seq."""

    def reverse(seq, start, end):
        # seq = seq[:start] + reversed(seq[start:end]) + \
        #       seq[end:]
        end -= 1
        if end <= start:
            return
        while True:
            seq[start], seq[end] = seq[end], seq[start]
            if start == end or start+1 == end:
                return
            start += 1
            end -= 1

    if not seq:
        raise StopIteration

    try:
        seq[0]
    except TypeError:
        raise TypeError("seq must allow random access.")

    first = 0
    last = len(seq)
    seq = seq[:]

    # Yield input sequence as the STL version is often
    # used inside do {} while.
    yield seq

    if last == 1:
        raise StopIteration

    while True:
        next = last - 1

        while True:
            # Step 1.
            next1 = next
            next -= 1

            if pred(seq[next], seq[next1]) < 0:
                # Step 2.
                mid = last - 1
                while not (pred(seq[next], seq[mid]) < 0):
                    mid -= 1
                seq[next], seq[mid] = seq[mid], seq[next]

                # Step 3.
                reverse(seq, next1, last)

                # Change to yield references to get rid of
                # (at worst) |seq|! copy operations.
                yield seq[:]
                break
            if next == first:
                raise StopIteration
    raise StopIteration

def is_square(n):
    sq = int(math.sqrt(n))
    return sq * sq == n

_fprimes = [2]

@memoize
def factors(n, first):
    global _fprimes
    if _fprimes[-1] < n:
        _fprimes = list(get_primes(n*2))

    factors = []
    for p in _fprimes:
        while n % p == 0:
            factors.append(p)
            n /= p
        if n == 1:
            break
    return factors

def zipWith(f, a, b):
    return map(f, zip(a,b))

def compose(f, g):
    def fg(*a, **kw):
        return f(g(*a, **kw))
    return fg

def trace(f):
    def inner(*a, **kw):
        print '> calling', f.func_name, 'with ', a, kw
        r = f(*a, **kw)
        print '> returning', f.func_name, r
        return r
    return inner

from math import sqrt


def is_prime(n):
    square_root_of_potential_prime = sqrt(n)

    for i in range(2, int(square_root_of_potential_prime) + 1):
        if n % i == 0:
            return False

    return True


def generate_nth_prime(n):
    prime_count = 0
    current_number = 1

    while prime_count < n:
        current_number += 1

        if is_prime(current_number):
            prime_count += 1

    return current_number

if __name__ == '__main__':
    print('10,001st prime number: ', generate_nth_prime(10001))

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline


import math

def is_prime(N):
	square_root = math.sqrt(N)
	dividers = [ d for d in range(2,int(square_root)+1) ]
	for d in dividers:
		if N % d == 0:
			return False
	return True

N=2000000
ints = range(2,N+1)
primes = []
for i in ints:
	if is_prime(i):
		primes.append(i)
sum_prime=sum(primes)

f = open('p010.txt','w')
f.write(str(sum_prime))
f.close()
low = 1
upper = 100
prec = 1000

# http://en.wikipedia.org/wiki/Integer_square_root
# Use Newton's method
def isqrt(n):
    x = n
    y = (x + n // x) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x

def count_digits_in_sqrt(num):
    return sum(map(int, str(isqrt(num * 10 ** (2 * (prec - 1))))))

total = 0
rational_root = 1
for curr in xrange(low, upper+1):
    if rational_root ** 2 != curr:
        total += count_digits_in_sqrt(curr)
    else:
        rational_root += 1

print total

# -*- coding: utf-8 -*-

import math

def square_root(a):
	x = a / 2.0
	while True:
	    y = (x + a/x) / 2.0
	    if abs(y-x) < 0.001:
	        break
	    x = y
	return y

print square_root(4)
print square_root(9)
print square_root(16)
print square_root(25)
print square_root(100)
print square_root(8)
print square_root(15)

#Write a program to determine the biggest prime palindrome under 1000. 

def square_root(num):
    initial_guess = 1
    while 1:    
        f_x = float(initial_guess*initial_guess - num)
        der_f_x = float(2 * initial_guess)
        new_guess = initial_guess - (f_x/der_f_x)*1.0
        if( abs(initial_guess-new_guess) < 0.001 or abs(initial_guess-new_guess)==0):
            break
        initial_guess = new_guess
    return "%.4f" %new_guess    
    
def is_prime(num):
    root = int(float(square_root(num)))
    for i in range(2,root+1):
        if( num%i == 0 ):
            return 1
    return 0    

def is_palindrome(num):
    dummy = int(num)
    rev = 0
    while(dummy!=0):
        r = dummy%10
        rev = rev*10+r
        dummy=int(dummy/10)
    if(num==rev):
            return 0
    return 1    


counter = 0
for i in range(1000,1,-1):
    if(is_prime(i)==0 and is_palindrome(i)==0):
        print(i)
        break
    
'''
name: Joshua Rodriguez
email: ewized@gmail.com
file: perfect_square.py
problem: chapter 2 number 10 page 145
description: Write a short program that will
    * prompt the user for a number
    * print out whether the number is a perfect square
    * prompt the user for another number if the number is now a perfect square
'''
import math

is_square = input("Enter a number: ")

def is_perfect_square(is_square):
    root = math.sqrt(int(is_square))
    return int(root) ** 2 == int(is_square)

while not is_perfect_square(is_square):
    #print(str(is_square))
    is_square = input("That was not a perfect square, enter another number: ")
else:
    print(str(is_square) + " was a perfect square well done!")


# Newton-Raphson for square root of a number

number = float(raw_input("Enter a positive number: "))

def newton_raphson_sqrt(number):
  epsilon = 0.01
  y = number
  guess = y/2.0

  while abs(guess*guess - y) >= epsilon:
    guess = guess - (((guess**2) - y)/(2*guess))
    #print(guess)

  return guess

print('Square root of ' + str(number) + ' is about ' + str(newton_raphson_sqrt(number)))
import numpy as np

def RMSE(estimation, truth):
    """Root Mean Square Error"""

    num_sample = len(estimation)

    # sum square error 
    sse = np.sum(np.square(truth - estimation))
    return np.sqrt(np.divide(sse, num_sample - 1.0))

# Newton's method to approximate square root
def sqrt(w, eps = 1.e-14, maxIter = 100):
  x = 1.
  for i in range(maxIter):
    x_old = x
    x = (x + w/x)/2
    if abs(x - x_old)/w < eps:
      return x




def fsolve(func, x0):
  pass

print(sqrt(99))
import sys
import math

def square_root(a):
    x = a/2.0
    y = x
    while True:
        #print "x = ", x
        y = (x + a / x) / 2.0
        #print "y = ", y
        if abs(y-x) < sys.float_info.epsilon:
            break

        x = y

    return x

def test_square_root():
    for i in range(1, 10):
        print i,
        mysqrt = square_root(i)
        print mysqrt,
        mathsqrt = math.sqrt(i)
        print mathsqrt,
        print abs(mysqrt - mathsqrt)

#test_square_root()

def factorial(n):
    if n < 0:
        return None
    elif n < 2:
        return 1
    else:
        return n * factorial(n - 1)

def estimate_pi():
    tot = 0
    k = 0
    factor = (2 * math.sqrt(2)) / 9801

    while True:
        num = factorial(4 * k) * (1103 + (26390 * k))
        den = (factorial(k) ** 4) * (396 ** (4 * k))
        term = factor * (num / den)
        tot += term

        if abs(term) < 1e-15: break

        k += 1

    return 1 / tot

print estimate_pi()
#!/usr/bin/env python

def square_root(a, x):
    while True:
        y = (x + a/x) / 2      
        if abs(y-x) < 0.0000001:
            return x
        x = y    
        
if __name__ == '__main__':
    print square_root(4.0, 3.0)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#euler 206
"""
Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0,
where each _ is a single digit.
"""
#in order for last digit of square to be 0, second to last digit must also be 0
#so square root must be multiple of 10
#consider 1_2_3_4_5_6_7_8_9 and multiply answer by 10

def found(n):
    n_string = str(n)
    for i in range(9):
        if int(n_string[i * 2]) != (i + 1):
            return False
    return True

    
#square root of 10203040506070809 (min) is 101010102
#for square to end in 9, square root must end in 3 or 7
n = 101010103

while not found(n ** 2):
    #increment end 3 to end 7
    if str(n)[-1] == "3":
        n += 4
    #increment end 7 to end 3
    else:
        n += 6

#multiplying by 10
print(n * 10)

'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
#! /usr/local/bin/python3.1

from math import sqrt

def isPrime (candidate):
    """
    Determines if candidate is prime or not.
    """
    if ((candidate % 2) == 0):
        if (candidate == 2):
            return True
        else:
            return False

    squareRoot = sqrt(candidate)
    i = 3
    while (i <= squareRoot):
        if ((candidate % i) == 0):
            return False
        i += 2

    return True


number = 600851475143
biggestPrime = sqrt(number)//1
if ((biggestPrime % 2) == 0):
    biggestPrime -= 1

print("Largest prime factor of", number, "is:")

while (biggestPrime > 1):
    if (isPrime(biggestPrime) and ((number % biggestPrime) == 0)):
        print(int(biggestPrime))
        break
    biggestPrime -= 2

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/python
def fact(n):
    if n >= 0:
        return fact2(n, 1)
    else:
        raise ValueError("Input must be more than or equal to 0")
def fact2(a, b):
    if a != 1:
        return fact2(a - 1, b * a)
    else:
        return b
    
def fib(n):
    if n >= 0:
        return fib2(n, 0, 1)
    else:
        raise ValueError("Input must be more than or equal to 0")
def fib2(a, b, c):
    if a != 1:
        return fib2(a - 1, c, b + c)
    else:
        return b

def sqrt(n):
    if n > 0:
        return sqrt2(n, 1)
    elif n == 0:
        return 0
    else:
        raise ValueError("Input must be more than or equal to 0")

def sqrt2(a, b):
    if abs(a - b * b) > .000000000000001:
        return sqrt2(a, (a/b + b)/2)
    else:
        return b

print("Factorial of 10")    
print(fact(10))
print("Fib of 20")
print(fib(20))
print("Square root of 625")
print(sqrt(625))

def square(x):
    """Return the square of `x`.

    Parameters
    ----------
    x : int or float
        The input number.

    Returns
    -------
    x2 : same type as `x`
        The square of the input value.

    Examples
    --------
    >>> square(5)
    25
    """
    return x ** 2


def sqrt(x):
    """Return the square root of `x`.
    
    Examples
    --------
    >>> sqrt(4.0)
    2.0
    """
    return x * 0.5

def sqrt(a):
    if a==0:
        return a
    elif a<0:
        return ('Error: The square root of a negative number is an imaginary number')
    else:
        n=0
        i=0
        while n<a:
            n=i**2
            i=i+1

        if n==a:
            return (i-1)

        else:
            g=(i-1)
            ng=((a/g)+g)/2
            while (ng != g):
                g=ng
                ng=((a/g)+g)/2
            return ng

r='y'
while r=='y' or r=='Y':
    while True:
        try:
            x=float(input('Please enter a number to apply square root: '))
            break
        except ValueError:
            print ('This is not a number, please try again')

    print (sqrt(x))
    r=input('Do you want to try any other number?(y/n) ')

'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# sqrt.py - finding square roots

ERROR = 0.0000000001

def square(x):
    """Returns the square of a number."""
    return x*x

def average(x,y):
    """Returns the average of two numbers."""
    return (x + y) / 2

def my_abs(x):
    """Returns the absolute value of x."""
    if x < 0:
        return -x
    else:
        return x

def sqrt(x, error):
    """Returns an approximation to the square root.
        Using Heron of Alexandria's algorithm."""
    guess = 1
    while my_abs(square(guess) - x) > error:
        guess = average(guess, x / guess)
    return guess

#main
print(sqrt(float(input("Square Root of: ")), ERROR))

#!/usr/bin/env python

__author__ = "bt3"

''' implement square root using binary search '''


def find_sqrt_bin_search(n, error=0.001):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid


def test_ind_sqrt_bin_search():
    number = 9
    assert(find_sqrt_bin_search(number) == 3)
    print('Tests passed!')


if __name__ == '__main__':
    test_ind_sqrt_bin_search()






import numpy as np

def power(x):
  return x**2
#
# Some more comments
#
def square_root(x):
  return np.sqrt(x)

#
# doesn't work on negative numbers
#
# (or strings)



#! /usr/bin/python
#
# From http://greenteapress.com/thinkpython/html/thinkpython008.html
# Chapter 7 exercise 2
# Implement Newton's method to find square roots
#

epsilon = 1.0E-12

def sqrt ( x ) :
    while True:
        print x
        y = (x + a/x) / 2
        if abs(y-x) < epsilon :
            break
        x = y
    return y

while True :
    a = float( raw_input ( "Enter a value to the take the square root of " ) )
    x = sqrt(a)
    e = a - x*x
    print "The calculated square root is ", x, " and the error is ", e


x = 0
root = 0
def squareRoot(x, maxPrecision, root):
    precision = maxPrecision
    low = 0.0
    high = x
    guess = (low + high)/2
    while (precision > 0):
        if guess**root > x:
            high = guess
        else:
            low = guess
        guess = (low + high)/2
        precision -= 1
    return guess
while True:
    x = float(raw_input('Enter a number: '))
    root = int(raw_input('Enter a number: '))
    if root <= 10:
        if root == 1:
            print('The first root of ' + str(x) + ' is about ' + str(squareRoot(x, 1000000, root)))
        elif root == 2:
            print('The square root of ' + str(x) + ' is about ' + str(squareRoot(x, 1000000, root)))
        elif root == 3:
            print('The cube root of ' + str(x) + ' is about ' + str(squareRoot(x, 1000000, root)))
        else:
            print('The ' + str(root) + 'th root of ' + str(x) + ' is about ' + str(squareRoot(x, 1000000, root)))
    else:
        print 'The exponent was too small!'
'''
Find the square root of n.

    Input: A number
    Output: The square root or the integers closest to the square root
    Assume: positive n

 Newton's method is a popular solution for square root, but not implemented here.
'''

def sqrt(n):
    for number in range(0, n):
        if isSqrt(number,n):
            return number
        else:
            if n < number * number:
                return number, number - 1


def isSqrt(a,b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True
    else:
        return False


# Test Section
if __name__ == '__main__':
    print "sqrt(25) = 5: %s" % (sqrt(25) == 5)
    print "sqrt(30) = (6, 5): %s" % (sqrt(30) == (6,5))


"""A program that asks the user for a positive number and then outputs the approximated square root of the number."""
while True:
    try:
        num = float(input('Please input a number:  '))
        break
    except:
        print("ERROR: Input not a number")
        continue

#print(num)

def sq_rt (num):
    """Approximates square root of parameter to 2 decimal places"""
    neg=""
    if num < 0:
        num = abs(num)
        neg = 'i'
    guess_1 = 1
    guess_2 = 0
    count = 0
    while round(guess_1, 2) != round(guess_2, 2):
        count += 1
        guess_2 = guess_1
        guess_1 = (guess_1 + num/guess_1)/2
        print("This loop has iterated", count, "times and the current guess is", str(guess_1)+".")
    return (str(round(guess_1,2))+neg)

print("The square root of", num, "is", sq_rt(num))

import fractions

def squareRootConvergents():
    count = 1
    numberCount = 0
    x = 2 + fractions.Fraction(1,2)
    while count < 999:
        y = 1 + 1 / x
        if len(str(y).split('/')[0]) > len(str(y).split('/')[1]):
            numberCount += 1
        x = 2 + 1 / x
        count += 1
    return numberCount
print squareRootConvergents()

import math

def is_prime(n):
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    max_divisor = int(n ** 0.5) # square root of n
    divisor = 5
    while divisor <= max_divisor:
        if n % divisor == 0 or n % (divisor + 2) == 0:
            return False
        divisor += 6
    return True

def factorize(n):
    factors = []

    for x in range(2, int(math.sqrt(n))+1):
        if n%x == 0:
            factors.append(x)
            factors.append(n/x)

    return factors

def chunker(lst, length):
    return (lst[pos:pos+length] for pos in xrange(0, len(lst)))

# Lambda

square = lambda x: x * x

# square
# <function <lambda> at 0x7fc6d32187d0>

# A function with formal parameter x that returns the value of "x * x"
# must be a single expression
# Important: No "return" keyword!

# Only the def statement gives the function an intrinsic name

def square(x):
    return x * x

# square
# <function square at 0x7fc6ce6582a8>

# Currying: transforming a multi-argument function into a single-argument, higher-order function

def curry2(f):
    """Returns a function g such that g(x)(y) returns f(x, y).

    >>> from operator import add
    >>> add_three = curry2(add)(3)
    >>> add_three(4)
    7
    """
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g

# curry2 = lambda f: lambda x: lambda y: f(x, y)
# curry2(add)(3)(2010)
# 2013

# Direct implementations of iterative improvement

def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x

def square_root_update(x, a):
    return (x + a/x) / 2

def cube_root(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    x = 1
    while pow(x, 3) != a:
        x = cube_root_update(x, a)
    return x

def cube_root_update(x, a):
    return (2*x + a/(x*x)) / 3

# How to find the square root of 2?
# f = lambda x: x*x - 2
# df = lambda x: 2*x
# find_zero(f, df)

# How to find the cube root of 729?
# g = lambda x: x*x*x - 729
# dg = lambda x: 3*x*x
# find_zero(g, dg)

# General iterative improvement

def improve(update, close, guess=1):
    """Iteratively improve guess with update until close(guess) is true."""
    while not close(guess):
        guess = update(guess)
    return guess

def improve(update, close, guess=1, max_updates=100):
    """Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied."""
    k = 0
    while not close(guess) and k < max_updates:
        guess = update(guess)
        k = k + 1
    return guess

def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance

def square_root_improve(a):
    """Return the square root of a.

    >>> square_root_improve(9)
    3.0
    """
    def update(x):
        return square_root_update(x, a)
    def close(x):
        return approx_eq(x * x, a)
    return improve(update, close)

def cube_root_improve(a):
    """Return the cube root of a.

    >>> cube_root_improve(27)
    3.0
    """
    return improve(lambda x: cube_root_update(x, a),
                   lambda x: approx_eq(x*x*x, a))

def cube_root2(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    def update(x):
        return cube_root_update(x, a)
    def close(x):
        return approx_eq(pow(x, 3), a)
    return improve(update, close)

# Newton's method

def find_zero(f, df):
    """Return a zero of the function f with derivative df."""
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)

def newton_update(f, df):
    """Return an update function for f with derivative df,
    using Newton's method."""
    def update(x):
        return x - f(x) / df(x)
    return update

def square_root_newton(a):
    """Return the square root of a.

    >>> square_root_newton(9)
    3.0
    """
    def f(x):
        return x*x - a
    def df(x):
        return 2*x
    return find_zero(f, df)

def cube_root_newton(a):
    """Return the cube root of a.

    >>> cube_root_newton(27)
    3.0
    """
    return find_zero(lambda x: x*x*x - a, lambda x: 3*x*x)

def power(x, n):
    """Return x * x * x * ... * x for x repeated n times."""
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product

def nth_root_of_a(n, a):
    """Return the nth root of a.

    >>> nth_root_of_a(2, 64)
    8.0
    >>> nth_root_of_a(3, 64)
    4.0
    >>> nth_root_of_a(6, 64)
    2.0
    """
    def f(x):
        return power(x, n) - a
    def df(x):
        return n * power(x, n-1)
    return find_zero(f, df)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def euler66():
	ans, ansmax = 0, 0
	for num in xrange(2, 1001):
		try:
			x, y = getApprox(num)
			if x > ansmax:
				ans, ansmax = num, x
		except StandardError:
			continue
	print ans

def continuedroot(number):
	from math import sqrt
	m, d, a, continued, Done = 0, 1, int(sqrt(number)), [], False
	a0 = a
	if a0**2 == number:
		raise StandardError("Cannot find a continued fraction for the root of a perfect square")
	else:
		while a != 2*a0:
			m = d*a-m
			d = (number - m**2)/d
			a = (a0+m)/d
			continued.append(a)
		return a0, continued

def getApprox(square):
	integer, fract = continuedroot(square)
	idx, cycle = 0, len(fract)
	num, denom  = 1, fract[idx]
	a, b = 1, 1
	while a**2-square*b**2 != 1:
		idx += 1
		a, b = integer*denom+num, denom
		denom, num = denom*fract[idx%cycle] + num, denom
	return a, b

if __name__ == "__main__":
	euler66()

def power(x):
	return x ** 2

def square_root(x):
	return np.sqrt(x)

__author__ = 'swenson'

import math

def example_function(x):
    """Compute the square root of x and return it."""
    return math.sqrt(x)
import math

def sqroot(x):
    """
    Finds the square root of the number passed in
    """
    return math.sqrt(x)

if __name__ == "__main__":
    square_rt = lambda x: math.sqrt(x)
    print( sqroot(49) )  
"""Here I've added documentation"""
""" Python Script to square a number """

import numpy as np

def power(x):
	return x ** 2

def square_root(x):
	return np.sqrt(x)

from math import *
from decimal import Decimal

def euclidian_distance(a,b ):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return  sqrt(sum(pow(x-y,2) for x, y in zip(a, b)))

#===============================================================

def manathan_distance(a,b):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return sum(abs(x-y) for x,y in zip(a,b))

#===============================================================

def nth_root(value, n_root):
    root_value = 1/float(n_root)
    return round (Decimal(value) ** Decimal(root_value),3)

def minkowski_distance(x,y,p_value):
    return nth_root(sum(pow(abs(a-b),p_value) for a,b in zip(x, y)),p_value)

#===============================================================
def square_rooted(x):
    return round(sqrt(sum([a*a for a in x])),3)

def cosine_similarity(x,y):
    numerator = sum(a*b for a,b in zip(x,y))
    denominator = square_rooted(x)*square_rooted(y)
    return round(numerator/float(denominator),3)
#===============================================================

# -*- coding: utf-8 -*-

# Implement int sqrt(int x).
#
# Compute and return the square root of x.
#
# Link:
#     https://leetcode.com/problems/sqrtx/


class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        


class SudokuException(Exception):
    
    def __init__(self, value):
        self.value = value
        
        
    def __str__(self):
        return repr(self.value)
        
        
class DeniedMoveException(SudokuException):
    
    pass


class OutOfRangeException(SudokuException):
    
    def __init__(self, value):
        try:
            self.value = 'Value out of range: %d' % value
        except:
            # In case value is a string
            self.value = value



class Dimensions(object):
    """
    A Dimensions object defines the size of the sudoku board as well as the range of the allowed moves
    """

    VALID_ROOTS = [2, 3, 4]
    

    def __init__(self, root):
        try:
            introot = int(root)
            if not introot in Dimensions.VALID_ROOTS:
                raise OutOfRangeException(root)
            self.__root = introot
            self.__size = self.__root**2
        except:
            raise
        
            
    @property
    def root(self):
        """
        For a typical sudoku board, root = 3
        """
        return self.__root
        
        
    @property
    def size(self):
        """
        The board size is the root value squared: 9 for a typical sudoku board
        """
        return self.__size
        
        
    @property
    def all_moves(self):
        return set(range(1, self.__size + 1))
        
        
    def get_int_in_range(self, value):
        try:
            intvalue = int(value)
            if intvalue < 0 or intvalue > self.__size:
                raise OutOfRangeException(intvalue)
            return intvalue
        except:
            # TODO: raise a SudokuException anyway?
            raise # ValueError
    
        
class Cell(object):
    """
    A board cell
    """
    
    def __init__(self, dimensions):
        self.__value = 0
        self.__dimensions = dimensions
        self.allow_all_moves()
        self.__listeners = []
    
    
    @property
    def dimensions(self):
        return self.__dimensions
    
        
    @property
    def value(self):
        return self.__value
    
                
    def move(self, value):
        intvalue = self.dimensions.get_int_in_range(value)
        if self.__value and intvalue:
            raise DeniedMoveException('The cell has already a value')
            
        if self.__value == intvalue:
            return
            
        if intvalue:
            if not intvalue in self.allowed_moves():
                raise DeniedMoveException('This value is denied for the cell')
            self.__value = intvalue
            self.changed(0)
        else:
            old_value = self.__value
            self.__value = 0
            self.changed(old_value)
    
    
    def changed(self, old_value):
        for g in self.__listeners:
            g.cell_changed(self, old_value)
            
    
    def add_listener(self, group):
        self.__listeners.append(group)
        
        
    def empty(self):
        self.move(0)
    
        
    def is_empty(self):
        return 0 == self.__value
    
        
    def allowed_moves(self):
        return self._allowed_moves
    
        
    def is_allowed_move(self, value):
        return value in self.allowed_moves()
        
        
    def allow_all_moves(self):
        self._allowed_moves = self.dimensions.all_moves


    def deny_move(self, value):
        value = self.dimensions.get_int_in_range(value)
        if value in self._allowed_moves:
            self._allowed_moves.remove(value)
        
        
class BaseCellGroup(object):

    def __init__(self, dimensions):
        self.__cells = []
        self.__dimensions = dimensions
        
        
    @property
    def num_cells(self):
        return self.__dimensions.size

    
    def cell_changed(self, cell, old_value):
        pass
        
        
    def add_cell(self, cell):
        if len(self.__cells) == self.num_cells:
            raise IndexError('Dimensions exceeded in group')
            
        if not isinstance(cell, Cell):
            raise Exception('This is not a Cell')
            
        self.__cells.append(cell)
        cell.add_listener(self)
        
        
    def cell(self, index):
        return self.__cells[index - 1]
        
        
    @property
    def cells(self):
        return self.__cells
        
        
    @property
    def dimensions(self):
        return self.__dimensions
        
        
    # TODO create Move class
    
    def find_only_available_move(self):
        """
        Here we have 8 full cells - the nineth one gets a compulsory move
        Convert in CellSolver(group) class?
        """
        for c in self.cells:
            if not c.value:
                if len(c.allowed_moves()) == 1:
                    return (c, list(c.allowed_moves())[0])
                    
        return (None, None)
        

    def find_forced_move(self):
        """
        Only one cell of the group can have one of the available moves for the group
        """
        for value in self.allowed_moves():
            cell = None
            for c in self.cells:
                if not c.value and c.is_allowed_move(value):
                    if cell is None:
                        cell = c
                    else:
                        cell = None
                        break
            if not cell is None:
                return (cell, value)
                
        return (None, None)
            

    def find_exclusive_move(self):
        """
        ???
        """
        return (None, None)
        
        
        
class CellGroup(BaseCellGroup):
    
    def __init__(self, dimensions):
        super(CellGroup, self).__init__(dimensions)
        self.allow_all_moves()

        
    def deny_move(self, value, source_cell):
        for c in self.cells:
            c.deny_move(value)
        self._allowed_moves.remove(value)
        

    def allow_all_moves(self):
        self._allowed_moves = self.dimensions.all_moves


    def allowed_moves(self):
        return self._allowed_moves
        
        
    def cell_changed(self, cell, old_value):
        if cell.value:
            self.deny_move(cell.value, cell)
        
    
    
class Board(BaseCellGroup):
    
    def __init__(self, root):
        super(Board, self).__init__(Dimensions(root))

        self.__rows = self.__makeCellGroups()
        self.__cols = self.__makeCellGroups()
        self.__squares = self.__makeCellGroups()

        cells_per_facet = self.dimensions.size
        cells_per_board = cells_per_facet**2        
        cells_per_square_facet = root
        
        # All zero-based
        for cell_index in range(cells_per_board):
            cell = Cell(self.dimensions)
            self.add_cell(cell)
            
            board_row = cell_index / cells_per_facet
            board_col = cell_index % cells_per_facet
            self.__rows[board_row].add_cell(cell)
            self.__cols[board_col].add_cell(cell)
            
            cell_square_index = cell_index / cells_per_square_facet
            square_row = cell_square_index / cells_per_square_facet / cells_per_square_facet
            square_col = cell_square_index % cells_per_square_facet
            
            square_index = square_row*cells_per_square_facet + square_col
            self.__squares[square_index].add_cell(cell)
            
        self.__empty_cells = cells_per_board
           
            
    @property
    def size(self):
        return self.dimensions.size
        
    @property
    def num_cells(self):
        return self.dimensions.size**2

           
    def __makeCellGroups(self):
        cgs = []
        for i in range(self.dimensions.size):
            cgs.append(CellGroup(self.dimensions))
        return cgs
        
        
    def row(self, rowIndex):
        return self.__rows[rowIndex - 1]
        
        
    def col(self, colIndex):
        return self.__cols[colIndex - 1]
        
        
    def square(self, squareIndex):
        return self.__squares[squareIndex - 1]
        
    
    @property    
    def rows(self):
        return self.__rows
        
        
    @property
    def cols(self):
        return self.__cols
        
    
    @property
    def squares(self):
        return self.__squares


    def cell_changed(self, cell, old_value):
        if cell.value:
            self.__empty_cells -= 1
        else:
            self.__empty_cells += 1
            self.recalc_allowed_moves()


    def finished(self):
        return 0 == self.__empty_cells


    def recalc_allowed_moves(self):
        self.__empty_cells = self.num_cells
        
        for cell in self.cells:
            cell.allow_all_moves()
        for group in self.all_groups:
                group.allow_all_moves()
        for cell in self.cells:
            if cell.value:
                cell.changed(0)
        
        
    @property
    def all_groups(self):
        return self.__rows + self.__cols + self.__squares


    def find_forced_move(self):                    
        for group in self.all_groups:
            (c, v) = group.find_forced_move()
            if not c is None:
                return (c, v)
                    
        return (None, None)


    def find_move(self):
        (c, v) = self.find_only_available_move()
        if c is not None:
            return (c, v)
            
        return self.find_forced_move()
        

'''
7/23/12
Page 24
'''

def testable(x):
    r"""
    The 'testable' funtion returns the square root of its
    parameter, or 3, whichever is larger.
    >>> testable(7)
    3.0
    >>> testable(16)
    4.0
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    return x**0.5
import math
def square_root(a):
    x=a+0.01
    while True:
        epsilon=0.000000000001
        y=(x+a/x)/2
        if abs(y-x)<epsilon:
            return y
            break
        x=y

def test_square_root(n):
    for k in range(1,n+1):
        x=square_root(k)
        y=math.sqrt(k)
        z=abs(x-y)
        print(k,x,y,z)

def estimate_pi():
    k=0
    s=0
    a=2*math.sqrt(2)*1103/9801
    while a>1e-15:
        s+=a
        k+=1
        a=(2*math.sqrt(2)*math.factorial(4*k)*(1103+26390*k))/(9801*(math.factorial(k)**4)*(396**(4*k)))
    return 1/s

def bisection(l,a,k):
    if l[math.floor(len(l)/2):][0]<a:
        print(k)
        k=k+math.floor(len(l)/2)
        print(k)
        bisection(l[math.floor(len(l)/2):],a,k)
    elif l[math.floor(len(l)/2):][0]==a:
        return k+1
    else:
        bisection(l[:math.ceil(len(l)/2)],a,k)
testlijst=list(range(1, 9))
bisection(testlijst,7,0)
#!/usr/bin/python

"""
Notes:

(1)  Pre-optimized:
     
     It occurs to me, after writing this, that the function which searches for
     lower and upper bounds for the square root is not really necessary.  
     
     (a)  Using the same special case handling for numbers <= 1, we could just
          binary search bounds at [1, number) since, for any number > 1, that
          number's square root will be less than the number itself
     
     (b)  Even the special case handling for number <= 1 could be simplified.  
          The bounds could simply be [0, max(number, 1)].  It would be 
          worthwhile to write a "bare bones" implementation which omits many of
          the frills below and implements a simple binary search inwards.  
"""

import sys


FLOAT_EQUALS_DIFF = 0.0000001

def float_equals(a, b):
    """
    The greatest trick the devil ever played was not creating an "approximate equality" operator for floating point values
    
    Preconditions:  a, b must be floating point values
    
    Postconditions:  returns True if the a and b are "approximately equal"
    """
    
    return abs(a - b) < FLOAT_EQUALS_DIFF


def find_square_root_bounds(number, starting_lower_bound=2.0):
    """
    Given a search value and a starting lower bound, finds a lower and upper bound for the square root of that value
    
    Preconditions: number must be a positive floating point value
    
    Postconditions: returns a pair of floating point values whose squares are
                    respectively LTE and GTE the arg "number"
    """
    
    current_bound = starting_lower_bound
    while current_bound * current_bound < number:
        current_bound *= 2.0
    return (current_bound / 2.0, current_bound)


def estimate_square_root_fancy(number, accuracy):
    sqrt = None
    
    # special case: negative numbers or exact matches for 0 or 1
    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    elif float_equals(number, 1.0):
        sqrt = 1.0
    
    # let's actually compute an estimated square root
    else:
        if number < 1.0:
            lower_bound = 0.0
            upper_bound = 1.0
        else:
            lower_bound, upper_bound = find_square_root_bounds(number)
        
        # special case: early termination on exact matches
        if float_equals(lower_bound * lower_bound, number):
            sqrt = lower_bound
        elif float_equals(upper_bound * upper_bound, number):
            sqrt = upper_bound
        else:
            # binary search within bounds for an accurate estimate
            while upper_bound - lower_bound > accuracy:
                midpoint = (upper_bound + lower_bound) / 2.0
                
                # special case: early termination on exact matches
                if float_equals(midpoint * midpoint, number):
                    lower_bound = midpoint
                    upper_bound = midpoint
                    break
                elif midpoint * midpoint < number:
                    lower_bound = midpoint
                else:
                    upper_bound = midpoint
        
            sqrt = lower_bound

    return sqrt


def estimate_square_root_simple(number, accuracy):
    """
    Bare-bones square root estimator

    Set guaranteed lower and upper bounds on the solution and binary search until
    we find something close enough
    """

    sqrt = None
    
    # special case: negative numbers or exact matches for 0 or 1
    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    # let's actually compute an estimated square root
    else:
        lower_bound = 0
        upper_bound = max(number, 1.0)
        
        # binary search within bounds for an accurate estimate
        while upper_bound - lower_bound > accuracy:
            midpoint = (upper_bound + lower_bound) / 2.0
            
            if midpoint * midpoint < number:
                lower_bound = midpoint
            else:
                upper_bound = midpoint
            
            sqrt = lower_bound
    
    return sqrt


def main(argv):
    if len(argv) < 2:
        sys.stderr.write("Usage: %s <number>" % (argv[0],))
        return 1

    number = float(argv[1])
    accuracy = 0.001
    assert FLOAT_EQUALS_DIFF < accuracy

    print "Estimating square root of %g with minimum accuracy of %g" % (number, accuracy)

    sqrt_fancy = estimate_square_root_fancy(number, accuracy)
    sqrt_simple = estimate_square_root_simple(number, accuracy)

    print "Estimated square root (fancy):\n  %g" % (sqrt_fancy)
    print "Estimated square root (simple):\n  %g" % (sqrt_simple)

    diff = abs(sqrt_fancy - sqrt_simple)
    if diff > accuracy:
        print "[Warning]  Difference between square root estimations (%d) differs by more than accuracy (%d)" % (diff, accuracy)


if __name__ == "__main__":
    sys.exit(main(sys.argv))





def sqrt(n, p):
    #square root arbitrary precision using newton's method
    #http://en.wikipedia.org/wiki/Newton%27s_method#Square_root_of_a_number
    x = 10 #initial guess
    i = 0
    while i < p:
        #x = x - (x*x - n)/(2*x)
        x = (x + n/x)/2
        print x
        i += 1
    
def divisor_count(n):
    """Count number of divisors. Used on problem 12, 179.
    """
    divcount = 0
    tmax = n**0.5
    for t in xrange(1, int(tmax+1)):
        if n % t == 0:
            divcount += 2
    if t == tmax:
        divcount -= 1
    return divcount
        
if __name__ == "__main__":
    sqrt(1919191919,20)
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from thread import start_new_thread

def square_thread():
	print("calculate the square root of a")
	eps = 0.0000001
	old = 1
	new = 1

	while True:
		old,new = new,(new + a/new) / 2.0
		print old,new
		if abs(new - old) < eps:
			break:
	return new

start_new_thread(square_thread,(99,))
start_new_thread(square_thread,(999,))
start_new_thread(square_thread,(16,))
start_new_thread(square_thread,(81,))

c = raw_input("Type something to quit")

import sys
import os
import math

def my_range(n):
    i = 1.0
    while i <= n:
	yield i
	i = i + 1.0

def square_root(a, x):
    while True:
        y = (x + a/x) / 2
        if y == x:
            break
        x = y
    return x

def test_square_root(x):
    for i in my_range(x):
	a = square_root(i, i+1)
	b = math.sqrt(i)
	print i, '\t',
        print a, '\t',
	print b, '\t',
	print abs(b - a)

if __name__ == '__main__':
    prompt = "Enter the limit : "
    value = float(raw_input(prompt))
    test_square_root(value)


"""
Log metrics to a [Cube](http://square.github.com/cube/) server.

"""
import os
from cloudly.metric import event

LOG_METRICS = os.environ.get("LOG_METRICS", False)


def evt(evt_type, data=None, request=None):
    if not LOG_METRICS:
        return

    if request:
        if not data:
            data = {}
        data['path'] = request.path
        data['root'] = request.url_root
        data['method'] = request.method
    event(evt_type, data)

#!/usr/bin/python

#============================================================================
# Project Euler: http://wwww.projecteuler.net
# Problem 10:
# Find the sum of all the primes below two million
#     - modification of euler7
#============================================================================

#import libraries/modules
import sys
from math import sqrt, floor
import time

#constants
LIMIT = 2000000

#find square root of passed number
def squareRoot(x):
     root = int(floor(sqrt(x)))
     #make the root number odd
     if root % 2 == 0:
          root +=1
     return root

#checks to see if number is prime
def checkPrime(x):
     prime = True   #flag
     
     #basic simple check to see if number passed is even, if it is then it's not a prime number
     if x % 2 == 0: 
          return False
     
     checkedNumber = squareRoot(x)
     for i in range(3,checkedNumber+2,2):
          if x % i == 0:
               prime = False
               break
     return prime

count = 0
sum = 2
count = 3
t0 = time.clock()
#main 
while count < LIMIT:
     if checkPrime(count):
          print count
          sum += count
     count += 2
t1 = time.clock() - t0

#total time is:  13.1200178791
print "sum of primes below", LIMIT, "is", sum
print "total time is: ", t1
from thumbnailer import _resizer
from unittest import TestCase, main
import os.path as path
from PIL import Image

class ThumbnailerTests(TestCase):

    def path(self, filename):
        return path.join(self.img_path, filename)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")
        self.img = Image.open(self.path("sample_image.jpg"))

    def testSquare(self):
        r = _resizer('square', '100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((100, 100), output.size)

    def testExact(self):
        r = _resizer('exact', '250x100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 100), output.size)

    def testWidth(self):
        r = _resizer('aspect', '250x?', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 166), output.size)

    def testHeight(self):
        r = _resizer('aspect', '?x250', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((375, 250), output.size)

class ThumbnailerFilenameTest(TestCase):

    def path(self, *parts):
        return path.join(self.img_path, *parts)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")

    def testRoot(self):
        """Test a file that is in the root of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testRootWithSlash(self):
        r = _resizer('square', '100', self.img_path + '/')
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testSubdir(self):
        """Test a file that is in a sub-directory of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('subdir', 'sample_image.jpg'))
        self.assertEqual('subdir/sample_image_square.jpg', new_name)

if __name__=="__main__":
    main()

import math
# Newton's method
# y = (x + a/x)/2 is always closer to sqr_root of a for any x
epsilon = 0.000000001
# required to calculate the difference between
# 2 floating values because they are unlikely to ever be  exactly the same

def square_root(a):
    global epsilon
    print "epsilon", epsilon
    x = a/2.0 # used 2.0 instead of 2 to make x a float
    y = (x + a/x)/2
    while True:
        if abs(y-x) <= epsilon:
            break
        x = y
        y = (x + a/x)/2
    return x

print square_root(963)
print math.sqrt(963)
print math.sqrt(2)
print square_root(2)

from mathutils.numbertheory import rabin_miller_is_prime as is_prime,\
    square_root, is_primitive_root


def fibonacci_primitive_root(p):
    """
    Returns a fibonacci primitive root if p has one and None otherwise.
    Assumes p is a prime and that p is congruent to 1 or -1 modulo 5.
    """
    # The fibonacci root is a root of the polynomial x^2-x-1.  The roots of
    # this polynomial are given by 1+sqrt(5) and 1-sqrt(5) So the basic idea is
    # to simply find the square root, and check to see if either of those
    # values are a primitive root.

    q = square_root(5, p)
    half = (p + 1) / 2

    q1 = half + half * q
    q2 = half - half * q

    q1 %= p
    q2 %= p

    if is_primitive_root(q1, p):
        return q1
    elif is_primitive_root(n - q1, p):
        return q2
    return None


def test_root(r, p):
    print "Testing p =", p, "root =", r
    subgroup = [(r ** k) % p for k in xrange(p - 1)]
    if len(set(subgroup)) != p - 1:
        print "Not a primitive root!"
        return

    print subgroup

    fib = [1, r]
    for __ in xrange(p - 3):
        fib.append((fib[-1] + fib[-2]) % p)

    print fib
    if len(set(fib)) != p - 1:
        print "Not a FIBONACCI primitive root!"
        return

    print "Good!"


# N = 10 ** 4  # for testing
# N = 10 ** 6  # for more testing
N = 10 ** 8  # for the actual question
s = 5L  # manually checked five. It has a fibonacci primitive root of 3.
l = []
for n in xrange(10, N, 5):
    for i in [-1, 1]:
        if is_prime(n + i, k=10):
            # print n + i
            root = fibonacci_primitive_root(n + i)
            if root:
                # test_root(root, n + i)
                # l.append(n + i)
                s += n + i
    # if n % 10000 == 0:
    #    print '%0.2f%%' % (100.0 * float(n)/float(N))

print "---"
# print '\n'.join(str(s) for s in l)
# print len(l)
print s

exit()

for p in [11, 19, 29, 31]:
    print "p = " + str(p)
    q = square_root(5, 11)
    print "square root of 5 is " + str(q)
    print 1 + q, is_primitive_root(1 + q, p)
    print p + 1 - q, is_primitive_root(p + 1 - q, p)
    print is_primitive_root(p + 1 - q, p)
    print '----'

import math
# Newton's method
# y = (x + a/x)/2 is always closer to sqr_root of a for any x
epsilon = 0.000000001
# required to calculate the difference between
# 2 floating values because they are unlikely to ever be  exactly the same

def square_root(a):
    global epsilon
    print "epsilon", epsilon
    x = a/2.0 # used 2.0 instead of 2 to make x a float
    y = (x + a/x)/2
    while True:
        if abs(y-x) <= epsilon:
            break
        x = y
        y = (x + a/x)/2
    return x

print square_root(963)
print math.sqrt(963)
print math.sqrt(2)
print square_root(2)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

__author__ = 'TeaEra'


def square_root(x):
    """
    Binary method;
    """
    if x == 0:
        return 0
    min_num = 1.0
    max_num = x
    half_num = 1.0
    while True:
        half_num = (min_num + max_num) / 2.0
        if half_num ** 2 == x or abs(half_num ** 2 - x) < 1e-5:
            return half_num
        elif half_num ** 2 < x:
            min_num = half_num
            max_num = max_num
        elif half_num ** 2 > x:
            min_num = 1.0
            max_num = half_num


def square_root_2(x):
    """
    Status: accepted;

    Newton-Raphson method
    """
    if x == 0:
        return 0
    k = 1.0
    while abs(k*k - x) > 1e-4:
        k = (k + x/k)/2.0
    return int(k)

if __name__ == "__main__":
    #
    print("---")
    print(square_root(9))
    #
    print("---")
    print(square_root(10))
    #
    print("---")
    print(square_root_2(9))
    #
    print("---")
    print(square_root_2(10))
#########################################################
## Newton's Square Root Approximation
## Bugs to vladimir dot kulyukin at gmail dot com
#########################################################

import math

## global variable that defines error tolerance level
error_tolerance = 0.0001;

def square(x): return x * x

def average(x, y): return (x + y)/2.0

def is_good_enough(guess, n):
    global error_tolerance
    return abs(square(guess) - n) < error_tolerance

def improve_guess(guess, n):
    return average(guess, n/guess)

def sqrt_iter(guess, n):
    if is_good_enough(guess, n):
        return guess
    else:
        print 'improve_guess(', guess, ', ', n, ')=', improve_guess(guess, n)
        return sqrt_iter(improve_guess(guess, n), n)

def newton_sqrt(n):
    ''' Computers Newton's square root approximation of n. '''
    return sqrt_iter(1, n)

## An alternative implementation of Newton's square root approximation
## that uses inner functions and avoids global variables through
## default parameters
def newton_sqrt_inner(n, error_tolerance=0.0001):
    ''' Computes Newton's square root approximation of n. '''
    def is_good_enough_inner(guess):
        return abs(square(guess) - n) < error_tolerance

    def improve_guess_inner(guess, n):
        return average(guess, n/guess)

    def sqrt_iter_inner(guess):
        if is_good_enough_inner(guess):
            return guess
        else:
            print 'improve_guess_inner(', guess, ', ', n, ')=',\
                  improve_guess_inner(guess, n)
            return sqrt_iter_inner(improve_guess_inner(guess, n))

    return sqrt_iter_inner(1)

## Some tests
sqrt_of_2 = newton_sqrt(2)
sqrt_of_3 = newton_sqrt(3)
sqrt_of_4 = newton_sqrt(4)
print 'math.sqrt(2)=', math.sqrt(2), 'newton_sqrt(2)=', sqrt_of_2
print 'math.sqrt(3)=', math.sqrt(3), 'newton_sqrt(3)=', sqrt_of_3
print 'math.sqrt(4)=', math.sqrt(4), 'newton_sqrt(4)=', sqrt_of_4
print "\n";

inner_sqrt_of_2 = newton_sqrt_inner(2)
inner_sqrt_of_3 = newton_sqrt_inner(3)
inner_sqrt_of_4 = newton_sqrt_inner(4)
print 'math.sqrt(2)=', math.sqrt(2), 'newton_sqrt_inner(2)=', inner_sqrt_of_2
print 'math.sqrt(3)=', math.sqrt(3), 'newton_sqrt_inner(3)=', inner_sqrt_of_3
print 'math.sqrt(4)=', math.sqrt(4), 'newton_sqrt_inner(4)=', inner_sqrt_of_4
print "\n";






import math

def sieve_of_atkin(limit):
    primes = []

    sieve = [False] * limit

    square_root_of_limit = int(math.sqrt(limit))

    for x in range(1, square_root_of_limit + 1):
        for y in range(1, square_root_of_limit + 1):
            n = (4 * x * x) + (y * y)

            if n <= limit and (n % 12 == 1 or n % 12 == 5):
                sieve[n] = not sieve[n]

            n = (3 * x * x) + (y * y)

            if n <= limit and n % 12 == 7:
                sieve[n] = not sieve[n]

            n = (3 * x * x) - (y * y)

            if x > y and n <= limit and n % 12 == 11:
                sieve[n] = not sieve[n]

    sieve[2] = True

    sieve[3] = True

    primes.append(2)

    primes.append(3)

    n = 5

    while n <= square_root_of_limit:
        if sieve[n]:
            i = n * n

            while i < limit:
                sieve[i] = False

                i += n * n

            primes.append(n)

        n += 2

    while n < limit:
        if sieve[n]:
            primes.append(n)

        n += 2

    return primes

print(sum(sieve_of_atkin(2000000)))

#!/usr/bin/env python

"""Mathematical utilities"""

import math


#------------------------------------------------------------------------------
def isPrime(num):
    """Check if num is prime"""
    for idx in range(2, int(math.sqrt(num))):
        if not num % idx:
            return False
    return True


#------------------------------------------------------------------------------
def binomialCoeff(elements, combinations):
    """
    Calculate binomial coefficient for the given number of
    elements and combinations
    """
    fact = math.factorial
    return fact(elements) / fact(combinations) * fact(elements - combinations)


#------------------------------------------------------------------------------
def average(seq):
    """Calculate the average value of a sequence of values"""
    return sum(seq) / len(seq)


#------------------------------------------------------------------------------
def sqrt(num) -> float:
    """Calculate the square root of the given number"""
    # root = num / 2  # make a guess TODO improve first guess
    root = num / 2 if num > 0 else 1
    while abs((num / root) - root) > 0.000000001:
        root = average((root, num / root))
    return root

#------------------------------------------------------------------------------
# test
if __name__ == '__main__':
    print(0.1*0.1)
    print(sqrt(0.001))

def sqrt(x):
    """ Compute square roots using method of Heron of Alexndria.

    Args:
        x: The number of which the square root is to be computed.

    Returns: The square root fo x.

    Raises:
        ValueError: if x is negative
    """
    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


import sys


def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
    except ValueError as e:
        print(e, file=sys.stderr)

if __name__ == '__main__':
    main()
import genutil


def compute(dm, do):
    """ Computes rms """
    if dm is None and do is None:  # just want the doc
        return {
            "Name": "Spatio-Temporal Root Mean Square",
            "Abstract": "Compute Spatial and Temporal Root Mean Square",
            "URI": "http://uvcdat.llnl.gov/documentation/" +
            "utilities/utilities-2.html",
            "Contact": "Peter Gleckler <gleckler1@llnl.gov>",
        }
    return float(
        genutil.statistics.rms(dm, do, axis='xyt', weights='weighted'))

import decimal, mpmath
from mpmath import mp
from fractions import Fraction
from timeit import timeit
from operator import itemgetter
from math import sqrt, ceil, floor
from itertools import count, product, takewhile
from functools import reduce
from pdb import set_trace
from collections import namedtuple
from eulerUtils import (
    getSimpleFractOfContinuedFract, getContinuedFract)


EULER66_NUM_OF_X_SQUARE_MINUS_1S = 10000000
EULER66_MAX_Y_SQUARE_WHICH_IS_EASY_TO_FIND = 10000000
EULER66_STOP_D = 1001
ONES_DIGITS_SQUARES_CANT_HAVE = {2, 3, 7, 8}
EVEN_DIGITS = {0, 2, 4, 6 ,8}
ODD_DIGITS = {1, 3, 5, 7, 9}
ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE = {  0: {0},
                                                1: EVEN_DIGITS,
                                                4: EVEN_DIGITS,
                                                5: {2},
                                                6: ODD_DIGITS,
                                                9: EVEN_DIGITS}
DIGITS_SQUARES_CAN_END_WITH = { '00',
                                '01', '21', '41', '61', '81',
                                '04', '24', '44', '64', '84',
                                '25',
                                '16', '36', '56', '76', '96',
                                '09', '29', '49', '69', '89'}

DIGIT_TO_COMPLEMENT_TO_TEN_MUL_DICT = { 0: 10,
                                        1: 10,
                                        2: 5,
                                        3: 10,
                                        4: 5,
                                        5: 2,
                                        6: 5,
                                        7: 10,
                                        8: 5,
                                        9: 10 }
EULER66_NEEDED_PRECISION_IN_DIGITS = 100
EULER66_NEEDED_PRECISION_IN_BITS = 150
EULER66_D_ROOT_MUL_Y_MIN_FIRST_DIGIT_AFTER_DEC_POINT = 9
EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT = 0.9999

BASE_ONES_DIGIT_TO_SQUARE_ONES_DIGIT_DICT = {   0: 0,
                                                1: 1,
                                                2: 4,
                                                3: 9,
                                                4: 6,
                                                5: 5,
                                                6: 6,
                                                7: 9,
                                                8: 4,
                                                9: 1    }

ONES_DIGITS_SQUARES_CAN_END_WITH = BASE_ONES_DIGIT_TO_SQUARE_ONES_DIGIT_DICT.values()

EULER66_MAX_FRACT_TO_REFER_TO_AS_ZERO = 0.000000001
EULER66_MIN_FRACT_TO_REFER_TO_AS_ONE = 0.999999999


def euler66(stopD=EULER66_STOP_D):
    # a set of squares doesn't help here.. too many squares 
    # (e.g. a set of 20m squares is ~1.5GB of my precious RAM).
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    potentDsList = [d for d in range(stopD) if not sqrt(d).is_integer()]

    potentialDToMinYSquareDict = {potentD: getMinXForDByContinuedFract(
        potentD) for potentD in potentDsList}
    return max(potentialDToMinYSquareDict.items(), key=itemgetter(1))


def getMinXForDByContinuedFract(d):
    dRootContinuedFract = getContinuedFract(
        decimal.Decimal(d).sqrt(), 
        EULER66_MAX_FRACT_TO_REFER_TO_AS_ZERO,
        EULER66_MIN_FRACT_TO_REFER_TO_AS_ONE)
    for numOfRepeatsOfPeriodicTerms in count(1):
        potentXDivPotentYAsSimpleFract = getSimpleFractOfContinuedFract(
            dRootContinuedFract.intPart,
            (dRootContinuedFract.periodicTermsList * (
                numOfRepeatsOfPeriodicTerms))[:-1])
        potentX, potentY = (potentXDivPotentYAsSimpleFract.numerator, 
                            potentXDivPotentYAsSimpleFract.denominator)
        if 1 == (potentX ** 2 - d * potentY ** 2):
            print('d: {0}, x: {1}, y: {2}'.format(d, potentX, potentY))
            return potentX
    #print(getSimpleFractOfContinuedFract(6, [1]))
    #print(getSimpleFractOfContinuedFract(7, [3, 1, 1, 3]))
    #print(getSimpleFractOfContinuedFract(7, [3, 1, 1, 3, 14, 3, 1, 1, 3]))





def getPotentialSolutionsToEuler66(stopD=EULER66_STOP_D):
    dList = [d for d in range(stopD) if not safeHasSquareRoot(d)]
    return filter(lambda d: getMinYSquareForD2(
        d, EULER66_MAX_Y_SQUARE_WHICH_IS_EASY_TO_FIND) is None, dList)


def getHardMinXForD(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    print(1 / dRoot)
    
    potentY = decimal.Decimal(1)
    while True:
        '''
        print((1 / zeroLeftToDecPoint(dRoot * potentY)).to_integral(
            rounding=decimal.ROUND_FLOOR))
        '''
        potentY *= floor(1 / zeroLeftToDecPoint(dRoot * potentY))
        potentX = (potentY ** 2 * d + 1).sqrt()
        if potentX == floor(potentX):
            print(d, potentX)
            return potentX
        print('potentY: {0}, potentY * dRootint: {1}, complexOne: {2}'.format(
            int(potentY), potentY * dRoot, int(floor(dRoot * potentY * 10) % 10)))
        potentY *= DIGIT_TO_COMPLEMENT_TO_TEN_MUL_DICT[floor(dRoot * potentY * 10) % 10]
        print('potentY: {0}, potentY * dRootint: {1}'.format(
            int(potentY), int(potentY * dRoot)))
        print()
        set_trace()

def getHardMinXForD2(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator(dRoot):
        '''
        print(dRootMulPotentY, dRootMulPotentY.adjusted() + 1)
        print(dRootMulPotentY, dRootMulPotentY.as_tuple().digits[
            dRootMulPotentY.adjusted() + 1])
        '''
        if EULER66_D_ROOT_MUL_Y_MIN_FIRST_DIGIT_AFTER_DEC_POINT <= (
                dRootMulPotentY.as_tuple().digits[dRootMulPotentY.adjusted() + 1]):
            potentX = (d * potentY ** 2 + 1).sqrt()
            #print(potentX)
            if potentX == floor(potentX):
                print(d, potentX)
                return potentX


def multiplesGenerator(base):
    currProduct = decimal.Decimal(base)
    for currMulVal in count(1):
        yield (decimal.Decimal(currMulVal), currProduct)
        currProduct += base


def getHardMinYForD3(d):
    '''
    failed at 61 when used 120 bits for precision (succeeded at 53, 46)
    '''
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator2(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if mpmath.isint((d * potentY ** 2 + 1).sqrt()):
                print(d, potentY)
                print()
                return potentY


def multiplesGenerator2(base):
    currProduct = mp.mpf(base)
    for currMulVal in count(1):
        yield (mp.mpf(currMulVal), currProduct)
        currProduct += base


def getHardMinYForD4(d):
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator3(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if ((int(dRootMulPotentY) + 1) ** 2) == (d * potentY ** 2 + 1):
                print(d, potentY)
                print()
                return potentY


def multiplesGenerator3(base):
    currProduct = mp.mpf(base)
    for currMulVal in count(1):
        yield (currMulVal, currProduct)
        currProduct += base


def powersGenerator(base=10, startExponent=0):
    currPower = base ** startExponent
    while True:
        yield currPower
        currPower *= base


def zeroLeftToDecPoint(num):
    return num - floor(num)


def getMinYForD(d):
    for y in count(1):
        if safeHasSquareRoot3(d * y ** 2 + 1):
            print(d, y)
            return y


def getMinYSquareForD2(d, stopYSquare=1000000000000000000000000):
    for ySquare in takewhile(lambda ySquare: ySquare < stopYSquare, 
                            squaresGenerator()):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD5(d): # almost identical to getMinYSquareForD2
    # best so far. even better than getHardMinYForD4.
    for ySquare in squaresGenerator():
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD6(d):
    for ySquare in euler66PotentialYSquaresGenerator(d):
        if safeHasSquareRoot6(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD7(d):
    # maybe slightly better than getHardMinYSquareForD5, but not as beautiful.
    ySquare = 1
    for diffToNextSquare in count(3, 2):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare
        ySquare += diffToNextSquare


def getHardMinYSquareForD8(d): 
    for ySquare in squaresGenerator():
        if isMaybeAPerfectSquare2(d * (ySquare % 100) + 1) and (
                safeHasSquareRoot(d * ySquare + 1)):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def isMaybeAPerfectSquare(num):
    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[
                numOnesDigit]
    return False


def isMaybeAPerfectSquare2(num):
    return ((num % 10) not in ONES_DIGITS_SQUARES_CANT_HAVE) and (
        (num // 10 % 10) in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[
                (num % 10)])


def getMinYForD3(d, stopY=None):
    if stopY is None:
        ysToTry = count(1)
    else:
        ysToTry = range(1, stopY)
    dRoot = d ** 0.5
    for y in ysToTry:
        # is dRoot * y safe??? what if the float is too big???
        if (ceil(dRoot * y) ** 2) == (d * y ** 2 + 1):
            print(d, ceil(dRoot * y))
            return y


def safeHasSquareRoot2(num):
    # really slow.
    lowMaybeRoot = 0
    highMaybeRoot = num
    while lowMaybeRoot <= highMaybeRoot:
        midMaybeRoot = (lowMaybeRoot + highMaybeRoot) // 2
        midMaybeRootSquare = midMaybeRoot ** 2
        if midMaybeRootSquare == num:
            return True
        elif midMaybeRootSquare < num:
            lowMaybeRoot = midMaybeRoot + 1
        else:
            highMaybeRoot = midMaybeRoot - 1

    return False


def safeHasSquareRoot3(num):
    # best so far.
    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[
                numOnesDigit]) and safeHasSquareRoot(num)
    return False


def safeHasSquareRoot6(num): 
    '''
    assuming the square was received from euler66PotentialYSquaresGenerator
    '''
    return ((num // 10 % 10) in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[
        num % 10]) and safeHasSquareRoot(num)


def safeHasSquareRoot4(num):
    if num > 1000000:
        numOnesDigit = num % 10
        if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
            numTensDigit = num // 10 % 10
            return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[
                    numOnesDigit]) and safeHasSquareRoot(num)
        return False
    else:
        return safeHasSquareRoot(num)


def safeHasSquareRoot5(num):
    # not so good
    numAsStr = str(num)
    return (numAsStr[-2:] in DIGITS_SQUARES_CAN_END_WITH) and safeHasSquareRoot(num)


def safeHasSquareRoot(num):
    return mpmath.isint(mpmath.sqrt(num))


def euler66PotentialYSquaresGenerator(d):
    for ySquare in squaresGenerator():
        if ((d * (ySquare % 10) + 1) % 10) in ONES_DIGITS_SQUARES_CAN_END_WITH:
            yield ySquare


def squaresGenerator():
    currSquare = 1
    for diffToNextSquare in count(3, 2):
        yield currSquare
        currSquare += diffToNextSquare


def squaresGeneratorEx(startBase=1, stopBase=10000000):
    startDiff = startBase * 2 + 1
    stopDiff = stopBase * 2 - 1
    currSquare = startBase ** 2
    for diffToNextSquare in range(startDiff, stopDiff, 2):
        yield currSquare
        currSquare = currSquare + diffToNextSquare


def checkSafeHasSquareRoot():
    list(map(safeHasSquareRoot, range(0, 100000000, 13)))






if __name__ == '__main__':
    print(euler66())
    #timeFunc('getHardMinYForD8', '996')

import rpyc

rpyc.core.protocol.DEFAULT_CONFIG['allow_pickle'] = True

def square(x):
    return x*x

c = rpyc.connect("localhost", port = 18861, config = rpyc.core.protocol.DEFAULT_CONFIG)

for i in range(0, 1):
    result = c.root.exposed_RemotePool(square, [0,1,2,3])
    print(result)
###
### Unit 3 Code
###

### This is all ridiculously inefficient code for clarity, not for any
### practical purpose!

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def totient(n):
    """Brute force computation of Euler's totient (not for large n)."""
    return [i for i in range(n) if gcd(i, n) == 1]

def is_primitive_root(g, q):
    reached = []
    x = g
    while True:
        if x in reached:
            break
        reached.append(x)
        x = (x * g) % q
    return len(reached) == q - 1

global count
count = 0

def mult(a, b):
    global count

    if a > 2 and b > 2:
        count = count + 1    
    return a * b

def square(x): return mult(x, x)

def counted_mod_exp(a, b, q):
    global count
    count = 0
    res = mod_exp(a, b, q)
    return (res, count)

def mod_exp(a, b, q):
    if b == 0:
        return 1
    if b % 2 == 0:
        return square(mod_exp(a, b / 2, q)) % q
    else:
        return (mult(a, mod_exp(a, b - 1, q))) % q
    
def generator_permutation(g, q):
    return [mod_exp(g, i, q) for i in range(1, q)]

    
def primitive_roots(q):
    """Brute force search for primitive roots of a prime q."""
    return [i for i in range(1, q) if is_primitive_root(i, q)]

#def toy_diffie_helman(q, alpha):
    

from PyQt5.QtQml import QQmlApplicationEngine

#
# TODO:
# - update example movie while changing rule
# - close button
# - integrate with main UI
# - load rule from preferences when loading UI
# - save rule in preferences when it changes
#

class RenamingRuleWindowView:
    def __init__(self):
        self.__engine = QQmlApplicationEngine()
        self.__engine.load("ui/renaming_rule_window.qml")

    def __get_root_window(self):
        return self.__engine.rootObjects()[0]

    def __get_property(self, property_name: str):
        return self.__get_root_window().property(property_name)

    def __set_property(self, property_name: str, property_value):
        return self.__get_root_window().setProperty(property_name, property_value)

    def add_rule(self, rule: str):
        self.__get_root_window().addRule(rule)

    def remove_rule(self, index: int):
        self.__get_root_window().removeRule(index)

    def remove_all_rules(self):
        self.__get_root_window().removeAllRules()

    def get_rule_changed_signal(self):
        return self.__get_root_window().ruleChanged

    def get_remove_rule_clicked_signal(self):
        return self.__get_root_window().removeRuleClicked

    def get_remove_all_rules_clicked_signal(self):
        return self.__get_root_window().removeAllRulesClicked

    def get_add_title_clicked_signal(self):
        return self.__get_root_window().addTitleClicked

    def get_add_original_title_clicked_signal(self):
        return self.__get_root_window().addOriginalTitleClicked

    def get_add_year_clicked_signal(self):
        return self.__get_root_window().addYearClicked

    def get_add_directors_clicked_signal(self):
        return self.__get_root_window().addDirectorsClicked

    def get_add_duration_clicked_signal(self):
        return self.__get_root_window().addDurationClicked

    def get_add_language_clicked_signal(self):
        return self.__get_root_window().addLanguageClicked

    def get_add_round_brackets_clicked_signal(self):
        return self.__get_root_window().addRoundBracketsClicked

    def get_add_square_brackets_clicked_signal(self):
        return self.__get_root_window().addSquareBracketsClicked

    def get_add_curly_brackets_clicked_signal(self):
        return self.__get_root_window().addCurlyBracketsClicked

    def get_close_clicked_signal(self):
        return self.__get_root_window().closeClicked

# Find square root of a number
# Apply the concept of a BST

def square_root(n, precision):
    low = 0.0
    high = n
    mid = (low+high)/2.0
    # precision is the +/- error allowed in our answer
    while (abs(mid*mid-n) > precision):
        if (mid*mid) < n:
            low = mid
        elif (mid*mid) > n:
            high = mid
        mid = (low+high)/2.0

    return mid
    
print square_root(1.0, 0.00001)
print square_root(3.0, 0.00001)
print square_root(4.0, 0.00001)
print square_root(49.0, 0.00001)

def sqrt(x):
    ans = 0
    if x >= 0:
        while ans*ans<x: ans = ans + 1
        if ans*ans != x:
            print x, 'is not a perfect square'
            return None
        else: return ans
    else :
        print x, 'is negative number'
        return None


def f(x):
    x = x + 1
    return x


def solve(numLegs, numHeads):
    for numChicks in range(0, numHeads + 1):
        numPigs = numHeads - numChicks
        totLegs = 4*numPigs + 2*numChicks
        if totLegs == numLegs:
            return [numPigs, numChicks]
    print 'Maybe there are some mutants. Dude.'
    return [None, None]

def barnYard():
    heads = int(raw_input('Enter number of heads: '))
    legs = int(raw_input('Enter number of legs: '))
    pigs, chickens = solve(legs, heads)
    if pigs == None:
        print 'There is no solution'
    else:
        print 'Number of pigs:', pigs
        print 'Number of chickens: ', chickens



def isPalindrome(s):
    if len(s) <= 1: return True
    else: return s[0] == s[-1] and isPalindrome(s[1:-1])

def isPalindromel(s, indent):
    print indent, 'isPalindromel called with', s
    if len(s) <= 1:
        print indent, 'About to return True frome this case'
        return True
    else:
        ans * s[0] == s[-1] and isPalindromel(s[1:-1], indent + indent)
        print indent, 'About to return', ans
        return ans


def fib(x):
    if x == 0 or x == 1: return 1
    else: return fib(x-1) + fib(x-2)



def testBi():
    print ' squareRootBi(4, 0.0001)'
    squareRootBi(4, 0.0001)
    print ' squareRootBi(9, 0.0001)'
    squareRootBi(9, 0.0001)
    print ' squareRootBi(2, 0.0001)'
    squareRootBi(2, 0.0001)
    print ' squareRootBi(0.25, 0.0001)'
    squareRootBi(0.25, 0.0001)


def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high)/2.0
    ctr = 1
    while abs(guess**2 - x) > epsilon and ctr <= 100:
        #print 'low:', low, 'high:', high, 'guess:', guess
        if guess**2 < x:
            low = guess

        else:
            high = guess
        guess = ( low + high )/2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:' , ctr, 'Estimate:', guess
    return guess
    
def squareRootNR(x, epsilon):
    """Assume x >= 0 and elsilon > 0
        Return y s.y. y*y is within epsilon of x"""
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    x = float(x)
    guess = x/2.0
    guess = 0.001
    diff = guess**2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:
        #print 'Error:', diff, 'guess:', guess
        guess = guess - diff/(2.0*guess)
        diff = guess**2 - x
        ctr += 1
        assert ctr <= 100, 'Iteration count exceeded'
        print 'NR method. Num.. iterations:', ctr, 'Estimated:', guess
        return guess


def compareMethods():
    print ' squareRoot(2, 0.01)'
    squareRootBi(2, 0.01)
    squareRootNR(2, 0.01)
    print ' squareRoot(2, 0.0001)'
    squareRootBi(2, 0.0001)
    squareRootBi(2, 0.0001)com
    

# -*- coding: utf-8 -*-
"""
Created on Thu Nov  1 14:40:51 2012

@author: esteban
"""
import numpy as np
from scipy.signal import lfilter

def trajVelocity(traj):
    "Compute trajectory velocities"
    data = np.array(traj.pointData)
    return data[1:,:] - data[:-1,:]

def trajEnergy(traj):
    "Compute trajectory energy by taking square of velocity vector length."
    vel = trajVelocity(traj)
    return np.sum(vel**2, 1)
    
def trajSpeed(traj):
    "Compute trajectory speed by taking square root of energy"
    e = trajEnergy(traj)
    return e**.5
    
def smooth(data, alpha):
    return  lfilter([alpha], [1.0, 1.0-alpha], data)
__author__ = 'wnduan'

"""
MIT OPEN COURSEWARE
Lecture 6: Bisection methods, Newton/Raphson, introduction to lists
"""

def squareRootBi(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using bisection method
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0.0
    high = max(x, 1.0)
    guess = (low + high)/2.0
    ctr = 0
    while abs(guess**2 - x) > epsilon and ctr < 100:
        if guess**2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high)/2.0
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'Bi method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess

def testBi():
    """
    test the function squareRootBi with different input
    :return: None
    """
    print 'squareRootBi(4, 0.0001)'.center(30,'*')
    squareRootBi(4, 0.0001)
    print 'squareRootBi(9, 0.0001)'.center(30,'*')
    squareRootBi(9, 0.0001)
    print 'squareRootBi(2, 0.0001)'.center(30,'*')
    squareRootBi(2, 0.0001)
    print 'squareRootBi(0.25, 0.0001)'.center(30,'*')
    squareRootBi(0.25, 0.0001)

#testBi()
def squareRootNR(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using Newton-Raphson method.
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    guess = float(x)/2.0
    # guess = 1
    ctr = 0
    while abs(guess**2 - x) > epsilon and ctr < 100:
        guess = guess - (guess**2 - x)/(2.0*guess)
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'NR method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess

squareRootNR(3,0.0001)
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# coding=utf-8
# AC Rate: 22.3%
# https://oj.leetcode.com/problems/sqrtx/

# Implement int sqrt(int x).
# Compute and return the square root of x.

class Solution:
    # @param x, an integer
    # @return an integer
    def sqrt(self, x):
        
"""
David Schonberger
Project Euler - problem 80
Square root digital expansion
"""

import datetime
import decimal
pr = 110
decimal.getcontext().prec = pr

def is_square(n):
    if(n == 1):
        return True
    else:
        i = 1
        while(i ** 2 < n):
            i += 1
        if(i**2 == n):
            return True
        else:
            return False

bef = datetime.datetime.now()
n = 100
upper = 100
digit_total = 0
sum_of_digital_sums = 0
for i in range(1,n + 1):
    if(not is_square(i)):
        num = str(decimal.Decimal(i).sqrt())
        d1 = int(num[0])
        r = num[2 : upper + 1]
        digit_total += sum([int(ch) for ch in r]) + d1
    
print "\n", digit_total
aft = datetime.datetime.now()

# -*- coding: utf-8 -*-
# Problem 80
# Square root digital expansion

# It is well known that if the square root of a natural number is not an integer,
# then it is irrational. The decimal expansion of such square roots is infinite
# without any repeating pattern at all.

# The square root of two is 1.41421356237309504880..., and the digital sum of the
# first one hundred decimal digits is 475.

# For the first one hundred natural numbers, find the total of the digital sums
# of the first one hundred decimal digits for all the irrational square roots.

from time import time
import decimal


def digit_sums(n):
    """
    take the square root of "n", get rid of ".", kep the first 100 digits,
    then return the sum of the 100 digits
    """
    decimal.getcontext().prec = 105     # seems that 100 is not precise enough

    square_root_str = str(decimal.Decimal(n).sqrt()).replace(".", "")[:100]
    return sum(map(int, square_root_str))
    
start_time = time()

perfect_squares = [i ** 2 for i in xrange(1, 11)]

sum_ = 0
for i in xrange(1, 101):
    if not i in perfect_squares:
        sum_ += digit_sums(i)

print "Answer:", sum_

print "Total Time: ", time() - start_time

# Completed on Sat, 29 Mar 2014, 23:16
# Solve by:  10044
# ---------------
# Answer: 40886
# Total Time:  0.0119998455048
# [Finished in 0.2s]

# -*- coding: utf-8 -*-
"""
Created on Mon Sep 21 10:38:13 2015

@author: MDeyell
"""


def sqrt(num):
    "Returns the square root of a number"
    Answer = num**0.5
    return float(Answer)

import math

'''square root of n will be represented as a tuple (x0,x1,...,x(p-1)), kp
where p is the precision, kp is the rest, i.e. 
n*(10**(p-1))*(10**(p-1)) - xox1...*xox1...
'''

def squareRoot(n,p):
	'''p- precision: the number of digits 
	usable only for n < 100
	return a string'''
	if p == 1: 
		t =  int(math.sqrt(n))
		# print t
		return (str(t),str(n - t*t))

	else:
		t = squareRoot(n,p-1)		
		x = int(t[0])
		k = int(t[1])
		xp = 100*k / (20*x)
		# print 'xp =',xp
		while (20*xp*x + xp*xp) > 100*k:
			xp = xp - 1 
		kp= 100*k - 20*xp*x-xp*xp
		# print t[0],t[1],xp,kp
		return (t[0]+str(xp), str(kp))
print squareRoot(2,10)
print math.sqrt(2)
print squareRoot(3,10)
print math.sqrt(3)
def sumDigits(n,p):
	''' the sum of first p digits of square root of n'''
	t = squareRoot(n,p)
	x= t[0]
	s = 0
	for i in range(0,len(x)):
		s+= int(x[i])
	return s
print sumDigits(2,100)	

def main()	:
	s= 0
	for n in range(2,100):
		t = int(math.sqrt(n))
		if n != t*t:
			print 'attack ', n
			s+= sumDigits(n,100)
	print 'answer',s		
main()	
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Reference: http://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/
"""

import os
import numpy as np
from math import sqrt
from decimal import Decimal


def euclid_dist(x, y):
    return sqrt(sum(
        [(x[n] - y[n]) ** 2 for n in range(len(x))]
    ))


def manhattan_dist(x, y):
    return sum(
        [abs(xx - yy) for xx, yy in zip(x, y)]
    )


def nth_root(value, n_root):
    root_value = 1/float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)


def minkowski_dist(x, y, p_value):
    return nth_root(sum(pow(abs(a-b), p_value) for a, b in zip(x, y)),
                    p_value)


def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)


def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)


def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)


def main():
    print euclid_dist([0, 3, 4, 5], [7, 6, 3, -1])
    print manhattan_dist([10, 20, 10], [10, 20, 20])
    print minkowski_dist([0, 3, 4, 5], [7, 6, 3, -1], 3)
    print cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15])
    print jaccard_similarity([0, 1, 2, 5, 6], [0, 2, 3, 5, 7, 9])


if __name__ == '__main__':
    main()

# scoping exercise Newton's square root

import math

def square(number):
  return number*number

def average(x,y):
  return (x+y)/2


def sqrt(number):
  def closeEnough(guess):
    return (math.fabs((square(guess))- number) < 0.001)
  def improve(guess):
    return average(guess, (number/guess))
  def sqrtHelper(guess):
    if closeEnough(guess):
      return guess
    else:
      return sqrtHelper(improve(guess))
  return sqrtHelper(1.0)



#!/usr/bin/python
# -*- coding: utf-8 -*-

"""Project Euler Solution 057

Copyright (c) 2011 by Robert Vella - robert.r.h.vella@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import cProfile

_roots = [
    (1, 1)
]

_square_numbers = {1}

def _nearest_whole_square_root(n):
    while _roots[-1][0] < n:
        next_root = _roots[-1][1] + 1
        square_number = next_root*next_root

        _square_numbers.add(square_number)

        _roots.append((square_number, next_root))

    for i in xrange(1, len(_roots)):
        if _roots[i][0] > n:
            return _roots[i - 1][1]

def _is_square_number(n):
    return n in _square_numbers

class _SquareRootFraction(object):
    """
        (sqrt(a) + b)/c
    """
    def __init__(self, a, b, c, nearest_whole_number):
        self.a = a
        self.nearest_whole_number = nearest_whole_number

        self.b = b
        self.c = c

    def reciprocal(self):
        new_c = (self.b*self.b - self.a) / -self.c
        new_b = -self.b

        whole_number = (self.nearest_whole_number + new_b) / new_c

        new_b -= whole_number * new_c

        return _SquareRootFraction(self.a, new_b, new_c, self.nearest_whole_number)

def get_period(n):
    if _is_square_number(n):
        return 0

    nearest_whole_number = _nearest_whole_square_root(n)

    current_reciprocal = _SquareRootFraction(n, -nearest_whole_number, 1, nearest_whole_number).reciprocal()
    period = 1

    while not (current_reciprocal.b == -nearest_whole_number and current_reciprocal.c == 1):
        current_reciprocal = current_reciprocal.reciprocal()
        period += 1

    return period

def get_number_of_odd_periods_up_to(n):
    return sum(1 for i in xrange(1, n + 1) if get_period(i) % 2 == 1)

def get_answer():
    return get_number_of_odd_periods_up_to(10000)

    
if __name__ == "__main__":
    cProfile.run("print(get_answer())")

<<<<<<< HEAD
#TEMP CODE





=======
"""
C
L
A
S
S
"""
class MiaClasse:
   
   Count = 0

   def __init__(root, item, price, vendor):
      root.item = item
      root.price = price
      root.vendor = vendor
      MiaClasse.Count += 1
   
   def CountResult(root):
     print MiaClasse.Count

   def PrintData(root):
      print "Item: ", root.item,  ", Price: ", root.price, ",Vendor:", root.vendor



#Create Data

D1 = MiaClasse("Apple", 10, "SuperMarket")
D2 = MiaClasse("Lemon", 5, "My Farm")
D3 = MiaClasse("PineApple", 50, "Market")

#Print Data
D1.PrintData()
D2.PrintData()
D3.PrintData()
print "Total:", MiaClasse.Count

"""
Def
F
U
N
C
T
I
O
N
"""
"""
Calling Function
"""
def PrintFunc( str ):
   print str;
   return;

#PrintFunc
PrintFunc("Yo! Function ");
PrintFunc("Print!!!!");

"""
Pass by Value
"""
#square Function Here!
def square(Val):
   SquareRel=Val*Val
   print "Got Value and Square equal=", SquareRel
   return SquareRel

# Throw Value to square Function
three=3
REL = square(three);
print "Values After Square = ", REL

"""
T
U
P
L
E
S
"""
T1=("Jan", "Feb", "Mar", "Apr", "May", "June", "Jul", "Aug", "Sep", "Oct" , "Nov", "Dec")
T2= ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
T=T1+T2
print T

#Index
print T1[6]
print T1[-2]
print T1[5:9]
print len(T2)

"""
py2exe
"""
from distutils.core import setup
import py2exe
#windows or console
setup(windows=["check_button.py"])

"""
OPEN EXTERNAL PROGRAM
"""
import os
os.startfile("""file directory""")


from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/env python

"""
This script is an implementation of Heron's Method (cs.utep.edu/vladik/2009/olg09-05a.pdf), one of the oldest ways of
calculating square roots by hand.
The script asks for maximum number of iterations to run, the square root to approximate, and the initial guess
for the square root. Each successive guess is closer to the square root until either the maximum number of iterations
is reached or the actual square root is found.
"""

__author__ = 'Carlos A. Gomez'


def ask_and_approx_roots():
    num_iterations = int(input("Please enter the number of iterations (an integer): "))
    square_root_to_approx = int(input("Please enter the square root to approximate (an integer): "))
    sq_root_guess = float(input("Please enter a guess for the square root: "))
    return heron_method(num_iterations, square_root_to_approx, sq_root_guess)


def heron_method(num_iterations, square_root_to_approx, sq_root_guess):
    sq_root_approximation = 1/2 * (sq_root_guess + square_root_to_approx/sq_root_guess)
    result_found = False
    run_counter = 0
    while not result_found:
        run_counter += 1
        last_guess = sq_root_approximation
        print("Guess number " + str(run_counter) + " is " + str(sq_root_approximation))
        sq_root_approximation = 1/2 * (sq_root_approximation + square_root_to_approx/sq_root_approximation)
        if abs(sq_root_approximation - last_guess) == 0 or run_counter == num_iterations:
                result_found = True
    print("The best guess for the square root, using " + str(run_counter) + " iterations, is "
          + str(sq_root_approximation))


if __name__ == '__main__':
    ask_and_approx_roots()

"""
Unit 1 - Lecture 1
Find a square root
author: Chris Lee
created: 10/14/2013
"""

def sqrt(number, guess = 1):
	if abs(number - guess*guess) < 5*pow(10,-(dec_accuracy + 1)):
		return guess
	else:
		return sqrt(number, guess = (float(number/guess) + guess)/2)

if __name__ == "__main__":
	dec_accuracy = 5
	square = 38
	print "The square root of %s is %s" % (square, sqrt(square))
	print "It is %f from the actual square-root" % (abs(pow(square,.5) - sqrt(square)))

from subtract_square_state import SubtractSquareState


s_distinct_nodes = set()
s_distinct_leaf = set()


class GameStateNode:
    '''
    A tree of possible states for a two-player, sequential move, zero-sum,
    perfect-information game.
    value: GameState -- the game state at the root of this tree
    children: list -- all possible game states that can be reached from this
        game state via one legal move in the game. children is None until grow
	is called.
    '''

    def __init__(self, game_state):
        ''' (GameStateNode, GameState) -> NoneType
        Initialize a new game state tree consisting of a single root node 
	that contains game_state.
        '''
        self.value = game_state
        self.children = []

    def __repr__(self):
    	# Get rid of before we hand in
        return 'GameStateNode({}, {})'.format(self.value, self.children)
    
    def __eq__(self, other):
        ''' (GameStateNode, object) -> bool
        Return whether this GameStateNode is equivalent to other, i.e., they
        contain equivalent GameStates, and equivalent children.  The order of
        their children does not matter.
        >>> s1 = SubtractSquareState('p1', current_total = 6)
        >>> s2 = SubtractSquareState('p2', current_total = 5)
        >>> s3 = SubtractSquareState('p1', current_total = 2)
        >>> leaf1 = GameStateNode(s1)
        >>> leaf2 = GameStateNode(s2)
        >>> leaf3 = GameStateNode(s3)
        >>> leaf1.__eq__(leaf2)
        False
        >>> root1 = GameStateNode(s1)
        >>> root1.children = [s2, s3]
        >>> root2 = GameStateNode(s1)
        >>> root1.__eq__(root2)
        False
        >>> root2.children = [s2, s3]
        >>> root1.__eq__(root2)
        True
        '''
        # Checking that the children lists have the same contents requires
        # checking that every element of one list is in the other, and vice
        # versa. Since checking "in" causes calls to the __eq__ method, we
        # end up recursing.
        return (type(self) == type(other) and
                self.value == other.value and        
                same_contents(self.children, other.children))

    def grow(self):
        ''' (GameStateNode) -> NoneType
        Grow the tree of all possible game state nodes that can be reached
	starting from this one.
        Assume that the game is finite (and so the tree will be finite).
        
        >>> a0 = SubtractSquareState('p1', current_total = 0)
        >>> b1 = SubtractSquareState('p2', current_total = 1)
        >>> a2 = SubtractSquareState('p1', current_total = 2)
        >>> b3 = SubtractSquareState('p2', current_total = 3)
        >>> a4 = SubtractSquareState('p1', current_total = 4)
        >>> b0 = SubtractSquareState('p2', current_total = 0)
        >>> a0_node = GameStateNode(a0)
        >>> b1_node = GameStateNode(b1)
        >>> b1_node.children = [a0_node]
        >>> a2_node = GameStateNode(a2)
        >>> a2_node.children = [b1_node]
        >>> b3_node = GameStateNode(b3)
        >>> b3_node.children = [a2_node]
        >>> b0_node = GameStateNode(b0)
        >>> a4_node = GameStateNode(a4)
        >>> a4_node.children = [b0_node, b3_node]
        >>> root = GameStateNode(SubtractSquareState('p1', current_total = 4))
        >>> root.grow()
        >>> root.__eq__(a4_node)
        True
        '''
        if self.value.possible_next_moves():
            self.children = [GameStateNode(self.value.apply_move(Move)) 
                             for Move in self.value.possible_next_moves()]
            for child in self.children:
                child.grow()


def same_contents(L1, L2):
    ''' (list, list) -> bool
    
    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.
    
    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and 
            all([x in L2 for x in L1]) and 
            all([x in L1 for x in L2]))


def node_count(root):
    ''' (GameStateNode) -> int
    
    Return the number of nodes in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    if root.value is None:
        return 0
    else:
        return 1 + sum([node_count(x) for x in root.children])


def leaf_count(root):
    '''(GameStateNode) -> int
    
    Return the number of leaves in the tree rooted at root.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    if root.children == []:
        return 1
    else:
        return sum([leaf_count(x) for x in root.children]) 


def distinct_node_count(root):
    '''(GameStateNode) -> int
    
    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    
    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1
    else:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1        
        for child in root.children:
            count += distinct_node_count(child)
    return count


def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int
    
    Return the number of leaves representing distinct game states in the
    tree rooted at root.
       
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_leaf:
            s_distinct_leaf.add(root.value.__str__())  
            count += 1
    else:
        for child in root.children:
            count += distinct_leaf_count(child)  
    return count

    
def branching_stats(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    # Look at children for base case.
    d = {0: 0}
    if not root.children:
        d[0] += 1 
    else:
        arity = len(root.children)
        if arity in d:
            d[arity] += 1
        else:
            d[arity] = 1        
        for child in root.children:
            merge_dict(d, branching_stats(child))
    return d


def merge_dict(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}
    
    Helper function
    
    Returns a merged dictionary from two dictionarys.
    '''
    d = d1
    for key in d2:
        if key in d:
            d[key] += d2[key]
        else:
            d[key] = d2[key]
    return d


def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]
    
    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    l = [0, 0, 0]
    if not root.children:
        if root.value.winner('p1'):
            l[0] += 1
        elif root.value.winner('p2'):
            l[1] += 1
        else:
            l[2] += 1
    else:
        for child in root.children:
            l = merge_list(l, outcome_counts(child))
    return l

        
def merge_list(l1, l2):
    ''' (list, list) -> list
    
    Helper function
    
    Returns a merged list from two lists
    Assumes that the lists have same lengths.
    ''' 
    l = l1
    for index in range(len(l2)):
        l[index] += l2[index]
    return l

        
def game_lengths(root):
    ''' (GameStateNode) -> {int: int}
    
    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    d = {}
    if not root.children:
        # Base length 0, count of 1 move to get there.
        d[0] = 1
    else:
        for child in root.children:
            # Recursion to merge game_lengths
            d = merge_dict2(d, game_lengths(child))
    return d

        
def merge_dict2(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}
    
    Helper function
    
    Returns a merged dictionary from two dictionarys, version 2.
    Adds d2 to d1, but with the keys in d2 incremented by 1.
    Assumes that the keys are Integers
    '''
    d = d1
    for key in d2:
        # Increments the key by 1 for each key, moves down 
        # (or up depending on visualization) a level.
        if (key + 1) in d:
            d[key + 1] += d2[key]
        else:
            d[key + 1] = d2[key]
    return d


def game_descriptions(root):
    ''' (GameStateNode) -> list of str
    
    Return a list containing a str describing each complete game that is
    possible from the game stored at root.
    
    Assume root is the root of a game state tree specifically for the game
    Subtract Square.
    
    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    # Not implemented...
    pass


def abbreviated(s):
    '''(GameState) -> str
    
    Return an abbreviated str representation of SubtractSquareState s.
    '''
    return "{}:{}".format(s.next_player, s.current_total)


if __name__ == '__main__':
    import doctest
    doctest.testmod()

    # Problem 80: Square root digital expansion

import time, math
t1 = time.clock()

def expand_root(square, precision):
    # Returns the sum of the first y decimal digits for x where y = precision.
    
    digits = []
    c = square
    p = 0
    x = 9
    y = 0
    while len(digits) < precision:
        while True:
            testnum = x*(20*p + x)
            if testnum > c:
                x -= 1
            else:
                y = testnum
                break
        digits.append(x)
        p = p*10 + x
        c = (c-y) * 100
        x = 9
        y = 0
    return sum(digits)

    # Now let's apply the function to each appropriate integer and sum
    # the results!

count = 0
precision = 100
for x in range(2,100):
    if x**.5 % 1 == 0:
        continue
    count += expand_root(x, precision)

print count
            
        
t2 = time.clock()

print "Execution time: ", str(t2-t1)[:5]

import pytest
import math
from pybelsberg import always


def test_sqrt(Point, almost):
    a = Point(0.0, 10.0)

    @always
    def constraint_square_root():
        #XXX Z3 returns -1 for a.x if not squared
        return math.sqrt(a.x ** 2) == 10

    assert almost(abs(a.x), 10)


def test_sum(Point):
    a = Point(0, 10)
    b = Point(20, 30)
    c = Point(40, 50)

    @always
    def constraint_sum_over_500():
        return sum([a.x, a.y, b.x, b.y, c.x, c.y]) > 500

    assert a.x + a.y + b.x + b.y + c.x + c.y > 500

import math
import time

t1 = time.time()

def square(lst):
    n = len(lst)
    temp = [0]*(n*2-1)
    for i in range(0,n):
        for j in range(0,n):
            temp[i+j] += lst[i]*lst[j]
    for i in range(0,len(temp)-1):
        if temp[-1-i] > 9:
            temp[-2-i] += temp[-1-i]//10
            temp[-1-i] = temp[-1-i]%10
    return temp

def bigger(num,lst):
    if lst[0] >= num:
        return False
    return True
    
def root(num):
    x = 100
    temp =[math.floor(math.sqrt(num))]
    while len(temp) < x:
        temp.append(1)
        while temp[-1] < 10 and bigger(num,square(temp)):
            temp[-1] += 1
        temp[-1] -= 1
    return temp

def isSquare(num):
    r = math.floor(math.sqrt(num))
    if r*r-num == 0:
        return True
    return False

total = 0
for i in range(2,100):
    if not isSquare(i):
        n = sum(root(i))
        total += n

print(total)

print("time:",time.time()-t1)
    

# Python Code for Square Root

num = int(input("Enter a positive number: "))

def newtonest(num):
    return num ** 0.5

def estimate(num):
    guess = num/3
    count = 0
    epsilon = 0.01
    sq_guess = ((num / guess) + guess)/2
    while abs(newtonest(num) - sq_guess) > epsilon:
        newguess = sq_guess
        sq_guess = ((num / newguess) + newguess)/2
        count +=1
    print("The square root of {} is {} with {} interations.".format(num,sq_guess,count))

estimate(num)

import sys

def sqrt(x):
    '''Computer square roots using the method of Heron of Alexandria.
    
    Args:
        x: The number for which the square root is to be computed.
        
    Returns:
        The square root of x
        
    Raises:
        ValueError: if x is negative
    '''
    if x < 0:
        raise ValueError('Cannot compute square root of negative number. {}'.format(x))
    
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    
    return guess
    
def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
    except ValueError as e:
        print(e,file=sys.stderr)
    
if __name__ == '__main__':
    main()
'''Program to do basic vector calculations in 3 dimensions: addition, dot product and normalization.
23 April 2014
Luke Barker'''

vectorA =input('Enter vector A: \n').split(' ')
vectorB =input('Enter vector B: \n').split(' ')

def addvectors(a,b):
    iteration = 0    #create variable called iteration
    new_list = []    #create list
    for i in a:
        add = eval(i)+eval(b[iteration])   #adding vector a to b
        new_list.append(add)
        iteration += 1
    return new_list
        
print('A+B =', addvectors(vectorA,vectorB))
       
def productvectors(a,b):
    iteration = 0    #create variable called iteration
    product = 0    #create variable product
    for i in a:
        multiply = eval(i)*eval(b[iteration])   #times vector a to b
        product += multiply
        iteration += 1
    return product

print('A.B =', productvectors(vectorA,vectorB))

def normA(a):
    sum_squares = 0    #create variable for the sum of the squared numbers
    for i in a:
        squares = eval(i)**2   #square number
        sum_squares += squares      
    x = sum_squares**0.5     #square root sum of the squares
    
    return x

print('|A| =', "{0:4.2f}".format(normA(vectorA)))

def normB(b):
    sum_squares = 0    #create variable for the sum of the squared numbers
    for i in b:
        squares = eval(i)**2   #square number
        sum_squares += squares      
    x = sum_squares**0.5   #square root sum of the squares
    
    return x

print('|B| =', "{0:4.2f}".format(normA(vectorB)))


#!/usr/bin/env python

from math import*
from decimal import Decimal

def euclidean_distance(x,y):
	
	return sqrt(sum(pow(a-b,2) for a, b in zip(x, y)))

def manhattan_distance(x,y):

	return sum(abs(a-b) for a,b in zip(x,y))


def minkowski_distance(x,y,p_value):
	return nth_root(sum(pow(abs(a-b),p_value) for a,b in zip(x, y)),p_value)

def nth_root(value, n_root):
    
    root_value  = 1/float(n_root)
    return round (Decimal(value) ** Decimal(root_value),3)

def cosine_similarity(x,y):

	numerator = sum(a*b for a,b in zip(x,y))
	denominator = square_rooted(x)*square_rooted(y)
	return round(numerator/float(denominator),3)

def square_rooted(x):

	return round(sqrt(sum([a*a for a in x])),3)


def jaccard_similarity(x,y):

	intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
	union_cardinality = len(set.union(*[set(x), set(y)]))
	return intersection_cardinality/float(union_cardinality)

#print cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15])
print euclidean_distance([0,3,4,5],[7,6,3,-1])
#print manhattan_distance([10,20,10],[10,20,20])
#print minkowski_distance([0,3,4,5],[7,6,3,-1],3)
#print jaccard_similarity([0,1,2,5,6],[0,2,3,5,7,9])





##print " this program computes square root of a number using"
##print "newton-rhapson method"
##
##number=float(input("Enter the number whose square root is desired "))
##
##guess_estimate = float(number/2.0)
##
##while (guess_estimate*guess_estimate != number):
##
##    quotient = (number / guess_estimate)
##    new_guess = (quotient+guess_estimate)/2
##    if guess_estimate ==new_guess:
##        print "the square root is", guess_estimate
##        break
##    else:
##        guess_estimate = new_guess
        
import math

def average(a,b):
    return (a+b)/2.0

def improve (guess,x):
    return average(guess, x/guess)

def good_enough(guess,x):
    d = abs(guess*guess-x)
    return (d < 0.000001)

def square_root(x):
    guess = 1
    while (not good_enough(guess,x)):
        guess = improve(guess,x)
    return guess

 



"""problem_080.py

Problem 80: Square root digital expansion

It is well known that if the square root of a natural number is not an integer,
then it is irrational. The decimal expansion of such square roots is infinite
without any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and the digital sum of the
first one hundred decimal digits is 475.

For the first NUM_COUNT natural numbers, find the total of the digital sums of
the first DIGIT_COUNT decimal digits for all the irrational square roots.

Author: Curtis Belmonte
"""

import common as com

# PARAMETERS ##################################################################

NUM_COUNT = 100 # default: 100
DIGIT_COUNT = 100 # default: 100

# SOLUTION ####################################################################

def solve():
    total = 0
    for n in range(2, NUM_COUNT + 1):
        if com.is_square(n):
            continue

        root = com.sqrt_expansion(n, DIGIT_COUNT)
        root = root.replace('.', '')
        total += sum([int(digit) for digit in root[:DIGIT_COUNT]])

    return total


if __name__ == '__main__':
    print(solve())

# -*- coding: utf-8 -*-

import math

def root_mean_square(x): # x is a list of values.
  """ Returns the root mean square (rms) given a list of values. """
  return math.sqrt(sum([i*i for i in x])/len(x))
  
def main(means):
  print "Input:", means
  means = map(float,means)
  print "root mean square = ", root_mean_square(means)

if __name__ == '__main__':
  import sys
  if len(sys.argv) < 2:
    sys.stderr.write('Usage: python %s mean1 mean2 mean3 ... \n' % sys.argv[0])
    sys.exit(1)
  main(sys.argv[1:])
import math
import gmpy

def get_period(root):
    history = []
    current_pair = Fraction(root, 0, 0, 1).disjoin_invert()
    history.append(current_pair)
    while True:
        # print current_pair
        current_pair = current_pair[1].rationalize().disjoin_invert()
        if current_pair in history:
            return len(history) - history.index(current_pair)
        history.append(current_pair)

def count_odd_periods(max_root):
    count = 0
    for root in xrange(2, max_root + 1):
        if gmpy.is_square(root):
            continue
        period = get_period(root)
        if period % 2 == 1:
            count += 1
    return count

class Fraction(object):
    def __init__(self, num_root, num_int, denom_root, denom_int):
        self.num_root = num_root
        self.num_int = num_int
        self.denom_root = denom_root
        self.denom_int = denom_int
    def rationalize(self):
        assert(self.denom_root != 0)
        assert(self.num_root == 0)
        new_denom_root = 0
        new_denom_int = (self.denom_root - self.denom_int ** 2) / self.num_int
        new_num_root = self.denom_root
        new_num_int = -self.denom_int
        return Fraction(new_num_root, new_num_int, new_denom_root, new_denom_int)
    def disjoin(self):
        assert(self.denom_root == 0)
        assert(self.num_root != 0)
        int_part = int((math.sqrt(self.num_root) + self.num_int) / self.denom_int)
        frac_part = Fraction(self.num_root, self.num_int - int_part * self.denom_int, 0, self.denom_int)
        return (int_part, frac_part)
    def invert(self):
        return Fraction(self.denom_root, self.denom_int, self.num_root, self.num_int)
    def disjoin_invert(self):
        int_part, frac_part = self.disjoin()
        return (int_part, frac_part.invert())
    def __eq__(self, other):
        return (
            self.num_root == other.num_root
            and self.num_int == other.num_int
            and self.denom_root == other.denom_root
            and self.denom_int == other.denom_int)
    def __str__(self):
        return "(%d, %d, %d, %d)" % (self.num_root, self.num_int, self.denom_root, self.denom_int)
    def __repr__(self):
        return str(self)

if __name__ == '__main__':
    print count_odd_periods(13)
    print count_odd_periods(10000)

from Scientific.BSP import ParSequence, ParFunction, ParRootFunction
import Numeric; N = Numeric
import operator

# The local computation function.
def square(numbers):
    return numbers**2

# The global computation function.
global_square = ParFunction(square)

# The local output function
def output(result):
    print result

# The global output function - active on processor 0 only.
global_output = ParRootFunction(output)

# A list of numbers distributed over the processors.
items = ParSequence(N.arange(100))

# Computation.
results = global_square(items)

# Collect results on processor 0.
all_results = results.reduce(lambda a, b: N.concatenate((a, b)), N.zeros((0,)))

# Output from processor 0.
global_output(all_results)

#square root algorithm
#http://www.homeschoolmath.net/teaching/square-root-algorithm.php
#http://en.wikipedia.org/wiki/Methods_of_computing_square_roots

from math import sqrt

def sqrt_digit(n): #long division method
    k = n  #remainder
    q = 0  #quotient
    while len(str(q)) < 100:  #check the digits of quotient
        if q == 0:
            temp = q
        else:
            temp = q * 2
        i = 1
        while (temp * 10 + i) * i <= k:
            i += 1
        i = i - 1
        t = (temp * 10 + i) * i  #divider
        q = q * 10 + i
        k = (k - t) * 100  #remainder
    return q

s = 0
for i in xrange(1, 101):
    if sqrt(i) != int(sqrt(i)): #make sure we only add the irrational numbers
        s += sum(map(int, str(sqrt_digit(i))))
    
print s
# Aram Rodrigo Curiel Graxiola
# A01229982
# WSQ13

def sqrt(n):
    a = n
    b = 0
    while(b != a):
        b = a
        a = (n/a + a)/2
    return a

print ("This program works giving the square root for each number")

ans = "Yes"
while (ans == "Yes"):
    num = float(input("Give me a number: "))
    if (num == 0):
        print("The square root is: 0")
    elif(num < 0):
        print("There is no square root for negative numbers!!")
    else:
            square = sqrt(num)
            print("The square root is: ",square)
    ans = str(input("Do you want to try again? (Yes/No): "))
    print("Thanks and have a nice day!")

#!/usr/bin/env python
# Random testing with assertion for pre and post conditions
import math
import random

def my_square_root(x):
    assert x >= 0
    y = math.sqrt(x)
    try:
        assert y * y == x
    except AssertionError, e:
        print x, y, y * y
        raise Exception
    return y

for i in xrange(1000):
    r = int(random.random() * 10000)
    z = my_square_root(r)

print "Done!"
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math

anumber = int(input("Enter an integer: "))
try:
	print(math.sqrt(anumber))
except:
	print("Bad value for square root")
	print("Using absolute value instead")
	print(math.sqrt(abs(anumber)))

anumber = int(input("Enter an integer: "))
if anumber < 0:
	raise RuntimeError("You can't use a negative number")
else:
	print(math.sqrt(anumber))

def cube(n):
	return n ** 3
print(cube(anumber))

def squaeroot(n):
	root = n/2
	for k in range(20):
		root = (1/2)*(root + (n / root))
	return root

print(squaeroot(anumber))

input("Press Enter")
#function that evaluates the following equation given A, C, and n
"""
(1 + sqrt(1 + C * n)) / A
"""
#returns True if result would be an integer
def has_int_root(n, V):
    A, C = V
    square = 1 + C * n
    sq_root = int(square ** 0.5 + 0.5)
    #in order for expression to be an integer, sq_root must be integer
    if sq_root ** 2 != square:
        return False
    num = 1 + sq_root
    #test if integer
    if int(num / A + 0.5) * A == num:
        return True
    return False




def triangle(n):
    '''return the nth triangle number'''
    return sum(range(1, n + 1))

def n_divisors(n):
    '''count unique divisors of n'''
    ret = 0
    # only need to go to the square root since factors come in pairs (except square root)
    for x in xrange(1, int(n**0.5)+1):
        if n % x == 0:
            if x**2 != n: # add 2 factors (for x and n/x)
                ret += 2
            else: # unless it's the square root, in case it only counts once
                ret += 1
    return ret

def search():
    # search semi-efficiently until we have enough triangle numbers
    top = 100
    while True:
        print top
        for x in range(top):
            t = triangle(x)
            if n_divisors(t) > 500:
                return t
        top *= 2

print search()




# coding=utf-8


def my_square_root(n, precision=None):
    if precision is None:
        precision = 5

    start = 0.01
    end = max(float(n), 1.0)
    max_e = 10.0 ** (-precision)
    while True:
        mid = start + (end - start) / 2.0
        e = n - (mid * mid)
        if abs(e) <= max_e:
            return mid
        elif e < 0:
            end = mid
        else:
            start = mid

import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)

def testable(x):
	r"""
	The `testable` function returns the square root of its
	parameter, or 3, whichever is larger.
	>>> testable(7)
	3.0
	>>> testable(16)
	4.0
	>>> testable(9)
	3.0
	>>> testable(10) == 10 ** 0.5
	True
	"""
	if x < 9:
		return 3.0
	return x ** 0.5


def sqrt(x):
    """
    give square root
    """
    if x >= 0:
        """
        if x is positive"""
        return x ** 0.5
    return (x + 0j) ** 0.5

def add(a, b):
    temp = a + b
    return temp

def f(x, y):
    return x ** 2 + x * y + y ** 2

res = f(2, 3) + sqrt(4)
print res



from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# -*- coding: utf-8 -*-
"""
Created on Wed Oct 29 15:48:18 2014

@author: Sifan
"""

def squareRootBi(x,epsilon):
    '''
    Assume x>=0 and epsilon > 0, 
    Return y s.t. y*y is within epsilon of x.
    '''
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    low = 0
    # high = x
    high = max(x, 1.0)        #  high=x  max(x,1.0)
    guess = (low + high)/2.0
    ctr = 1
    while abs(guess**2 - x) > epsilon and ctr <= 100:
        if guess**2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high)/2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bi Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess
    
def testBi():
    print '   squareRootBi(4, 0.0001)'
    squareRootBi(4,0.0001)
    print '   squareRootBi(9, 0.0001)'
    squareRootBi(9,0.0001)
    print '   squareRootBi(2, 0.0001)'
    squareRootBi(2,0.0001)
    print '   squareRootBi(0.25, 0.0001)'
    squareRootBi(0.25,0.0001)
    print '   squareRootBi(0.75, 0.0001)'
    squareRootBi(0.75,0.0001)

def squareRootNR(x,epsilon):
    '''
    Assume x >= 0 and epsilon > 0,
    Return y s.t. y**2 is within epsilon of x.
    '''
    assert x >=0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    x = float(x)
    guess = x / 2.0
    # guess = 0.01
    diff = guess**2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:
        # print 'guess=', guess, 'diff=', diff, 'ctr=', ctr
        guess = guess - diff/(2*guess)
        diff = guess**2 - x
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess

def test_compareMethods():
    print '   squareRoot(2, 0.01)'
    squareRootBi(2, 0.01)
    squareRootNR(2, 0.01)
    raw_input()
    print '   squareRoot(2, 0.0001)'
    squareRootBi(2, 0.0001)
    squareRootNR(2, 0.0001)
    raw_input()
    print '   squareRoot(2, 0.000001)'
    squareRootBi(2, 0.000001)
    squareRootNR(2, 0.000001)
    raw_input()
    print '   squareRoot(123456789, 0.0001)'
    squareRootBi(123456789, 0.0001)
    squareRootNR(123456789, 0.0001)
    raw_input()
    print '   squareRoot(123456789, 0.0000001)'
    squareRootBi(123456789, 0.0000001)
    squareRootNR(123456789, 0.0000001)
    raw_input()

def addthe2(x,y):
    return x + y

def printntimes(s,n):
    for i in range(n):
        print s

#printntimes(addthe2('Stefan', 'Duan'),5)

def right_justify(s):
    length = len(s)
    spaces = ' ' * (70 - length)
    print spaces + s
    
#right_justify("South China University")
#right_justify("of Technology")
#right_justify("Duan Weining")
#right_justify("2014.10.29")

def cal(f,x):
    return f(x,0.0001)
"""
Exercise 7.2. 

if abs(y-x) < epsilon:
    break

Encapsulate this loop in a function called square_root that takes a as a parameter, chooses a reasonable value of x, and returns an estimate of the square root of a.

"""
import math

def square_root(a):
    
    x = a / 3.0
    epsilon = 0.000000000001
    
    while abs(a - (x**2)) > epsilon:
        x = (x + a/x) / 2
    return x

print square_root(0)

# Question: What is square root of 6427?

import random as rand

class FindSquareRoot:

    def __init__(self,target,sensitivity):
        self.tg = target
        self.sy = sensitivity
    
    def setup(self):
        self.ulim = self.tg + (self.tg * self.sy)
        self.llim = self.tg - (self.tg * self.sy)
    
    def test_sqrt(self,val):
        if (val**2 <= self.ulim) and (val**2 >= self.llim):
            return True
        else:
            return False
    
    def get_next_value(self):
        # Guess the next root value
        # in this case, simply increment the current root
        if (self.rt**2 > self.tg):
            self.rt = self.rt - self.sy
        elif (self.rt**2 < self.tg):
            self.rt = self.rt + self.sy
    
    def random_increment(self):
        self.rt = self.rt + ((0.5-rand.random())*2)

    def run(self):
        # Want to count how many steps
        self.steps = 0
        while not self.test_sqrt(val=self.rt):
            self.steps = self.steps + 1
            #self.get_next_root()
            self.random_increment()

    def print_answer(self):
        print 'The answer is: ' + str(self.rt)
        print 'Which gives:   ' + str(self.rt**2)
        print 'and it took:   ' + str(self.steps) + ' steps'
    
    def run_model(self,seedRoot):
        self.rt = seedRoot
        print 'Seed Root is: ' + str(seedRoot)        

        self.setup()
        self.run()
        self.print_answer()

def main():
    m = FindSquareRoot(target=642.0,sensitivity=0.001)
    m.run_model(seedRoot=32.0)

main()






#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import math

def is_lucky(x):
    s = str(x)
    for c in s:
        if c != "4" and c != "7":
            return False
    return True

def is_almost_lucky(x):
    if is_lucky(x):
        return True
    square_root = int(math.sqrt(x)) + 1
    for i in range(1, square_root + 1):
        if x % i == 0 and (is_lucky(i) or is_lucky(x / i)):
            return True
    return False

n = int(sys.stdin.readline().strip())

if is_almost_lucky(n):
    print "YES"
else:
    print "NO"

import math
from fractions import gcd
 
def problem7(): return find_prime_by_index(10001)
 
def find_prime_by_index(i):
        return generate_fixed_amount_of_primes(i)[-1]
 
# we do not need to store intermediate primes, but this function can be a good auxiliary function for other euler problems
def generate_fixed_amount_of_primes(n):
        assert(n > 0)
        primes = [2, 3] # first primes
        current_number = primes[1]
        while (len(primes) < n):
                current_number += 2
                square_root = math.floor(math.sqrt(current_number))
                prime = True
                for p in primes:
                        if p > square_root: break
                        elif current_number % p == 0:
                                prime = False
                                break
 
                if prime: primes.append(current_number)
        return primes[:n]
# -*- coding: utf-8 -*-


class MathSymbol():
    '''
    Class that performs the verification
    of operation and operand types
    '''
    def __init__(self, text):
        self.text = text

    def is_digit(self):
        try:
            float(self.text)
            return True
        except ValueError:
            return False

    def is_simple_operation(self):
        if (self.text == '+' or self.text == '-' or
                self.text == u'' or self.text == u'' or
                self.text == u'^' or self.text == u'.'):
            return True
        return False

    def is_ce(self):
        if self.text == 'CE':
            return True
        return False

    def is_equal(self):
        if self.text == '=':
            return True
        return False

    def is_square_root(self):
        if self.text == u'':
            return True
        return False

    def is_sign(self):
        if self.text == '+/-':
            return True
        return False

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (connection.introspection.table_name_converter(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), connection.introspection.table_name_converter(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

#!/usr/local/bin/python

import sys

usage = """        Find square root of a give number

        Usage: findSquareRoot.py <number>
        Example: findSquareRoot.py 16"""

def main(argv):
    """
    Executes the main() flow
    @param argv: Command-line arguments
    @type argv: array of strings
    """
    if (len(argv) != 1):
        print usage
        sys.exit(2)
    num = float(argv[0])
    print 'Input number: ', num
    squareRoot = getSquareRoot(num)
    print 'Square root: ', squareRoot

def getSquareRoot(num):
    """
    Finds square root of a given number
    @param num: Number
    @type num: integer
    """
    isNegative = False
    if (num < 0):
        isNegative = True
        num = abs(num)

    # start with guess num / 2
    guess = num / 2

    # try to find square root within range
    while (abs(guess * guess - num) > 0.001):
        print guess
        guess = (guess + num / guess) / 2

    if (isNegative):
        return str(guess) + " i"

    return guess

if __name__ == "__main__":
    main(sys.argv[1:])
import pandas as pd
from bokeh.charts import Line, output_file, show


iterations = 0
difference = []
output_file("lines.html")


def square(x):
    return x * x


def average(x, y):
    return (x + y) / 2


def improve(guess, x):
    return average(guess, (x / guess))


def good_enough(guess, x):
    global difference
    difference.append(abs(square(guess) - x))
    return abs(square(guess) - x) < 0.001


def square_root_iter(guess, x):
    global iterations
    iterations += 1
    if good_enough(guess, x):
        return guess
    else:
        return square_root_iter(improve(guess, x), x)


def square_root(x):
    return square_root_iter(1.0, x)


square_root(100)
data = {"y": difference}
p = Line(data, title="Newton Square Root", xlabel="iterations", ylabel="difference", width=400, height=400)

grades = [100, 100, 90, 40, 80, 100, 85, 70, 90, 65, 90, 85, 50.5]

def print_grades(grades):
    for item in grades:
        print item
print print_grades(grades)

def grades_sum(grades):
    total = 0
    for item in grades: 
        total += item
    return total
print grades_sum(grades)
    
def grades_average(grades):
    sum_of_grades = grades_sum(grades)
    average = sum_of_grades / len(grades)
    return average
print grades_average(grades)

def grades_variance(grades, average):
    sum_of_square = 0
    for item in grades:
        square_of_difference = (average - item) ** 2
        sum_of_square += square_of_difference
        variance = sum_of_square / len(grades)
    return variance
print grades_variance(grades, grades_average(grades))

def grades_std_deviation(variance):
    std_deviation = variance ** 0.5 # taking square root of variance
    return std_deviation
print grades_std_deviation(grades_variance(grades, grades_average(grades)))
def square_root_convergents():
    num = 3
    den = 2
    result = 0
    for i in range(1, 1001):
        num += 2 * den
        den = num - den
        if len(str(num)) > len(str(den)):
            result += 1
    return result

# Enter your code here. Read input from STDIN. Print output to STDOUT
n = int(raw_input())
p = int(raw_input())

def squareRoot(n, p):
    a = 5 * n
    b = 5
    limit = 10 ** (p + 1)
    while b < limit:
        if (a >= b):
            a -= b
            b += 10
        else:
            a *= 100
            b = (b - 5) * 10 + 5
    return b / 100

def sumDigits(n):
   r = 0
   while n:
       r, n = r + n % 10, n / 10
   return r

def sqrtFloat(n, p):
    from decimal import *
    getcontext().prec = p
    return Decimal(n).sqrt()

def perfectRoot(x):
    import math
    sqrt = int(math.sqrt(x))
    return sqrt * sqrt == x

irrational = [ x for x in range(1, n + 1) if not perfectRoot(x) ]
digits = [ sum(sqrtFloat(m, p + 10).as_tuple()[1][:p]) for m in irrational ]
print(sum(digits))

#  File: CalcSqrt.py

#  Description: Calculate the square root of a number and display it

#  Student Name: Collin Murphy

#  Student UT EID: cbm772

#  Course Name: CS 303E

#  Unique Number: 52680

#  Date Created: 15 Oct 2012

#  Date Last Modified: 15 Oct 2012

def sqrt(n):
  '''function to determine the square root of a given numebr n'''

  #set initial values
  error = 1
  oldGuess = n / 2
  newGuess = 0

  #perform computation
  while (error > 1e-6):
    newGuess = ((n / oldGuess) + oldGuess) / 2
    error = abs(oldGuess - newGuess)
    oldGuess= newGuess

  #return result
  return newGuess

def main():
  '''main function to test square root function'''

  #get user input until it is valid
  n = -1
  while (n <= 0):
    n = eval(input("Enter a positive number: "))
    print()

  #calculate square root
  result = sqrt(n)

  #print result
  print("Square root is: %s" %format(result, '0.12g'), end = '\n\n')
  print("Difference is: %s" %format((result - n ** 0.5), '0.1f'))

main()

import numpy as np

# Calculate Root Mean Square Logarithmic Error for difference of target-values and the
# corresponding predictions
def rmsle(target, prediction):
    squared_diff = np.power(np.log1p(prediction) - np.log1p(target), 2)
    return np.sqrt(squared_diff.mean())
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def squareRootBi(x, epsilon):
    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"

    lowBound = 0
    highBound = max(1.0,x)
    guess = (lowBound + highBound)/2.0
    counter = 1
    while abs(guess**2 - x) > epsilon and counter <= 1000:
        if guess**2 < x:
            lowBound = guess
        if guess**2 > x:
            highBound = guess
            
        guess = (lowBound + highBound)/2
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: " , guess , " Count: " , counter
    return guess

def squareRootNR(x, epsilon):
##    Searching method by Newton-Raphson:
##    Formulae: x(n+1) = x(n) - f(x(n))/f'(x(n))
    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    
    counter = 1
    x = float(x)
    guess = x/2.0
    diff = guess**2 - x
    while abs(diff) > epsilon and counter <= 1000:
        guess = guess - (diff/(2.0*guess)) #2.0*guess is the derivitive of guess**2
        diff = guess**2 - x
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: ", guess, " Count: ", counter
    return guess

squareRootBi(123456789,0.01)
squareRootNR(123456789, 0.01)

squareRootBi(123456789,0.0001)
squareRootNR(123456789, 0.0001)

squareRootBi(123456789,0.000001)
squareRootNR(123456789, 0.000001)

squareRootBi(123456789,0.000001)
squareRootNR(123456789, 0.000001)


def is_square(n):
    root = int(n**.5)
    return root*root == n

largest = 0
count = 0
for i in xrange(3,1001):
    if is_square(i):continue
    m = 0
    d = 1
    a = int(i**.5)
    s = a
    h0 = a
    k0 = 1
    h_1 = 1
    k_1 = 0
    while h0*h0-i*k0*k0 !=1:
        m = d*a - m
        d = (i-m*m)/d
        a = int((s+m)/d)
        temp_h = h0
        temp_k = k0
        h0 = a*temp_h+h_1
        k0 = a*temp_k+k_1
        h_1 = temp_h
        k_1 = temp_k
    if h0>largest:
        largest = h0
        count = i

print "The answer is :",count
print "The number is :",largest

import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)

"""
Given two numbers x and n, calculate the nth root of x.

This means that being r = result, r^n = x; Examples

root(4, 2)    # 2 (the square root of 4 is 2 , 2^2 = 4);
root(8, 3)    # 2 (the cube root of 8 is 2   , 2^3 = 8);
root(256, 4)  # 4 (the 4th root of 256 is 4  , 4^4 = 256);
root(9, 2)    # 3 (the square root of 9 is 3 , 3^2 = 9)
Expect inputs greater than 1 10^19
"""

def root(x, n):
    return x**(1/n)

if __name__ == "__main__":
    num = float(input("What number would you like to know the root of? "))
    nth = float(input("What root would you like to know? "))
    print(root(num, nth))

import sys 
def cn(s):
	s=int (s)
	i=1
	while (1):
		if i*i==s:
			return i
		elif i*i>s:
			return "no square root"
		else :
			i=i+1			

sqr=sys.argv[1]
print(cn (sqr))

import sys
import os
import math

def my_range(n):
    i = 1.0
    while i <= n:
	yield i
	i = i + 1.0

def square_root(a, x):
    while True:
        y = (x + a/x) / 2
        if y == x:
            break
        x = y
    return x

def test_square_root(x):
    for i in my_range(x):
	a = square_root(i, i+1)
	b = math.sqrt(i)
	print i, '\t',
        print a, '\t',
	print b, '\t',
	print abs(b - a)

if __name__ == '__main__':
    prompt = "Enter the limit : "
    value = float(raw_input(prompt))
    test_square_root(value)


import math

limit = 1000

primes = [2]
triangular = []
tetrahedrals = []


#find prime
index = 3

while index <= limit:

    remainders = []
    j = 0

    while j < len(primes):
        remainders.append(index % primes[j])

        j = j + 1

    if 0 not in remainders:
        primes.append(index)

    index = index + 1
        
#find triangular
index = 1
while index <= limit:
    if (math.sqrt(index * 8 + 1) - 1) % 2 == 0:
        triangular.append(index)
    index += 1

#def find_tetrahedrals(limit):

j = 1
while j <= len(triangular):
    
    tetrahedrals.append(sum(triangular[:j]))
    j = j + 1
        
def is_prime(n):

    return n in primes


def is_triangular(n):
    """To tell whether n is a triangular number"""
    return n in triangular
#the summation formula of arithmetic sequence is sum = (m + 1) * m / 2

def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    return n in tetrahedrals

def is_square(n):

    return n ** 0.5 % 1 == 0

def is_square_pyramidal(n):
    """To tell whether n is a tetrahedral number"""
    remainder = n
    subtractor_root = 0
    while remainder > 0:
        subtractor_root += 1
        remainder -= subtractor_root ** 2
    return remainder == 0
#n is subtracted by 1^2, 2^2, ... subtractor_root^2 until it is equal to or smaller than 0 (remainder <=0).
#If remainder == 0, then n is ansquare piramidal number.

def is_pentagonal(n):
    """To tell whether n is a pentagonal number"""
    return (math.sqrt(n * 24 + 1) + 1) % 6 == 0
#the general ofrmula of pentagonal sequence is n = (3 * m - 1) * m / 2

def is_prime_oblong(n):

    prime_oblong = False
    j = 0

    while j < len(primes):

        if n % primes[j] == 0 and n / primes[j] in primes:
            prime_oblong = True
            break
        j = j + 1

    return prime_oblong

def is_pointy(n):

    pointy = False

    j = 0
    while j < len(tetrahedrals):
        if n - tetrahedrals[j] in tetrahedrals and n != 2 * tetrahedrals[j]:
            pointy = True
            break
        j += 1
    
    return pointy
    
def print_result(n):
    
    str_prime = 'composite'
    str_triangular = 'not triangular'
    str_tetrahedral = 'not tetrahedral'
    str_square = 'not square'
    str_square_pyramidal = 'not square pyramidal'
    str_pentagonal = 'not pentagonal'
    str_prime_oblong = 'not prime oblong'
    str_pointy = 'not pointy'
    
    if is_prime(n):
        str_prime = 'prime'
    if is_triangular(n):
        str_triangular = 'triangular'
    if is_tetrahedral(n):
        str_tetrahedral = 'tetrahedral'
    if is_square(n):
        str_square = 'square'
    if is_square_pyramidal(n):
        str_square_pyramidal = 'square pyramidal'
    if is_pentagonal(n):
        str_pentagonal = 'pentagonal'
    if is_prime_oblong(n):
        str_prime_oblong = 'prime oblong'
    if is_pointy(n):
        str_pointy = 'pointy'
    print '%d %s, %s, %s, %s, %s, %s, %s, %s' % (n, str_prime, str_triangular, str_tetrahedral, str_square, str_square_pyramidal, str_pentagonal, str_prime_oblong, str_pointy)

def main():

    i = 1
    while i <= limit:
        print_result(i)
        i += 1
    
if __name__ == "__main__":
    main()

#!/usr/bin/python

"""Problem 57: Square root convergents"""

from math import log10

def main():
    num, den, cnt = 3, 2, 0

    for _ in range(1, 1001):
        if int(log10(num)) > int(log10(den)):
            cnt += 1
        # http://en.wikipedia.org/wiki/Square_root_of_2#Continued_fraction_representation
        num, den = num+2*den, num+den

    return cnt

if __name__ == "__main__":
    print(main())

#Sum all amicable numbers less than 10000

import math

#Sum of proper divisors of x
def d(x):
    if (x == 0):
        return 0
    
    result = 1
    limit = int(math.floor(math.sqrt(x)))

    #If perfect square subtract square root since it will be counted twice
    if limit*limit == x:
       result -= int(math.sqrt(x))

    for i in range(2,limit + 1):
        if (x % i) == 0:
            result += i
            result += (x/i)   

    return result

def isAmicable(x):
    y = d(x)
    if x == d(y) and x != y:
        return 1
    else:
        return 0



result = 0
for i in range(1,10000):
    if isAmicable(i):
        result += i

print(result)

"""
File Name: Ch2_Ex10.py
Developer: Justin A. Shores
Date Last Modified: 09/02/2014
Description: Prompt user for a number
 	     Print whether number is a perfect square
	     If not ask for another number
"""
import math

# is the number a perfect square?
def is_perfect_square(integer):
        number_root = math.sqrt(integer) + 0.5 # add .5 to avoid base value err.
        if (int(number_root) ** 2) == integer:
                return False # is perfect square
        else:
                return True # not perfect square

# while user does not enter perfect square
while True:
	# get number
	number_str = input("Enter a number that you believe is a perfect square: ")
	number_int = int(number_str)

	# check if perfect square and try again
	if is_perfect_square(number_int) == False:
		print("The number " + str(number_int) + " is a perfect square!")
		break #user entered perfect square
	else:
		print("Sorry try again! " + str(number_int) + " isn't a perfect square")

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

def squareRootBi(x, epsilon):
    '''Assumes x >= 0, and epsilon > 0
       Return y
    '''
    low = 0
    high = x
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess**2 - x) > epsilon and ctr <= 100:
        if guess**2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    
    
    print "Bi method. Num. iterations:", ctr, "Estimated: ",guess
    return guess
    
    
squareRootBi(100, 5)
import math 

def divisors(p):
    divs = [1]
    square_root = int(math.ceil(math.sqrt(p))) 
    for x in xrange(2, square_root):
        if p % x == 0:
            div1 = x
            div2 = p/x

            divs.append(div1)
            if div1 != div2:
                divs.append(div2)

    return divs

sum_of_amicable = 0
for x in range(10000):
    sum_of_divs = sum(divisors(x))
    if x == sum_of_divs:
        continue

    if x > sum_of_divs:
        continue

    reverse = sum(divisors(sum_of_divs))

    if reverse == x:
        sum_of_amicable += sum_of_divs
        sum_of_amicable += x

print sum_of_amicable

from Zone import *
from json_serialize import *

class Table:
    def __init__(self, config_file = ''):
            self.root_zone = None
            self.zones_map = {}
            self.red_robots = []
            self.blue_robots = []
            self.elements = []

    def set_root(self, zone):
        self.root_zone = zone
        self.add_zone(zone)
        
    def add_zone(self, zone):
        self.zones_map[zone.id] = zone
        

    def __repr__(self):
        res = 'Table, zones: \n'
        for zone in self.zones_map.values():
            res += str(zone) + '\n'
        return res

  

if __name__ == '__main__':   
    background = Zone('background')
    square = [(0,0), (3000,0), (3000,2000), (0,2000)]
    background.set_polygon(square)
    up_left = Zone('start_red')
    square = [(0,0), (50,0), (50,50), (0,50)]
    up_left.set_polygon(square)
    up_right = Zone('start_blue')
    square = [(3000-50,0), (3000,0), (3000,50), (3000-50,50)]
    up_right.set_polygon(square)

    background.add_child(up_left.id)
    background.add_child(up_right.id)

    table = Table()
    table.set_root(background)
    table.add_zone(up_left)
    table.add_zone(up_right)
    print table

__author__ = 'student'


import math

class Function:
    def __init__(self, key, header, explanation, compute):
        self.key = key
        self.header = header
        self.explanation = explanation
        self.compute = compute

def sqrt(x):
    return math.sqrt(x)

function_list = [
    Function('sqrt', 'SQRT', "Square root function", sqrt),
    Function('sqr', "Square", "Square of the argument", (lambda x : x*x)),
    Function('log2', "Log2", "Binary logarithm", (lambda x : math.log2(x))),
    Function('cube', "Cube", "Cube of the argument", (lambda x: x*x*x))
    ]

def getFunctionByKey(key):
    for func in function_list:
        if key == func.key:
            return func

##Authors: Dichen Li and Anders Schneider
##September 8, 2014

import math

def is_prime(n):
    """This determines if n is prime by dividing n by all numbers smaller than the square root of n"""
    i = 2
    prime = True

    if n == 1:
        prime = False

    while i <= int(n ** 0.5):
        if n % i == 0:
            prime = False
            break
        i = i + 1

    return prime

def is_triangular(n):
    """To tell whether n is a triangular number"""
    return (math.sqrt(n * 8 + 1) - 1) % 2 == 0
#the summation formula of arithmetic sequence is sum = (m + 1) * m / 2

def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    m = 0
    f_m = 0
    tetrahedral = False
    while n - f_m > 0:
        m += 1
        f_m = (m ** 3 + 3 * m * m + 2 * m) / 6
        if f_m - n == 0:
            tetrahedral = True
            break
    return tetrahedral
#the general formula of tetrahedral sequence is n = f(m) = (m^3 + 3 * m^2 + 2 * m) / 6

def is_square(n):
    """Determines if n is square by taking the square root and evaluating if the result is an integer"""
    return n ** 0.5 % 1 == 0

def is_square_pyramidal(n):
    """To tell whether n is a tetrahedral number"""
    remainder = n
    subtractor_root = 0
    while remainder > 0:
        subtractor_root += 1
        remainder -= subtractor_root ** 2
    return remainder == 0
#n is subtracted by 1^2, 2^2, ... subtractor_root^2 until it is equal to or smaller than 0 (remainder <=0).
#If remainder == 0, then n is a square pyramidal number.

def is_pentagonal(n):
    """To tell whether n is a pentagonal number"""
    return (math.sqrt(n * 24 + 1) + 1) % 6 == 0
#the general formula of pentagonal sequence is n = (3 * m - 1) * m / 2

def is_prime_oblong(n):
    """Determines if n is prime oblong by dividing by every number smaller
    than n and evaluating if that number and n are prime and distinct"""
    i = 2
    prime_oblong = False

    while i <= int(n ** 0.5):

        if n % i == 0 and is_prime(i) and is_prime(n/i) and n/i != i:
            prime_oblong = True

        i = i + 1

    return prime_oblong

def is_pointy(n):
    """To tell whether n is a pointy number"""
    i = 1
    pointy = False
    while i < n / 2:
        if is_tetrahedral(i) and is_tetrahedral(n - i):
            pointy = True
            break
        i += 1
    return pointy
#From i = 1 to n / 2, test whether i and n - i are both tetrahedrals.

def print_result(n):
    """This function generates a string depending on if n is prime, square, etc."""
    
    str_prime = 'composite'
    str_triangular = 'not triangular'
    str_tetrahedral = 'not tetrahedral'
    str_square = 'not square'
    str_square_pyramidal = 'not square pyramidal'
    str_pentagonal = 'not pentagonal'
    str_prime_oblong = 'not prime oblong'
    str_pointy = 'not pointy'
    
    if is_prime(n):
        str_prime = 'prime'
    if is_triangular(n):
        str_triangular = 'triangular'
    if is_tetrahedral(n):
        str_tetrahedral = 'tetrahedral'
    if is_square(n):
        str_square = 'square'
    if is_square_pyramidal(n):
        str_square_pyramidal = 'square pyramidal'
    if is_pentagonal(n):
        str_pentagonal = 'pentagonal'
    if is_prime_oblong(n):
        str_prime_oblong = 'prime oblong'
    if is_pointy(n):
        str_pointy = 'pointy'
    print '%d %s, %s, %s, %s, %s, %s, %s, %s' % (n, str_prime, str_triangular, str_tetrahedral, str_square, str_square_pyramidal, str_pentagonal, str_prime_oblong, str_pointy)

def main():
    """From 1 to upper limit, this function executes the print function"""
    limit = 1000
    
    i = 1
    while i <= limit:
        print_result(i)
        i += 1
    
if __name__ == "__main__":
    main()

import os
import sys
import numpy as np


f=float(sys.argv[1])

def power(x):
    return x**2

def square_root(x):
    return np.sqrt(x)

square=power(f)
root=square_root(f)

print "square result=",square, "root result =",root

for num in range(201):
    print "The top ",num+1 , "is :",num

#!/usr/bin/env python
def sqrt(n):
    approx = n/2.0
    better = (approx + n/approx)/2.0
    while better != approx:
        approx = better
        better = (approx + n/approx)/2.0
    return approx

if __name__ == '__main__':
    print 'The square root of two is approximately: ' + str(sqrt(2))
    print

#!/usr/bin/env python
import math


def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True
    else:
        return False


def count_neighbourhoods(r):
    cnt = 0
    for i in range(int(math.ceil(math.sqrt(r)))):
        if is_square(r - i * i):
            cnt += 4
    return cnt


if __name__ == '__main__':
    t = input()
    for i in range(t):
        a = map(int, raw_input().strip().split(" "))
        if a[1] >= count_neighbourhoods(a[0]):
            print "possible"
        else:
            print "impossible"

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/env python


def newmark(oldmark):

    """Mr. Arkiletian's mark-boosting function"""

    return 10 * round(oldmark ** 0.5, 0)  # 10 times square root of old mark


while True:
    old = raw_input()
    if old == "":
        break
    print newmark(float(old)), '\n'

#Think Python exercise .2
# estimating square root through newton's method

#The variable assignment is so ugly. maybe figure this out in the future? 
#Don't prematurely optimize. I thought hard already, time to move on
#and I can review later.

def square_root(n):
	"""
		epsilon_constant is used to determine how close the approximation needs to be

	"""
	epsilon_constant = .000001
	x = n
	y = n
	while True:
		x = y
		y = (float(x) + (float(n)/float(x)))/2
		if abs(y-x) < epsilon_constant:
			break
	return y

print (square_root(25))

import numpy as np

class RegressionMetrics:
    
    def __init__(self):
        pass
    
    def rmse(self, yPred, yTrue):
        """Finds the root mean square error """
        return np.sqrt(np.mean(np.power((yPred - yTrue), 2)))
    
    def mae(self, yPred, yTrue):
        """Finds the mean absolute error"""
        return np.mean(np.fabs(yPred - yTrue))
    
    
if __name__ =="__main__":
    pass
#!/usr/bin/python

import sys
import math

def isPerfectSquare(n):
	root_n = math.sqrt(n)
	res1 = math.floor(root_n)*math.floor(root_n)
	return (res1 == float(n))

def isFib(n):

	x1 = 5*n*n+4
	x2 = 5*n*n-4

	res1 = isPerfectSquare(x1)
	res2 = isPerfectSquare(x2)

	return ( res1 or res2 )


def main():
	inStream = ''

	#determine in stream(file or stdin)
	if len(sys.argv) < 2:
		inStream = sys.stdin
	else:
		inStream = open('is_fib.in')
	nCases = int(inStream.readline())

	for i in range(0, nCases):
		n = int(inStream.readline())
		result = isFib(n)
		if result:
			print "IsFibo"
		else:
			print "IsNotFibo"


if __name__ == "__main__":
    main()
'''
Created on Dec 22, 2011

@author: pablocelayes
'''

def egcd(a,b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a

def gcd(a,b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a,b=(b,a) if a<b else (a,b)
    while b:
        a,b=b,a%b
    return a

def modInverse(e,n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e,n)[0]%n

def totient(p,q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)

def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x>>1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),
    
    otherwise returns -1
    '''
    h = n & 0xF; #last hexadecimal "digit"
    
    if h > 9:
        return -1 # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    
    return -1

#TEST functions

def test_is_perfect_square():
    print("Testing is_perfect_square")
    testsuit = [4, 0, 15, 25, 18, 901, 1000, 1024]
    
    for n in testsuit:
        print("Is ", n, " a perfect square?")
        if is_perfect_square(n)!= -1:
            print("Yes!")
        else:
            print("Nope")

if __name__ == "__main__":
    test_is_perfect_square()
#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      cain297
#
# Created:     27/03/2012
# Copyright:   (c) cain297 2012
# Licence:     <your licence>
#-------------------------------------------------------------------------------
#!/usr/bin/env python

def main():
    pass

if __name__ == '__main__':
    main()
x = int(raw_input("Please enter a non-negative integer"))

def sqrt(x):
    #Returns the Square Root of the value input
    i= 0
    if x >= 0:
        while i < x:
            if i*i == x:
                print i, "is the square root of the number", x
                return None
            elif i*i >x:
#                print "I am here"
                print x, "is not a perfect square"
                return None
            else:
                i += 1


    else:
        print x + "is not a positive integer"
        return None

sqrt(x)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#!/usr/bin/env python


"""
Problem Definition :

It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.

The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.

For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.

"""

__author__ = 'vivek'

import time
from decimal import *


def find_sum(num):
    add = 0

    while num > 0:
        num, digit = divmod(num,10)
        add += digit

    return add


def main():

    start_time = time.clock()
    getcontext().prec = 102

    answer = 0

    for number in xrange(1, 100):
        square_root = str(Decimal(number).sqrt())

        if len(square_root) > 1:
            decimal = int(square_root[:1] + square_root[-101:-2])
            answer += find_sum(decimal)

    print(answer)

    print "Run time...{} secs \n".format(round(time.clock() - start_time, 4))

if __name__ == '__main__':
    main()


# Find the smallest odd composite that cannot be written as the sum of a prime
# and twice a square

from math import sqrt, floor

def findSpecialComposite():
    listPreviousOddPrime = []
    
    x = 3
    while True:
        if isOddPrime(x, listPreviousOddPrime):
            listPreviousOddPrime.append(x)
        else:
            flagSpecial = False
            # Check if this odd composite can be written as the sum of a prime
            # and twice a square or not
            for oddPrime in listPreviousOddPrime:
                if isSquare((x - oddPrime) // 2):
                    flagSpecial = True
            if flagSpecial == False:
                return x
        
        x += 2
            
            
def isOddPrime(N, listPreviousOddPrime):
    if N <= 2:
        return False
    if not any(listPreviousOddPrime):
        return True

    for divisor in listPreviousOddPrime:
        if N % divisor == 0:
            return False

    return True

def isSquare(N):
    floorSquareRoot = floor(sqrt(N))
    if floorSquareRoot *  floorSquareRoot == N:
        return True
    else:
        return False

# import appropriate modules/libraries
from sys import argv

# define Babylonian Algorithm used in finding root
def bab(n,r):
	return 0.5*(n+r/n)

# find roots
def find_root(x):	
	eps=1e-11
	root = x
	while(abs(root-bab(root,x))>eps):
		root = bab(root,x)
	return root 

# return results
i = 1
while (i < len(argv)):
	print "The square root of", argv[i], "is", find_root(int(argv[i]))
	i = i + 1
	
__author__ = 'swenson'

import math

def example_function(x):
    """Compute the square root of x and return it."""
    return math.sqrt(x)
# Finds the square root of a number using recursion 


def rec_square_root(x, epsilon=0.01, low=None, high=None):

  if low == None:
    low = 0.0 
  if high == None:
    high = x
  bisection = (low+high)/2.0


  if abs(bisection**2 - x) < epsilon or bisection > x:
    return bisection

  else:
    if bisection**2 < x:
      return rec_square_root(x, epsilon, bisection, high)
    else:
      return rec_square_root(x, epsilon, low, bisection)

print rec_square_root(4)
print rec_square_root(16)
print rec_square_root(98)
#/usr/bin/env python

# 2010 Giannis Fysakis
# E-mail: giannisfs@gmail.com
# Released subject to the GPL  License
/*
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License 3 as published by
 *      the Free Software Foundation; 
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *      
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *      MA 02110-1301, USA.
 *      
 */


from math import sqrt

#4 x 4 Matrix
SquareMatrixof4 = (1,2,3,4,\
                   2,3,5,7,\
                   2,5,7,0,\
                   3,4,5,6)

#5 x 5 Matrix
SquareMatrixof5 =  (1,4,3,4,5,\
                    2,3,4,5,8,\
                    5,6,8,9,6,\
                    1,2,3,4,5,\
                    3,3,4,6,4)
#6 x 6 Matrix
SquareMatrixof6 =  (1,4,3,4,5,7,\
                    2,3,4,5,8,6,\
                    5,6,8,9,6,4,\
                    1,2,3,4,5,3,\
                    3,3,4,6,4,8,\
                    4,5,6,8,7,6)

def isValidSquare(seq):
    """
Any Sequence can be treated as a square as long as
the square root of the number of elements is a positive integer"""
    NumberOfElements = len(seq)
    return sqrt(NumberOfElements).is_integer()



def Diagonal(seq ,Diagonal="Left",X=4):
    diag = []
    LeN = len(seq)
    if Diagonal == "Left":
        pos = 0
        for i in xrange(0,LeN,LeN/X):
            diag.append( seq[ pos + i ] )
            pos += 1
    elif Diagonal == "Right":
        pos = X
        for i in xrange(0,LeN,LeN/X):
            diag.append( seq[ pos - i ] )
            pos  -= 1

    return diag
    
        
        
#examples
##>>> isValidSquare(SquareMatrixof4)
##True
##>>> Diagonal(SquareMatrixof6,X=6)
##[1, 3, 8, 4, 4, 6]
##>>> Diagonal(SquareMatrixof5,X=5)
##[1, 3, 8, 4, 4]
##>>> Diagonal(SquareMatrixof4,X=4)
##[1, 3, 7, 6]
##>>> 

import math
import sys

def summation(n, term):
    return sum(term(k) for k in range(1, n + 1))

def invSquareSum(n):
    return summation(n, lambda k : 1 / (k * k))

# NOTE: if you try using 1e3 here, you'll get an error.  Why is that,
# and how could you fix it inside summation()?
x = invSquareSum(1000)
print(math.sqrt(6 * x))

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def goldenUpdate(x):
    return 1 / x + 1

def squareCloseToSuccessor(x):
    return approxEq(x * x, x + 1)

def approxEq(x, y, epsilon=1e-15):
    return abs(x - y) < epsilon

print(improve(goldenUpdate, squareCloseToSuccessor))

def interpolate(x, y, f=0.5):
    return (1 - f) * x + f * y

def cubeRoot(a, f=0.5):
    iters = 0
    def cubeRootUpdate(x):
        nonlocal iters
        iters += 1
        return interpolate(x, a / (x * x), f)
    def cubeRootClose(x):
        return approxEq(x * x * x, a)
    ret = improve(cubeRootUpdate, cubeRootClose)
    print('iters: {0}'.format(iters))
    return ret

# NOTE: convergence speed depends on the initial guess and iteration
# algorithm.  How can you compute the optimal value of f?  Can you
# generalize this process for any improve() call?
print(cubeRoot(8))
print(cubeRoot(8, 1/4))
print(cubeRoot(8, 1/3))

from operator import add

def curry2(f):
    """
    >>> curry2(add)(41)(1)
    42
    """
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g

def myAdd(a, b):
    return a + b

def curry(f):
    """
    >>> curry(myAdd)(41)(1)
    42
    >>> curry(myAdd)(a=41)(b=1)
    42
    >>> curry(myAdd)(41)(b=1)
    42
    >>> curry(myAdd)(a=41)(1)
    Traceback (most recent call last):
        ...
    TypeError: myAdd() got multiple values for argument 'a'

    NOTE: what other tests should be added?
    """
    def g(*args, **kwargs):
        def h(*moreArgs, **moreKwargs):
            nonlocal args
            nonlocal kwargs
            args += moreArgs
            kwargs.update(moreKwargs)
            return f(*args, **kwargs)
        return h
    return g

if __name__ == '__main__':
    from doctest import testmod
    print(testmod())

#!/usr/bin/env python
#coding:utf-8

"""
Square root digital expansion

It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.
The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.
For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.

"""
from decimal import *

def digitalSumOfSquareNum(n,k):
    getcontext().prec=k
    digits=list(str(Decimal(n).sqrt()).replace('.','')[:-2])
    digits=[int(i) for i in digits]
    return sum(digits)

def answer():
    total=0
    for n in set(range(2,100))-set([i**2 for i in xrange(10)]):
        total+=digitalSumOfSquareNum(n,102)
    print total

import time
tStart=time.time()
answer()
print 'run time=',time.time()-tStart
# 40886
# run time= 0.0131640434265

__author__ = 'Tony Beltramelli - 07/11/2015'
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import numpy as np
from math import sqrt

def detect_peaks(signal, threshold=0.5):
	""" Performs peak detection on three steps: root mean square, peak to
	average ratios and first order logic.
	threshold used to discard peaks too small """
	# compute root mean square
	root_mean_square = sqrt(np.sum(np.square(signal) / len(signal)))
	# compute peak to average ratios
	ratios = np.array([pow(x / root_mean_square, 2) for x in signal])
	# apply first order logic
	peaks = (ratios > np.roll(ratios, 1)) & (ratios > np.roll(ratios, -1)) & (ratios > threshold)
	# optional: return peak indices
	peak_indexes = []
	for i in range(0, len(peaks)):
		if peaks[i]:
			peak_indexes.append(i)
	return peak_indexes

execfile("16 - Power Digit Sum.py")
execfile("57 - Square Root Convergents.py")

def fracs(array):    # Finds the fractions of continuous expansion
    a = array
    f = frac(a[-2], 1, 1, a[-1])
    a = a[:-2]
    while a:
        f = frac(a[-1], 1, f[1], f[0])
        a = a[:-1]
    return tuple(f)

def exp(r):
    e = [1, 1, 2]
    while len(e) < r:
        if (e[-1] + e[-2]) % 2 == 0:
            e.append(e[-1] + e[-2] + e[-3])
        else:
            e.append(1)
    e[0] = 2
    return fracs(e)

# n = 100
# f = exp(n)
# s = sumup(f[0])
# print "The sum of digits in the numerator of", str(n) + 'th convergent is:', s

#Pablo Enrique Crdenas Viera
#A01630814
#Function
def Root(n):
    x=n
    y=0
    while(x!= y):
        y=x
        x=(n/x + x)/2
    return x
print("I will calculate the square root af any number you type")
x= float(input("type the number: "))
if(x== 0 ):
    print("The square root is: "+str(x))
elif( x < 0):
    print("Negative numbers can not have square root")
else:
    Answer= Root(x)
    print ("The square root is: "+str(Answer))
#!/usr/bin/env python3
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

# Support python2 
from __future__ import division

def sqrt(number):
    """This function uses division to converge to a square root"""

    # We have to initialize these variables
    guess = 2  # Our first guess will always be 2
    old = 0    # This must be set to something, or we get an error

    # This is a while loop, it repeats the block
    # until the test (guess != old) is False
    # This loop will converge towards the square root
    while (guess != old): 
        old = guess              # We need to keep a copy of our previous guess
        quotient = number/guess  
        guess = (quotient + guess)/2  # We average our guess and  quotient

    # Once we are done, we must return the value
    return guess

def main():
    print(sqrt(2685)) # Display the square root of 2685
    print(sqrt(2))    # Display the square root of 2
    #print(sqrt(-2))  # never converges


# This calls main
# This is specific to python
if __name__ == '__main__':
    main()


def square_root(a, x):
    i = 10;
    y = 0;
    while i > 0:
        i=i-1
        y = (x + a/x) / 2
        print i, y
        x = y

    return y

def main():
    while True:
        a = input('> ')
        #print 'entered', a
        if a == 'done':
            print 'Done!'
            return
        else:

            # check if its int or float
            if isinstance(a, int):
                pass
            elif isinstance(a, float):
                pass
            else:
                print 'Please enter int or float values'
                continue
        
            sq_val = square_root(a, 10);
            print 'sq(', a, ')=', sq_val


if __name__ == "__main__":
    main()        

#-----------------------------------------------------------------------------------
#! /usr/bin/env python
# --------------------------------------------------------
# SQUARE ROOT CALCULATOR USING INTERVALL-SPLITTING
#
# description:
#	simple s_root approximation function _square_root(param1)
#	usage: int.py => enter positive number
#
# options: 
# 	return_param_1 = number of needed steps
#  	return_param_2 = final result of square root
#
# (c) fred
# --------------------------------------------------------
# settings [don't change unless you are babo]
steps = 1000 # number of max loop_steps
debug = 5   # max number of lines for debugging output

# app_description
print   '[-----------------------------]\n'+ \
	'|-- SQUARE ROOT  CALCULATOR --|\n'+ \
	'|-----------------------------|\n'+ \
	'|--  using intervall-split  --|\n'+ \
	'[-----------------------------]'

# normal input
num = raw_input('[*] Please insert number: ')

# func_for_calculation using black magic c0de :)
def _square_root(num):

	# lazy error_checking for failheads
	try: num = float(num)
	except ValueError: 
		print '[!] Value has to be a number'
		return -1
	if(num<=0): 
		print '[!] Value has to be positive'; 
		return -2

	print '[-] Calculating square root of: '+str(num)

	#set start_intervall limits [0,num]
	_I_o = num; 	# upper limit
	_I_u = 0; 	# lower limit
	print '[-] Lower limit: '+str(_I_u)+' Upper limit: '+str(_I_o)
	if(int(debug)>0): print '[-] Debug-information:'

	#black magic :>
	for i in range(0, steps): 

		_I_t = (_I_o+_I_u)/2 	 # define intervall-split
		if i<debug:              # print temp value, temp intervall and square
			print '['+str(i+1)+'] value: '+str(_I_t) \
			+'\tIntervall: ['+str(_I_u)+','+str(_I_o)+']'
		# check by type_cast to str char_by_char for len(_x_) cause no
		# external routines were allowed such as substr(), find() etc..
		# accuracy max 10^-10 due to length of [float]
		if(str(_I_t*_I_t)==str(num)):  break
		elif(_I_t*_I_t>num): _I_o=_I_t # change upper intervall limit
		elif(_I_t*_I_t<num): _I_u=_I_t # change lower intervall limit

	print '[.] .......................'
	if(i==steps-1):
		print '[!] '+str(steps-1)+' steps are reached: cant guarantee full accuracy'
		
	res1 = str(i+1)		# final number of steps
	res2 = str(_I_t)	# final result
	print '['+res1+'] Found square root with accuracy of 10^-10: ['+res2+']' # output
	return(res1,res2)	# return the shit to _main_ if needed (addr of call func)

# simple call root_function, usage of return[0],return[1] possible as well
_square_root(num)

# EOF 12.2013

#!/usr/bin/env python

def square_root(a, x):
    while True:
        y = (x + a/x) / 2      
        if abs(y-x) < 0.0000001:
            return x
        x = y    
        
if __name__ == '__main__':
    print square_root(4.0, 3.0)

###Lambda is used when we need to return a function from within a function. 
# That means that Python has two tools for building functions: def and lambda.
#It is an expression that is simply a function without a name - its an anonymous function
#lambda arg1, arg2, ...argN : expression using arguments
def square_root(x): return math.sqrt(x)
#or
square_root = lambda x: math.sqrt(x)

def p(t):
    return t*2

print p(2)
print p(3)

#Equivalent Lambda function
#lambda x:x**2 is the actual function
#y only contains the function and itself is NOT a function
y=lambda x:x**2

print y(2)


###Ex3:
f = lambda x, y : x + y
f(1,1)

###Ex4:
Celsius = [39.2, 36.5, 37.3, 37.8]
Fahrenheit = map(lambda x: (float(9)/5)*x + 32, Celsius)


###Ex5:
mz = (lambda a = 'Wolfgangus', b = ' Theophilus', c = ' Mozart': a + b + c)
mz('Wolfgang', ' Amadeus')

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

<<<<<<< HEAD
def power(x):
    return x ** 2

=======
import numpy as np


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    return np.sqrt(x)
>>>>>>> 97ef1a78922bd78e9022e6451ed7adc78bdce0a2

def square_root(a):
    
    x = 3
    epsilon = 0.000000000001
    while True:
        y = (x + a/x) /2
        if abs(y-x) < epsilon:
            break
        x = y
    return x


if __name__ == '__main__':
    print(square_root(49))




def square_root(a, iters=4):
		"""a = number to find the square root of 
		x = number of passes
		square_root calculates a square root using Newton's method
		"""
		y = 0
		x = a/3
		for i in range(iters):
				y = (x + a/x) / 2
				x = y
				#print (" guess is {0}".format(y))
		
		return y

print(square_root(4))
print(square_root(3))
print(square_root(4,20))
print(square_root(3,20))
		

__author__ = "BeepC"

from tkinter import *


class Board:

    squares = {}
    active_square = None
    active_state = -1
    active_x = -1
    active_y = -1
    last_x = -1
    last_y = -1
    dragging = False
    clicked = False
    drag_plane = ""
    drag_coord = -1

    def __init__(self, master, x, y, launcher_used):

        self.frame = Frame(master, bg="GREY28")
        self.x = x
        self.y = y
        self.frame.tk_focusFollowsMouse()
        self.frame.grid()

        launcher_used.destroy()

        self.frame.bind_all("<Button-1>", self.start_mark)
        self.frame.bind_all("<ButtonRelease-1>", self.end_mark)
        self.frame.bind_all("<B1-Motion>", self.drag)

        for j in range(0, self.y):
            for i in range(0, self.x):
                square_id = "{0},{1}".format(i, j)
                self.squares[square_id] = Square(self.frame, self, i, j)

        self.frame.lift()

    def start_mark(self, event):

        self.clicked = True
        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        self.active_square = self.squares["{0},{1}".format(event_grid[0], event_grid[1])]
        self.active_x, self.active_y = [int(i) for i in self.active_square().split(',')]
        self.last_x = self.active_x
        self.last_y = self.active_y

        if self.active_square.state == 0:
            self.active_square.state = 1
        elif self.active_square.state == 1:
            self.active_square.state = 2
        elif self.active_square.state == 2:
            self.active_square.state = 0

        self.active_state = self.active_square.state
        print(self.active_square())

    def drag(self, event):

        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        event_x, event_y = [int(i) for i in event_grid]

        if event_x < 0:
            event_x = 0
        elif event_x >= self.x:
            event_x = self.x - 1

        if event_y < 0:
            event_y = 0
        elif event_y >= self.y:
            event_y = self.y - 1

        event_square = self.squares["{0},{1}".format(event_x, event_y)]

        if self.drag_coord != -1:
            self.drag_mark(event_square, event_x, event_y)
            return None

        if self.clicked is True and self.dragging is False:

            if self.active_x == event_x and self.active_y != event_y:
                    self.drag_coord = event_x
                    self.drag_plane = "V"
                    self.dragging = True
            elif self.active_y == event_y and self.active_x != event_x:
                    self.drag_coord = event_y
                    self.drag_plane = "H"
                    self.dragging = True

    def drag_mark(self, event_square, event_x, event_y):
        if self.drag_plane == "V" and event_y != self.last_y:

            event_square = self.squares["{0},{1}".format(self.drag_coord, event_y)]
            last_square = self.squares["{0},{1}".format(self.drag_coord, self.last_y)]

            if event_square.dragged is False and event_square != self.active_square:
                event_square.dragged = True
                event_square.state = self.active_state

            elif last_square.dragged is True and last_square != self.active_square:
                last_square.dragged = False
                last_square.state = last_square.prev_state

            self.last_y = event_y

        elif self.drag_plane == "H" and event_x != self.last_x:

            event_square = self.squares["{0},{1}".format(event_x, self.drag_coord)]
            last_square = self.squares["{0},{1}".format(self.last_x, self.drag_coord)]

            if event_square.dragged is False and event_square != self.active_square:
                event_square.dragged = True
                event_square.state = self.active_state

            elif last_square.dragged is True and last_square != self.active_square:
                last_square.dragged = False
                last_square.state = last_square.prev_state

            self.last_x = event_x

    def end_mark(self, event):

        mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
        mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
        event_grid = self.frame.grid_location(mouse_x, mouse_y)
        event_x, event_y = [int(i) for i in event_grid]

        if event_x < 0:
            event_x = 0
        elif event_x >= self.x:
            event_x = self.x - 1

        if event_y < 0:
            event_y = 0
        elif event_y >= self.y:
            event_y = self.y - 1

        event_square = self.squares["{0},{1}".format(event_x, event_y)]

        for square in self.squares:
            self.squares[square].prev_state = self.squares[square].state
            self.squares[square].dragged = False

        self.clicked = False

        if self.dragging is True:

            event_square.prev_state = self.active_state
            event_square.dragged = False
            print(event_square())

            self.active_square = None
            self.active_state = 0
            self.dragging = False
            self.drag_coord = -1
            self.active_x = -1
            self.active_y = -1
            self.last_x = -1
            self.last_y = -1


class Square(Label):

    __state = 2
    __prev_state = 2
    __dragged = False

    def __init__(self, frame, board, x, y):

        super(Square, self).__init__(frame)

        self.frame = frame
        self.board = board
        self.x = x
        self.y = y

        self.tk_focusFollowsMouse()

        self.grid(row=self.y, column=self.x, padx=1, pady=1)
        self.config(image="", height=1, width=2, bg="BLANCHED ALMOND")

    def __call__(self):
        return "{0},{1}".format(self.x, self.y)

    @property
    def state(self):
        return self.__state

    @state.setter
    def state(self, value):
        if value == 0:
            self.config(bg="BLACK")
        elif value == 1:
            self.config(bg="WHITE")
        else:
            self.config(bg="BLANCHED ALMOND")
        self.__state = value

    @property
    def prev_state(self):
        return self.__prev_state

    @prev_state.setter
    def prev_state(self, value):
        self.__prev_state = value

    @property
    def dragged(self):
        return self.__dragged

    @dragged.setter
    def dragged(self, value):
        self.__dragged = value


class CCLauncher(Frame):

    def __init__(self, master):

        super(CCLauncher, self).__init__(master)

        self.master = master
        self.button_frame = Frame(master)

        self.pack()
        self.button_frame.pack()

        self.get_x_entry = Entry(self)
        self.get_y_entry = Entry(self)
        self.get_x_label = Label(self, text="How many columns?")
        self.get_y_label = Label(self, text="How many rows?")
        self.ok_button = Button(self.button_frame, text="OK", command=self.click_ok, width=10)
        self.ok_button.bind("<Return>", self.click_ok)

        self.get_x_entry.grid(row=0, column=1, sticky='E')
        self.get_y_entry.grid(row=1, column=1, sticky='E')
        self.get_x_label.grid(row=0, column=0, sticky='W')
        self.get_y_label.grid(row=1, column=0, sticky='W')
        self.ok_button.pack()

        self.get_x_entry.focus_set()

    def click_ok(self, events=None):
        make_board(int(self.get_x_entry.get()), int(self.get_y_entry.get()), self.master)


def make_board(x, y, launcher_used):

    global checker_board
    global root
    root = Tk()
    root.tk_focusFollowsMouse()
    checker_board = Board(root, x, y, launcher_used)
    root.mainloop()

launcher_root = Tk()
launcher = CCLauncher(launcher_root)
launcher_root.mainloop()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return '%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return "%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math

def is_square(x):
    root = (int)(math.sqrt(x))
    return x == root ** 2

def int_area(s, b):
    if b % 2 != 0:
        return False
    if is_square(s ** 2 - (b/2) ** 2) == False:
        return False
    return True

def perim(s, b):
    return s * 2 + b

perim_sum = 0
side = 3
while (side <= 1000):
    if int_area(side, side+1):
        print side, side + 1
        perim_sum += perim(side, side+1)
        side*=3
    elif int_area(side, side-1):
        print side, side - 1
        perim_sum += perim(side, side-1)
        side*=3
    side+=2
print perim_sum

#!/usr/bin/env python
# encoding: utf-8
"""
exercise-7.3.py

Created by Terry Bates on 2012-08-29.
Copyright (c) 2012 http://the-awesome-python-blog.posterous.com.
All rights reserved."""
import math



def square_root(a):
    # we will guess that x will be 1/2 of a, to start
    x =  0.75 * float(a)
    epsilon = 0.000001
    while True:
        y = (x + a/x) / 2
        if abs(y-x) < epsilon:
            break
        x = y
    return x
    

if __name__ == '__main__':

    for n in range(1, 10):
        print n, "\t",
        print square_root(n),"\t",
        print math.sqrt(n),"\t",

        print abs(square_root(n) - math.sqrt(n))


"""
Matrix square root and inverse matrix square root.
"""

__license__ = 'MIT License <http://www.opensource.org/licenses/mit-license.php>'
__author__ = 'Lucas Theis <lucas@theis.io>'
__docformat__ = 'epytext'
__version__ = '1.0.0'

from numpy import log, mean, dot, diag, sqrt
from numpy.linalg import eig

def sqrtm(mat):
	"""
	Matrix square root.

	@type  mat: array_like
	@param mat: matrix for which to compute square root
	"""

	# find eigenvectors
	eigvals, eigvecs = eig(mat)

	# matrix square root
	return dot(eigvecs, dot(diag(sqrt(eigvals)), eigvecs.T))



def sqrtmi(mat):
	"""
	Compute matrix inverse square root.

	@type  mat: array_like
	@param mat: matrix for which to compute inverse square root
	"""

	# find eigenvectors
	eigvals, eigvecs = eig(mat)

	# eliminate eigenvectors whose eigenvalues are zero
	eigvecs = eigvecs[:, eigvals > 0]
	eigvals = eigvals[eigvals > 0]

	# inverse square root
	return dot(eigvecs, dot(diag(1. / sqrt(eigvals)), eigvecs.T))

"""
CP1404 Week 11 Workshop - GUI program to square a number
Lindsay Ward, IT@JCU
13/10/2015
"""

from kivy.app import App
from kivy.lang import Builder
from kivy.core.window import Window

__author__ = 'Lindsay Ward'


class SquareNumberApp(App):
    """ SquareNumberApp is a Kivy App for squaring a number """
    def build(self):
        """ build the Kivy app from the kv file """
        Window.size = (200, 100)
        self.title = "Square Number"
        self.root = Builder.load_file('squaring.kv')
        return self.root

    def handle_calculate(self):
        """ handle calculation (could be button press or other call), output result to label widget """
        value = float(self.root.ids.input_number.text)
        result = value ** 2
        self.root.ids.output_label.text = str(result)


SquareNumberApp().run()

# http://projecteuler.net/problem=64
import math

def getRootSequence(r):
    """ See problem statement for details """
    a = -1 * math.floor(math.sqrt(r))
    b = 1
    
    sequence = []
    for i in range(500):
        d, r, a, b = helper(r, a, b)
        sequence.append(d) 

    return sequence

def helper(r, a, b):
    """ 
    Finds the next integer answer and returns the new fraction in terms
    of r, a, and b:   b / (r + a)
    """
    c = r - (a * a)
    d = int(math.floor(b * (math.sqrt(r) - a) / c))

    newA = (-1 * a) - (c * d / b)
    newB = c / b

    return d, r, newA, newB

def getPeriod(sequence):
    """ Returns the period of the repeating sequence """
    for period in range(1, len(sequence)):
        sequences = [tuple(sequence[j*period :j*period + period]) for j in range(len(sequence) / period)]
        if len(set(sequences)) == 1:
            return period

def isPerfectSquare(n):
    root = math.sqrt(n)
    return True if int(root + 0.5) ** 2 == n else False
        

total = 0
roots = [r for r in range(2, 10001) if not isPerfectSquare(r)]
periods = [getPeriod(getRootSequence(root)) for root in roots]
print len([period for period in periods if period % 2 == 1])


def squareRoot(a, precision=0.001):
    x = 4.0
    while True:
        y = (x + a/x) / 2
        if abs(y-x) < precision:
            break
        x = y
    
    return y

print (squareRoot(10))
   

from thumbnailer import _resizer
from unittest import TestCase, main
import os.path as path
from PIL import Image

class ThumbnailerTests(TestCase):

    def path(self, filename):
        return path.join(self.img_path, filename)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")
        self.img = Image.open(self.path("sample_image.jpg"))

    def testSquare(self):
        r = _resizer('square', '100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((100, 100), output.size)

    def testExact(self):
        r = _resizer('exact', '250x100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 100), output.size)

    def testWidth(self):
        r = _resizer('aspect', '250x?', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 166), output.size)

    def testHeight(self):
        r = _resizer('aspect', '?x250', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((375, 250), output.size)

class ThumbnailerFilenameTest(TestCase):

    def path(self, *parts):
        return path.join(self.img_path, *parts)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")

    def testRoot(self):
        """Test a file that is in the root of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testRootWithSlash(self):
        r = _resizer('square', '100', self.img_path + '/')
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testSubdir(self):
        """Test a file that is in a sub-directory of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('subdir', 'sample_image.jpg'))
        self.assertEqual('subdir/sample_image_square.jpg', new_name)

if __name__=="__main__":
    main()

def square(x): return x * x
def cube(x): return x * square(x)

# First problem
# f(x) = x ^ 3 - 2x - 5
# f`(x) = 3x*2 - 2

def f1(x): 
	return cube(x) - 2 * x - 5

def dfdx1(x):
	return 3 * square(x) - 2


# Second problem
# f(x) = x^6 - 2
# f`(x) = 6x^5

def f2(x):
	return cube(x) * cube(x) - 2

def dfdx2(x):
	return 6 * cube(x) * square(x)

# x is the initial guess
# f is the poly function
# dfdx is the derivative function

def newton_raphson(x, f, dfdx):
	xn = x - ( f(x) / dfdx(x) ) 
	print xn, " ", x
	while(xn > (x + 0.01)):
		newton_raphson(xn, f(xn), dfdx(xn))
	return xn


# xFound = newton_raphson(2, f1, dfdx1)
# print "solution: x = ", xFound


 # expected value of 2.09455, 5 guesses
print newton_raphson(3, f1, dfdx1)
# print newton_raphson(116, f1, dfdx1)


# print (1.2 - (f2(1.2) / dfdx2(1.2)))
# print (1.13395919067 - (f2(1.13395919067) / dfdx2(1.13395919067)))
# print (1.12274956058 - (f2(1.12274956058) / dfdx2(1.12274956058)))
# print (1.12246223231 - (f2(1.12246223231) / dfdx2(1.12246223231)))
# print (1.12246204831 - (f2(1.12246204831) / dfdx2(1.12246204831)))

# print (f1(2) / dfdx1(2))
# print (2 - (f1(2) / dfdx1(2)))
# print (2.1 - (f1(2.1) / dfdx1(2.1)))
# print (2.09456 - (f1(2.09456) / dfdx1(2.09456)))

# print (1 - (f2(1) / dfdx2(1)))
# print (1 - (f2(1) / dfdx2(1)))
# newton_raphson(1, f2, dfdx2) # expected value of 1.122462048309373, 6 guesses
# return the approximate root (when 2 consecutive guesses are the same)

def sqr(a):
	#newton method
	#http://stackoverflow.com/questions/18838265/python-square-root-function
	x = a
	for i in range(a):
		x = x-(x*x - a)/(2.0*x)
	return "{0:.2f}".format(x)
print sqr(4)
import math
import functools

def deprecate(f):
    f._PRINTED = False
    def func(x):
        if not f._PRINTED:
            print("This function is deprecated. Use something else.")
            f._PRINTED=True
        out = f(x)
        return out
    func = functools.update_wrapper(func, f)
    func.__doc__ = func.__doc__+'\nNote: this function is deprecated'
    return func

@deprecate
def sqrt(x):
    """Return sqare root of input"""
    square = math.sqrt(x)
    return square


def square_root(num, precission=0.001):
    x = num
    pow_two = x*x
    while abs(num-pow_two) > precission:
        pow_two = x*x
        x -= (pow_two - num) / (2.0 * x)

    return x

print square_root(4)
print square_root(10)
print square_root(3)

"""
CP1404 Week 11 Workshop - GUI program to square a number
Lindsay Ward, IT@JCU
13/10/2015
"""

from kivy.app import App
from kivy.lang import Builder
from kivy.core.window import Window

__author__ = 'Lindsay Ward'


class SquareNumberApp(App):
    """ SquareNumberApp is a Kivy App for squaring a number """
    def build(self):
        """ build the Kivy app from the kv file """
        Window.size = (200, 100)
        self.title = "Square Number"
        self.root = Builder.load_file('squaring.kv')
        return self.root

    def handle_calculate(self):
        """ handle calculation (could be button press or other call), output result to label widget """
        value = float(self.root.ids.input_number.text)
        result = value ** 2
        self.root.ids.output_label.text = str(result)


SquareNumberApp().run()

class Roots:

    # Finds the square root of a number using binary search.
    # number - int
    def square_root(self, number):
        left = 0
        right = number

        for a in range(100):
            middle = left + ((right - left) / 2)
            if middle ** 2 > number:
                right = middle
            else:
                left = middle

        return middle


def main():
    number = int(input())
    print('%.5f' % Roots().square_root(number))


if __name__ == '__main__':
    main()

import math
import time

t1 = time.time()

# use [num,a,b,c] to store a/b*(sqrt(num)-c)
def valueOf(com):
    result = (math.sqrt(com[0])-com[3])*com[1]/com[2]
    return math.floor(result*math.pow(10,6))

def gcd(x,y):
    if x < y:
        temp = x
        x = y
        y = temp
    while y > 0:
        temp = x%y
        x = y
        y = temp

    return x

def oneOver(com):
    na = com[2]
    nb = com[1]*(com[0]-com[3]*com[3])
    nc = -com[3]
    d = gcd(na,nb)
    return [com[0],na//d,nb//d,nc]

def head(com):
    return int(valueOf(com)//math.pow(10,6))

def trun(com,a):
    nc = com[3]+a*com[2]/com[1]
    return [com[0],com[1],com[2],nc]
    
def notation(num):
    root = math.sqrt(num)
    a = math.floor(root)
    if a == root:
        return [a,[]]
    rest = [num,1,1,a]
    mark = valueOf(rest)
    lst = []
    while True:
        temp = oneOver(rest)
        na = head(temp)
        lst.append(na)
        rest = trun(temp,na)
        if valueOf(rest) == mark:
            break
    return [a,lst]
        
def period(note):
    return len(note[1])

def digseq(num,i):
    note = notation(num)
    if i == 0:
        return note[0]
    p = period(note)
    return note[1][(i-1)%p]

def convergent(num,n):
    if n == 1:
        return [notation(num)[0],1]
    i = n-1
    temp = [1,digseq(num,i)]
    while True:
        i -= 1
        t = digseq(num,i)
        ntemp = [t*temp[1]+temp[0],temp[1]]
        if i == 0:
            return ntemp
        flip = [ntemp[1],ntemp[0]]
        temp = flip[:]

# wikipedia pell's equation

def Dmim(d):
    i = 0
    while True:
        i += 1
        ab = convergent(d,i)
        x = ab[0]
        y = ab[1]
        if x*x-d*y*y == 1:
            return x

def square(num):
    root = math.sqrt(num)
    r = math.floor(root)
    if r == root:
        return True
    return False

largest = 0
td = 0
for i in range(2,1001):
    if not square(i):
        md = Dmim(i)
        if md > largest:
            largest = md
            td = i

print(td)


print("time:",time.time()-t1)

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

__author__ = 'andi'
import math
import re


def arithmetic(question):
    question = question[8:]
    question = question.replace("plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))


def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)


def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []
    for number in number_list:
        if __is_square(number) and __is_third_square(number):
            return_values.append(number)
    return_value = ", ".join(return_values)
    return return_value


def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False
    else:
        return True


def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)


def float_equals(a, b, tolerance=0.00000001):
    return abs(a-b) < tolerance

primes_under_100 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]


def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100
    if n % 2 == 0 or n % 3 == 0:
        return False

    for f in range(5, int(n ** .5), 6):
        if n % f == 0 or n % (f + 2) == 0:
            return False
    return True


def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)


def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))
    return question


def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a


# what is 13 to the power of 11
def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))

from utils.numbers import rootConvergentGenerator

# Pell's equation

def isSquare(n):
    return int(n**0.5)**2 == n

def diophantineX(d):

    for x, y in rootConvergentGenerator(d, True):
        ans = x**2 - d * y**2
        if ans == 1:
            return x

def challenge066():
    limit = 1000
    solutions = [[d, diophantineX(d)] for d in xrange(1, limit + 1) if not isSquare(d)]
    return max(solutions, key=lambda x: x[1])[0]

answer = 661

if __name__ == "__main__":
    print challenge066()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import Teams
import CheckerType
import TreeNode


def get_possible_moves(state, team):
	moves = []

	for checker in state.get_team_checkers(team):
		root = TreeNode.TreeNode([checker.location, True])
		_build_siblings(root, state, checker.team, checker.type, [])
		moves.append([checker.location, root])

	return moves


def _build_siblings(node, state, team, type, temp_deleted = []):
	moves = _find_moves(state=state, location=node.data[0], team=team , type=type, temp_deleted=temp_deleted)


	for move in moves[0]:
		if moves[1]:
			deleted = _find_deleted(move, node.data[0])
			temp_deleted.append(deleted)


		node.siblings.append(TreeNode.TreeNode([move, moves[1]]))

	for sib in node.siblings:
		if not sib.data[1]:
			continue
		_build_siblings(sib, state, team, type, temp_deleted)


def _find_moves(state, location, team, type, temp_deleted = []):
	direction = Teams.direction(team)
	if type == CheckerType.king():
		direction = 0

	empty_moves = []
	take_moves = []

	enemy = Teams.opposite(team)
	diagonals = _get_diagonals(location, direction)

	for square in diagonals:
		new_checker = state.get_checker_from_location(tuple(square))

		if new_checker == None or new_checker.location in temp_deleted:
			empty_moves.append(square)
			continue
		elif new_checker.team == enemy:
			dx = square[0] - location[0]
			dy = square[1] - location[1]

			new_square = (square[0] + dx, square[1] + dy)

			if not _valid_square(new_square):
				continue
			if state.get_checker_from_location(new_square) == None:
				take_moves.append(new_square)

	if not len(take_moves) == 0:
		return take_moves, True
	return empty_moves, False


def _get_diagonals(square, y_restrict):
	# y_restrict: -1 implies that y can only decrease from that given in square [max 2 diagonals]
	# 			   0 that y can increase and decrease [max 4 diagonals]
	#			   1 that y can increase [max 2 diagonals]

	coords = []

	c1 = [square[0] + 1, square[1] + 1]
	c2 = [square[0] - 1, square[1] + 1]

	c3 = [square[0] + 1, square[1] - 1]
	c4 = [square[0] - 1, square[1] - 1]

	if _valid_square(c1) and y_restrict >= 0:
		coords.append(c1)
	if _valid_square(c2) and y_restrict >= 0:
		coords.append(c2)
	if _valid_square(c3) and y_restrict <= 0:
		coords.append(c3)
	if _valid_square(c4) and y_restrict <= 0:
		coords.append(c4)

	return coords


def _valid_square(square):
	if square[0] < 0 or square[1] < 0:
		return False

	if square[0] > 7 or square[1] > 7:
		return False

	return True


def check_move_is_valid(moves, state, team):
	if len(moves) < 2:
		raise ValueError('Argument moves must have more than one item')

	possible_moves = get_possible_moves(state, team)
	current_node = None

	for move in possible_moves:
		if move[0] == moves[0]:
			current_node = move[1]
	if current_node == None:
		return False

	return _find_route(current_node, moves[1:])


def _find_route(start_node, values):
	current_level = 0
	current_node = start_node
	found_no_take = False
	deleted = []

	for val in values:
		current_level += 1

		sib = _find_sibling(current_node, val)
		if sib == None:
			return False

		if found_no_take:
			return False

		if not sib.data[1]:
			found_no_take = True
		else:
			# Figure out which piece has been taken
			start = current_node.data[0]
			end = sib.data[0]

			deleted.append(_find_deleted(start, end))

		current_node = sib

	return deleted

def _find_deleted(start, end):
	x = start[0] + ((end[0] - start[0]) / 2)
	y = start[1] + ((end[1] - start[1]) / 2)

	return (x, y)


def _find_sibling(node, value):
	for sib in node.siblings:
		if list(sib.data[0]) == list(value):
			return sib

	return None
from __future__ import division
import numpy as np


class Regression(object):

    def __init__(self, d_mat, t_vec):
        """
        prepends 1's onto each row in the design matrix, and runs regressions,
        to find w.

        :param d_mat (Design matric):
        :param t_vec (Target vector):
        """

        self.d_mat = np.array(map(lambda x: [1] + x, d_mat))
        self.t_vec = np.array(t_vec)

    def predict(self, x):
        raise Exception('Not yet implemented')

    def root_mean_square(self):
        """
        Find the root-dimension_means-square error for the given regression
        :return:
        """
        N = len(self.d_mat)

        guess_sum = 0
        for i in range(N):
            guess_sum += (self.t_vec[i][0] - self.predict(i))**2

        return np.sqrt((1/N) * guess_sum)
import math
import time

t1 = time.time()

# a,b,c

# c >= b >= a
# l >= root(3)*a
# a+b > c

# b2 = p2+q2-2pq*(-1/2) = p2+q2+pq
# a2 = q2+r2-2qr*(-1/2) = q2+r2+qr
# c2 = p2+r2-2pr*(-1/2) = p2+r2+pr

def isSquare(n):
    r = math.sqrt(n)
    if r == int(r):
        return int(r)
    return 0

# p >= q >= r

N = 120000

rset = []
for r in range(3,N//3+1):
    for q in range(r,(N-r)//2+1):
        a = isSquare(q*q+r*r+q*r)
        if a > 0:
            for p in range(q,N-r-q+1):
                b = isSquare(p*p+q*q+p*q)
                if b > 0:
                    c = isSquare(p*p+r*r+p*r)
                    l = p+q+r
                    if c > 0 and not l in rset:
                        rset.append(l)
                        #print(a,b,c,p,q,r,l)

print(sum(rset))

      
print("time:",time.time()-t1)  
# time: 6303.283174037933

    


def square_root(x,guess=1):
    def improve_answer():
        def average(a,b):
            return (a+b)/2.0
        return average(guess,x/guess)   
    def good_enough():
        good = abs(guess*guess-x)
        return good<0.001
    while not good_enough():
        guess = improve_answer()
    return guess

if __name__ == '__main__':
    x = float(raw_input("Enter a number to get the square root: "))
    sqrt = square_root(x)
    print "sqrt(%f) = %f"%(x,sqrt)
    print "sqrd(%f) = %f"%(sqrt,sqrt*sqrt)

__author__ = 'Vivek'
#Find Square root of an inetger , if Square root is not integer returns floor of sqrt
def sqrt(A) :
        if 2 > A :
            return A
        low = 0
        high = A
        while high > low + 1 :
            num = (low + high)/2
            if num**2 < A  :
                low = num
            elif num**2 > A :
                high = num
            else :
                break
        if A == num**2:
            return num
        else :
            return low

print(sqrt(25))

import math

def square_root(a):
    epsilon = 0.0000001
    if a < 0:
        return 'a must be larger than 0'
    elif a < 1:
        x = 0
    else:
        x = 3**(int(math.log10(a))+1)

    while True:
        y = (x + a / x) / 2.0
        if abs(y-x) < epsilon:
            break
        x = y

    return y

print square_root(4654897)
def return_name (str):
  # length method
  return len(my_name)
  # to lowercase method
  return my_name.lower()
  # capitalize method
  return my_name.upper()

def pi_to_string():
  i_love_pi = 3.14
  return str(i_love_pi)

def hello_world():
  return "Hello World!"

def return_smallest(x, y):
  if x < y: return x
  elif y < x: return y
  else: return "that is the same number!"

def square_root(num):
  while ans * ans < x:
    ans = ans + 1
  return ans

def divisor(num):
  for i in range(1, num):
    if num%i == 0:
      return 'divisor ', i

# tuple is an ordered sequence of elements
test = (1, 2, 3, 4) #immutable
print test[1:3] #from 1 up to index 3

test_2 = [3, 5, 4, 2]
sorted_array = test_2.sort()
print sorted_array

# File Name: newton.py
# Using newton's algorithmn, compute the square root of the input
# and error
#
# Helen Chac, ECS 010, FALL 2012
#

# import math functions
import math

def newton(k):

    # raise error if inputted number is negative
   if k<0:
        raise ValueError("Cannot take the square root of a negative number")
   else:
        x = k/2 #take half of the guess
            
        # repeat until the difference of the guess is 10 ** (-10) 
        while abs (k - x**2) >= ((10) ** (-10)):

            # assign x to plus x and k / x and divide by 2 
            x = (x + k / x ) / 2
            
        # return the value x 
        return x

def main():

    # use try to catch errors
    try:
        k = float (input ("Number? "))

            # the x from newton (k)
        x = newton(k)
            
            # compute the error for the print
        error = abs ( math.sqrt(k) - x )

            # print square root
        print ("The approximate square root of", k, "is", "%.10f" % x)

            # print error
        print ("The error is", error )

    # if text is printed in the input, it will print
    # "cannot take the square root of a negative number"
    except ValueError as msg:
        print (msg)

    # stop program if user types in control + D        
    except EOFError as msg:
        print (" ")
        
# run main
main()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

from thumbnailer import _resizer
from unittest import TestCase, main
import os.path as path
from PIL import Image

class ThumbnailerTests(TestCase):

    def path(self, filename):
        return path.join(self.img_path, filename)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")
        self.img = Image.open(self.path("sample_image.jpg"))

    def testSquare(self):
        r = _resizer('square', '100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((100, 100), output.size)

    def testExact(self):
        r = _resizer('exact', '250x100', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 100), output.size)

    def testWidth(self):
        r = _resizer('aspect', '250x?', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((250, 166), output.size)

    def testHeight(self):
        r = _resizer('aspect', '?x250', self.img_path)
        output = r.resize(self.img)
        self.assertEqual((375, 250), output.size)

class ThumbnailerFilenameTest(TestCase):

    def path(self, *parts):
        return path.join(self.img_path, *parts)

    def setUp(self):
        self.img_path = path.join(path.dirname(__file__), "test_data")

    def testRoot(self):
        """Test a file that is in the root of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testRootWithSlash(self):
        r = _resizer('square', '100', self.img_path + '/')
        new_name = r.get_thumbnail_name(self.path('sample_image.jpg'))
        self.assertEqual('sample_image_square.jpg', new_name)

    def testSubdir(self):
        """Test a file that is in a sub-directory of img_path."""

        r = _resizer('square', '100', self.img_path)
        new_name = r.get_thumbnail_name(self.path('subdir', 'sample_image.jpg'))
        self.assertEqual('subdir/sample_image_square.jpg', new_name)

if __name__=="__main__":
    main()

'''
Calculating the digital sum of the decimal digits of irrational square roots.
'''

import decimal
import intlib
decimal.getcontext().prec = 105  # 105.


def square_root(n):
    ans = []
    p = 0
    c = n
    for i in range(100):
        x = 0
        while x * (20 * p + x) <= c:
            x += 1
        x = x - 1
        ans.append(x)
        c = (c - x * (20 * p + x)) * 100
        p = 10 * p + x

    return ans


def cheat():
    'decimal?'
    ans = 0
    dec = decimal.Decimal
    for n in range(1, 100):
        if not intlib.is_square(n):
            ans += sum(int(d) for d in str(dec(n) ** dec(.5))[:101]
                       if d != '.')
    return ans


def main():
    return sum(sum(square_root(n)) for n in range(1, 100)
               if n not in (n * n for n in range(1, 10)))

if __name__ == '__main__':
    import time
    t1 = time.time()
    print(main())
    t2 = time.time()
    print('{:.3f} s'.format(t2 - t1))
    t1 = time.time()
    print(cheat())
    t2 = time.time()
    print('{:.3f} s'.format(t2 - t1))

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

'''
Find the square root of n.

    Input: A number
    Output: The square root or the integers closest to the square root
    Assume: positive n

 Newton's method is a popular solution for square root, but not implemented here.
'''

def sqrt(n):
    for number in range(0, n):
        if isSqrt(number,n):
            return number
        else:
            if n < number * number:
                return number, number - 1


def isSqrt(a,b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True
    else:
        return False


# Test Section
if __name__ == '__main__':
    print "sqrt(25) = 5: %s" % (sqrt(25) == 5)
    print "sqrt(30) = (6, 5): %s" % (sqrt(30) == (6,5))


import math
import itertools

#Naive method.
def get_largest_prime_factor(number):
    possible_factors = itertools.count(2)
    square_root_num = math.sqrt(number)

    for num in possible_factors:

        if num > square_root_num:
            break

        if num >= number:
            break

        while number / num % 1 == 0:
            if number / num != 1:
                number /= num

    return number

#print(str(int(getLargestPrimeFactor(9007199254740992))))
print(str(int(get_largest_prime_factor(600851475143))))
#! /usr/bin/python
from __future__ import print_function
from math import sqrt

def is_prime(n):
    """returns True if n is a prime #
    """
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    square_root = int(sqrt(n))
    if [i for i in range(2, square_root + 1) if n % i == 0]:
        return False
    else:
        return True


def largest_prime(n):
    """Returns None if n is already a prime"""
    div = 2
    while div < n:
        if n % div == 0:
            current = n / div
            if is_prime(current) and n % current == 0:
                return current
        div += 1


if __name__ == '__main__':
    x = 600851475143
    print(largest_prime(x))

import sys


def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    '''

    if x < 0:
        raise ValueError("Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def main():
    try:
        print(sqrt(9))
        print(sqrt(2))
        print(sqrt(-1))
        print("This is never printed.")
    except ValueError as e:
        print(e, file=sys.stderr)

    print("Program execution continues normally here.")


if __name__ == '__main__':
    main()

#!/usr/bin/python

import sys

class Calculator:
  def square_root(self, num, guess=1.0):
    print str(guess)
    if '{:.2f}'.format(guess * guess) == '{:.2f}'.format(num):
      return guess

    return self.square_root(num, (guess + (num / guess)) / 2.0)

calc = Calculator()
number = int(sys.argv[1])
print calc.square_root(number)

from django.db import models
from django.db import connection

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

if connection.features.uses_case_insensitive_names:
    t_convert = lambda x: x.upper()
else:
    t_convert = lambda x: x
qn = connection.ops.quote_name

__test__ = {'API_TESTS': """

#4896: Test cursor.executemany
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> opts = Square._meta
>>> f1, f2 = opts.get_field('root'), opts.get_field('square')
>>> query = ('INSERT INTO %s (%s, %s) VALUES (%%s, %%s)'
...         % (t_convert(opts.db_table), qn(f1.column), qn(f2.column)))
>>> cursor.executemany(query, [(i, i**2) for i in range(-5, 6)]) and None or None
>>> Square.objects.order_by('root')
[<Square: -5 ** 2 == 25>, <Square: -4 ** 2 == 16>, <Square: -3 ** 2 == 9>, <Square: -2 ** 2 == 4>, <Square: -1 ** 2 == 1>, <Square: 0 ** 2 == 0>, <Square: 1 ** 2 == 1>, <Square: 2 ** 2 == 4>, <Square: 3 ** 2 == 9>, <Square: 4 ** 2 == 16>, <Square: 5 ** 2 == 25>]

#4765: executemany with params=[] does nothing
>>> cursor.executemany(query, []) and None or None
>>> Square.objects.count()
11

#6254: fetchone, fetchmany, fetchall return strings as unicode objects
>>> Person(first_name="John", last_name="Doe").save()
>>> Person(first_name="Jane", last_name="Doe").save()
>>> Person(first_name="Mary", last_name="Agnelline").save()
>>> Person(first_name="Peter", last_name="Parker").save()
>>> Person(first_name="Clark", last_name="Kent").save()
>>> opts2 = Person._meta
>>> f3, f4 = opts2.get_field('first_name'), opts2.get_field('last_name')
>>> query2 = ('SELECT %s, %s FROM %s ORDER BY %s'
...          % (qn(f3.column), qn(f4.column), t_convert(opts2.db_table),
...             qn(f3.column)))
>>> cursor.execute(query2) and None or None
>>> cursor.fetchone()
(u'Clark', u'Kent')

>>> list(cursor.fetchmany(2))
[(u'Jane', u'Doe'), (u'John', u'Doe')]

>>> list(cursor.fetchall())
[(u'Mary', u'Agnelline'), (u'Peter', u'Parker')]

"""}

def square_root(a, x):
    while True:
        print x
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y-x) < epsilon:
            return y
            break
        x = y

print square_root(4.0, 3.0)


# Function handling on list.



lst_a = [1, 2, 3, 4]
lst_b = [5, 6, 7, 8]

func_list = ['square', 'add', 'root']

def list_function(list, function):
    '''(list, function) -> list
    Apply a function to the values of a list and returns a new list.
    >>> list_function([1, 2, 3, 4], add)
    [2, 4, 6, 8]
    >>> list_function([1, 2, 3, 4], square)
    [1, 4, 9, 16]
    list_function([1, 2, 3, 4], root)
    [1.0, 1.4142135623730951, 1.7320508075688772, 2.0]
    '''
    for i in range(len(list)):
        list[i] = function(list[i])
    print list

def square(x):
    '''(number) -> number
    Returns the square of a given number x.
    >>> square(3)
    9
    >>> square(-2)
    4
    >>> square(0)
    0
    '''
    return x ** 2

def add(x):
    '''(number) -> number
    Returns the number added with it self.
    >>> add(3)
    6
    >>> add(-1)
    -2
    '''
    return x + x

def root(x):
    try:
        return x ** 0.5
    except ValueError, e:
        print str(e) + '''.
        List contains negative numbers.'''
    finally:
        print "Remove negative numbers from list and try again."

def choose():
    func_choose = raw_input("Choose function: square = 1, add = 2, root = 3 : ")
    if 1 == int(func_choose):
        return list_function(lst_a, square)
    elif 2 == int(func_choose):
        return list_function(lst_a, add)
    elif 3 == int(func_choose):
        return list_function(lst_a, root)


choose()
#!/usr/bin/env python3
import sys

def squareRoot(number):
	num1 = 1
	num2 = 0.5*(1+int(number))
	while abs(num1 - num2) > 0.0001:
		num2 = num1
		num1 = 0.5*(num2 + int(number)/num2)
	return num1;
	
	
print ("The square root of " + sys.argv[1] + " is " + str(squareRoot(sys.argv[1])))
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

import math


def square_root(a):
    x = 3.0
    epsilon = 0.000001
    while True:
        y = (x + (a/x))/2
        if abs(y-x) < epsilon:
            return y
            break
        x = y


def test_square_root(a):
    function = square_root(a)
    builtin = math.sqrt(a)
    diff = abs(function - builtin)
    return '%d    %.8f    %.8f    %.11g' % (a, function, builtin, diff)


def eval_loop():
    while True:
        line = raw_input('>>> ')
        if line == 'done':
            print 'DONE'
            break
        print eval(line)


if __name__ == '__main__':

    # for a in range(2, 37, 3):
        # print 'Square root of %d is %f' %(a, square_root(a))

    # for a in range(0, 10):
        # print test_square_root(a)

    # eval_loop()

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

__author__ = 'gokhan'

import math

# class declaration

class myFirstClass():
    print "myFirstClass"


    # contractor declaration
    def __init__(self, name):
        self.name = name
        print name

    # function declaration
    def myFirstFunction(self):
        print "myFirstFunction"

    # apply function

    def func(x, y, z): return x + y + z

    print apply(func, (2, 3, 4))
    f = lambda x, y, z: x + y + z
    print apply(f, (2, 3, 4))


    # programmer-defined exception


class NegativeNumberError(ArithmeticError):
    pass


def squareRoot(number):
    if number < 0:
        raise NegativeNumberError, "Square root of negative number not permitted"
    return math.sqrt(number)


while 1:
    try:
        userValue = float(raw_input("\nPlease enter a number: "))
        print squareRoot(userValue)
    # float raises ValueError if input is not numerical
    except ValueError:
        print "The entered value is not a number"
    # squareRoot raises NegativeNumberError if number is negative
    except NegativeNumberError, exception:
        print exception
    else:
        break

# -*- coding: utf-8 -*-
'''
  Square root digital expansion
  Problem 80
  It is well known that if the square root of a natural number is not an 
  integer, then it is irrational. The decimal expansion of such square roots is 
  infinite without any repeating pattern at all.

  The square root of two is 1.41421356237309504880..., and the digital sum of 
  the first one hundred decimal digits is 475.

  For the first one hundred natural numbers, find the total of the digital sums 
  of the first one hundred decimal digits for all the irrational square roots.

  Answer: 40886 Completed on Wed, 28 Jan 2015, 20:52
  https://projecteuler.net/problem=80
  
  @author Botu Sun
'''
import math

def sqrt(n, precision_digits=100):
  '''
  Calculate the square root of a integer with high precision.

  Uses digit-by-digit calculation found on:
  http://en.wikipedia.org/wiki/Methods_of_computing_square_roots

  Returns:
    The root with dot and the position of the dot.
  '''
  dot = 0
  count = 0
  root = 0
  current = 0
  while not (current == 0 and n == 0) and count < precision_digits:
    if n == 0:
      current *= 100
    else:
      tmp = n
      i = 0
      while tmp > 100:
        tmp /= 100
        i += 1
      n -= tmp * 100 ** i
      current = current * 100 + tmp
      dot += 1
    # Get trial root
    if root == 0: 
      x = int(math.sqrt(current))
    else:
      x = current / (20 * root)
    # Adjust
    while x * (20 * root + x) > current:
      x -= 1
    current -= x * (20 * root + x)
    root = root * 10 + x
    count += 1
  return root, dot

def sum_of_digits(n):
  sum = 0
  while n != 0:
    sum += n % 10
    n /= 10
  return sum

total = 0
for i in xrange(1, 100):
  if int(math.sqrt(i)) ** 2 != i:
    root, _ = sqrt(i, 100)
    total += sum_of_digits(root)
print total
def is_square(n):
	if n < 1: return False
	root = int(n**0.5)
	return root*root == n

def euler142():
	squares = [1]
	root = 2

	while True:
		square = root * root
		squares.append(square)

		for iy in range(len(squares)-1):
			y = square - squares[iy]
			if y % 2 != 0: continue
			y = y / 2

			x = square - y
			for iz in range(iy+1, len(squares)-1):
				if squares[iz] >= x: break

				z = x-squares[iz]
				if not is_square(x + z): continue
				if(is_square(y + z) and is_square(y - z)):
					return x + y + z

		root += 1

if __name__ == "__main__":
	print euler142()
from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

#Basic calculator project
import math
def cube(n):
    """
    Returns the cube of the number n
    """
    return n*n*n;

def squareroot(n):
    """
    Returns the square root of the number n. If n < 0, 
    then return the string "NAN" (not a number)
    """
    return math.sqrt(n);


def negate(n):
    """ Return negative n
    """
    return -n;

def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    return math.factorial(n)


import math
def factors(number):
	t = 0	
	square_root = int(math.sqrt(number))
	for i in range(square_root,0,-1):
		if number % i == 0:
			t = t + 1
	if number == pow(square_root,2):
		return (2 * t) - 1
	else:	
		return 2 * t

a,b,factor_count = 1,2,3
while factor_count < 500:
	a,b = a+1,b+1
	if a%2==0:
		factor_count = factors(a/2)*factors(b)-1
	else:
		factor_count = factors(a)*factors(b/2)-1

print "The Number = ",(a*b)/2," and Number of Factors=",factor_count

from django.db import models

class Square(models.Model):
    root = models.IntegerField()
    square = models.PositiveIntegerField()

    def __unicode__(self):
        return "%s ** 2 == %s" % (self.root, self.square)

class Person(models.Model):
    first_name = models.CharField(max_length=20)
    last_name = models.CharField(max_length=20)

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class SchoolClass(models.Model):
    year = models.PositiveIntegerField()
    day = models.CharField(max_length=9, blank=True)
    last_updated = models.DateTimeField()


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    def __unicode__(self):
        return u"%s %s" % (self.first_name, self.last_name)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter)

    def __unicode__(self):
        return self.headline

# Compute the square root of a real number
# Comlpexity = O(log n)

from __future__ import division

def square_root(val):

	if 0.0 < val < 1.0:
		l = float(val)
		u = 1.0

	if val >= 1.0:
		l = 1.0
		u = float(val)

	while (l + 0.0001 < u):
		m = l + (u-l)/2.0

		if ( (m*m) - 0.01 < val < (m*m) + 0.01 ):
			return m
		if (m * m > val):
				u = m
		if (m * m < val):
				l = m
		
print "%.5f" % square_root(9.0)
print "%.5f" % square_root(8.0)
print "%.5f" % square_root(25)
print "%.5f" % square_root(0.25)

def square_root(a):
    epsilon = 0.0000001
    x = a / 2
    while True:
        print(x)
        y = (x + a/x) / 2
        print(y)
        if abs(y-x) < epsilon:
            #break
            return y
        else:
            x = y
    #return x

print(square_root(25))

# Calculate the square root to a given precision
# Using Newtons Method - https://en.wikipedia.org/wiki/Newton%27s_method
def squareroot(number, precision = 5):
  root = number/2.0
  for i in range(20):
    nroot = (1/2.0)*(root + (number / root))
    #print i, nroot
    if (root - nroot < 1.0/10**precision):
      break
    root = nroot
  return round(nroot, precision)

#!/usr/bin/env python3

import decimal
import math
import sys

def is_square(number):
    root = int(round(math.sqrt(number)))
    return root ** 2 == number

def solve(N, P):
    decimal.getcontext().prec = P + 5
    return sum([sum(map(int, list(filter(lambda digit: digit != '.', list(str(decimal.Decimal(number).sqrt()))))[:P])) for number in range(1, N + 1) if not is_square(number)]) 

def main():
    print(solve(100, 100), file=sys.stderr)
    
    N = int(input())
    P = int(input())
    
    print(solve(N, P))

if __name__ == '__main__':
    main()

# Sqrt(x)
# Implement int sqrt(int x).
# Compute and return the square root of x.
#
# Example
# sqrt(3) = 1, sqrt(4) = 2, sqrt(5) = 2
#
#Challenge
# O(log(x))

class Solution:
    """
    @param x: An integer
    @return: The sqrt of x
    """
    def sqrt(self, x):
        # write your code here
        if x < 0: return None
        if x == 0: return 0
        
        start, end = 1, x
        while start + 1 < end:
            mid = start + (end - start) / 2
            if mid ** 2 > x:
                end = mid
            else:
                start = mid
            
        if end ** 2 <= x:
            return end
        return start
                

def print_square_root(x):
    if x <= 0:
        print "Positive numbers only, please."
        return

        result = x**0.5
        print "The square root of", x, "is", result
            

#! env python

# if a ^ 2 + b ^ 2 = c ^ 2
# and a + b + c = s
# then we can write a ^ 2 + b ^ 2 = (s - a - b) ^ 2

from math import sqrt

def hasRoot(x):
    a = x // 2
    seen = set([a])
    while a * a != x:
        a = (a + (x // a)) // 2
        if a in seen:
            return a, False
        seen.add(a)
    return a, True

a = 1
b = 1
found = False
while not found:
    c2 = a ** 2 + b ** 2
    c, isSquare = hasRoot(c2)
    if isSquare:
        if a + b + c == 1000:
            print(a * b * c)
            found = True
    if a + b + c > 1000:
        a += 1
        b = 0
    b += 1

__author__ = 'Brennan'

from euler5 import is_evenly_divisible
import itertools
import math


def is_prime(number):
    if number == 1:
        return False
    if number == 2:
        return True

    # we only need to check up to the sqrt of n.
    square_root = int(math.ceil(math.sqrt(number)))
    top_of_range = square_root + 1
    # we don't need to check any even numbers besides 2.
    range_to_check = itertools.chain([2], range(3, top_of_range, 2))

    for divisor in range_to_check:
        if is_evenly_divisible(divisor, number):
            return False
    return True


def get_nth_prime(n):
    prime_count = 0
    for x in itertools.count(1):
        if is_prime(x):
            prime_count += 1
            print("prime " + str(prime_count) + ": " + str(x))
        if prime_count == n:
            return x


            # print(get_nth_prime(10001))
from Tkinter import Tk, Canvas, Frame, Button, BOTH, TOP, BOTTOM, LEFT
import tkMessageBox

MARGIN = 20  # Pixels around the board
SIDE = 50  # Width of every board cell.
WIDTH = HEIGHT = MARGIN * 2 + SIDE * 9  # Width and height of the whole board

def mapping(row, col):
    return [a+b for a in row for b in col]

digits = '123456789'
rows = 'ABCDEFGHI'
cols = digits
squares = mapping(rows, cols)
unitlist = ([mapping(rows, c) for c in cols] + [mapping(r, cols) for r in rows] + [mapping(rs, cs) for rs in ('ABC', 'DEF', 'GHI') for cs in ('123', '456', '789')]) #cols, rows, boxes
units = dict((square, [u for u in unitlist if square in u]) for square in squares) #col, row, and box for each square
peers = dict((square, set(sum(units[square],[]))-set([square])) for square in squares) #unit for each square in unit of s, but not s

#possibilities is dict mapping each square to every value it can have
#possibilities[s] is specific square

def parse_grid(board):
    possibilities = dict((square, digits) for square in squares) #each square has every possible answer
    for square,digit in grid_values(board).items():
        if digit in digits and not assign(possibilities, square, digit): #assign if d is a digit
            return False
    return possibilities

def grid_values(board):
    values = [c for c in board if c in digits or c in '0.'] #list of squares values (0 or . for empty/unknown squares)
    return dict(zip(squares, values)) #map each square to its value

def assign(possibilities, square, digit):
    other_possibilities = possibilities[square].replace(digit, '') #other_values is every possiblity except digit
    if all(remove(possibilities, square, d2) for d2 in other_possibilities): #if those values are all invalid, found answer
        return possibilities
    else:
        return False

def remove(possibilities, square, digit): #eliminate d from values[s]
    if digit not in possibilities[square]:
        return possibilities #eliminated
    
    possibilities[square] = possibilities[square].replace(digit, '') #remove possibility from square
    
    if len(possibilities[square]) == 0:
        return False #removed last value, should be impossible
    
    elif len(possibilities[square]) == 1:
        d2 = possibilities[square]
        if not all(remove(possibilities, s2, d2) for s2 in peers[square]): #should be impossible
            return False
        
    for u in units[square]:
        dplaces = [square for square in u if digit in possibilities[square]] #valid places to put d
        if len(dplaces) == 0: #no valid places
            return False
        elif len(dplaces) == 1:
            if not assign(possibilities, dplaces[0], digit):
                return False
    return possibilities

def search(possibilities):
    if possibilities is False:
        return False
    if all(len(possibilities[square]) == 1 for square in squares): #if each square has one solution, solved
        return possibilities
    n, square = min((len(possibilities[square]), square) for square in squares if len(possibilities[square]) > 1) #find square with min guesses not already solved
    return find_element(search(assign(possibilities.copy(), square, digit)) for digit in possibilities[square]) #for each square, reduce the possiblities, go through each square (depth first)

def find_element(values):
    for e in values:
        if e:
            return e
    return False

class SudokuUI(Frame):
    
    def __draw_puzzle(self):
        self.canvas.delete("numbers")
        for i in xrange(9):
            for j in xrange(9):
                answer = self.puzzle[i][j]
                if answer != 0:
                    x = MARGIN + j * SIDE + SIDE / 2
                    y = MARGIN + i * SIDE + SIDE / 2
                    color = "black"
                    self.canvas.create_text(
                        x, y, text=answer, tags="numbers", fill=color
                    )

    def __draw_grid(self):
        """
        Draws grid divided with blue lines into 3x3 squares
        """
        for i in xrange(10):
            color = "blue" if i % 3 == 0 else "gray"

            x0 = MARGIN + i * SIDE
            y0 = MARGIN
            x1 = MARGIN + i * SIDE
            y1 = HEIGHT - MARGIN
            self.canvas.create_line(x0, y0, x1, y1, fill=color)

            x0 = MARGIN
            y0 = MARGIN + i * SIDE
            x1 = WIDTH - MARGIN
            y1 = MARGIN + i * SIDE
            self.canvas.create_line(x0, y0, x1, y1, fill=color)

    def __initUI(self):
        self.parent.title("Sudoku Solver")
        self.pack(fill=BOTH)
        self.canvas = Canvas(self,
                             width=WIDTH,
                             height=HEIGHT)
        self.canvas.pack(fill=BOTH, side=TOP)

        f = Frame(width=100)
        f.pack()

        solve_button = Button(f, text="Solve", command=self.__solve)
        solve_button.pack(side=LEFT)

        clear_button = Button(f, text="Clear", command=self.__clear)
        clear_button.pack(side=LEFT)


        self.__draw_grid()
        self.__draw_puzzle()

        self.canvas.bind("<Button-1>", self.__cell_clicked)
        self.canvas.bind("<Key>", self.__key_pressed)
        self.canvas.bind("<Left>", self.__go_left)
        self.canvas.bind("<Right>", self.__go_right)
        self.canvas.bind("<Up>", self.__go_up)
        self.canvas.bind("<Down>", self.__go_down)
    
    def __init__(self, parent):
        Frame.__init__(self, parent)
        self.parent = parent

        self.row, self.col = -1, -1

        self.puzzle = []

        for i in range(9):
            self.puzzle.append([])
            for j in range(9):
                self.puzzle[i].append(0)

        self.convert()

        self.__initUI()

    def reset(self):
        for i in range(9):
            for j in range(9):
                self.puzzle[i][j] = 0

    def convert(self):
        self.string = ''.join([str(cell) for sub in self.puzzle for cell in sub])

    def __draw_cursor(self):
        self.canvas.delete("cursor")
        if self.row >= 0 and self.col >= 0:
            x0 = MARGIN + self.col * SIDE + 1
            y0 = MARGIN + self.row * SIDE + 1
            x1 = MARGIN + (self.col + 1) * SIDE - 1
            y1 = MARGIN + (self.row + 1) * SIDE - 1
            self.canvas.create_rectangle(
                x0, y0, x1, y1,
                outline="red", tags="cursor"
            )

    def __cell_clicked(self, event):
        x, y = event.x, event.y
        if (MARGIN < x < WIDTH - MARGIN and MARGIN < y < HEIGHT - MARGIN):
            self.canvas.focus_set()

            # get row and col numbers from x,y coordinates
            row, col = (y - MARGIN) / SIDE, (x - MARGIN) / SIDE

            #if cell was selected already - deselect it
            if (row, col) == (self.row, self.col):
                self.row, self.col = -1, -1
            else:
                self.row = row
                self.col = col
        else:
            self.row, self.col = -1, -1

        self.__draw_cursor()

    def __go_up(self, event):
        if self.row >= 1 and self.row <= 8:
            self.row -= 1
            self.__draw_cursor()

    def __go_down(self, event):
        if self.row >= 0 and self.row <= 7:
            self.row += 1
            self.__draw_cursor()

    def __go_right(self, event):
        if self.col >= 0 and self.col <= 7:
            self.col += 1
            self.__draw_cursor()

    def __go_left(self, event):
        if self.col >= 1 and self.col <= 8:
            self.col -= 1
            self.__draw_cursor()

    def __key_pressed(self, event):
        if self.row >= 0 and self.col >= 0 and event.char in "1234567890":
            self.puzzle[self.row][self.col] = int(event.char)
            #self.col, self.row = -1, -1
            self.__draw_puzzle()
            self.__draw_cursor()        

    def __clear(self):
        self.reset()
        self.__draw_puzzle()

    def __solve(self):
        self.convert()
        raw = search(parse_grid(self.string))

        if raw == False:
            tkMessageBox.showinfo("Error", "Your sudoku is invalid. Check your input again")

        else:
            it = iter(sorted(raw.items()))

            temp = []
            i = 0
            
            while i < 81:
                temp.append(it.next()[1])
                i += 1

            for i in range(9):
                for j in range(9):
                    self.puzzle[i][j] = temp[i*9 + j]

            self.__draw_puzzle()
        
def main():
    root = Tk()
    SudokuUI(root)
    root.geometry("%dx%d" % (WIDTH, HEIGHT + 40))
    root.mainloop()

if __name__ == '__main__':
    main()

import math


def polignac(num, p):
    """
    input: num can be any positive integer and p and prime number.

    output: Gives the total number of factors of p in num! (num factorial).
    Stated another way, this function returns the total number of factors
    of p of all numbers between 1 and num; de Polignac's formula is pretty 
    nifty if you are into working with prime numbers.
    """
    factorsDict = {}
    if num > 1 and p == 1:
        print("Invalid entry since 1 is the identity.")
    else:
        while num > 1:
            factorsDict[num // p] = num // p
            num = num // p
        return sum(factorsDict)


def primes():
    '''Yields the sequence of primes via the Sieve of Eratosthenes.'''
    yield 2                 # Only even prime.  Sieve only odd numbers.

    # Generate recursively the sequence of primes up to sqrt(n).
    # Each p from the sequence is used to initiate sieving at p*p.
    roots = primes()
    root = roots.next()
    square = root * root

    # The main sieving loop.
    # We use a hash table D such that D[n]=2p for p a prime factor of n.
    # Each prime p up to sqrt(n) appears once as a value in D, and is
    # moved to successive odd multiples of p as the sieve progresses.
    D = {}
    n = 3
    while True:
        if n >= square:     # Time to include another square?
            D[square] = root + root
            root = roots.next()
            square = root * root

        if n not in D:      # Not witnessed, must be prime.
            yield n
        else:               # Move witness p to next free multiple.
            p = D[n]
            q = n + p
            while q in D:
                q += p
            del D[n]
            D[q] = p
        n += 2


def limite(n, p):
    return(int(math.log(n) / math.log(p)))
print(limite(1000, 3))

MAX = 100

result = {}
for p in primes():
    if p >= MAX:
        break
    lim = limite(MAX, p)
    result[p] = sum(int(MAX / p ** i) for i in range(1, lim + 1))


keys=result.keys()
keys.sort()
for k in keys:
    print(k,result[k])

import math
import sys


# class Button(QToolButton):
#     def __init__(self, text, parent=None):
#         super(Button, self).__init__(parent)
#         self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
#         self.setText(text)

#     def sizeHint(self):
#         size = super(Button, self).sizeHint()
#         size.setHeight(size.height() + 20)
#         size.setWidth(max(size.width(), size.height()))
#         return size


class Calculator(QWidget):
    NumberDigit = 10

    def __init__(self, parent=None):
        self.Pi = math.pi
        self.e = math.e
        self.factorial_memo = {0: 1, 1: 1}

    def add(self, a, b):
        return a + b

    def sub(self, a, b):
        return a - b

    def multiply(self, a, b):
        return a * b

    def divide(self, a, b):
        return a / b

    def mod(self, a, b):
        return a % b

    def power(self, a, b):
        return a ** b

    def factorial(self, a):
        if a not in self.factorial_memo:
            self.factorial_memo[a] = self.factorial(a-1) * a

        return self.factorial_memo[a]

    def log(self, number, base):
        return math.log(number, base)

    def square_root(self, number):
        return math.sqrt(number)

'''
Created on 31 May 2015

@author: Piers
'''
import unittest

def difference_is_less_than(number_1, number_2, precision):
    print number_1, number_2, precision, abs(number_1 - number_2)
    return abs(number_1-number_2) <= precision

def decirange(start, stop, step_size):
    i = float(start)
    while True:
        print 'yielding %s' % i
        yield i
        i += float(step_size)
        if i > stop:
            raise StopIteration()

def sqr_root(number, precision):
    """return an approximation of the square root of number
    
    precision is the max difference between the real square root and the value returned
    e.g. sqr_root(1.44,1) = 1
    sqr_root(1.44, 0.1) = 1.2
    """
    
    for guess in decirange(1,number,0.05):
        print guess
        square = guess*guess
        if difference_is_less_than(square, number, precision):
            break
    return guess

class TestSqrRoot(unittest.TestCase):
    def test_15_1(self):
        self.assertEqual(sqr_root(15,1), 4)
         
    def test_15_2(self):
        self.assertEqual(sqr_root(15,0.1), 3.9)
         
#     def test_169_1(self):
#         self.assertEqual(sqr_root(169,0.1), 13)

# class TestDecirange(unittest.TestCase):
#     def test_simple(self):
#         for i in decirange(1,2,0.1):
#             print i
def testable(x):
    r"""
    The `testable` function returns the square root of its
    parameter, or 3, whichever is larger.
    >>> testable(7)
    3.0
    >>> testable(16)
    4.1
    >>> testable(9)
    3.0
    >>> testable(10) == 10 ** 0.5
    True
    """
    if x < 9:
        return 3.0
    return x ** 0.5

