def mySqrt():
    print()
    print ('***Square Root Calculator***')
    print()
    print ('Please enter your number of choice:')

    x = int(input())

    time.sleep(2)

    """Returns the square root of x if x is a perfect square.
Prints an error message and returns none if otherwise."""


def square_fun(params):
    """
    Square the scalar input
    """
    return {"value": params["n"] ** 2}


def root_fun(params):
    """
    Find the root of the scalar input
    """
    return {"value": math.sqrt(params["n"])}


def one_plus_inverse(params):
    if params["n"] == 0:
        return {"value": None}


def wait_5_secs(params):
    time.sleep(5)
    return {"value": 1}


def __unicode__(self):
    return "%s ** 2 == %s" % (self.root, self.square)


def __unicode__(self):
    return u'%s %s' % (self.first_name, self.last_name)


def r8_sqrt_i4(i):

    from math import sqrt

    value = sqrt(float(i))

    return value


def bisect(square, left_end=0, right_end=None):
    """
    Square root realisation using bisection method.
    Usage:
    bisect(square, left_end, right_end)
    where square - number from which root is extracted,
    and left_end, right_end are the ends of segment where we're looking for root, optional parameters

    >>> bisect(18)
    4
    >>> bisect(9)
    3
    >>> bisect(100, 0, 50)
    10

    :type square int
    :type left_end int
    :type right_end int
    """

    if square < 0:
        raise ValueError('Cannot extract root of negative number')
    if right_end is None:
        right_end = square
    if right_end - left_end <= 1:
        return rounding_correction(lambda x: x * x - square, [right_end])


def error(x):
    return abs(func(x))


def get_roots(a, b, c, discr):
    """
    Main solver

    >>> get_roots(1, -4, 4, 0)
    [2, 2]
    >>> get_roots(50, -225, 253, 25)
    [2, 2]

    :type a int
    :type b int
    :type c int
    :type discr int
    """
    doub_a = a << 1
    sqrt_discr = bisect(discr)
    t1 = - b - sqrt_discr
    t2 = - b + sqrt_discr
    root_l = t1 / doub_a
    root_r = t2 / doub_a

    roots = rounding_correction(
        lambda x: a * x ** 2 + b * x + c, [root_l, root_r])
    return roots


def square_root(N):
    guess = 1.0
    while abs(N - guess ** 2) > 0.000000000000001:
        quotient = N / guess
        guess = (guess + quotient) / 2.0
    return guess


def ask_for_number():
    """Asks user for a positive number"""
    number = 0
    while True:
        if number > 0:
            return number




def euclid(a, b):
    if b == 0:
        return a


def extended_euclid(a, b):
    """Returns (s, t) where as + bt = gcd(a, b)"""
    if b == 0:
        return (1, 0)


def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a


def totient(n):
    """Brute force computation of Euler's totient (not for large n)."""
    return [i for i in range(n) if gcd(i, n) == 1]


def is_primitive_root(g, q):
    reached = []
    x = g
    while True:
        if x in reached:
            break
        reached.append(x)
        x = (x * g) % q
    return len(reached) == q - 1


def square(x):
    return x * x


def mod_exp(a, b, q):
    if b == 0:
        return 1


def generator_permutation(g, q):
    return [mod_exp(g, i, q) for i in range(1, q)]


def primitive_roots(q):
    """Brute force search for primitive roots of a prime q."""
    return [i for i in range(1, q) if is_primitive_root(i, q)]


def __unicode__(self):
    return u"%s %s" % (self.first_name, self.last_name)


def __unicode__(self):
    return self.headline


def squareroot(number):
    estimate = number / 2
    epsilon = 0.000000000001

    while True:

        root = 0.5 * (estimate + number / estimate)
        if abs(root - estimate) < epsilon:
            return root


def square_root(a):
    a = float(a)
    x = a / 2
    while True:
        y = (x + a / x) / 2
        if x == y:
            break
        x = y
    return x


def square(x):
    return x ** 2


def sum_(*args):
    return sum(args)


def sqrt(square):
    print '** taking square root of {:.2f}'.format(square)
    return math.sqrt(square)


def update_chessboard(self, data):
    data = data[::-1]
    in_table = 'prnbqkx-RNBQKPX'
    out_table = 'prnbqkx tmvwloX'
    tran_table = maketrans(in_table, out_table)
    pieces = converted_data = list(data.translate(tran_table, ' <12>'))
    col = False, True
    colour_square = ((col[0], col[1]) * 4 + (col[1], col[0]) * 4) * 4
    file_board = [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 4),
                  ('f', 5), ('g', 6), ('h', 7), ]
    rank_board = [('8', 7), ('7', 6), ('6', 5), ('5', 4), ('4', 3), ('3', 2),
                  ('2', 1), ('1', 0), ]
    pieces = ''
    for x, y in zip(colour_square, converted_data):
        if x and y != chr(32):
            pieces = pieces + (y.upper())
        elif x and y == chr(32):
            pieces = pieces + ('+')
        else:
            pieces = pieces + y

    square = list(
        [(7 * self.square_size - x[1] * self.square_size,
          y[1] * self.square_size,
          x[0] + y[0],
          pieces[(y[1] * 8) + x[1]],)
         for y in rank_board for x in file_board]
    )
    self.chessboard.delete(ALL)
    for x in square:
        self.output = self.chessboard.create_text(x[0] + self.square_size / 2,
                                                  x[1] +
                                                  self.square_size / 2,
                                                  fill='black', font=('Chess Cases',
                                                                      self.font_size,
                                                                      'normal'))
        self.chessboard.itemconfig(self.output, text=x[3])
    self.chessboard.update_idletasks()
    return


def Square(x):
    return SquareHelper(abs(x), abs(x))


def SquareHelper(n, x):
    if n == 0:
        return 0


def __eq__(self, other):
    ''' (GameStateNode, object) -> bool

    Return whether this GameStateNode is equivalent to other, i.e., they
    contain equivalent GameStates, and equivalent children.  The order of
    their children does not matter.

    >>> s1 = SubtractSquareState('p1', current_total = 6)
    >>> s2 = SubtractSquareState('p2', current_total = 5)
    >>> s3 = SubtractSquareState('p1', current_total = 2)
    >>> leaf1 = GameStateNode(s1)
    >>> leaf2 = GameStateNode(s2)
    >>> leaf3 = GameStateNode(s3)
    >>> leaf1.__eq__(leaf2)
    False
    >>> root1 = GameStateNode(s1)
    >>> root1.children = [s2, s3]
    >>> root2 = GameStateNode(s1)
    >>> root1.__eq__(root2)
    False
    >>> root2.children = [s2, s3]
    >>> root1.__eq__(root2)
    True
    '''

    return (type(self) == type(other) and


def __str__(self):
    ''' (GameStateNode) -> str

    Return a convenient string representation of GameStateNode(self).

    >>> s = SubtractSquareState('p1', current_total = 17)
    >>> node = GameStateNode(s)
    >>> print(node)
    Current total: 17; next player: p1
    '''
    return self.value.__str__()


def same_contents(L1, L2):
    ''' (list, list) -> bool

    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.

    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and


def _nodes(root):
    ''' (GameStateNode) -> list

    Return the list of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_nodes(root))
    13
    '''
    nodes = [root]
    for node in root.children:
        nodes += _nodes(node)
    return nodes


def node_count(root):
    ''' (GameStateNode) -> int

    Return the number of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    return len(_nodes(root))


def _leafs(root):
    '''(GameStateNode) -> list

    Return the list of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_leafs(root))
    4
    '''
    leafs = []
    if root.value.over:
        leafs.append(root)
    for node in root.children:
        leafs += _leafs(node)
    return leafs


def leaf_count(root):
    '''(GameStateNode) -> int

    Return the number of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    return len(_leafs(root))


def _distinct_nodes(root):
    '''(GameStateNode) -> set

    Return the set of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_nodes(root))
    10
    '''
    nodes = set()
    nodes.add(str(root))
    for node in root.children:
        nodes |= _distinct_nodes(node)
    return nodes


def distinct_node_count(root):
    '''(GameStateNode) -> int

    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    return len(_distinct_nodes(root))


def _distinct_leafs(root):
    '''(GameStateNode) -> set

    Return the set of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_leafs(root))
    2
    '''
    leafs = set()
    if root.value.over:
        leafs.add(str(root))
    for node in root.children:
        leafs |= _distinct_leafs(node)
    return leafs


def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int

    Return the number of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    return len(_distinct_leafs(root))


def branching_stats(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    result = {}
    nodes = _nodes(root)
    for i in range(len(nodes)):
        count = 0
        for node in nodes:
            if len(node.children) == i:
                count += 1
        if count > 0:
            result[i] = count
    return result


def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]

    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    leafs = _leafs(root)
    p1 = p2 = tie = 0
    for leaf in leafs:
        if leaf.value.winner("p1"):
            p1 += 1
        elif leaf.value.winner("p2"):
            p2 += 1
        else:
            tie += 1
    return [p1, p2, tie]


def _games(root, games=[], t=[]):
    '''(GameStateNode, games, t) -> list of list

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_games(root))
    4
    '''
    t = t + [root]
    if root.value.over:
        games = games + [t]
    for node in root.children:
        games = _games(node, games, t)
    return games


def game_lengths(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    result = {}
    games = _games(root)
    for game in games:
        lenght = len(game) - 1
        result[lenght] = result.get(lenght, 0) + 1
    return result


def game_descriptions(root):
    ''' (GameStateNode) -> list of str

    Return a list containing a str describing each complete game that is
    possible from the game stored at root.

    Assume root is the root of a game state tree specifically for the game
    Subtract Square.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    descriptions = []
    games = _games(root)
    for game in games:
        abbreviateds = [abbreviated(node.value) for node in game]
        description = " -> ".join(abbreviateds)
        if game[-1].value.winner("p1"):
            description += " = p1 wins!"
        elif game[-1].value.winner("p2"):
            description += " = p2 wins!"
        else:
            description += " = tie!"
        descriptions.append(description)
    return descriptions


def abbreviated(s):
    '''(GameState) -> str

    Return an abbreviated str representation of SubtractSquareState s.
    '''

    return "{}:{}".format(s.next_player, s.current_total)


def matches_template(nr):
  nr_str = str(nr)
  return (len(nr_str) == 19 and


def solve():
    min_root = 1010101010
    max_root = 1389026620
    for root in range(min_root, max_root + 1, 10):
        square = root * root
        if matches_template(square):
            return root


def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x = 1
    xOld = 1
    while True:
        aux = (x + (n / x)) / 2
        if aux == x:
            return x


def check(x):
    n = x * x
    for x in pattern:
        if n % 10 != x:
            return False


def solve():
    start = iSqrt(19293949596979899)
    start /= 10
    n = start
    while n > 0:
        if check(10 * n + 3):
            return 100 * n + 30


def sqrt(x):
    return math.sqrt(x)


def getFunctionByKey(key):
    for func in function_list:
        if key == func.key:
            return func


def square_root(N, accuracy=0.000001, guess=1.0):

    while abs(N - guess ** 2) > accuracy:
        quotient = N / guess
        guess = (guess + quotient) / 2.0
    return guess


def factors(num):
    """Finds all the factors of a given number and returns them as a list."""


def get_primes(n):
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    sieve = numpy.ones(n / 3 + (n % 6 == 2), dtype=numpy.bool)
    for i in xrange(1, int(n ** 0.5) / 3 + 1):
        if sieve[i]:
            k = 3 * i + 1 | 1
            sieve[k * k / 3::2 * k] = False
            sieve[k * (k - 2 * (i & 1) + 4) / 3::2 * k] = False
    return numpy.r_[2, 3, ((3 * numpy.nonzero(sieve)[0][1:] + 1) | 1)]


def squareroot(a, b):
    a1 = a * a
    b1 = b * b
    c = a1 + b1
    result = math.sqrt(c)
    print("Result of square root of a %d and b %d is %c", a, b, result)
    if result.is_integer() == False:
        return 0


def squareCypher(s):
    from math import sqrt
    s = s.replace(' ', '')

    root = sqrt(len(s))
    cols = int(root) + 1 if root % 1 else int(root)

    result = ''
    for i in range(cols):
        for j in range(cols):
            index = j * cols + i
            if index < len(s):
                result += s[index]

        result += ' '

    return result




def example_function(x):
    """Compute the square root of x and return it."""


def square_root(x):
    return np.sqrt(x)


def countNodes(self, root):
    if root is None:
        return 0


def is_square(n):
    root = int(math.sqrt(n))
    if root * root == n:
        return True


def count_side(a, b):
    n_pt = 0

    for x in range(0, a + 1):
        for y in range(0, b + 1):
            if y * a == -b * x + a * b:
                n_pt += 1
    return n_pt


def calc_twice_area(a, b, c, d):
    area = 0
    area += a * b
    area += a * d
    area += d * c
    area += b * c

    return area


def hasOddRootPeriod(a):
    return getRootPeriod(a) % 2 == 1


def getRootPeriod(a):
    l = help.conFraction(a)
    return len(l) - 1


def is_anagram(a, b):
    """
    Check if a is an anagram of b
    """
    return set(str(a)) == set(str(b))


def is_palindrom(n):
    return str(n)[::-1] == str(n)


def sqrt_n(value, exponent):
    return pow(value, 1.0 / exponent)


def visitNumber(self, number):
    return int(number.value.value)


def visitPlus(self, plus):
    return plus.left.accept(self) + plus.right.accept(self)


def visitMul(self, mul):
    return mul.left.accept(self) * mul.right.accept(self)


def visitPower(self, power):
    return pow(power.value.accept(self), power.power.accept(self))


def visitSquareRoot(self, sqrt):
    return sqrt_n(sqrt.value.accept(self), sqrt.sqrtpower.accept(self))


def visitEquation(self, eq):
    return


def visitNumber(self, number):
    return "{}".format(number.value)


def visitPlus(self, plus):
    return "({} + {})".format(plus.left.accept(self),


def visitMul(self, mul):
    return "({} * {})".format(mul.left.accept(self),


def visitPower(self, power):
    return "pow({}, {})".format(


def visitSquareRoot(self, sqrt):
    return "sqrt_n({}, {})".format(


def visitEquation(self, eq):
    return "{} = {}".format(eq.left.accept(self), eq.right.accept(self))


def accept(self, visitor):
    return visitor.visitSquareRoot(self)


def accept(self, visitor):
    return visitor.visitPower(self)


def accept(self, visitor):
    return visitor.visitMul(self)


def accept(self, visitor):
    return visitor.visitPlus(self)


def accept(self, visitor):
    return visitor.visitNumber(self)


def accept(self, visitor):
    return visitor.visitEquation(self)


def Sqrt(x, e):
    if x == 0:
        return 0


def avg(vals):
    """Calculate average of values in list."""
    return sum(vals) / float(len(vals))


def disp(y_1, y_2):
    """Calculate sum of differences between f[] and y[] values."""
    total = 0
    for i in range(min(len(y_1),
                       len(y_2))):
        total += (y_1[i] - y_2[i]) ** 2

    return total


def std(y_1, y_2):
    """Calculate square root of dispersion."""
    return math.sqrt(disp(y_1, y_2))


def createRowLinkedList(inputList):
    parseSquare(inputList)

    rowHead = extendRowRight(inputList)

    return rowHead


def extendRowRight(inputList):
    input = inputList[0]
    square = parseSquare(input)

    if len(inputList[1::]) > 0:
        square.nextSquare = extendRowRight(inputList[1::])
        return square


def parseSquare(input):
    square = Square()
    if input == 'DW':
        square.wordBonus = 2
    elif input == 'TW':
        square.wordBonus = 3
    elif input == 'DL':
        square.letterBonus = 2
    elif input == 'TL':
        square.letterBonus = 3
    else:
        square.tile = input

    return square


def return_all_factors(n):


def get_number_of_factors(n):
    square_root = numpy.sqrt(n)
    number_of_factors = 0
    if n % square_root == 0:
        number_of_factors = -1

    for i in range(1, int(square_root) + 1):
        if n % i == 0:
            number_of_factors += 2
    return number_of_factors


def do_problem_12_try2(max_factors):
    """method is too slow! -after several hours no result: up to triangle number: 63850650"""
    number_of_factors = 0
    n = 0

    while number_of_factors <= max_factors:
        n = n + 1
        number_of_factors = get_number_of_factors(
            Problem_001.sum_of_all_whole_numbers(n))

    dictionary = {}

    dictionary[Problem_001.sum_of_all_whole_numbers(n)] = return_all_factors(
        Problem_001.sum_of_all_whole_numbers(n))


def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            return y


def square_root(n, start=None, end=None):
    if start is None:
        start = 1
    if end is None:
        end = n
    mid = (end + start) / 2
    print (start, end, mid)
    squared_n = mid * mid
    if squared_n == n:
        return mid


def is_palindromic(num):
    return str(num) == str(num)[::-1]


def approx_sqrt(a, g):
    """ Returns the aproximation of the square root of the first parameter accurate to ten decimal places. The second parameter is your guess of what the square root is.
    """
    import math
    if g < 0:
        print 'The square root of a number is never negative. Guess a positive value'
        return


def eval_loop():
    while True:
        r = raw_input('Mathematical expression = ')
        if r == 'done' or r == 'Done':
            break
        print eval(r)
    print 'Done!'
    return


def magnitude(v):
    return math.sqrt(sum(v[i] * v[i] for i in range(len(v))))


def add(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(x) for x in zip(u, v)]
    else:
        utils.error('Vectors are of different length (utils_math: add)')
    return a


def sub(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [u[i] - v[i] for i in range(len(u))]
    else:
        utils.error('Vectors are of different length (utils_math: sub)')
    return a


def dot(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(u[i] * v[i] for i in range(len(u)))]
        print('\n', a, '\n')
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a


def normalize(v):
    vmag = magnitude(v)
    return [v[i] / vmag for i in range(len(v))]


def squareRoot(list):
    return [math.sqrt(x) for x in list]


def square(list):
    return [x ** 2.0 for x in list]


def fft(signal):
    n = len(signal)
    if n == 1:
        return signal


def sqrt(x):
    """
    Trivial square root implementation.
    """
    return x ** 0.5


def dot(x, y):
    """
    Compute the dot product of two equal length vectors, `x`, and `y`.
    """
    return sum(n * m for n, m in izip(x, y))


def findroot(anum):
    """
    Find square root of a number
    """
    try:
        time.sleep(10)
        return math.sqrt(anum)


def minimal_solution(D):

    root = int(math.sqrt(D)) + 1
    while True:
        left = root * root - 1
        if left % D == 0:
            if primes.is_square(left / D):
                return root


def solve66(max_D):
    largest = 0
    for D in range(max_D):
        if not primes.is_square(D):
            min_solution = minimal_solution(D)
            if min_solution > largest:
                print min_solution
                largest = min_solution
    return largest


def is_prime(n):

    for i in range(0, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False


def square(x, delta):
    start = 1
    end = x
    if (x < 1):
        start = 0
    sq = float(end + start) / 2

    while(abs(sq * sq - x) > delta):
        if (sq * sq > x):
            end = sq
        else:
            start = sq
        sq = (end + start) / 2
    return sq








def subtract(x, y):
    return x - y


def add(x, y):
    return x + y


def power(x, y):
    return x ** y


def multiply(x, y):
    return x * y


def divide(x, y):
    return x / y


def square(x):
    return x ** 2


def sqr_root(x):
    return x ** 0.5


def find_root(a, b):
    i = float(a)
    step = float(b)
    return step - ((step ** 2 - i) / (2 * step))


def square_root(in_put, precision):
    """
    :param input: Takes an input number
    :param precision: Takes a precision to output
    :return: The square root of the input number
    """
    in_put = float(in_put)
    precision = 1 / (10 ** float(precision))

    if in_put < 0:
        raise Exception("The square root of a negative number is non-real")
    elif in_put == 0:
        return 0


def func(a, n):
    return (


def get_continued_fraction(square_root_argument):
    first_appearance = {}
    sequence = []
    square_root_floor = int(math.sqrt(square_root_argument))
    if square_root_floor ** 2 == square_root_argument:
        return [square_root_floor], []


def main():
    odd_period_count = 0
    max_period = 0
    max_period_argument = 0
    for n in xrange(10001):
        period = len(get_continued_fraction(n)[1])
        if period > max_period:
            max_period = period
            max_period_argument = n
        if period % 2 == 1:
            odd_period_count += 1
    return odd_period_count


def square_root(a):
    epsilon = 0.0000001
    x = a / 2.0
    while True:
        print x
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def is_prime(exponent):
    for k in range(0, 10000000):
        p = 10 ** exponent + k
        a = gmpy2.powmod(2, p - 1, p)

        if (a == 1):
            print "k = ", k
            return


def square_roots(base, prime):
    exponent = (prime + 1) / 4
    root_1 = (base ** exponent) % prime
    root_2 = prime - root_1

    print "\n"
    print "first root = %i \nsecond root = %i\n" % (root_1, root_2)
    return


def probable_prime(prime, count):
    for k in range(1, 10000000):
        p = prime + k
        a = gmpy2.powmod(2, p - 1, p)

        if (a == 1):
            print "k = ", k
            count += 1

            if count == 4:
                return


def problem7():
    return find_prime_by_index(10001)


def find_prime_by_index(i):
    return generate_fixed_amount_of_primes(i)[-1]


def generate_fixed_amount_of_primes(n):
    assert(n > 0)
    primes = [2, 3]
    current_number = primes[1]
    while (len(primes) < n):
        current_number += 2
        square_root = math.floor(math.sqrt(current_number))
        prime = True
        for p in primes:
            if p > square_root:
                break
            elif current_number % p == 0:
                prime = False
                break

        if prime:
            primes.append(current_number)
    return primes[:n]


def is_prime(num):

    for i in range(2, num / 2):
        if num % i == 0:
            return False


def highest_factor(num):
    square_root = int(math.sqrt(num))

    for i in reversed(range(2, square_root)):
        if num % i == 0:
            if is_prime(i):
                return i


def square_root(a):
    x = a / 3.0
    epsilon = 0.000000000001
    while abs(a - (x ** 2)) > epsilon:
        x = (x + a / x) / 2
    return x


def root_mean_square(self):
    """
    Find the root-dimension_means-square error for the given regression
    :return:
    """
    N = len(self.d_mat)

    guess_sum = 0
    for i in range(N):
        guess_sum += (self.t_vec[i][0] - self.predict(i)) ** 2

    return np.sqrt((1 / N) * guess_sum)


def square(x):
    """Returns the square of a number."""
    return x * x


def average(x, y):
    """Returns the average of two numbers."""
    return (x + y) / 2


def my_abs(x):
    """Returns the absolute value of x."""
    if x < 0:
        return -x


def sqrt(x, guess, error):
    """Recursive version."""
    if my_abs(square(guess) - x) < error:
        return guess


def newton(a, x):
    return (x + (a / x)) / 2.0


def sqrt2(x, debug=False):
    '''
    square root of a give number
    '''
    if x == 0:
        return 0


def sqrt(self, x):
    if x < 0:
        return -1


def sqrt2(self, x):
    if x < 0:
        return -1


def is_twice_square(num):
    square_root = sqrt(num / 2)
    return square_root == int(square_root)


def P046():
    primes = [_ for _ in sieve(10000)]
    found = True
    i = 1

    while (found):
        found = False
        i += 2
        j = 0

        while (i >= primes[j]):
            if is_twice_square(i - primes[j]):
                found = True
                break
            j += 1

    return i


def drag(self, event):

    mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
    mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
    event_grid = self.frame.grid_location(mouse_x, mouse_y)
    event_x, event_y = [int(i) for i in event_grid]

    if event_x < 0:
        event_x = 0
    elif event_x >= self.x:
        event_x = self.x - 1

    if event_y < 0:
        event_y = 0
    elif event_y >= self.y:
        event_y = self.y - 1

    event_square = self.squares["{0},{1}".format(event_x, event_y)]

    if self.drag_coord != -1:
        self.drag_mark(event_square, event_x, event_y)
        return None


def __call__(self):
    return "{0},{1}".format(self.x, self.y)


def state(self):
    return self.__state


def prev_state(self):
    return self.__prev_state


def dragged(self):
    return self.__dragged


def start(self):
    self.root.mainloop()
    return self.cause


def f(event=None):
    self.game.click(i, j)
    return f


def f(event):
    self.game.rightClick(i, j)
    return f




def square_root(a, x):
    for i in a:
             y = (x + i / x) / 2
              return y


def isprime(n):
    if n < 2:
        return False


def squareRoot(x):
    g = x / 2.0
    while True:
        g = (g + x / g) / 2.0
        if (abs(x - g ** 2) <= 0.001):
            break
    return g


def square_root(a):

    x = 3
    epsilon = 0.000000000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2


def square_root(x):
    y = x / 2
    count = 0
    while abs((y ** 2) - x) > 0.01:
        y = (y + x / y) / 2
        count += 1
        print("After iterating {} times, my guess is {}.".format(count, y))
    return y


def my_square_root(a, x):
    e = 0.0001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < e:
            return y


def sqrt(x):
    assert(x > 0), 'input error'
    if x < 2:
        return x


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def genGrid(rows, cols):
    initVal = 0
    grid = [[initVal for r in range(rows)] for c in range(cols)]
    setStartingVals(grid)
    for r, row in enumerate(grid):
        for c, val in enumerate(row):

            if val != initVal:
                continue

            upVal = 0
            if r != 0:
                upVal = grid[r - 1][c]

            leftVal = 0
            if c != 0:
                leftVal = grid[r][c - 1]

            sum = upVal + leftVal
            grid[r][c] = removeDuplicateFactors(sum)

    return grid


from functools import reduce


def removeDuplicateFactors(n):
    factors = primeFactors(n)
    uniqueFactors = []
    for factor in factors:
        if factor not in uniqueFactors:
            uniqueFactors.append(factor)
    product = reduce(lambda x, y: x * y, uniqueFactors, 1)
    return product


def primeFactors(n):
    factors = []
    remaining = n
    while True:

        nextFactor = firstPrimeFactor(remaining)

        if nextFactor <= 0:
            return factors


def isPrime(n):
    return firstPrimeFactor(n) == n


def firstPrimeFactor(n):
    if n < 2:
        return -1


def firstSquareFactor(n):
    root = 2
    square = root * root
    while square <= n:
        if n % square == 0:
            return square


def isSquareful(n):
    return firstSquareFactor(n) != 1


def square(x):
    return x * x


def solve():
    for num in range(START_NUM, END_NUM + 1):
        super_number = generate_super_number(num)
        print "Checking {0}, {1}".format(str(num).zfill(8), super_number)
        if is_perfect_square(super_number):
            return int(Decimal(super_number).sqrt())


def get_digital_root(num):
    """
    Gets the digital sum of a number
    :param num: Int
    :return: Int
    """
    while len(str(num)) > 1:
        r = 0
        while num:
            r, num = r + num % 10, num / 10
        num = r

    return num


def generate_super_number(num):
    """
    Shuffles num in between 1234567890 to generate the special number to check.
    :param num: Int
    :return: Int
    """
    new_num = int('0'.join(list(str(num).zfill(8))) + '000')
    new_num += 1020304050607080900
    return int(new_num)


def is_perfect_square(num):
    """
    Determines whether or not a number is a perfect square. Checks using its digital root first to
    rule out impossible choices. We know that for a number to be a square number, its digital root
    must be 1, 4, 7, or 9
    :param num: Int
    :return: Boolean
    """
    digital_root = get_digital_root(num)
    if digital_root not in REQUIRED_ROOT_LIST:
        return False


def is_concealed_number(n):
    matches = 0
    while n != 0:
        digit = n % 10
        if digit != DIGITS[10 - 1 - matches]:
            return False


def main():
    MIN = 1020304050607080900
    MAX = 1929394959697989990
    root = int(math.sqrt(MIN))
    while True:
        if root % 100 == 30 or root % 100 == 70:
            square = root * root

            if square % 1000 == 900:
                if is_concealed_number(square):
                    print "Rock on!"
                    print "square = %d, root = %d" % (square, root)
                    return


def square(n):
    """Returns the square of a number."""
    squared = n ** 2
    print "%d squared is %d." % (n, squared)
    return squared


def problem():
    """ Attempt to solve the problem """

    return 'N/A'


def get_input_int():

    number = raw_input("Please give me a number \n")
    number = int(number)

    return number


def dequeue(self):
    return self.items.delMin()


def isEmpty(self):
    return self.items.size() == 0


def size(self):
    return self.items.size()


def __str__(self):
    st = str(self.col) + ',' + str(self.row)
    return st


def getCol(self):
    return self.col


def getRow(self):
    return self.row


def __lt__(self, other):
    if manhattenDistance(self) < manhattenDistance(other):
        return True


def __eq__(self, other):
    if self.row == other.row and self.col == other.col:
        return True


def getTurtle(self):
    return self.t


def getPath(self):
    return self.visitedList


def __lt__(self, other):
    if manhattenDistance(self.getPath()[0]) < manhattenDistance(
            other.getPath()[0]):
        return True


def __eq__(self, other):
    if manhattenDistance(self.getPath()[0]) == manhattenDistance(
            other.getPath()[0]):
        return True


def manhattenDistance(currentNode):
    curRow = currentNode.getRow()
    curCol = currentNode.getCol()
    goalRow = goalNode.getRow()
    goalCol = goalNode.getCol()
    rowDiff = goalRow - curRow
    colDiff = goalCol - curCol
    return fabs(colDiff) + fabs(rowDiff)




def sqrt(x):
    '''Compute square roots using the method of Helon of Alexandria.

        Args:
            X: The number for which the square root is be computed

        Returns:
            The square root of x.

        Raises:
            ValueError: If x is Negative
    '''
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def square_root(a):
    """Computes squar root of a
    """
    espilon = 0.1e-11
    x = a
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < espilon:
            return y


def square_root(a):
    a = float(a)
    x = 10.0
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < 0.000000000001:
            break
        x = y
    return x


def layout(m):
    s = str(m)
    return s + ' ' * (14 - len(s))


def squareRootBi(x, epsilon):
    assert epsilon > 0, 'epsilon must be postive, not ' + str(epsilon)
    low = 0
    high = max(x, 1)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
        assert ctr <= 1000, 'iteration count exceeded'
    print 'iterations:', ctr, 'Estimate:', guess
    return guess


def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True


def add(x, y):
    return x + y


def multiply(x, y):
    return x * y


def square_root(x):
    return sqrt(x)


def op_ln(x):
    return np.log(x)


def op_log10(x):
    return np.log10(x)


def op_power(x, y):
    return x ** y


def op_exp(x):
    return np.exp(x)


def op_power10(x):
    return 10 ** x


def op_square(x):
    return x * x


def op_cube(x):
    return x * x * x


def op_root(x):
    return np.sqrt(x)


def op_cube_root(x):
    return x ** (1. / 3)


def op_inverse(x):
    return 1. / x


def rms(a):
    """
    Computes the root mean square of *a*, which is a numpy array. The
    result is a double constant.
    """
    return sqrt((a ** 2).mean())


def cmc(a):
    """
    Computes the cubic root mean cube of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a ** 3).mean()) ** (1.0 / 3.0)


def nmn(a, n):
    """
    Computes the nth root mean nth power of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a ** n).mean()) ** (1 / float(n))


def mySqrt():
    n = int(input("O hai, please enter a number you'd like to take square root of it:"))
    if n > 0:
        approximation = 0.5 * n
        b = 0.5 * (approximation + n / approximation)
        while b != approximation:
            approximation = b
            b = 0.5 * (approximation + n / approximation)
    else:
        print("please enter a nonzero value")
    return approximation


def solver():
    """ Find the unique positive integer whose square has the form
    1_2_3_4_5_6_7_8_9_0 where _ is a single digit

    We can find the maximum and minimum boundary of square roots
    that satisfy 1020304050607080900 < n ** 2 < 1929394959697989990

    Note that a square ending in "0" has to end in at least "00",
    therefore we can simplify the problem to fnding the bounds of
    10203040506070809 < n ** 2 < 19293949596979899 and then multiplying
    the square root by 10

    (solved 2014-11-29)
    """
    min_bound = int(10203040506070809 ** 0.5)
    max_bound = int(19293949596979899 ** 0.5) + 1

    for number in xrange(min_bound, max_bound):
        if str(number ** 2)[::2] == "123456789":
            return number * 10


def solvePellEquation(D):
    x = -1
    y = -1
    a = [int(sqrt(D)), int(1.0 / (sqrt(D) - int(sqrt(D))))]
    pnm2 = a[0]
    pnm1 = a[1] * pnm2 + 1
    qnm2 = 1
    qnm1 = a[1]
    Pnm2 = 0
    Pnm1 = a[0]
    Qnm1 = D - a[0] * a[0]
    n = 2
    found = False
    while not found:
        Pn = a[n - 1] * Qnm1 - Pnm1
        Qn = (D - Pn * Pn) / Qnm1
        a.append(int((a[0] + Pn) / Qn))
        pn = a[n] * pnm1 + pnm2
        qn = a[n] * qnm1 + qnm2
        if a[n] == 2 * a[0]:
            if (n - 1) % 2 != 0:
                x = pnm1
                y = qnm1
            else:
                pnm2 = pnm1
                pnm1 = pn
                qnm2 = qnm1
                qnm1 = qn
                Pnm1 = Pn
                Qnm1 = Qn
                limit = 2 * n - 1
                while n < limit:
                    n = n + 1
                    Pn = a[n - 1] * Qnm1 - Pnm1
                    Qn = (D - Pn * Pn) / Qnm1
                    a.append(int((a[0] + Pn) / Qn))
                    pn = a[n] * pnm1 + pnm2
                    qn = a[n] * qnm1 + qnm2
                    pnm2 = pnm1
                    pnm1 = pn
                    qnm2 = qnm1
                    qnm1 = qn
                    Pnm1 = Pn
                    Qnm1 = Qn
                x = pn
                y = qn
            found = True
        pnm2 = pnm1
        pnm1 = pn
        qnm2 = qnm1
        qnm1 = qn
        Pnm1 = Pn
        Qnm1 = Qn
        n = n + 1
    return x, y


def mysqrt(n, x):
    if abs(n - x ** 2) < 0.0000000000001:
        return x


def is_perfect_square(n):
    root = n ** 0.5
    return root == int(root)


def generate(self):
    modules = PomUtils.get_modules()

    contents = "
    for module in modules:
        contents += "square_maven_layout('{0}')\n".format(module)

    return contents




def numberofDivisors(num):
    nod, squareRoot = 0, int(sqrt(num))
    for i in range(1, squareRoot + 1):
        if(num % i == 0):
            nod += 2
    if((squareRoot * squareRoot) == num):
        nod = nod - 1
    return nod


def reverse_number(n, base=10):
    result = 0
    while n > 0:
        result = result * base + n % base
        n //= base
    return result


def is_palindrome(n, base=10):
    return n == reverse_number(n, base)


def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0


def is_triangular(tn):
    '''Leverages:
    The inverse of triangular: n = -1/2 + 1/2 * sqrt(1 + 8 * tn)
    Therefore, 1 + 8 * pn must be square for tn to be triangular.
    Also, since n must be an integer, the evaluated sqrt must be odd
    '''
    special_factor = 1 + 8 * tn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 2 == 1:
            return True


def is_hexagonal(hn):
    '''Leverages:
    The inverse of hexagonal: n = -1/4 + 1/4 * sqrt(1 + 8 * hn)
    Therefore, 1 + 8 * hn must be square for hn to be hexagonal.
    Also, since n must be an integer, the evaluated sqrt must:
        Have a modulus of 3 with 4
    '''
    special_factor = 1 + 8 * hn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 4 == 3:
            return True


def is_joint_number(num):
    return is_triangular(num) and is_hexagonal(num)


def find_next_joint_number(nth_pentagonal=1):
    while not is_joint_number(pentagonal(nth_pentagonal)):
        nth_pentagonal += 1
    return pentagonal(nth_pentagonal)


def squareRoot(x):
    root = int(floor(sqrt(x)))

    if root % 2 == 0:
        root += 1
    return root


def checkPrime(x):
    prime = True

    if x % 2 == 0:
        return False


def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
            print 'guess**2 - x is less than epsilon : ', epsilon, ' and now low value is ', low
        else:
            high = guess
            print 'guess**2 - x is greater than epsilon : ', epsilon, ' and now high value is ', high
        guess = (low + high) / 2.0
        print guess
        ctr += 1
        print ctr
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:', ctr, 'Estimate:', guess
    return guess


def getSquareRootIteration(self, iterations):
    if iterations == 1:
        return Fraction(3, 2)


def answer(self):
    bigNumSum = 0
    for i in range(1, 1001):
        print("iteration:" + str(i))
        frac = self.getSquareRootIteration(i)
        if len(str(frac.numerator)) > len(str(frac.denominator)):
            bigNumSum += 1
    return bigNumSum


def square_root_convergents(upper_limit):
    pell = [0, 1]
    H = [1, 1]

    res = 0
    for n in range(2, upper_limit + 1):
        pell.append(2 * pell[n - 1] + pell[n - 2])
        H.append(H[n - 1] + 2 * pell[n - 1])
        if len(str(H[n])) > len(str(pell[n])):
            res += 1

    return res


def square_root(n):
    s = int(math.sqrt(n))
    if s * s == n:
        return s


def max_by_value(d):
    max_key = None
    max_value = None
    for k in d:
        if not max_value or d[k] > max_value:
            max_key = k
            max_value = d[k]
    return max_key




def gcd(a, b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a, b = (b, a) if a < b else (a, b)
    while b:
        a, b = b, a % b
    return a


def modInverse(e, n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e, n)[0] % n


def totient(p, q):
    '''
    Calculates the totient of pq
    '''
    return (p - 1) * (q - 1)


def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')

    if n == 0:
        return 0






def sqrt(self, x):
    start, end = 1, x
    while start + 1 < end:
        mid = start + (end - start) / 2
        if mid * mid <= x:
            start = mid
        else:
            end = mid
    if end * end <= x:
        return end


def is_prime(num):

    for i in range(2, num):
        if num % i == 0:
            return False


def prime_factor_powers(num):
    square_root = int(math.sqrt(num)) + 1
    prime_factors = []

    for i in range(2, square_root):
        if num % i == 0:
            if is_prime(i):
                prime_factors.append(i)

    prime_factor_powers = []

    for prime_factor in prime_factors:
        dividend = num
        power = 0
        while dividend % prime_factor == 0:
            dividend /= prime_factor
            power += 1
        prime_factor_powers.append(power)

    return prime_factor_powers


def solution():
    n = 1
    triangle_number = 1
    num_divisors = 1
    prime_powers = []

    while num_divisors <= 500:
        n += 1
        triangle_number += n
        prime_powers = prime_factor_powers(triangle_number)
        product = 1
        for power in prime_powers:
            product *= power + 1
        num_divisors = product

    return n, triangle_number, num_divisors


def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE,
    starting at GUESS, until DONE yields a true value
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""


def solution(guess):
    if done(guess):
        return guess


def solution(guess, iteration_limit):
    if done(guess):
        return guess


def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE,
    starting at GUESS, until DONE yields a true value
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    while not done(guess):
        if iteration_limit <= 0:
            raise ValueError("failed to converge")
        guess, iteration_limit = update(guess), iteration_limit - 1
    return guess


def square_root(x):
    """Compute an approximation to the square root of X.
    >>> round(square_root(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    tol = abs(x) * 1.0e-10
    y = x * 0.5
    while abs(y * y - x) > tol:
        y -= (y * y - x) / (2.0 * y)
    return y


def close_enough(x):
    return abs(func(x)) < tolerance


def newton_update(x):
    return x - func(x) / deriv(x)


def square_root(a):
    """Compute an approximation to the square root of A.
    >>> round(square_root(9), 10)
    3.0
    """
    if a < 0:
        raise ValueError("square root of negative value")
    return newton_solve(lambda x: x * x - a, lambda x: 2 * x,


def cube_root(a):
    """Compute an approximation to the cube root of X.
    >>> round(cube_root(8), 10)
    2.0
    """
    return newton_solve(lambda x: x ** 3 - a, lambda x: 3 * x ** 2,


def iter_solve2(guess, done, update, state=None):
    """Return the result of repeatedly applying UPDATE to GUESS
    and STATE, until DONE yields a true value when applied to
    GUESS and STATE.  UPDATE returns an updated guess and state."""


def close_enough(x, state):
    return abs(func(x)) < tolerance


def secant_update(xk, xk1):
    return (xk - func(xk) * (xk - xk1)


def square_root2(x):
    """An approximation to the square root of X, using the secant method.
    >>> round(square_root2(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    return secant_solve(lambda y: y * y - x, 1, 0.5 * (x + 1), x * 1.0e-10)


def remove_offset(data):
    """Makes the minimum value of data be zero."""
    return data - np.min(data)


def normalize(data):
    """Normalizes data by dividing by the maximum value."""
    return data / np.max(data)


def fix_offset_and_normalize(data):
    """Removes dc offsets and normalizes data."""
    offset = remove_offset(data)
    return normalize(offset)


def rms(x):
    """Return the root mean square value of the array x."""
    return np.sqrt(np.sum(x ** 2) / len(x))


def super_root(number):
    divisor = 1
    hi = number + 0.001
    low = number - 0.001
    super_root = 1

    while True:
        current = super_root ** super_root
        if low < current < hi:
            return super_root


def check_result(function, number):
    result = function(number)
    if not isinstance(result, (int, float)):
        print("The result should be a float or an integer.")
        return False


def squareRootInt(x):
    '''
    Calculate the square root of a perfect square
    :param x: Positive integer
    :return: Square root of the integer (IF AND ONLY IF is a perfect square)
    '''

    if x < 0:
        return None


def rmsdiff(im1, im2):
    "Calculate the root-mean-square difference between two images"

    h = ImageChops.difference(im1, im2).histogram()

    return math.sqrt(reduce(operator.add,


def equal(im1, im2):
    return ImageChops.difference(im1, im2).getbbox() is None


def is_prime(n):
    if _primes[-1] < n:
        next_prime(n)
    i = bisect.bisect(_primes, n)
    return _primes[i] is n


def next_prime(n):
    i = bisect.bisect(_primes, n + 1)
    if i < len(_primes):
        return _primes[i]


def square_root_cf(s):
    a0 = int(math.sqrt(s))
    yield a0
    if a0 * a0 == s:
        return


def solve_diophantine(d):
    for x, y in convergents(square_root_cf(d)):
        if x * x - d * y * y == 1:
            return x, y


def square_root(a):
    x = a / (2.0 ** (len(str(a))))

    while True:
        y = (x + (a / x)) / 2.0
        if abs(y - x) <= 0.0000001:

            break
        else:
            x = y
            print x
        return x


def square_root(x, epsilon=0.0001):
    ans = x / 2.0

    while abs(ans ** 2 - x) > epsilon:
        ans = ans - (((ans ** 2) - x) / (2 * ans))

    if abs(ans ** 2 - x) > epsilon:
        return None


def cube_root(x, epsilon=0.0001):
    ans = 0

    while ans ** 3 < abs(x):
        ans += 1

    if ans ** 3 != abs(x):
        return None


def flatten1(m):
    return sum(m, [])


def isNoComment(line):
    return not line.startswith('*')


def isLinearity(line):
    return line.startswith('linearity')


def getLinearity(line):
    return int(line.split()[1])


def getFacettes(flines):
    began = False
    for line in flines:
        if 'end' in line:
            return


def squareRoot(n):

    a = int(sqrt(n - 1))
    if a * a + 1 != n:
        print "length %s not square" % (n - 1)
    return a


def triRoot(n):
    a = -0.5 + sqrt(0.25 + 2 * n)
    if a != int(a):
        print "warnin:", n, " not triangular"
    return int(a)


def squareIt(line):

    numbers = map(int, line.split())
    n = len(numbers)
    a = triRoot(n)
    beta = numbers[0]
    m = [numbers[1:][y * a:(y + 1) * a] for y in range(a)]
    s = ''.join([''.join(['% i ' % num for num in line]) + '\n' for line in m])
    return s, "% i" % beta


def squareTri(numbers):
    n = len(numbers)
    a = triRoot(n)
    numbers = ['% i ' % num for num in numbers]
    m = [numbers[y * (y + 1) / 2:(y + 1) * (y + 2) / 2] +
         (a - y - 1) * [' . '] for y in range(a)]
    s = ''.join([''.join(line) + '\n' for line in m])
    return s


def triCo(numbers, x, y):
    c = y * (y + 1) / 2 + x
    if x <= y and c < len(numbers):
        return numbers[c]


def biSquareTri(num1, num2, n):
    return ''.join([''.join([dd[triCo(num1, x, y), triCo(num2, x, y)]


def squareItFromTri(line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    return squareTri(numbers), beta


def squareTri2(line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    n = len(numbers)
    s = biSquareTri(numbers[:n / 2], numbers[n / 2:], triRoot(n / 2))
    return s, beta


def isPrime(candidate):
    """
    Determines if candidate is prime or not.
    """
    if ((candidate % 2) == 0):
        if (candidate == 2):
            return True


def exp_(x):
    return IntrinsicEmitter("exp", (x,), (T,), T)


def pow_(x, y):
    return IntrinsicEmitter("pow", (x, y), (T,), T)


def log_(x):
    return IntrinsicEmitter("log", (x,), (T,), T)


def sqrt_(x):
    return IntrinsicEmitter("sqrt", (x,), (T,), T)


def isWholeNumber(x, y):
    val = x ** 2 + y ** 2
    if is_square(val):
        return True


def iterSqRt(number):
    for counter in range(1, number):
        if counter ** 2 == number:
            return "square root of" + str(number) + 'is' + str(number)


def findsquareroot(number):
    low = 0.0
    high = number
    epsilon = 0.001
    guess = (low + high) / 2

    while abs(guess ** 2 - number) > epsilon:
        print "guess:  " + str(guess ** 2)
        if guess ** 2 > number:
            high = guess
        elif guess ** 2 < number:
            low = guess
        elif guess ** 2 == number:
            return 'Found square root of' + str(number)


def squareRootNR(x, precision):
    '''
    Calculate the square root of a float number through Newton-Raphson method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None




def squareRootConvergentsOfE():
    numretor1, demenator1 = 8, 3
    numretor2, demenator2 = 11, 4
    out_put = 0
    p = 4
    for i in range(5, 101):
        if i % 3 == 0:
            numretor = numretor2 * p + numretor1
            demenator = demenator2 * p + demenator1
            p += 2
        else:
            numretor = numretor2 + numretor1
            demenator = demenator2 + demenator1
        numretor1, demenator1 = numretor2, demenator2
        numretor2, demenator2 = numretor, demenator

    return numberSum(numretor)


def evt(evt_type, data=None, request=None):
    if not LOG_METRICS:
        return


def newton_raphson(y):
    '''
    Newton-Raphson for square root
    '''
    epsilon = 0.01
    ans = y / 2.0
    numGuesses = 0
    while abs(ans * ans - y) >= epsilon:
        numGuesses += 1
        ans = ans - (((ans ** 2) - y) / (2 * ans))
    return ans, numGuesses


def exhaustive_enumeration(x):
    '''
    Approximating the square root using exhaustive enumeration
    '''
    epsilon = 0.01
    step = epsilon ** 2
    numGuesses = 0
    ans = 0.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        ans += step
        numGuesses += 1
    if abs(ans ** 2 - x) >= epsilon:
        print 'Failed on square root of', x
    else:
        print ans, 'is close to square root of', x
    return ans, numGuesses


def bisection(x):
    '''
    Bisection search to approximate square root
    '''
    epsilon = 0.01
    numGuesses = 0
    low = 0.0
    high = max(1.0, x)
    ans = (high + low) / 2.0
    while abs(ans ** 2 - x) >= epsilon:

        numGuesses += 1
        if ans ** 2 < x:
            low = ans
        else:
            high = ans
        ans = (high + low) / 2.0
    return ans, numGuesses


def sqrt(x, error_threshold=1e-4):
    res = 1.0
    error = error_threshold + 1
    while error > error_threshold:
        next_ = 0.5 * (res + (x + 0.0) / (res + 0.0))
        error = abs(next_ - res)
        res = next_
    return res


def square_root(a):
    epsilon = 0.0000000000000001
    if a < 0:
        return 'a must be larger than 0'


def squareRoot(x, epsilon):
    low = 0.0
    high = max(1.0, x)

    ans = low + (high - low) / 2.0

    while abs(ans ** 2 - x) >= epsilon:
        if ans ** 2 < x:
            low = ans
        else:
            high = ans
        ans = low + (high - low) / 2.0
    return ans


def count_prime_power_triples(threshold):
    primes = [p for p in ntheory.primerange(1, math.sqrt(threshold))]
    numbers = set()
    for fourth_root in primes:
        n4 = fourth_root ** 4
        if n4 >= threshold:
            break
        for cube_root in primes:
            n3 = cube_root ** 3
            if n4 + n3 >= threshold:
                break
            for square_root in primes:
                n2 = square_root ** 2
                s = n4 + n3 + n2
                if s >= threshold:
                    break

                numbers.add(s)
    return len(numbers)




def sumSquares(n, m):
    r = n * (n + 1) * (2 * n + 1)
    r /= 6
    r = r % m
    return r


def solve():
    B = 10 ** 15
    k = iSqrt(B)
    m = 10 ** 9
    r = 0
    s = B
    for n in range(1, k + 1):
        s2 = B / (n + 1)
        a1 = n * (sumSquares(s, m) - sumSquares(s2, m))
        r += a1
        r = r % m
        a2 = n * n * s
        r += a2
        r = r % m
        s = s2
    return r


def mySqrt(self, x):
    if x <= 1:
        return x


def isSquare(n):

    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:

        return True


def diophantine(d):
    """Determines the minimum solution of x for the equation
    x**2 - Dy**2 = 1"""
    x = 2
    while True:
        num = x * x - 1
        if num % d == 0 and isSquare(num / d):
            return x


def squareRoot(x):
    epsilon = 0.001
    low = 0
    high = max(x, 1)
    bisection = (high + low) / 2.0

    while abs((bisection ** 2) - x) >= epsilon and bisection <= x:
        if (bisection ** 2) > x:
            high = bisection
        else:
            low = bisection
        bisection = (high + low) / 2
    return bisection


def getContinuedFraction(N):
    a = [int(sqrt(N)), int(1.0 / (sqrt(N) - int(sqrt(N))))]
    pnm2 = a[0]
    pnm1 = a[1] * pnm2 + 1
    qnm2 = 1
    qnm1 = a[1]
    Pnm2 = 0
    Pnm1 = a[0]
    Qnm1 = N - a[0] * a[0]
    n = 2
    while True:
        Pn = a[n - 1] * Qnm1 - Pnm1
        Qn = (N - Pn * Pn) / Qnm1
        a.append(int((a[0] + Pn) / Qn))
        pn = a[n] * pnm1 + pnm2
        qn = a[n] * qnm1 + qnm2
        if a[n] == 2 * a[0]:
            if a[n] == a[n - 1]:
                return a[:2]


def solve():
    lower = int(math.sqrt(1020304050607080900))
    upper = int(math.ceil(math.sqrt(1929394959697989990)))

    for x in xrange(lower - (lower % 100), upper + 100 - (upper % 100), 100):
        if attempt(x + 30):
            return x + 30


def attempt(n):
    sq = n * n
    return odd_digits(sq) == '1234567890'


def odd_digits(n):
    return str(n)[0::2]


def strict_floor(f):
    if int(math.floor(f)) == f:
        return int(f - 1)


def strict_ceil(f):
    if int(math.ceil(f)) == f:
        return int(f + 1)


def count_in_right_triangle(s1, s2):
    n_in = 0
    for x in range(1, s1):

        for y in range(1, s2):
            if s1 * y < -s2 * x + s2 * s1:
                n_in += 1
    return n_in


def count_on_cross(a, b, c, d):
    counts = a + b + c + d - 3
    return counts


def square_root(a):
    """ calculates the square root of a number using Newton's algorithm

    a: a number
    """

    x = a / 4.0
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < 0.0000001:
            break
        x = y
    return x


def read(fn):

    return open(fn, 'r').read()


def read_filter_split(fn):
    s = open(fn, 'r').read()
    return [w for w in s.split() if w.isalnum()]


def square_root(x):
    guess = 1.0
    while not is_good_enough(guess, x):
        guess = improve(guess, x)
        print(guess)
    return guess


def improve(guess, x):
    q = (x * 1.0) / guess
    return average(q, guess)


def average(x, y):
    return (x + y) / 2.0


def is_good_enough(guess, x):
    return abs(improve(guess, x) - guess) < 0.0001


def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps
    return y


def display_dir(dir):
    if dir == LEFT:
        return "LEFT"


def fromIndex(index):
    return Coord(index % 3, index / 3)


def __str__(self):
    return "(%d, %d)" % (self.x, self.y)


def index(self):
    return self.x + self.y * 3


def dist(self, other):
  return max(


def move(self, dir):
    if dir == LEFT:
        if self.x == 0:
            return None


def fromStr(str):
    data = []
    entries = str.split(" ")
    if len(entries) != 9:
        print "Invalid square format: %s" % str
        sys.exit(2)
    for entry in str.split(" "):
        if entry == '_':
            data.append(None)
        else:
            data.append(int(entry))
    return Square(data)


def __key(self):
    return self.__str__()


def __eq__(self, other):
    return self.__key() == other.__key()


def __hash__(self):
    return hash(self.__key())


def find(self, num):
    index = None
    for i in xrange(len(self.data)):
        if self.data[i] == num:
            index = i
            break
    if index is None:
        return None


def lookup(self, coord):
    return self.data[coord.index()]


def dist(self, other):
    dist = 0
    for i in [None, 1, 2, 3, 4, 5, 6, 7, 8]:

        self_coords = self.find(i)
        other_coords = other.find(i)
        dist += self_coords.dist(other_coords)
    return dist


def swap(self, dir):
    blank = self.find(None)
    if blank is None:
        return None


def __str__(self):
    out = ""
    for i in xrange(3):
        for j in xrange(3):
            val = self.data[i * 3 + j]
            if val:
                out += "%d" % val
            else:
                out += "_"
        if i < 2:
            out += " "
    return out


def display(self):
    out = ""
    for i in xrange(3):
        for j in xrange(3):
            val = self.data[i * 3 + j]
            if val:
                out += "%d" % val
            else:
                out += " "
        if i < 2:
            out += "\n"
    return out


def cost(self):
    return self.path_cost + self.h_cost


def add_child(self, node):
    if node.parent != self:
        return


def show_path(self):
    if self.parent:
        path = self.parent.show_path()
        path.append(self.action)
    else:
        path = []
    return path


def __str__(self):
    return "Node for [%s]" % self.square


def display(self):
  return "[%s] (c: %d, p:%d, h:%d, order: %s)" % (


def help_display(indent, node):

    str = "%sNode %s\n" % (indent * "  ", node.display())
    for action in node.children.keys():
        child = node.children[action]

        str += help_display(indent + 1, child)
    return str


def display_tree(root):
    return help_display(0, root)


def make_node(self, square, action=None, parent=None):
    if parent:
        path_cost = parent.path_cost + 1
    else:
        path_cost = 0
    h_cost = square.dist(self.goal)
    return Node(parent, action, square, path_cost, h_cost)


def pop(self):
    (score, node) = heapq.heappop(self.frontier)
    del self.frontier_seen[node]
    return node


def findGoalNode(self):
    root = self.make_node(self.start)
    self.push(root)

    while self.frontier:
        node = self.pop()

        if node.square == self.goal:
            return (root, node)


def square(x):
    return x * x


def draw_square(canvas, color, width, height, center):
    '''Does: Draws a square.
    Arguments: The canvas to draw on, the fill and outline color,
    the width and height of the square, and the center as a tuple.
    Returns: The square that is drawn.'''

    x1 = center[0] - width / 2
    x2 = center[0] + width / 2
    y1 = center[1] - height / 2
    y2 = center[1] + height / 2
    square = canvas.create_rectangle(x1, y1, x2, y2, fill=color,
                                     outline=color)
    return square


def mySquareRoot(x):
    return math.sqrt(x)


def factor(n):
    if n == 1:
        return [1]


def findFactors(n):
    x = []

    z = n
    x.append(z)
    x.append(1)
    y = z ** .5 + 1
    p = 2

    while p < y:

        if z % p == 0:

            x.append(p)
            x.append(z / p)
            p = p + 1
        else:
            p = p + 1
    x.sort()

    return x


def transform(cls, y):
    return np.array(y)


def transform_back(cls, y):
    return np.array(y)


def transform(cls, y):
    y = np.clip(y, 0, np.inf)
    return np.array([np.sqrt(yy) for yy in y])


def transform_back(cls, y):
    return np.array([yy ** 2 for yy in y])


def transform(cls, y):
    y = np.clip(y, 0, np.inf)
    return np.array([np.log(yy + 1) for yy in y])


def transform_back(cls, y):
    return np.array([np.exp(yy) - 1 for yy in y])


def transform(cls, y):
    return np.clip(y, 0, 20)


def transform(cls, y):
    y = np.clip(y, 0, 20)
    return SquareRootTargetTransform.transform(y)


def transform_back(cls, y):
    return SquareRootTargetTransform.transform_back(y)


def add(token):
    tot = 0
    for i in range(1, len(token)):
        tot = tot + float(token[i])
    return tot


def subtract(token):
    tot = float(token[1])
    for i in range(2, len(token)):
        tot = tot - float(token[i])
    return tot


def multiply(token):
    product = 1
    for i in range(1, len(token)):
        product = product * float(token[i])
    return product


def divide(token):
    quo = float(token[1])
    for i in range(2, len(token)):
        quo = quo / float(token[i])
    return quo


def square(token):
    return float(token[1]) * float(token[1])


def cube(token):
    return float(token[1]) ** 3


def power(token):
    base = float(token[1])
    for i in range(2, len(token)):
        base = base ** float(token[i])
    return base


def mod(token):
    return float(token[1]) % float(token[2])


def root(token):
    return float(token[1]) ** (1 / float(token[2]))


def path(self, filename):
    return path.join(self.img_path, filename)


def path(self, *parts):
    return path.join(self.img_path, *parts)


def square_fluct(in1):
    """
    Calculates ``(in1 - <in1>)*(in1 - <in1>)``.

    ``<...>`` stands for the average over the whole vector.

    Parameters
    ----------
    in1: :class:`numpy.ndarray`
        (Nx1) NumPy array.

    Returns
    -------
    sq_fluct : :class:`numpy.ndarray`
    """

    sq_fluct = (in1 - in1.mean()) ** 2
    return sq_fluct


def root_mean_square_fluct(in1):
    """
    Calculates mean squre fluctuation or root-mean-square (RMS) error.

    Parameters
    -----------
    in1 : :class:`numpy.ndarray`
        (Nx1) Numpy array

    Returns
    -------
    rms : :class:`numpy.ndarray`
        Mean square fluctuation.

    Notes
    -----

    RMS: Square-root of arithmetic mean of squares of original values.

    For an unbiased estimator, the RMSE is the square root of the variance,
    known as the standard error.

    References
    -----------
    * http://mathworld.wolfram.com/Root-Mean-Square.html
    * http://en.wikipedia.org/wiki/Root_mean_square_error

    """
    rms = np.sqrt(square_fluct(in1).sum() / in1.size)
    return rms


def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess


def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance


def f(x):
    return x * x - a


def df(x):
    return 2 * x


def nth_root(n, a):
    return find_zero_of_x_to_the_n_minus_a(n, a)


def power(x, n):
    """Return x * x * x * ... * x for x repeated n times.

    >>> power(2, 3)
    8
    >>> power(4, 5)
    1024
    >>> power(6, 0)
    1
    """
    product, num_xs = 1, 0
    while num_xs < n:
        product, num_xs = product * x, num_xs + 1
    return product


def f(x):
    return power(x, n) - a


def df(x):
    return n * power(x, n - 1)


def update(x):
    return x - f(x) / df(x)


def near_zero(x):
    return approx_eq(f(x), 0)


def is_prime(potential_prime, primes_so_far):
    square_root_of_prime = sqrt(potential_prime)

    for prime in primes_so_far:
        if prime > square_root_of_prime:
            return True


def generate_primes_up_to(n):
    primes_so_far = [2]

    for potential_prime in range(3, n + 1, 2):
        if is_prime(potential_prime, primes_so_far):
            primes_so_far.append(potential_prime)

    return primes_so_far


def square_root(a):
    x = float(a / 2)
    while True:
        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return x


def check_perfect(n):
    return math.floor(math.sqrt(n)) ** 2 == n


def check(n):
    square = str(n * n)
    return all(int(square[x * 2]) == x + 1 for x in range(9))


def average_damp(f):
    return lambda x: (x + f(x)) / 2


def square(x):
    return x * x


def cube_root(x):
    return fixed_point(average_damp(lambda y: x / square(y)), 1)






def factorial(n):
    """Computes factorial of n."""
    if n == 0:
        return 1


def getSquareRoot_Wrapper(target, precision):
    return getSquareRoot_recur(0, target, target, precision)


def getSquareRoot_recur(left, right, target, precision):
    print("called")
    candidate = (left + right) / 2

    if(target - candidate ** 2 == 0 or abs(target - candidate ** 2) < precision):
        return candidate


def is_perfect_square(s):
    x = babylonian_square_root(s)
    if x * x == s:
        return True


def perfect_square_root(s, maxbits=4096):
    root = babylonian_square_root(s, maxdepth=20, maxbits=maxbits)
    if root * root == s:
        return root


def squareRoot(a):
    if a > 1:
        x = a - 1.0
    else:
        x = 1.0
    y = (x + (a / x)) / 2
    epsilon = 0.00000001
    while abs(y - x) >= epsilon:
        x = y
        y = (x + (a / x)) / 2
    return y


def evalLoop():
    end = "done"
    n = raw_input()
    while n != end:
        print eval(n)
        n = raw_input()
    return eval(n)


def converge_square_2(n, x=1):
    if n <= 0:
        return x


def solve(n=1000):
    cnt = 0
    for n in range(1, n + 1):
        f = converge_square_2(n)
        if len(str(f.numerator)) > len(str(f.denominator)):
            cnt += 1
    return cnt


def run():
    return solve()


def is_prime(test):
    factors = factor(test)
    if len(factors) == 0:
        return True


def factor(test):

    i = 2
    limit = test ** 0.5
    factors = []
    while i <= (limit):
        if (test % i) == 0:

            factors.append(i)

        if i == 2:
            i = i + 1
        else:
            i = i + 2
    return factors


def factor_to_primes(n):
    primfac = []
    d = 2
    while d * d <= n:
        while (n % d) == 0:
            primfac.append(d)
            n /= d
        d += 1
    if n > 1:
        primfac.append(n)
    return Counter(primfac)


def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))


def subsets(s):
    return map(set, powerset(s))


from functools import reduce


def gcd(*numbers):
    """Return the greatest common divisor of the given integers"""
    from fractions import gcd
    return reduce(gcd, numbers)


def lcm(a, b):
    return (a * b) // gcd(a, b)


def square_root(a):
    '''
    Use x(n+1) = [x(n) + a/x(n)]/2 to calculate square root of a
    '''
    e = 1
    x = a / 2
    while e >= 0.0000001:
        y = (x + a / x) / 2
        e = abs(y - x)
        x = y
    return y


def bmeth(x):
    a = x
    y = 0
    while(y != a):
        y = a
        a = (x / a + a) / 2
    return a

print("Babylonian Method")
print("This program calculates the square root of a number using the Babylonian Method")
num = int(input("Give me a positive integer: "))
bab = bmeth(num)
print("The square root of {} is {}".format(num, bab))

'''
Implement int sqrt(int x).
.
Compute and return the square root of x.


def sqrt(self, x):
    l = 0
    h = x + 1
    while l <= h:
        m = (l + h) / 2
        if m ** 2 <= x < (m + 1) ** 2:
            return m




def square(x):
    '''(number) -> number
    Returns the square of a given number x.
    >>> square(3)
    9
    >>> square(-2)
    4
    >>> square(0)
    0
    '''
    return x ** 2


def add(x):
    '''(number) -> number
    Returns the number added with it self.
    >>> add(3)
    6
    >>> add(-1)
    -2
    '''
    return x + x


def root(x):
    try:
        return x ** 0.5


def choose():
    func_choose = raw_input(
        "Choose function: square = 1, add = 2, root = 3 : ")
    if 1 == int(func_choose):
        return list_function(lst_a, square)


def square_root(a, x):
    """returns the square root of the number using newton's method
       other parameter is a valid integer """
    for i in range(5):
        y = (x + a / x) / 2
        x = y
    return y


def mod_mult(x, y, mod):
    return (x * y) % mod


def mod_exp(x, y, mod):
    if y == 0:
        return 1


def to_nomalized(a):
    return preprocessing.normalize(a)


def to_float(a):
    for i in range(len(a)):
        a[i] = float(a[i])
    return a


def dis_to_sim(d):
    return 1 / (1 + d)


def euclidean_distance(x, y):
    return sqrt(sum(pow(a - b, 2) for a, b in zip(x, y)))


def manhattan_distance(x, y):
    return sum(abs(a - b) for a, b in zip(x, y))


def nth_root(value, n_root):
    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)


def minkowski_distance(x, y, p_value):
    return nth_root(sum(pow(abs(a - b), p_value)
                        for a, b in zip(x, y)), p_value)


def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)


def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)


def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)


def loge(n, li, ls):
    if fabs(li - ls) <= 0.000001:
        return (li + ls) / 2.0


def ln(n):
    if n == 0 or n < 0:
        return "Math Domain Error"


def bhatta_distance(hist1, hist2, num):
    h1 = np.average(hist1)
    h2 = np.average(hist2)

    dis = 0
    for i in range(num):
        dis += sqrt(hist1[i] * hist2[i])
    if h1 != h1:
        dis = sqrt(1 - (1 / sqrt(h1 * h2 * num * num)) * dis)
    return dis


def odd(n):
    if ((n % 2) == 1):
        return True


def even(n):
    if ((n % 2) == 0):
        return True


def int_sqrt(n):

    ans = int(n ** .5)
    if ((ans ** 2) == n):
        return ans


def count_divisors(number):
    """ Determines the number of divisors that the number
        specified has."""

    divisor_count = 0
    square_root = math.sqrt(number)

    counter = 1
    while counter <= square_root:
        if number % counter == 0:
            divisor_count += 2
        counter += 1

    if square_root * square_root is number:
        divisor_count -= 1

    return divisor_count


def power(x):
    return x ** 2


def f(x):
    return OctoCat


def is_square(n):
    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:
        return True


def square_root_bisection(self, num):
    epsilon = 0.01
    num_guesses = 0
    low = 0.0
    high = num
    ans = (high + low) / 2.0

    while abs(ans ** 2 - num) >= epsilon:
        num_guesses += 1
        if ans ** 2 < num:
            low = ans
        else:
            high = ans
        ans = (high + low) / 2.0

    return ans


def square_root(a):
    x = a / 2
    epsilon = 0.00000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def isFair(s):
    """ determine if n is a palindrome """
    if len(s) <= 1:
        return True


def isFair2(s):
    return s == s[::-1]


def isSquare(n, listFairs):

    for i in listFairs:

        if n[0] == i[1]:
            return i[0]


def isSquare2(n, listFairs):

    return 0


def initFairs(n):
    """ initialize an array of fairs up to our end point """
    print "In init fairs with n = " + str(n)
    fairList = []
    for i in xrange(1, n + 1):
        if isFair(str(i)):
            fairList.append((i, i * i))
    return fairList


def closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def WebsterLocey(x):
    y1 = closest_perfect_square(x)

    y2 = y1 + 1
    z1 = x - y1 ** 2
    z2 = y1 + y2
    a = y + z1 / z2

    return float(a)


def cube(x):
    return x * x * x


def cube_root_iter(guess, x):
    if is_good_enough(guess, x):
        return guess


def improve(guess, x):
    return (x / square(guess) + (2 * guess)) / 3


def is_good_enough(guess, x):
    return abs(cube(guess) - x) < 0.001


def cube_root(x):
    return cube_root_iter(1.0, x)


def bigger(root, base, offset):
    root = int(root)
    return (root * root) > (int(base) * (10 ** offset))


def root(n, digits):
    base = str(n)
    root = str(int(sqrt(n)))
    offset = 0
    while len(root) < digits:
        offset += 2
        root += "9"
        for digit in "876543210":
            if bigger(root, base, offset):
                root = root[:-1] + digit
    return root


def digital_sum(n):
    return sum([int(x) for x in str(n)])


def square(n):
    return n in [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


def solution():
    return sum([digital_sum(root(x, 100))






def egcd(x, y):
    a, b, u, v = 0, 1, 1, 0
    while x != 0:
        q, r = y // x, y % x
        m, n = a - u * q, b - v * q
        y, x, a, b, u, v = x, r, u, v, m, n
    return y, a, b


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None


def sqroot(x):
    return sqrt(x)


def cross_product(A, B):
    the_list = []
    for a in A:
        for b in B:
            the_list.append(a + b)
    return the_list


def grid_values(grid):
    char_list = []
    for c in grid:
        if c in digits or c in '0.':
            char_list.append(c)
    result = dict(zip(square_list, char_list))
    return result


def newton_sq_rt(root_of):
    '''Finds square root to minimum precision of 0.01 using Newton's method
        of successive approximations'''

    apxroot = root_of / 2
    n = 0
    while abs(root_of - apxroot ** 2) > 0.01:
        if n == 0:
            print(
                "{} iteration,  guess is {}".format(
                    n + 1,
                    round(
                        apxroot,
                        2)))
        else:
            print(
                "{} iterations, guess is {}".format(
                    n + 1,
                    round(
                        apxroot,
                        2)))
        apxroot = (apxroot + root_of / apxroot) / 2
        n += 1
    return apxroot


def get_input():
    root_of = input("Enter a number: ")
    try:
        float(root_of)
    except:
        print("Non-numeric input.".format(end=''))
        return get_input()


def decimal_part(expansion):
    if expansion <= 1:
        return Fraction(1, 2)


def tw_square_root_gen(limit=100):
    i, r = 0, 1 + Fraction(1, 2)
    while i < limit:
        yield r
        r = 1 + 1 / (1 + r)
        i += 1

    s = 0
    for f in tw_square_root_gen(1001):
    if len(str(f.numerator)) > len(str(f.denominator)):
        s += 1
    return s


def isPrime(candidate):
    prime = True
    squareRoot = math.floor(math.sqrt(candidate))
    numbers = range(2, squareRoot)
    divisors = list(filter(lambda x: candidate % x == 0, numbers))
    if len(divisors) != 0:
        prime = False

    return prime


def print_n(s, n):
    while n <= 0:
        return


def square_root(a):
    x = a / 2.0
    epsilon = 0.000000000001
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def squareroot(number):
    difference = 1
    number_guess = float(number / 2)
    while difference > 0.01:
        square_root = number_guess - \
            ((number_guess * number_guess - number) / (2 * number_guess))
        difference = float(abs(number_guess - square_root))
        number_guess = square_root
    return round(square_root, 3)


def root(number, exp):
    i = exp - 1
    if i > 0:
        root1 = squareroot(number)
        return root(root1, exp - 1)


def sqrt(self, x):
    return int(math.sqrt(x))


def sigmoid(x):

    return 0.5 * (1 + np.tanh(x / 2))


def sigmoid_T(x):
    return 0.5 * (1 + T.tanh(x / 2))


def inv_sigmoid(x):
    """
    inverse sigmoid
    """
    return np.log(x / (1. - x))


def inv_sigmoid_T(x):
    return T.log(x / (1. - x))


def RMSE(a, b):
    """
    Root Mean Square Error
    """
    return np.sqrt(np.sum(np.square(a - b), axis=1))


def RMSE_T(a, b):
    return T.sqrt(T.sum(T.square(a - b), axis=1))


def sqrt(n):
    approx = n / 2.0
    better = (approx + n / approx) / 2.0
    while better != approx:
        approx = better
        better = (approx + n / approx) / 2.0
    return approx


def square_root_method(a, x):
    while True:

        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return y


def table():
    for i in range(1, 10):
        tabelle = []
        p = math.sqrt(i)

        q = square_root_method(i, i + 1)

        r = abs(p - q)

        tabelle.append([i, p, q, r])
        print(tabelle)
    return tabelle


def is_prime_slower(num):
    if num <= 1:
        return False


def isPrime(num):
    """Check if num is prime"""
    for idx in range(2, int(math.sqrt(num))):
        if not num % idx:
            return False


def binomialCoeff(elements, combinations):
    """
    Calculate binomial coefficient for the given number of
    elements and combinations
    """
    fact = math.factorial
    return fact(elements) / fact(combinations) * fact(elements - combinations)


def average(seq):
    """Calculate the average value of a sequence of values"""
    return sum(seq) / len(seq)


def sqrt(num) -> float:
    """Calculate the square root of the given number"""

    root = num / 2 if num > 0 else 1
    while abs((num / root) - root) > 0.000000001:
        root = average((root, num / root))
    return root


def binary_search(self, x, y):
    m = (x + y) / 2
    if x > y:
        return y


def sqrt(self, x):
    self.target = x
    return self.binary_search(0, x)


def isSquare(n):
    root = int(sqrt(n))
    if root ** 2 == n or (root + 1) ** 2 == n:
        return True


def checkSeq1(n):
    true = []
    for i in range(2, n + 1, 2):
        if isSquare((i + 2) * (3 * i + 2)):
            true.append(i)
    return true


def checkSeq2(n):
    true = []
    for i in range(2, n + 1, 2):
        if isSquare((i - 2) * (3 * i - 2)):
            true.append(i)
    return true


def sequence(bound, starter_values):
    values = [i for i in starter_values]
    if values[-1] >= bound:
        return values


def fibonacci_term(n):
    square_root_of_five = sqrt(5)
    phi = (1 + square_root_of_five) / 2
    phi_2 = (1 - square_root_of_five) / 2
    return int((phi ** n - phi_2 ** n) / square_root_of_five)


def sqrt(x):
    x = float(x)
    for i in range(10):
        newtonX = x - (((x * x) - 2) / (2 * x))
        if (math.fabs(newtonX - x)) < 10 ** -10:
            return newtonX


def sqrt(x):
    if x < 0:
        return None


def get_period(n):
    root = int(sqrt(n))
    m, d, a = 0, 1, root
    seq = [(0, 1, root)]
    while True:
        m = d * a - m
        d = (n - m * m) / d
        if d == 0:
            return 0


def squareRoot(x, power, eps):
    if x < 0 and power % 2 == 0:
        return None


def square_root(a):
    x = a / 2.0
    epsilon = 0.00000001
    while True:
        y = (x + a / x) / 2.0
        if abs(x - y) <= epsilon:
            break
        x = y
    return x


def square_root(num):
    initial_guess = 1
    while True:
        f_x = float(initial_guess * initial_guess - num)
        der_f_x = float(2 * initial_guess)
        new_guess = initial_guess - (f_x / der_f_x) * 1.0
        if(abs(initial_guess - new_guess) < 0.001 or abs(initial_guess - new_guess) == 0):
            break
        initial_guess = new_guess
    return "%.4f" % new_guess


def is_prime(num):
    root = int(float(square_root(num)))
    for i in range(2, root + 1):
        if(num % i == 0):
            return 1


def is_prime(number, primes=None):
    if number < 2:
        return False


def gen_primes(max, primes):

    for n in primes:
        if n > max:
            return


def __improve(guess, x):
    return __average(guess, (x / guess))


def __average(x, y):
    return (x + y) / 2


def __good_enough(guess, x):
    return math.fabs((guess ** 2 - x)) < PRECISION


def root_mean_square(array):
    return (np.mean(array ** 2)) ** 0.5


def normalized(array):
    return array / max(array)


def spectrum(array):
    array *= np.hamming(len(array))
    complex_array = np.fft.fft(array)
    complex_array = complex_array[:len(complex_array) // 2]
    array = list(map(abs, complex_array))
    return array


def cepstrum(array):
    array *= np.hamming(len(array))
    complex_array = np.fft.fft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    complex_array = np.fft.ifft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    return array


def energy(array, size_chunk):
    list_energy = []
    for i in range(len(array) // size_chunk):
        l = array[i * size_chunk:i * size_chunk + size_chunk]
        list_energy.append(root_mean_square(l))
    l = []
    for i in range(len(list_energy) - 1):
        l.append(sum(list_energy[i:i + 2]) / 2)
    return l


def derivative(array):
    d = []
    for i in range(len(array) - 1):
        d.append(array[i + 1] - array[i])
    return d


def moves(square):
    N = dict((d for d in zip("abcdefgh", range(1, 9))))
    L = dict((d for d in zip(range(1, 9), "abcdefgh")))

    numbers = N[square[0]], int(square[1])

    m = []
    for two in (-2, +2):
        for one in (-1, +1):
            h = numbers[0] + two
            v = numbers[1] + one

            if 1 <= h <= 8 and 1 <= v <= 8:

                m.append((L[h], v))

            h = numbers[0] + one
            v = numbers[1] + two

            if 1 <= h <= 8 and 1 <= v <= 8:

                m.append((L[h], v))

    return ["%s%i" % (a, n) for a, n in set(m)]


def random_walk(startingsq):
    sq = startingsq
    N = 0
    while True:
        N += 1
        sq = random.choice(moves(sq))

        if sq == startingsq:
            return N


def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a / x) / 2
        print "x:" + str(x) + " y:" + str(y)
        if abs(y - x) < epsilon:
            return y


def squareRootBi(x, epsilon=0.0001220703125):
    """Find the square root of x using successive approximation by bissection"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    low = 0

    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while ctr < 100 and abs(guess ** 2 - x) > epsilon:

        if guess ** 2 > x:
            high = guess
        else:
            low = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("Bi Method. Steps:", ctr)
    return guess


def squareRootNR(x, epsilon=0.0001220703125):
    """Find the square root of x using Newton/Raphson method"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    guess = 1
    diff = guess ** 2 - x
    ctr = 1
    while ctr < 100 and abs(diff) > epsilon:
        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("NR Method. Steps:", ctr)
    return guess


def arithmetic(question):
    question = question[8:]
    question = question.replace(
        "plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))


def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)


def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []


def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False


def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)


def float_equals(a, b, tolerance=0.00000001):
    return abs(a - b) < tolerance


def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100


def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)


def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))


def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a


def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))


def wrapper(n, *args, **kwargs):
    if n <= 0:
        print 'From inside Decorator: n <=0 before raising exception'
        raise Exception("Exception raised: n must be > 0")
    else:
        print 'From inside Decorator: n > 0, before calling SquareRoot fn'
        return fnToCall(n, *args, **kwargs)


def square_root(n):
    result = n ** (1 / 2)
    return result


def sqrt(x):
    """ Calculate the square root of a perfect square"""
    if x >= 0:
        ans = 0
        while ans * ans < x:
            ans += 1
        if ans * ans == x:
            return ans


def root_decimal_expansion(n, limit=10):
    """
    http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
    """
    n = str(int(n))
    if len(n) % 2 == 1:
        n = '0' + n
    pairs = zip(n[::2], n[1::2])[::-1]
    c = 0
    p = 0
    while pairs or c:
        c *= 100
        if pairs:
            c += int(''.join(pairs.pop()))
        x = 0
        y = lambda x: x * (20 * p + x)
        while y(x + 1) <= c:
            x += 1
        c -= y(x)
        p = 10 * p + x
        if len(str(p)) >= limit:
            break
    return p


def digital_sum(n, limit=100):
    return reduce(lambda x, y: x + int(y),


def bitlength(x):
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n


def isqrt(n):
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    if n == 0:
        return 0


def is_perfect_square(n):
    h = n & 0xF
    if h > 9:
        return -1


def partial_quotiens(x, y):
    partials = []
    while x != 1:
        partials.append(x // y)
        a = y
        b = x % y
        x = a
        y = b

    return partials


def indexed_convergent(sequence):
    i = len(sequence) - 1
    num = sequence[i]
    denom = 1
    while i > 0:
        i -= 1
        a = (sequence[i] * num) + denom
        b = num
        num = a
        denom = b

    return (num, denom)


def convergents(sequence):
    c = []
    for i in range(1, len(sequence)):
        c.append(indexed_convergent(sequence[0:i]))

    return c


def phiN(e, d, k):
    return ((e * d) - 1) / k


def wiener_attack(N, e):
    (p, q, d) = (0, 0, 0)
    conv = convergents(partial_quotiens(e, N))
    for frac in conv:
        (k, d) = frac
        if k == 0:
            continue
        y = -(N - phiN(e, d, k) + 1)
        discr = y * y - 4 * N
        if(discr >= 0):

            sqr_discr = is_perfect_square(discr)

            if sqr_discr != -1 and (-y + sqr_discr) % 2 == 0:
                p = ((-y + sqr_discr) / 2)
                q = ((-y - sqr_discr) / 2)
                return p, q, d


def make_groups_of_two(n):
    str_n = str(n)
    if len(str_n) % 2 == 1:

        str_n = "0" + str_n
    groups = []
    i = 0
    while i < len(str_n):
        groups.append(str_n[i:i + 2])
        i += 2
    groups += ["00"] * (100 - len(groups))
    return groups


def sum_of_digits(n):
    total = 0
    while n != 0:
        total += n % 10
        n /= 10
    return total


def get_best_x(c, p):
    for x in range(0, 11):
        if (20 * p + x) * x > c:
            return x - 1


def sum_of_100_digits_of_irr_root(n):
    n_groups = make_groups_of_two(n)
    result = 0
    remainder = 0
    for group in n_groups:
        c = remainder * 100 + int(group)
        x = get_best_x(c, result)
        remainder = c - (20 * result + x) * x
        result = result * 10 + x
    return sum_of_digits(result)


def power(x, y=2):
    return x ** y


def square_root(x):
    return numpy.sqrt(x)


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for witch the square root is to be computed.

    Returns:
        The square root of x.
    """
    if x < 0:
        raise ValueError(
            'Cannot compute square root of negative number {}'.format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def square(numbers):
    return [x * x for x in numbers]


def dist_to_dest(num, square_config):
    return DISTANCE_HASH[(num, square_config.index(num))]


def heuristic(square_config):
    d = 0
    for i in range(len(square_config)):
        d += dist_to_dest(i, square_config)

    return d


def neighbors(square_config):
    open_spot = square_config.index(0)
    n_list = []
    for i in N_HASH[open_spot]:
        new_config = list(square_config)
        new_config[open_spot] = square_config[i]
        new_config[i] = 0
        n_list.append(new_config)

    return n_list


def average(x, y):
    return (x + y) / 2.0


def average_damp(function):
    return lambda x: average(x, function(x))


def is_small_enough(neg_point, pos_point):
    tolerance = abs(neg_point - pos_point) / 2.0
    return tolerance <= tolerance_range


def find_fixed_point(function, guess):
    next_guess = function(guess)
    if is_small_enough(guess, next_guess):
        return next_guess


def square_root(n):
    return find_fixed_point(lambda x: average(x, n / x), 1)


def cubic_root(n):
    return find_fixed_point(average_damp(lambda x: n / (x * x)), 1)


def golden_ratio():
    return find_fixed_point(lambda x: average(x, (x + 1) / x), 1)


def getSum(n):
    x = iSqrt(n)
    if x * x == n:
        return 0


def solve():
    r = 0
    for k in range(1, 101):
        r += getSum(k)
    return r


def squareRootBisection(x, precision):
    '''
    Calculate the square root of a float number through bisection method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None


def get_square_root(n):
    root = []
    period = []
    cache = []
    x, y = 0, 1
    while (x + 1) ** 2 <= n:
        x += 1
    root.append(x)
    if x ** 2 != n:
        while (x, y) not in cache:
            cache.append((x, y))
            k = 0
            d = (n - x ** 2) // y
            while ((k + 1) * d - x) ** 2 <= n:
                k += 1
            period.append(k)
            x, y = k * d - x, d
    root.append(period)
    return root


def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a


def generate_primes_upto_number(n):
    primes = [2, 3]
    n -= 1
    current_number = primes[1]
    while current_number < n:
        current_number += 2
        square_root = math.floor(math.sqrt(current_number))
        prime = True
        for p in primes:
            if p > square_root:
                break
            elif current_number % p == 0:
                prime = False
                break

        if prime:
            primes.append(current_number)
    return primes


def largest_prime_factor(number):
    result = prime_factors(number)
    if result:
        result[-1]
    return result


def prime_factors(number):
    factors = []
    for n in xrange(2, number / 2):
        if number % n == 0 and is_prime(n):
            factors.append(n)
    return factors


def is_prime(number):

    if number % 2 == 0:
        return False


def cube(n):
    """
    Returns the cube of the number n
    """
    "REPLACE THIS CODE WITH YOUR CUBE METHOD"
    return n ** 3




def negate(n):
    """ Return negative n
    """
    "REPLACE THIS CODE WITH YOUR NEGATE METHOD"
    return (-n)


def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    "REPLACE THIS CODE WITH YOUR FACTORIAL METHOD"
    return math.factorial(n)


def isSquare(a):
    '''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''

    if 0 <= a <= 2 ** 50:
        sr = int(a ** (1 / 2.0))
        if sr ** 2 == a:
            return sr


def square_root(n, d=100):
    nstr = str(n)
    if len(nstr) % 2 == 1:
        nstr = '0' + nstr

    vals = [int(nstr[i:i + 2]) for i in range(0, len(nstr), 2)]
    ans = [-1 for i in range(d)]

    p = 0
    r = 0
    vcnt = 0
    vmax = len(vals)
    for i in range(d):
        if vcnt < vmax:
            c = 100 * r + vals[vcnt]
            vcnt += 1
        else:
            c = 100 * r
        x = get_max_x(p, c)
        y = x * (20 * p + x)
        r = c - y
        p = 10 * p + x
        ans[i] = x
    dec = len(vals)
    ans = ans[:dec] + ["."] + ans[dec:]
    return(ans)


def get_max_x(p, c):
    for x in range(1, 10):
        if x * (20 * p + x) > c:
            break
    return(x - 1)


def get_sum(n):
    start = n.index(".") + 1
    return(sum(n[start:]))


def square_root(a):
    epsilon = 0.00000000001
    x = float(a / 2.0)
    while True:

        if abs(x - 0) < epsilon:
            y = a / 2.0
        else:
            y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def loadObjects(root, folder):
    print "\nLoading: " + folder
    n = 0
    objects = []
    for subdir, dirs, files in os.walk(root + folder):
        for file in files:
            objects += perception(os.path.join(subdir, file), show=False)
            print str(file) + ", " + str(len(objects[-1]))
            gc.collect()
    return objects


def divisible_by(dividend, divisor):
    return dividend % divisor == 0


def is_even(n):
    return divisible_by(n, 2)


def less_than_n(x):
    return x < n


def less_than_or_equal_to_n(x):
    return x <= n


def fibonacci_less_than(n):
    return take_while_less_than(n, fibonacci())


def evens(xs):
    return itertools.ifilter(is_even, xs)


def any(predicate, xs):
    for x in xs:
        if predicate(x):
            return True


def primes_less_than(n):
    return take_while_less_than(n, primes())


def n_primes(n):
    return itertools.islice(primes(), n)


def product(xs):
    result = 1

    for x in xs:
        result = result * x

    return result


def first(xs, predicate=lambda x: True):
    for x in xs:
        if predicate(x):
            return x


def last(xs):
    return list(xs)[-1]


def is_palindromic(n):
    n = str(n)
    return n[:] == n[::-1]


def numbers_with_digits(digits, radix=10):
    start = pow(radix, digits - 1)
    end = pow(radix, digits)
    return range(start, end)


def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


def lcm(a, b):
    return a * b / gcd(a, b)


def count_to(n):
    return range(1, n + 1)


def square(n):
    return n * n


def squares(start=0):
    return itertools.imap(square, itertools.count(start))


def is_perfect_square(n):
    root = math.sqrt(n)
    return root == int(root)


def sqrt(num):
    epsilon = 0.000001
    rt = num / 2
    while True:
        newrt = (rt + num / rt) / 2
        if abs(newrt - rt) < epsilon:
            return newrt


def get_input(prompt):
    num = raw_input(prompt)
    return num


def square_root(a):

    x = 0.75 * float(a)
    epsilon = 0.000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def add(term1, term2):
    result = term1 + term2
    return result


def subtract(term1, term2):
    result = term1 - term2
    return result


def multiply(factor1, factor2):
    product = factor1 * factor2
    return product


def square(value):
    product = value * value
    return product


def square_of_square_root(value):
    import math
    root = value ** 2
    product = math.sqrt(root)
    return product


def test_square_root(s1, s2):
    for i in range(s1, s2):
        a = i ** 0.5
        b = math.sqrt(i)
        if (a).is_integer():
            print ("%1.1f\t %1.1f \t\t\t%1.1f \t\t\t%1.1f" % (i, a, b, a - b))
        else:
            print ("%1.1f\t %13.11f\t%13.11f\t%16.13e" % (i, a, b, a - b))
    return True


def main():

    total = 0

    for num in range(2, 100):
        if num not in {4, 9, 16, 25, 36, 49, 64, 81}:
            root = isqrt(num * (10 ** 2) ** 99)
            total += sum([int(x) for x in str(root)])
    return total


def raiz(n):
    x = n
    y = 0
    while(x != y):
        y = x
        x = (n / x + x) / 2
    return x


def newtonSqrt(n):
    '''Calculates the square root of n'''

    i = 0
    approx = n / 2
    better_approx = 0.5 * (approx + (n / approx))

    while better_approx != approx:

        approx = better_approx
        better_approx = 0.5 * (approx + (n / approx))
        i = i + 1
        print(better_approx, "number of iterations: ", i)

    return approx


def squareRoot(a, b):
    for counter in range(1, squareRoot):
        if counter ** 2 == squareRoot:
            return 'square root of' + str(squareRoot) + " is " + str(counter)


def exSqrRt(number):

    float(number)
    counter = 1.0

    while counter ** 2 == number:
        return str(counter) + 'is the square root of' + number


def sqrt(x, eps=1e-6):
    r = x * 1.
    while abs(x - r * r) > eps:
        r = 0.5 * (r + x / r)
    return r


def ig(x, y):
    a, b, u, v = 0, 1, 1, 0
    while x != 0:
        q, r = y // x, y % x
        m, n = a - u * q, b - v * q
        y, x, a, b, u, v = x, r, u, v, m, n
    return y, a, b


def ig_mod(a, m):
    g, x, y = ig(a, m)
    if g != 1:
        return None


def squareRoot(a):
    for number in range(1, a):
        if a ** 2 == a:
            return "square root of" + str(a) + "would be" + str(number)


def create_parser():
    parser = argparse.ArgumentParser(description="Square or root of number")
    parser.add_argument(
        '-r',
        type=int,
        dest="ROOT",
        nargs=1,
        help="Root of number")
    parser.add_argument(
        '-s',
        type=int,
        dest="SQUARE",
        nargs=1,
        help="Square of number")
    return parser


def GetANumber(PromptMessage):
    Num = -1
    while (Num < 1):
        Num = requestNumber(PromptMessage)
        if (Num < 1):
            showError("Input can not be negative!")
    return Num


def Process(N):
    print "The Number is " + str(N)
    print "The Square is " + str(N)
    print "The Square root is " + str(math.sqrt(N))
    return


def Run():
    Process(
        GetANumber(
            "Please enter a positive number, " +
            requestString("Enter your name")))
    return


def mySqrt(self, x):
    i, j = 0, x / 2 + 1
    while i <= j:
        mid = (i + j) / 2
        cur = mid ** 2
        if cur == x:
            return mid


def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns: The square root of x

    Raises:
        ValueError: If x is negative
    '''

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def square_root(x, eps):
    ''' (float, float) -> float
    Return the square root of x to within "the accuracy" of eps.
    '''
    counter = 0
    this_guess = 1.0
    next_guess = 0.5 * (this_guess + (x / this_guess))
    error = next_guess - this_guess
    while abs(error) > eps and counter <= 10:
        this_guess = next_guess
        next_guess = 0.5 * (this_guess + (x / this_guess))
        error = next_guess - this_guess
        counter += 1
    if counter <= 10:
        return next_guess


def square_root(a):
    x = 1
    while x * x != a:
        print(x)
        x = square_root_update(x, a)
    return x


def square_root_update(x, a):
    return (x + a / x) / 2


def pe57(limit=1000):
    """
    Investigate the expansion of the continued fraction
    for the square root of two.
    """
    n, d = 3, 2
    cnt = 0
    for a in range(limit + 1):

        nn = n
        n += d << 1
        d += nn
        if len(str(n)) > len(str(d)):
            cnt += 1
    return cnt


def calc(n):
    nd13 = n // 13
    return (nd13 << 1) + ((n - nd13 * 13) >> 3)


def pe57a(n=1000):
    return calc(n)


def mySqrt(self, x):

    n = max(1, 10 * (len(str(x)) / 2))

    while not (pow(int(n), 2) <= x and x < pow(int(n) + 1, 2)):
        n = (n + x / n) / 2

    return int(n)


def solve(fvals, x0, debug=False):

    x = x0
    n_iter = 0
    tol = 1.e-14
    for h in range(100):

        """evaluate function and its derivative:
            """
        fx, fpx = fvals(x)

        if (abs(fx) < tol):
            break
        """update x
            """
        x = x - fx / fpx

    return x, h


def fvals_sqrt(x):
    """
        Return f(x) and f'(x) for applying Newton to find a square root.
        """
    f = x ** 2 - 4.
    fp = 2. * x
    return f, fp


def test1(debug_solve=False):
    """
        Test Newton iteration for the square root with different initial
        conditions.
        """
    from numpy import sqrt
    for x0 in [1., 2., 100.]:
        print " "
        x, iters = solve(fvals_sqrt, x0, debug=debug_solve)
        print "solve returns x = %22.15e after %i iterations " % (x, iters)


def interceptor(value):
    tracker['called'] = True
    return value.pop()


def root_value(wrapper):
    if isinstance(wrapper._value, _.chaining.ChainWrapper):
        return root_value(wrapper._value)


def primesByMaxValue(MAX):

    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    root_index = 3
    root = 7
    square = 49
    r = range(1, root_index)

    for n in range(41, MAX, 2):

        if square <= n:
            r.append(root_index)
            root_index += 1
            root = primes[root_index]
            square = root * root

        for i in r:
            p = primes[i]
            if n % p == 0:
                break
        else:
            primes.append(n)

    return primes


def print_square_root():
    y = input("Enter a number: ")

    y = float(y)

    if y <= 0:
        print("Positive numbers only, please.")
        return


def triangular(p):
    return (p * (p + 1)) / 2


def divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num


def digit_sum_sqrt(n):
    square_root = str(int(n ** 0.5))
    for i in range(1, 100):
        for j in range(10):
            if (int(square_root) * 10 + j) ** 2 > n * 10 ** (2 * i):
                square_root += str(j - 1)
                break
            if j == 9:
                square_root += str(j)

    s = sum(map(int, square_root))

    return s


def input():
    data = open('numbers').readlines()
    numbers = map(string.atoi, map(string.strip, data))
    chunk_size = (len(numbers) + numberOfProcessors - 1) / numberOfProcessors
    chunks = []
    for i in range(numberOfProcessors):
        chunks.append((i, numbers[i * chunk_size:(i + 1) * chunk_size]))
    return chunks


def empty():
    return []


def sumdicemal(a, b):
    result, a = str(a // b), a % b
    while len(result) < 100:
        a = a * 10
        result += str(a // b)
        a = a % b
    return sum(int(i) for i in result)


def decimal(p, l):
    if l == []:
        return 0


def HCF(a, b):
    if a < b:
        return HCF(b, a)


def H(m, n):
    k = HCF(m, n)
    return m // k, n // k


def ContinuedFraction(x):
    y = x ** 0.5
    p = int(y)
    if p * p == x:
        return p, []


def S(x):
    p, L = ContinuedFraction(x)
    return decimal(p, L)


def p80():
    return sum(S(i) for i in range(2, 100))


def sqrt(num):
    if num < 0:
        return ValueError


def isGood(val):
    return abs(val * val - x) / x < 0.00001


def improve(val):
    return (val + x / val) / 2


def iter(val):
    if isGood(val):
        return val


def create_continued_fraction(layers):
    if layers == 0:
        half = Fraction(1, 2)
        half = 2
        return half


def square_root_two(layers):

    return Fraction(1 + Fraction(1, create_continued_fraction(layers)))


def solve_problem():

    max_range = 1000
    count = 0

    for i in range(max_range):
        current_square_root = square_root_two(i)
        numerator = len(str(current_square_root.numerator))
        denominator = len(str(current_square_root.denominator))
        if numerator > denominator:
            count += 1

        if i % 10 == 0:
            print("progress: " + str(i / max_range * 100))

    print("Condition fulfilled by:")
    print(count)

    return 0


def square_root(a):
    new_root = a / 3.0
    old_root = 0.0
    while abs(old_root - new_root) > epsilon:
        old_root = new_root
        new_root = (new_root + a / new_root) / 2.0

    return new_root


def closest_square_root(number):
    if number == 1:
        return number


def get_closest_number(low, high, number):
    difference_from_low_sauared = math.fabs((low ** 2) - number)
    difference_from_high_squared = math.fabs((high ** 2) - number)
    if difference_from_low_sauared > difference_from_high_squared:
        return high


def addn(l, n):
    return [l[0] + n * l[1], l[1]]


def flip(l):
    return [l[1], l[0]]


def trajVelocity(traj):
    "Compute trajectory velocities"
    data = np.array(traj.pointData)
    return data[1:, :] - data[:-1, :]


def trajEnergy(traj):
    "Compute trajectory energy by taking square of velocity vector length."
    vel = trajVelocity(traj)
    return np.sum(vel ** 2, 1)


def trajSpeed(traj):
    "Compute trajectory speed by taking square root of energy"
    e = trajEnergy(traj)
    return e ** .5


def smooth(data, alpha):
    return lfilter([alpha], [1.0, 1.0 - alpha], data)


def sqrt(x):
    if x == 0 or x == 1:
        return x


def euclid_dist(x, y):
    return sqrt(sum(


def manhattan_dist(x, y):
    return sum(


def nth_root(value, n_root):
    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)


def minkowski_dist(x, y, p_value):
    return nth_root(sum(pow(abs(a - b), p_value) for a, b in zip(x, y)),


def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)


def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)


def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)


def is_prime(n):
    '''Checks to see if n is prime'''
    root = n ** 0.5
    for i in primes:

        if n % i == 0:
            return False


def sqrt(n):
    for number in range(0, n):
        if isSqrt(number, n):
            return number


def isSqrt(a, b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True


def super_root(number):
    return 1


def __get_root_window(self):
    return self.__engine.rootObjects()[0]


def __get_property(self, property_name: str):
    return self.__get_root_window().property(property_name)


def __set_property(self, property_name: str, property_value):
    return self.__get_root_window().setProperty(property_name, property_value)


def get_rule_changed_signal(self):
    return self.__get_root_window().ruleChanged


def get_remove_rule_clicked_signal(self):
    return self.__get_root_window().removeRuleClicked


def get_remove_all_rules_clicked_signal(self):
    return self.__get_root_window().removeAllRulesClicked


def get_add_title_clicked_signal(self):
    return self.__get_root_window().addTitleClicked


def get_add_original_title_clicked_signal(self):
    return self.__get_root_window().addOriginalTitleClicked


def get_add_year_clicked_signal(self):
    return self.__get_root_window().addYearClicked


def get_add_directors_clicked_signal(self):
    return self.__get_root_window().addDirectorsClicked


def get_add_duration_clicked_signal(self):
    return self.__get_root_window().addDurationClicked


def get_add_language_clicked_signal(self):
    return self.__get_root_window().addLanguageClicked


def get_add_round_brackets_clicked_signal(self):
    return self.__get_root_window().addRoundBracketsClicked


def get_add_square_brackets_clicked_signal(self):
    return self.__get_root_window().addSquareBracketsClicked


def get_add_curly_brackets_clicked_signal(self):
    return self.__get_root_window().addCurlyBracketsClicked


def get_close_clicked_signal(self):
    return self.__get_root_window().closeClicked


def concealed_square():
    """ solves problem 206"""
    pat = re.compile(r'1\d2\d3\d4\d5\d6\d7\d8\d9\d0')

    start = 1010101010
    while True:
        if len(pat.findall(str(start ** 2))):
            return start




def newton(f, guess):
    """Takes a function and a guess.
    Returns the fixed point of Newton's square root method."""
    df = deriv(f)
    return fixed_point(lambda x: x - (f(x) / df(x)), guess)


def deriv(f):
    """Takes a function and returns its derivative."""


def fixed_point(f, new):
    """Takes a function and a guess. Returns the fixed point of the function."""
    old = 0
    while not close_enough(old, new):
        old, new = new, f(new)
    return new


def try_as_int(x):
    """Takes a number and returns it as an int if it is a whole number."""


def close_enough(u, v):
    """Takes two numbers and returns True if they differ by less than ERROR."""


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    """

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def euler():
    acc = 0

    for c in range(2, MAX):
        acc += square_root_digit_sum(c)
    return acc


def square_root_digit_sum(c):

    p = 0
    i = 0

    rational = False

    while i < 100:
        i += 1

        x = guess_x(p, c)
        y = x * (20 * p + x)

        p = 10 * p + x

        c -= y
        c *= 100

        if c == 0:
            return 0


def guess_x(p, c):

    x = 1
    while x * (20 * p + x) <= c:
        x += 1
    return x - 1


def _square(self, cr, uid, ids, field_name, arg, context=None):
    res = {}
    for record in self.browse(cr, uid, ids, context=context):
        b = record.num
        res[record.id] = b ** 2
        print res
    return res


def _square_root(self, cr, uid, id, name, value, args, context=None):
    return self.write(


def isPrime(n):
    squareRoot = math.ceil(math.sqrt(n))
    for i in xrange(2, int(squareRoot) + 1):
        if n % i == 0:
            return False


def solution():
    b = 15
    n = 21
    target = 1000000000000

    while n < target:
        btemp = 3 * b + 2 * n - 2
        ntemp = 4 * b + 3 * n - 3

        b = btemp
        n = ntemp
    return b


def findSquareRoot(number):
    low = 0.0
    high = number
    epsilon = 0.01
    guess = (low + high) / 2

    while abs((number) - guess ** 2) > epsilon:
        if guess ** 2 < number:
            low = guess
        elif guess ** 2 > number:
            high = guess
        elif guess ** 2 == number:
            return "The square root of" + str(number) + "would be" + str(guess)


def isPerfectRoot(n):
    return gmpy2.is_square(n)


def find_root(min, max):
    guess = (min + max) / 2.0
    guess2 = guess * guess
    if (abs(guess2 - num) < delta):
        return guess


def find_root(whim):
    guess = (whim + num / whim) / 2.0
    guess2 = guess ** 2
    if (abs(guess2 - num) < delta):
        return guess


def abc(a):

    r = a / 2
    while (abs(r - (a / r)) > t):
        r = 0.5 * (r + (a / r))

    return r


def squareRoot(num):
    root = num / 2

    while (abs(root - (num / root)) > t):
        r = 0.5 * (root + (num / root))

    return root


def IsSquare(apositiveint):
    squareRoot = int(math.sqrt(apositiveint))
    return apositiveint == (squareRoot * squareRoot)


def FermatFactor(N):
    if N % 2 == 0:
        return None


def largestPrimeFactor(N):
    result = FermatFactor(N)
    if (result is not None):
        if result[0] == 1 or result[1] == 1:
            return N


def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x


def cube_root(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    x = 1
    while pow(x, 3) != a:
        x = cube_root_update(x, a)
    return x


def cube_root_update(x, a):
    return (2 * x + a / (x * x)) / 3


def improve(update, close, guess=1):
    """Iteratively improve guess with update until close(guess) is true."""
    while not close(guess):
        guess = update(guess)
    return guess


def improve(update, close, guess=1, max_updates=100):
    """Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied."""
    k = 0
    while not close(guess) and k < max_updates:
        guess = update(guess)
        k = k + 1
    return guess


def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance


def update(x):
    return square_root_update(x, a)


def close(x):
    return approx_eq(x * x, a)


def cube_root_improve(a):
    """Return the cube root of a.

    >>> cube_root_improve(27)
    3.0
    """
    return improve(lambda x: cube_root_update(x, a),


def f(x):
    return x * x - a


def df(x):
    return 2 * x


def cube_root_newton(a):
    """Return the cube root of a.

    >>> cube_root_newton(27)
    3.0
    """
    return find_zero(lambda x: x * x * x - a, lambda x: 3 * x * x)


def f(x):
    return pow(x, n) - a


def df(x):
    return n * pow(x, n - 1)


def slope(f, x, a=1e-10):
    """Return the approximate slope of f at x.

    >>> f = lambda x: x * x - 16
    >>> slope_at_two = 4
    >>> abs(slope(f, 2) - slope_at_two) < 1e-3
    True
    """
    return (f(x + a) - f(x)) / a


def approx_zero(f):
    """Find a zero of f using approximate differentiation.

    >>> approx_zero(lambda x: x*x*x - 27)
    3.0
    """
    return find_zero(f, lambda x: slope(f, x))


def critical(f):
    """Find a critical value of f, such as a minimum.

    >>> min = critical(lambda x: x*x + 4*x + 1)
    >>> round(min, 7)
    -3.0
    """
    return f(approx_zero(derive(f)))


def inverse(f):
    """Return the inverse function of f.

    >>> square_root = inverse(square)
    >>> square_root(16)
    4.0
    """
    return lambda y: approx_zero(lambda x: f(x) - y)


def get_root(n, m):

    root = [0] * m
    root[0] = isqrt(n)
    n -= root[0] ** 2
    if n == 0:
        return [root[0]]


def addvectors(a, b):
    iteration = 0
    new_list = []
    for i in a:
        add = eval(i) + eval(b[iteration])
        new_list.append(add)
        iteration += 1
    return new_list


def productvectors(a, b):
    iteration = 0
    product = 0
    for i in a:
        multiply = eval(i) * eval(b[iteration])
        product += multiply
        iteration += 1
    return product


def normA(a):
    sum_squares = 0
    for i in a:
        squares = eval(i) ** 2
        sum_squares += squares
    x = sum_squares ** 0.5

    return x


def normB(b):
    sum_squares = 0
    for i in b:
        squares = eval(i) ** 2
        sum_squares += squares
    x = sum_squares ** 0.5

    return x


def mySqrt(self, x):
    if x < 0:
        return None


def solution(n):

    sieve = {}
    for i in range(2, n + 1):
        sieve[i] = True

    square_root = int(math.sqrt(n))
    primes = []

    for i in range(2, square_root + 1):
        if sieve[i] == True:
            for j in range(i * i, n + 1, i):
                sieve[j] = False

    for index in sieve:
        if sieve[index] == True:
            print index
            primes.append(index)

    return sum(primes)


def square_root(num):
    low = 0.0
    high = 1.0 + (num / 2.0)

    while low < high:
        mid = (low + high) / 2
        sqr = mid ** 2
        diff = abs(num - sqr)

        if diff <= EPSILON:
            return mid


def RootBab(num):
    n = num
    r = 1
    acc = 0.0000001
    while (n - r) > acc:
        n = (n + r) / 2
        r = num / n
    return n


def add(self, a, b):
    return a + b


def sub(self, a, b):
    return a - b


def multiply(self, a, b):
    return a * b


def divide(self, a, b):
    return a / b


def mod(self, a, b):
    return a % b


def power(self, a, b):
    return a ** b


def factorial(self, a):
    if a not in self.factorial_memo:
        self.factorial_memo[a] = self.factorial(a - 1) * a

    return self.factorial_memo[a]


def log(self, number, base):
    return math.log(number, base)


def square_root(self, number):
    return math.sqrt(number)


def dot(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(u[i] * v[i] for i in range(len(u)))]
        print '\n', a, '\n'
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a


def squareRoot(list):
    return map(lambda x: math.sqrt(x), list)


def square(list):
    return map(lambda x: x ** 2.0, list)


def is_square(test):
    from math import sqrt
    root = sqrt(test)

    if int(root) == root:
        return True


def getSquareRoot(num):
    sq = float(sqrt(num))

    return sq


def _square(x):
    return x + 1


def h(y):
    return f(x, y)


def power(x, n):
    """Return x * x * x * ... * x for x repeated n times."""
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product


def euclidean_distance(self, x, y):
    """ return euclidean distance between two lists """


def manhattan_distance(self, x, y):
    """ return manhattan distance between two lists """


def minkowski_distance(self, x, y, p_value):
    """ return minkowski distance between two lists """


def nth_root(self, value, n_root):
    """ returns the n_root of an value """


def cosine_similarity(self, x, y):
    """ return cosine similarity between two lists """


def square_rooted(self, x):
    """ return 3 rounded square rooted value """


def jaccard_similarity(self, x, y):
    """ returns the jaccard similarity between two lists """


def square_root(x):

    return np.sqrt(x)


def primes_trial(n):
    primes = [2]
    for x in range(2, n + 1):
        if all(x % p for p in primes):
            primes.append(x)
    return primes


def isNugget(n):
    return isSquare(5 * n * n + 2 * n + 1)


def isSquare(n):
    root = int(math.sqrt(n))
    return root * root == n


def fib(n):
    a, b = 1, 1
    for i in range(1, n):
        a, b = a + b, a
    return a


def is_prime(i):
    """ function to determine whether an integer is a prime number or not"""
    if i == 1:
        return False


def is_prime(maybe_p):
    root = int(sqrt(maybe_p))
    for prime in primes:
        if prime > root:
            primes.append(maybe_p)
            return True


def is_goldbach(candidate):
    for p in primes:
        squares = square_generator()

        while True:
            square = squares.next()
            sum = p + (2 * square)
            if sum == candidate:
                return True


def pow_seven(n):

    p = 0
    d = n

    while d % 7 == 0:
        d //= 7
        p += 1

    if p > 0:
        t, e = is_root(d, 2 * p + 1)

        if t:
            return [True, p, e]


def is_root(n, p):

    r = get_root(n, p)

    return [r ** p == n, r]


def get_root(n, p):

    sj, ej = find_search_range(n, p)

    return root_binary_search(sj, ej, n, p)


def find_search_range(n, p):

    l = 1

    while (l ** p < n):
        l *= 2

    s = l // 2
    e = l

    return [s, e]


def root_binary_search(s, e, n, p):

    while (s <= e):
        m = (s + e) // 2

        if (m ** p < n):
            s = m + 1
        elif (m ** p > n):
            e = m - 1
        else:
            return m


def squareRoot(self, x, esp):
    if self.compare(x, 1.0, esp) < 0:
        l, r = x, 1.0
    else:
        l, r = 1.0, x
    while self.compare(l, r, esp) == -1:
        mid = l + 0.5 * (r - l)
        if self.compare(mid * mid, x, esp) == 0:
            return mid


def compare(self, a, b, esp):
    diff = (a - b) / b
    if diff < -esp:
        return -1


def square_root(a):
    x = a / 2.0
    epsilon = 0.000001
    while True:
        y = (x + (a / x)) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def f(n):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n / 2) ** 2
    s = sqrt
    i = 1
    for x in range(1, w):
        y = s(-x ** 2 + r)
        if int(y) == y:
            i += 1

    return i * 4


def f420(n, p):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n / 2) ** 2
    s = sqrt
    i = 1
    t = int
    for x in range(1, w):
        y = s(r - x * x)

        if t(y) == y:

            i += 1

            if i > p:
                return 0


def prob(d, p):
    p = p // 4
    x = 0
    for n in range(p, d + 1):
        if f420(n, p) == p:

            x += n
    return x


def squareRoot(num, epsilon):
    iteration = 0
    result = 0.0
    while abs(result ** 2 - num) > epsilon and result < num:
        result += epsilon ** 2
        iteration += 1
    print iteration
    return result


def square_root(n):
    '''Square root calculated using Netwton's method
    '''
    x = n / 2.0
    while True:
        y = (x + n / x) / 2

        if abs(y - x) < sfi.epsilon:
            break
        x = y

    return x


def factorial_new(n):
    '''Factorial using for loop
    '''
    result = 1
    if n < 0:
        return None




def sum_digits(numbers):
    """Return the sum of the first one hundred decimal digits
    for all the irrational square root."""
    numbers = list(str(numbers))
    numbers.remove(".")
    numbers = numbers[:100]
    return sum([int(x) for x in numbers])


def create_cntfrac(fraction):
    new_frac = [[fraction[0]]]
    for i in repeat(fraction[1:], 200 / len(fraction[1:])):
        new_frac.append(i)
    new_frac = flatten(new_frac)
    return new_frac


def head(a):
    for e in a:
        return e


def square_root(n, l, m=0):
    if l == 0:
        return m


def __str__(self):
    return str((self.x, self.y, self.sin_theta, self.cos_theta, self.edge))


def __repr__(self):
    return self.__str__()


def build_left_square(self):
    x = self.x - self.edge * self.sin_theta
    y = self.y + self.edge * self.cos_theta
    sin_theta = self.sin_theta * \
        Decimal(0.8) + self.cos_theta * Decimal(0.6)
    cos_theta = self.cos_theta * \
        Decimal(0.8) - self.sin_theta * Decimal(0.6)
    edge = self.edge * Decimal(0.8)
    return Square(x, y, sin_theta, cos_theta, edge)


def build_right_square(self):
    x = self.x - Decimal(1.48) * self.edge * self.sin_theta + \
        Decimal(0.64) * self.edge * self.cos_theta
    y = self.y + Decimal(0.64) * self.edge * self.sin_theta + \
        Decimal(1.48) * self.edge * self.cos_theta
    sin_theta = - self.cos_theta * \
        Decimal(0.8) + self.sin_theta * Decimal(0.6)
    cos_theta = self.sin_theta * \
        Decimal(0.8) + self.cos_theta * Decimal(0.6)
    edge = self.edge * Decimal(0.6)
    return Square(x, y, sin_theta, cos_theta, edge)


def get_leftmost_coordinate(self):
    coordinates = [
        self.x,
        self.x + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta,
    ]
    return sorted(coordinates)[0]


def get_rightmost_coordinate(self):
    coordinates = [
        self.x,
        self.x + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta,
    ]
    return sorted(coordinates)[-1]


def get_topmost_coordinate(self):
    coordinates = [
        self.y,
        self.y + self.edge * self.sin_theta,
        self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.y + self.edge * self.cos_theta,
    ]
    return sorted(coordinates)[-1]


def get_bottommost_coordinate(self):
    coordinates = [
        self.y,
        self.y + self.edge * self.sin_theta,
        self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.y + self.edge * self.cos_theta,
    ]
    return sorted(coordinates)[0]


def get_boundary_coordinate(self):
    h = []
    index = 0
    heapq.heappush(
        h,
        (self.get_boundary(
            self.root_square),
            index,
            self.root_square))

    performance_counter = 0
    boundary_so_far = self.INF
    while performance_counter < 10 ** 5:
        performance_counter += 1
        boundary, dummy_index, square = heapq.heappop(h)
        if square.edge < 1e-15:
            continue
        if boundary < boundary_so_far:
            boundary_so_far = boundary
        left_square = square.build_left_square()
        right_square = square.build_right_square()
        heapq.heappush(
            h, (self.get_boundary(left_square), index + 1, left_square))
        heapq.heappush(
            h, (self.get_boundary(right_square), index + 2, right_square))
        index += 2
    return boundary_so_far


def get_boundary(self, square):
    return square.get_leftmost_coordinate()


def get_boundary(self, square):
    return -square.get_rightmost_coordinate()


def get_boundary(self, square):
    return -square.get_topmost_coordinate()


def get_boundary(self, square):
    return square.get_bottommost_coordinate()


def debug(command, my_arg, my_locals):
    global stepping
    global breakpoints
    global watchpoints

    if command.find(' ') > 0:
        arg = command.split(' ')[1]
    else:
        arg = None

    if command.startswith('s'):
        stepping = True
        return True


def square_root(x, eps=0.00001):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(square(y) - x) <= eps
    return y


def __repr__(self):
    return repr(self.min) + ".." + repr(self.max)


def __repr__(self):

    s = ""
    for function, events in self.vars.iteritems():
        for event, vars in events.iteritems():
            s += event + " " + function + ":\n"

            for var, range in vars.iteritems():
                s += "    assert "
                if range.min == range.max:
                    s += var + " == " + repr(range.min)
                else:
                    s += repr(range.min) + " <= " + var + \
                        " <= " + repr(range.max)
                s += "\n"

    return s


def traceit(frame, event, arg):

    invariants.track(frame, event, arg)
    return traceit


def absoluteValue(x):
    if(x < 0):
        x = -x
    return x


def squareRoot(x):
    epsilon = 0.0001
    guess = 1.0
    while(absoluteValue(guess * guess - x) >= epsilon):
        guess = (x / guess + guess) / 2.0
    return guess


def square_root(a, x):
    while True:
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y - x) < epsilon:
            return y


def square_root(a):
    x = a / 2.0

    while True:
        y = (x + a / x) / 2

        if x == y:
            return x


"""def f(x):
    return x + 3


def g(x):
    return x ** 2


def squareRoot(x):
    return x ** .5


def areaOfCircle(r):
    '''Computes and returns the are of the circle with radius p'''


def int_rac(n, guess):
    """Integer Square Root of an Integer"""
    x = [guess]

    while (x[-1] + n / x[-1]) / 2 != x[-1]:
        x.append((x[-1] + n / x[-1]) / 2)

    return len(x)


def square(x):
    '''
    x: int or float.
    '''
    result = 1
    result = x * x
    return result


def fourthPower(x):
    '''
    x: int or float.
    '''
    return square(square(x))


def findsquare(a):
    epsilon = 0.0000001
    x = a / 2.0
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            return x


def index():
    q = request.args.get('q')
    try:
        result = str(api(request.args))
        print q, '=>', result
        return result


def index2():
    q = request.args.get('q')
    result = str(api(request.args))
    print q, '=>', result
    return result


def api(args):
    q = args['q']
    if "largest" in q or "primes" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        numbers = q.split(':')[2]
        numbers = map(int, numbers.split(', '))
        if "largest" in q:
            return largest(numbers)


def largest(numbers):
    return max(numbers)


def plus(numbers):
    total = 0
    for n in numbers:
        total += n
    return total


def square_and_cube(numbers):
    return filter(is_square_and_cube, numbers)


def is_square_and_cube(number):
    square_root = number ** 0.5
    cube_root = number ** (1 / 3.0)
    return equal_float(square_root, int(square_root)
                       ) and equal_float(cube_root, int(cube_root))


def equal_float(a, b):
    return abs(a - b) < 0.00001


def prime(numbers):
    return filter(is_prime, numbers)


def is_prime(n):
    if n % 2 == 0 and n > 2:
        return False


def fibo(n):
    if n < 2:
        return n


def is_anagram(a, b):
    return sorted(list(a)) == sorted(list(b))


def root(x):
    epsilon = 0.01
    guess = x / 2.0
    while abs(guess * guess - x) >= epsilon:
        guess = guess - (((guess ** 2) - x) / (2 * guess))

    return guess


def square(x):
    return x ** 2


def square_root(x):
    return math.sqrt(x)


def gev(matrix):
    x = (matrix[0, 0] + matrix[1, 1]) / 2
    y = sp.sqrt(-sp.square(matrix[0, 0] - matrix[1, 1]
                           ) - 4 * matrix[1, 0] * matrix[0, 1]) / 2
    return complex(x, y)


def csr0(complex_n):
    s = sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))
    angle = sp.angle(complex_n)
    return sp.sqrt(s) * (complex((sp.cos(angle * 0.5)), (sp.sin(angle * 0.5))))


def csr1(complex_n):
    CMP0 = (sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))) / 2
    CMP1 = (complex_n.real / 2)
    return complex(sp.sqrt(CMP0 + CMP1), sp.sign(complex_n.imag)
                   * (sp.sqrt(CMP0 - CMP1)))


def csr2(complex_n):
    t = sp.sqrt((sp.absolute(complex_n.real) +
                 (sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag)))) / 2)
    if(complex_n.real >= 0):
        return complex(t, (complex_n.imag / (2 * t)))


def csr3(complex_n):
    ang = sp.angle(complex_n)
    r = sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))
    if (sp.sin(ang / 2) >= 0):
        return sp.sqrt(r) * (complex(sp.cos(ang / 2), sp.sin(ang / 2)))


def blockRoot(matrix):
    if (matrix.shape[0] == 2):
        a = csr3(gev(matrix)).real
        ris = sp.ndarray(shape=(2, 2))
        ris[0, 0] = a + (1 / (4 * a)) * (matrix[0, 0] - matrix[1, 1])
        ris[1, 1] = a - (1 / (4 * a)) * (matrix[0, 0] - matrix[1, 1])
        ris[0, 1] = (1 / (2 * a)) * matrix[0, 1]
        ris[1, 0] = (1 / (2 * a)) * matrix[1, 0]
    else:

        return sp.sqrt(matrix)


def diagRoots(matrix):
    ris = sp.zeros(shape=matrix.shape)
    bb, eb, dims, wb, i, j = findBlocks0(matrix)
    k = 0
    for i in range(0, j):
        ris[k:k + dims[i], k:k + dims[i]
            ] = blockRoot(matrix[k:k + dims[i], k:k + dims[i]])

        k += dims[i]

    return ris


def square_root(s):
    i = 1
    j = s
    while (abs(j - i) > 0.001):
        print i, j
        j = (i + j) / 2.0
        i = s * 1.0 / j
    return i


def is_square(number):
    root = math.sqrt(number)
    if int(root + 0.5) ** 2 == number:
        return True


def print_coef(coef):
    """Gre le format du coef
    """
    if isinstance(coef, (float, int)):
        if coef > 0:
            return "+" + decimaux(coef)


def __repr__(self):
    """Renvoie une chane de caractre reprsentant un :mod:`SquareRoot`
    valuable pour crer un :mod:`SquareRoot`.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> repr(SquareRoot(-4, [-2, 1], [3, 45], [-1, 7], 8))
    'SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])'

    :rtype: String
    """
    return "SquareRoot(%s)" % self.racines


def __len__(self):
    """*object*\ .\ **__len__**\ ()

    Renvoie le nombre d'lments de l'objet SquareRoot.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> len(SquareRoot(3, [2, 2], [4, 5]))
    3

    :rtype: integer
    """
    return len(self.racines)


def __getitem__(self, i):
    """*object*\ .\ **__getitem__**\ (*integer*)

    Renvoie le i me lment de l'objet SquareRoot.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot(3, [2, 2], [4, 5])[2]
    [4, 5]

    :rtype: list
    """
    return self.racines[i]


def __add__(self, other):
    """Renvoie la somme d'un objet SquareRoot et d'un nombre.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([3,45],3)+SquareRoot([2,45])
    SquareRoot([[3, None], [5, 45]])

    :rtype: SquareRoot
    """

    if not isinstance(other, SquareRoot):
        other = SquareRoot([other, None])
    self.racines.extend(other.racines)
    return SquareRoot(self.racines).simplifie()


def __radd__(self, other):
    """
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> 2+SquareRoot([3,45],3)
    SquareRoot([[5, None], [3, 45]])

    :rtype: SquareRoot
    """
    other = SquareRoot([other, None])
    other.racines.extend(self.racines)
    return SquareRoot(other.racines).simplifie()


def __neg__(self):
    """*object*\ .\ **__neg__**\ ()

    ``p.__neg__()`` est quivalent  ``-p`` est quivalent  ``p = -p``

    Renvoie l'oppos d'un objet SquareRoot.

    :rtype: SquareRoot
    """
    if self.EstDecomposable() or self.EstReductible():
        return '-%r' % self.simplifie()


def __abs__(self):
    """ Renvoie la valeur absolue d'un objet SquareRoot

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> abs(SquareRoot([5, 5], [-2, 7]))
    SquareRoot([[5, 5], [-2, 7]])
    >>> abs(SquareRoot([-5, 5], [2, 7]))
    SquareRoot([[5, 5], [-2, 7]])

    :rtype: SquareRoot
    """
    t = 0
    for e in self.racines:
        if e[1] is None:
            t += e[0]
        else:
            t += e[0] * sqrt(e[1])
    if t > 0:
        return self


def __mul__(self, other):
    """Multiplie un objet SquareRoot par un nombre.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([3,45],3)*SquareRoot([2,45],-1)
    SquareRoot([['6*45', None], [-3, 45], [6, 45], [-3, None]])
    """
    if not isinstance(other, SquareRoot):
        other = SquareRoot([other, None])
    reduction = False
    if self.EstReductible():
        self = self.simplifie()
        reduction = True
    if other.EstReductible():
        other = other.simplifie()
        reduction = True
    if reduction:
        return '%r*%r' % (self, other)


def __rmul__(self, other):
    """
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> 5*SquareRoot([3,45],3)
    SquareRoot([[15, 45], [15, None]])

    :rtype: SquareRoot
    """
    return SquareRoot([other, None]) * self


def __floordiv__(self, other):
    """
    Division entire par un entier

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([10, 8], [15, 5])//5
    SquareRoot([[2, 8], [3, 5]])

    :rtype: SquareRoot
    """
    if isinstance(other, int):
        r = list(self.racines)
        for i in range(len(r)):
            r[i][0] = r[i][0] // other
        return SquareRoot(r)


def EstDecomposable(self):
    """
    Renvoie True si une des racines est de la forme sqrt{a**2*b} avec a != 1

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8], [1, 7]).EstDecomposable()
    True
    >>> SquareRoot([5, 7], [1, 7]).EstDecomposable()
    False

    :rtype: Boolean
    """
    for e in self.racines:
        if e[1] is not None and (carrerise(e[1]) != e[1] or e[1] == 1):
            return True


def EstReductible(self):
    """
    Renvoie True si la somme de racines est rductible

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8], [1, 45]).EstReductible()
    False
    >>> SquareRoot([5, 8], [1, 8]).EstReductible()
    True

    :rtype: Boolean
    """
    lradicandes = []
    rationnel = False
    for e in self.racines:
        if e[1] is not None:
            if e[1] in lradicandes:
                return True


def Decompose(self):
    """
    Dcompose une unique racine carre de la forme a*sqrt(b^2*c) en a*sqrt(b^2)*sqrt(c)

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8]).Decompose()
    'SquareRoot([[5, 4]])*SquareRoot([[1, 2]])'

    :rtype: string
    """
    racine = self.racines[0]
    if racine[1] is None:
        return repr(racine[0])


def simplifie(self):
    """
    Additionne les nombres rationnels et dcompose les racines carres.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([[3, 9]]).simplifie()
    '3*3'
    >>> SquareRoot(-2, [-2, 1], [3, 1], [-1, 7], 8).simplifie()
    SquareRoot([[6, None], [1, 1], [-1, 7]])
    >>> SquareRoot(-2, [-2, 1], [3, 45], [-1, 7], 8).simplifie()
    SquareRoot([[6, None], [-2, 1], [3, 45], [-1, 7]])
    >>> SquareRoot([-2,1],[3,45]).simplifie()
    '-2+SquareRoot([[3, 9]])*SquareRoot([[1, 5]])'

    :rtype: SquareRoot ou String
    """
    decomposable = self.EstDecomposable()
    reductible = self.EstReductible()
    if not decomposable and not reductible:
        return self


def square(x):
    """Return the square of `x`.

    Parameters
    ----------
    x : int or float
        The input number.

    Returns
    -------
    x2 : same type as `x`
        The square of the input value.

    Examples
    --------
    >>> square(5)
    25
    """
    return x ** 2


def sqrt(x):
    """Return the square root of `x`.

    Examples
    --------
    >>> sqrt(4.0)
    2.0
    """
    return x * 0.5


def euler57():
    """http://projecteuler.net/index.php?section=problems&id=57

    Investigate the expansion of the continued fraction for the square root of
    two."""
    generator = sqrt_two_expansion()
    return len(filter(lambda x: len(str(x.numerator)) > len(str(x.denominator)),


def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""

    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    low = 0
    high = max(x, 1.0)

    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, ''
    print 'Bi', ctr, '', guess
    return guess


def squareRootNR(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""

    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr <= 100, ''
    print 'NR', ctr, '', guess
    return guess


def getMax(self, data):
    input_array = data

    find(largest(square, that(contains(same(digit, all, corner)))))

    return(number(cells(square)))


def example0():
    cls = SquareOfDigits()
    input0 = ["12", "34"]
    returns = 1
    result = cls.getMax(input0)
    return result == returns


def example1():
    cls = SquareOfDigits()
    input0 = ["1255", "3455"]
    returns = 4
    result = cls.getMax(input0)
    return result == returns


def example2():
    cls = SquareOfDigits()
    input0 = ["42101", "22100", "22101"]
    returns = 9
    result = cls.getMax(input0)
    return result == returns


def example3():
    cls = SquareOfDigits()
    input0 = ["1234567890"]
    returns = 1
    result = cls.getMax(input0)
    return result == returns


def example4():
    cls = SquareOfDigits()
    input0 = [
        "9785409507",
        "2055103694",
        "0861396761",
        "3073207669",
        "1233049493",
        "2300248968",
        "9769239548",
        "7984130001",
        "1670020095",
        "8894239889",
        "4053971072"]
    returns = 49
    result = cls.getMax(input0)
    return result == returns


def r8_pi_sqrt():

    value = 1.7724538509055160273

    return value


def is_amicable_pair(n):
    """tests if it is amicable pair, and returns the pair"""


def find_all_amicable_numbers(n):
    """finds all amicable numbers until n"""
    list_pairs = []
    for i in range(2, n + 1):
        if i not in list_pairs:
            pair = is_amicable_pair(i)
            if pair == i:
                continue
            if pair:
                list_pairs.append(i)
                list_pairs.append(pair)
    for item in list_pairs:
        if item > n:
            list_pairs.remove(item)
    return list_pairs


def __lt__(self, other):
    if manhattenDistance(self.getPath()[
                         0]) + len(self.getPath()) < manhattenDistance(other.getPath()[0]) + len(other.getPath()):
        return True


def __eq__(self, other):
    if manhattenDistance(self.getPath()[
                         0]) + len(self.getPath()) == manhattenDistance(other.getPath()[0]) + len(other.getPath()):
        return True


def is_square(n):
    root = float(n) ** .5
    root = int(root + .5)
    if root * root == n:
        return root


def square_root(a, x):
    """
    a: find the sqrt of a
    x: estimate
    """
    y = (x + a / x) / 2
    while abs(y - x) > 0.0000001:
        x = y
        y = (x + a / x) / 2

    return y


def square_root_2(a, x):

    y = (x + a / x) / 2
    while True:
        x = y
        y = (x + a / x) / 2

        if abs(y - x) < 0.0000001:
            break
    return y


def test_square_root():
    a = 1.0
    while a < 10:
        m = square_root(a, 3)
        n = math.sqrt(a)
        print(a, "\t", m, "\t", n, "\t", abs(n - m))
        a = a + 1.0

test_square_root()


"""
Implement int sqrt(int x).
Compute and return the square root of x.


def sqrt(self, x, blind_steps=0, accepted_error=1):
    if x < 0:
        print 'error, cannot compute square root of negative number'
        return -1


def is_square(n):
    root = int(n ** 0.5)
    return root * root == n


def euler86():
    size = 0
    M = 1
    target = 1000000

    while True:
        for ab in range(2, 2 * M + 1):
            if is_square((ab) ** 2 + M ** 2):
                if ab < M:
                    size += ab / 2
                else:
                    size += (ab / 2 - (ab - M) + 1)
                if size > target:
                    return M


def square_root(a, x, iteration=0):
    a = float(a)
    if abs(x - sqrt(a)) > 0.000001:
        next_x = ((x + (a / x)) / 2)
        iteration += 1
        return square_root(a, next_x, iteration)


def square_root(num, guess):
    print 'Current guess: %f' % guess
    return 0.5 * (guess + (num / guess))


def main(num, tolerance):
    first_guess = num / 2.0
    approx_root = square_root(num, first_guess)
    while True:
        new_guess = square_root(num, approx_root)
        if abs(new_guess - approx_root) < tolerance:
            return new_guess


def findSquareRoot(number):
    low = 0.0
    high = number
    epsilon = 0.00000000001
    guess = (low + high) / 2

    while abs(number - guess ** 2) > epsilon:
        print "high:  " + str(high) + "  low:  " + str(low) + "  guess:   " + str(guess)
        if guess ** 2 < number:
            low = guess
        elif guess ** 2 > number:
            high = guess
        elif guess ** 2 == number:
            return "found square root of" + \
                str(number) + 'would be' + str(guess)


def sum_of_squares(x, y):
    return square(x) + square(y)


def f(a):
    return sum_of_squares(a + 1, a * 2)


def abs(x):
    if x > 0:
        return x


def abs(x):
    if x < 0:
        return -x


def ge(x, y):
    return x > y or x == y


def ge(x, y):
    return not(x < y)


def three_n(n1, n2, n3):
    if n1 > n2:
        if n1 > n3:
            if n2 > n3:
                return n1 * n1 + n2 * n2


def a_plus_abs_b(a, b):
    if b > 0:
        return a + b


def p():
    return p()


def test(x, y):
    if x == 0:
        return 0


def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001


def average(x, y):
    return (x + y) / 2.0


def improve(guess, x):
    return average(guess, float(x) / guess)


def sqrt_iter(guess, x):
    if good_enough(guess, x):
        return guess


def sqrt(x):
    return sqrt_iter(1.0, float(x))


def new_if(predicate, then_clause, else_clause):
    if predicate:
        return then_clause


def sqrt_iter(guess, x):
   return new_if(


def good_enough_gp(guess, prev):
    return abs(guess - prev) / guess < 0.001


def sqrt_iter_gp(guess, prev, x):
    if good_enough_gp(guess, prev):
        return guess


def sqrt_gp(x):
    return sqrt_iter_gp(4.0, 1.0, float(x))


def improve_cube(guess, x):
    return (2.0 * guess + float(x) / (guess * guess)) / 3.0


def cube_iter(guess, prev, x):
    if good_enough_gp(guess, prev):
        return guess


def cube_root_0(x):
    return cube_iter(27.0, 1.0, x)


def double(x):
    return x + x


def square_real(x):
    return math.exp(double(math.log(x)))


def sqrt(x):
    return sqrt_iter(1.0, x)


def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001


def improve(guess, x):
    return average(guess, float(x) / guess)


def sqrt_iter(guess, x):
    if good_enough(guess, x):
        return guess


def good_enough(guess):
    return abs(square(guess) - x) < 0.001


def improve(guess):
    return average(guess, float(x) / guess)


def sqrt_iter(guess):
    if good_enough(guess):
        return guess


def factorial(n):
    if n == 1:
        return 1


def fact_iter(product, counter, max_count):
    if counter > max_count:
        return product


def factorial(n):
    return fact_iter(1, 1, n)


def iter(product, counter):
    if counter > n:
        return product


def inc(a):
    return a + 1


def dec(a):
    return a - 1


def plus(a, b):
    if a == 0:
        return b


def a(x, y):
    if y == 0:
        return 0


def f(n):
    return a(0, n)


def g(n):
    return a(1, n)


def h(n):
    return a(2, n)


def k(n):
    return 5 * n * n


def fib(n):
    if n == 0:
        return 0


def fib_iter(a, b, count):
    if count == 0:
        return b


def fib(n):
    return fib_iter(1, 0, n)


def first_denomination(x):
    if x == 1:
        return 1


def cc(amount, kinds_of_coins):
    if amount == 0:
        return 1


def count_change(amount):
    return cc(amount, 5)


def f(n):
    if n < 3:
        return n


def f_iter(a, b, c, count):
    if count == 0:
        return c


def f(n):
    return f_iter(2, 1, 0, n)


def pascals_triangle(n, k):
    if n == 0:
        return 1


def cube(x):
    return x * x * x


def p(x):
    return 3.0 * x - 4.0 * cube(x)


def sine(angle):
    if not(abs(angle) > 0.1):
        return angle


def expt(b, n):
    if n == 0:
        return 1


def expt_iter(b, counter, product):
    if counter == 0:
        return product


def expt(b, n):
    return expt_iter(b, n, 1)


def even(n):
    return (n % 2) == 0


def fast_expt(b, n):
    if n == 0:
        return 1


def multiply(a, b):
    if b == 0:
        return 0


def gcd(a, b):
    if b == 0:
        return a


def divides(a, b):
    return (b % a) == 0


def find_divisor(n, test_divisor):
    if square(test_divisor) > n:
        return n


def smallest_divisor(n):
    return find_divisor(n, 2)


def prime(n):
    return n == smallest_divisor(n)


def expmod(nbase, nexp, m):
    if nexp == 0:
        return 1


def try_it(a):
    return expmod(a, n, n) == a


def fast_prime(n, ntimes):
    if ntimes == 0:
        return True


def expmod(nbase, nexp, m):
    return fast_expt(nbase, nexp) % m


def carmichael(n):
    return fast_prime(n, 100) and not(prime(n))


def sum_integers(a, b):
    if a > b:
        return 0


def sum_cubes(a, b):
    if a > b:
        return 0


def pi_sum(a, b):
    if a > b:
        return 0.0


def sum(term, a, next, b):
    if a > b:
        return 0


def inc(n):
    return n + 1


def sum_cubes(a, b):
    return sum(cube, a, inc, b)


def identity(x):
    return x


def sum_integers(a, b):
    return sum(identity, a, inc, b)


def pi_term(x):
    return 1.0 / (x * (x + 2.0))


def pi_next(x):
    return x + 4.0


def add_dx(x):
    return x + dx


def sum_iter(term, start, next, stop, acc):
    if start > stop:
        return acc


def sum_iter(term, a, next, b, acc):
    if a > b:
        return acc


def sum_cubes(a, b):
    return sum_iter(cube, a, inc, b, 0)


def product(term, a, next, b):
    if a > b:
        return 1


def factorial(n):
    return product(identity, 1, inc, n)


def product_iter(term, a, next, b, acc):
    if a > b:
        return acc


def accumulate(combiner, null_value, term, a, next, b):
    if a > b:
        return null_value


def sum(a, b):
    return accumulate(lambda x, y: x + y, 0, identity, a, inc, b)


def product(a, b):
    return accumulate(lambda x, y: x * y, 1, identity, a, inc, b)


def accumulate_iter(combiner, term, a, next, b, acc):
    if a > b:
        return acc


def sum(a, b):
    return accumulate_iter(lambda x, y: x + y, identity, a, inc, b, 0)


def product(a, b):
    return accumulate_iter(lambda x, y: x * y, identity, a, inc, b, 1)


def filtered_accumulate(combiner, null_value, term, a, next, b, pred):
    if a > b:
        return null_value


def pi_sum(a, b):
    return sum(lambda x: 1.0 / (x * (x + 2.0)), a, lambda x: x + 4.0, b)


def integral(f, a, b, dx):
    return sum(f, a + (dx / 2.0), lambda x: x + dx, b) * dx


def plus4(x):
    return x + 4


def f_helper(a, b):
    return x * square(a) + y * b + a * b


def f(x, y):
    return (lambda a, b: x * square(a) + y * b + a * b)(1 + x * y, 1 - y)


def f(x, y):
    a = 1 + x * y
    b = 1 - y
    return x * square(a) + y * b + a * b


def f(g):
    return g(2)


def close_enough(x, y):
    return abs(x - y) < 0.001


def positive(x):
    return x >= 0.0


def negative(x):
    return not(positive(x))


def search(f, neg_point, pos_point):
    midpoint = average(neg_point, pos_point)
    if close_enough(neg_point, pos_point):
        return midpoint


def half_interval_method(f, a, b):
    a_value = f(a)
    b_value = f(b)
    if negative(a_value) and positive(b_value):
        return search(f, a, b)


def close_enough(v1, v2):
    return abs(v1 - v2) < tolerance


def tryit(guess):
    next = f(guess)
    if close_enough(guess, next):
        return next


def sqrt(x):
    return fixed_point(lambda y: float(x) / y, 1.0)


def sqrt(x):
    return fixed_point(lambda y: average(y, float(x) / y), 1.0)


def golden_ratio():
    return fixed_point(lambda x: 1.0 + 1.0 / x, 1.0)


def average_damp(f):
    return lambda x: average(float(x), f(x))


def sqrt(x):
    return fixed_point(average_damp(lambda y: float(x) / y), 1.0)


def cube_root(x):
    return fixed_point(average_damp(lambda y: float(x) / square(y)), 1.0)


def deriv(g):
    return lambda x: float(g(x + dx) - g(x)) / dx


def newton_transform(g):
    return lambda x: x - float(g(x)) / (deriv(g)(x))


def newtons_method(g, guess):
    return fixed_point(newton_transform(g), guess)


def sqrt(x):
    return newtons_method(lambda y: square(y) - x, 1.0)


def fixed_point_of_transform(g, transform, guess):
    return fixed_point(transform(g), guess)


def sqrt(x):
    return fixed_point_of_transform(lambda y: x / y, average_damp, 1.0)


def sqrt(x):
    return fixed_point_of_transform(
        lambda y: square(y) - x, newton_transform, 1.0)


def cubic(a, b, c):
    return lambda x: cube(x) + a * x * x + b * x + c


def double(f):
    return lambda x: f(f(x))


def compose(f, g):
    return lambda x: f(g(x))


def iterate(arg, i):
    if i > n:
        return arg


def smooth(f, dx):
    return lambda x: average(x, (f(x - dx) + f(x) + f(x + dx)) / 3.0)


def iterate(guess):
    next = improve(guess)
    if good_enough(guess, next):
        return next


def good_enough(v1, v2):
    return abs(v1 - v2) < tolerance


def squareRootBisect(num, precise=3):
    ''' Returns closest square-root of a number,
        using Bisection search algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1


def squareRootNR(num, precise=3):
    ''' Returns closest square-root of a number,
        using Newton-Rapson approximation algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1


def frac_iter(n, v=Fraction(1, 2)):
    '''Yield expression for n expansions'''
    while n > 0:
        yield Fraction(1, 1) + v
        v = Fraction(1, Fraction(2, 1) + v)
        n -= 1
    return


def check_if_numerator_larger_denominator(number_as_fraction):
    numerator = len(str(number_as_fraction.numerator))
    denominator = len(str(number_as_fraction.denominator))
    return numerator > denominator


def solve_problem():

    max_range = 1000
    count = 0

    for i, square_root in enumerate(yield_square_root(max_range)):
        if check_if_numerator_larger_denominator(square_root):
            count += 1

    print("Condition fullfilled by:")
    print(count)

    return 0


def sqrt(x):
    """Compute square root using the Heron of Alexandria method

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError('Cannot compute square root '
                         'of negative number {}'.format(x))

    guess = x
    i = 0

    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def print_n(s, n):
    while n > 0:
        print s
        n = n - 1
    return None


def square_root(a, x):
    """
    a : number to compute square root
    x : approximation guess
    """
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < 0.000000001:
            break
        x = y
    return x


def eval_loop():
    while True:
        a = raw_input('Give me a sting to evaluate : \n')
        if a == 'done':
            break
        r = eval(a)
        print r
    return r


def estimate_pi():
    s = 0
    k = 0
    while True:
        time = 2 * math.sqrt(2) / 9810
        numer = math.factorial(4 * k) * (1103 + 26390 * k)
        denom = (math.factorial(k)) ** 4 * 396 ** (4 * k)
        if time * numer / denom < 1e-15:
            break
        s = s + time * numer / denom
        k = k + 1
    pi = 1 / s
    return pi


def add(x, y):
    s = x + y
    return "\n\t{} + {} = {}".format(x, y, s)


def minus(x, y):
    s = x - y
    return "\n\t{} - {} = {}".format(x, y, s)


def division(x, y):
    s = x / y
    return "\n\t{} / {} = {}".format(x, y, s)


def multiplication(x, y):
    s = x * y
    return "\n\t{} * {} = {}".format(x, y, s)


def exponentiation(x, y):
    s = x ** y
    return "\n\t{} ** {} = {}".format(x, y, s)


def squareRoot(x):
    s = sqrt(x)
    return "\n\t{} = {}".format(x, s)


def de_decimal(n):
    n = str(n)
    n = "".join(n.split("."))
    return int(n)


def get_square_root(n, precision=100):
    """
    Used the square root by subtraction method by Frazer Jarvis
    """
    a = 5 * n
    b = 5
    while len(str(b)) < precision + 2:
        if a >= b:
            a, b = a - b, b + 10
        elif a < b:
            a, b = a * 100, (b - 5) * 10 + 5
    return str(b)[:-2]


def main(upper=100, precision=100):
    a = 0
    for i in range(1, upper + 1):
        if not (i ** 0.5).is_integer():
            for j in get_square_root(i, precision):
                a += int(j)
    return a


def mySqrt(self, x):
    """
    :type x: int
    :rtype: int
    """

    if x == 0:
        return 0


def sqrt(self, x):
    if x < 0:
        return


def Adder(N1, N2):
    MyResult = N1 + N2
    return MyResult


def Subtractor(N1, N2):
    MyResult = N1 - N2
    return MyResult


def Main():
    X = input("Enter a value for X ---")
    Y = input("Enter a value for Y ---")
    if (X >= Y):
        print "Subtraction happened"
        MyResult = Subtractor(X, Y)
    else:
        print "Addition happened"
        MyResult = Adder(X, Y)
    Result1 = math.sqrt(MyResult)
    print "the square root of ", MyResult, " is ", Result1
    return


def Frog():
    print "Yay!"
    return


def square_root(a):
    eps = 1e-8
    x = 1.0
    y = 2.0
    cnt = 1
    while abs(y - x) > eps:
        x = y
        y = (x + a / x) / 2
        print 'iter', cnt, '\ty=', y
        cnt = cnt + 1
    return y


def root_of_closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """

    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def iroot(k, n):
    """ http://stackoverflow.com/questions/15978781/how-to-find-integer-nth-roots"""

    u, s = n, n + 1
    while u < s:
        s = u
        t = (k - 1) * s + n // pow(s, k - 1)
        u = t // k
    return s


def closest_perfect_kth_root(x, k):
    """ naive method by KJL """

    y = 2
    while y <= x:
        y = y ** k
        if y > x:
            return y ** (1 / k) - 1


def WHL_kth(x, k):
    """ main computing function derived by Kevin Webster, Blane Hollingsworth,
    and Ken Locey """

    n = closest_perfect_kth_root(x, k)
    i = 1
    a = 0
    while i <= k:
        b = scipy.special.binom(k, 1)
        a += (b * (n ** (k - i)))
        i += 1

    a = (x - n ** k) / a
    a += n

    return float(a)


def Guess(x, k):
    """ a function to guess the remainder of the root to reveal whether
    decreasing error in the WHL algorithm is meaningful """

    n = closest_perfect_kth_root(x, k)
    a = np.random.uniform(0, 1)

    a += n

    return float(a)


def root_mean_square(features, values, w, f=None):
    size = len(features[0])
    if f is None:
        v = dot(features, w) - values
    else:
        v = f(dot(features, w)) - values
    return sqrt(dot(v, v) / size)


def accept_n_gt_zero(fnToCall):
    if n <= 0:
        print 'From inside Decorator: n <=0 before raising exception'

        return 0


def SquareRoot(n):
    result = n ** (1 / 2)
    return result


def squareRoot(expansions_count):
    if expansions_count == 1:
        return 2


def powersInMod(n):
    ''' Computes all the squares in the integers mod n.
    '''
    return set((x * x) % n for x in range(0, n // 2 + 1))


def isSquare(n):
    '''Checks for perfect squares by checking mod 64 to rule out 52/64 cases immediately.'''
    if n % isSquare.mod in isSquare.set:
        m = math.floor(math.sqrt(n))
        return m * m == n


def tsSquareRoot(a, p):
    '''Calculates the square root mod p of a.'''
    jacobi = jacobi_symbol(a, p)
    if jacobi == -1:
        raise ValueError("No square root mod {0} exists.".format(p))
    s = p - 1
    e = 0
    while s % 2 == 0:
        e += 1
        s //= 2
    n = findQuadraticNonresidue(p)
    x = pow(a, ((s + 1) / 2), p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e
    while r > 0:

        m = 0
        bp = b
        while m < r:
            if bp == 1:
                break
            bp = (bp * bp) % p
            m += 1
        if m == 0:
            break

        g = pow(g, pow(2, (r - m - 1), p), p)
        x = (x * g) % p
        g = (g * g) % p
        b = (b * g) % p
        r = m
    return x


def findQuadraticNonresidue(p):
    if p % 8 in [3, 5]:
        return 2


def square_root(number):
    left = 0
    right = number

    while left < right:
        middle = left + ((right - left) / 2.0)
        squared = middle ** 2

        if number - squared < 0.00001 and number - squared > 0:
            return round(middle, ROUND)


def fib_iter(a, b, p, q, count):
    if count == 0:
        return b


def fib_monster(n):
    return fib_iter(1, 0, 0, 1, n)


def sqrt(n):
    if n < 0:
        raise ValueError("sqrt can't be less than 0")

    upper = 1 if n < 1 else n
    lower = 0
    return SquareRoot._sqrt(n, lower, upper)


def _sqrt(n, lower, upper):
    mid = (lower + upper) / 2.0
    midsq = mid * mid

    if abs(midsq - n) < SquareRoot.epsilon:
        return mid


def f(self, dict, n):
    if n == 0:
        return 0


def numSquares(self, n):
    """
    :type n: int
    :rtype: int
    """
    dict = {}
    return self.f(dict, n)


def sum_digs(n):
    s = 0
    while n > 0:
        s += n % 10
        n /= 10
    return s


def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0


def get_largest_prime_factor(number):
    possible_factors = itertools.count(2)
    square_root_num = math.sqrt(number)

    for num in possible_factors:

        if num > square_root_num:
            break

        if num >= number:
            break

        while number / num % 1 == 0:
            if number / num != 1:
                number /= num

    return number


def square_root(target):
    guess = 0
    guesses = 0

    while (abs(guess * guess - target) > _tolerance and
           guess * guess < target):
        guess += 0.00001
        guesses += 1

    if abs(guess * guess - target) > _tolerance:
        raise(_NO_GOOD_SOLUTION_FOUND)

    if _debug:
        print(guesses)

    return(guess)


def sqrt(n, error=0.1):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid


def sqrt2(a):
    x = a / 4
    while True:
        y = (x + a / x) / 2
        if x == y:
            return x


def tabs(x):
    return str(x) + 4 * ' '


def factorial(n):
    if n == 0:
        return 1


def estimate_pi():
    const = (2 * math.sqrt(2)) / 9801
    k = 1
    sumeval = 1103
    x = sumeval
    while x >= 1e-15:
        x = (factorial(4 * k) * (1103 + 26390 * k)) / \
            ((factorial(k) ** 4) * (396 ** (4 * k)))
        sumeval += x
        k = k + 1
    return 1 / (const * sumeval)


def avg(*args):
    return float(reduce(lambda x, y: x + y, args)) / len(args)


def improve(guess, x):
    return avg(x / guess, guess)


def guess_change_is_small_fraction_of_guess(guess, x):
    return math.fabs(improve(guess, x) - guess) < guess * 0.0001


def good_enough(guess, x):
    return guess_change_is_small_fraction_of_guess(guess, x)


def sqrt_iter(guess, x, calls=0):
    if good_enough(guess, x):
        return guess


def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def registered_factors():
    return ErrorUtil.REGISTERED_FUNCTIONS.keys()


def get_factor(name):
    if name == ErrorUtil.ROOT_MEAN_SQUARE:
        return ErrorUtil.REGISTERED_FUNCTIONS[name]


def default_factor():
    return ErrorUtil.ROOT_MEAN_SQUARE


def squareRootBi(x, epsilon):
    assert x >= 0, 'x must be non-negative,not' + str(x)
    assert epsilon > 0, 'epsilon must be postive,not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100,  'Iteration count exceeded'
    print 'Bi method. Num. iterations', ctr, 'Estimer', guess
    return guess


def iterSqRt(number):
    for counter in range(1, number):
        if counter ** 2 == number:
            return "square root of" + str(number) + "is" + str(counter)


def sqrt(self, x):

    return int(x ** 0.5)


def json(self):
    return jsonpickle.encode(self)


def __unicode__(self):
    return self.title + " by " + self.author


def pseudo_bin_search(start, end, gap, number):
    left = start
    right = end
    curr = left + (right - left) / 2
    for i in range(120):

        doubled_curr = curr * curr
        if doubled_curr >= number and (curr - gap) * (curr - gap) <= number:
            return curr


def bin_search(arr, number):
    left = 0
    right = len(arr) - 1
    curr = left + (right - left) // 2

    while left < right:
        if arr[curr + 1] ** 2 >= number and arr[curr - 1] ** 2 <= number:
            return arr[curr]


def generate_range(number):
    left = 0
    right = number
    gap = 1
    return pseudo_bin_search(left, right, gap, number)


def square_root(number):
    max_item = generate_range(number)
    left = max_item - 1
    right = max_item + 1
    gap = 0.0000001

    return pseudo_bin_search(left, right, gap, number)


def draw_level(
    self,
    root,
    root_size,
    directory_sizes,
    file_sizes,
    spacing=4,
    square_color=(200, 225, 255),
    font_color=(0, 0, 0),
    border_color=(0, 0, 0),
    ):

    min_square_size = (
        2 * spacing + 3 * self.font_size,
        3 * spacing + self.font_size)

    if root not in self.square_size:

        return


def sqrt(n):
    '''function to determine the square root of a given numebr n'''

    error = 1
    oldGuess = n / 2
    newGuess = 0

    while (error > 1e-6):
        newGuess = ((n / oldGuess) + oldGuess) / 2
        error = abs(oldGuess - newGuess)
        oldGuess = newGuess

    return newGuess


def fermat_factor(n):
    assert n % 2 != 0

    a = gmpy2.ceil(gmpy2.sqrt(n))
    b2 = gmpy2.square(a) - n
    while not is_square(b2):
        a += 1
        b2 = gmpy2.square(a) - n

    factor1 = a + gmpy2.sqrt(b2)
    factor2 = a - gmpy2.sqrt(b2)
    return int(factor1), int(factor2)


def is_square(n):
    root = gmpy2.sqrt(n)
    return root % 1 == 0


def fact(n):
    if n >= 0:
        return fact2(n, 1)


def fact2(a, b):
    if a != 1:
        return fact2(a - 1, b * a)


def fib(n):
    if n >= 0:
        return fib2(n, 0, 1)


def fib2(a, b, c):
    if a != 1:
        return fib2(a - 1, c, b + c)


def sqrt(n):
    if n > 0:
        return sqrt2(n, 1)


def sqrt2(a, b):
    if abs(a - b * b) > .000000000000001:
        return sqrt2(a, (a / b + b) / 2)


def my_sqrt(x):
    EPSILON = 1e-10
    done = False
    root = (x + 1) / 2

    while not done:
        root1 = (root + x / root) / 2
        done = abs(root - root1) < EPSILON
        root = root1

    return root


def sieve_of_atkin(limit):
    primes = []

    sieve = [False] * limit

    square_root_of_limit = int(math.sqrt(limit))

    for x in range(1, square_root_of_limit + 1):
        for y in range(1, square_root_of_limit + 1):
            n = (4 * x * x) + (y * y)

            if n <= limit and (n % 12 == 1 or n % 12 == 5):
                sieve[n] = not sieve[n]

            n = (3 * x * x) + (y * y)

            if n <= limit and n % 12 == 7:
                sieve[n] = not sieve[n]

            n = (3 * x * x) - (y * y)

            if x > y and n <= limit and n % 12 == 11:
                sieve[n] = not sieve[n]

    sieve[2] = True

    sieve[3] = True

    primes.append(2)

    primes.append(3)

    n = 5

    while n <= square_root_of_limit:
        if sieve[n]:
            i = n * n

            while i < limit:
                sieve[i] = False

                i += n * n

            primes.append(n)

        n += 2

    while n < limit:
        if sieve[n]:
            primes.append(n)

        n += 2

    return primes


def square_root_update(x, a):
    return average(x, a / x)


def average(x, y):
    return (x + y) / 2


def largestPrimeFactor(n):
    largest = 2
    sqrtN = int(round(math.sqrt(n)))
    for i in xrange(2, sqrtN):

        if n % i == 0 and isPrime(i) and i > largest:
            largest = i
            i = n / largest
    return largest


def isPrime(n):
    squareRoot = round(math.sqrt(n))
    for i in xrange(2, int(squareRoot)):
        if n % i == 0:
            return False


def add(a, b):
    return a + b


def subtract(a, b):
    return a - b


def multiply(a, b):
    return a * b


def divide(a, b):
    return a / b


def square_root(a):
    return math.sqrt(abs(a))


def power(a, b):
    return math.pow(a, round(b))


def greater_than(a, b, yes, no):
    if a > b:
        return yes


def lesser_than(a, b, yes, no):
    if a < b:
        return yes


def l1_norm(w):
    """
    Returns L1 norm of the given matrix (w).
    L1 norm is simply sum of a matrix elements.

    @input: w, a theano shared variable.
    @output: L1 norm of w
    """

    return abs(w).sum()


def l2_norm(w):
    """
    Returns L2 norm of the given matrix (w).
    L2 norm of a matrix is simply square root of the sum of square of elements of the matrix.
    In an other word, it's length for a matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return T.sqrt((w ** 2).sum())


def l2_norm_sqr(w):
    """
    Returns square of L2 norm of the given matrix (w).
    square of L2 norm of a matrix is simply the sum of square of elements of the matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return (w ** 2).sum()


def square(y):
    return y * y


def average(x, y):
    return (x + y) / 2


def improve(guess):
    return average(guess, (x / guess))


def good_enough(guess):
    return abs(square(guess) - x) < 0.00001


def square_root_iter(guess):
    if good_enough(guess):
        return guess


def cube_root(a):
    return find_zero(lambda x: x * x - a,


def power(x, n):
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product


def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance


def update(x):
    return square_root_update(x, a)


def close(x):
    return approx_eq(x * x, a)


def cube_root(a):
    return improve(lambda x: cube_root_update(x, a),


def squareRootInt(self, x):
    if x <= 1:
        return x


def compute(dm, do):
    """ Computes rms"""
    if dm is None and do is None:
        return {


def problem(n):
    if (n < 1):
        raise ValueError("n must be a positive integer")
    elif (n == 1):
        return True


def isPrime(n):
    if (n <= 1):
        return False


def square_root(a):
    """Approximates the square root of input a to accuracy of 0.000001"""
    x = a / 2
    while True:
        print(x)
        y = (x + a / x) / 2
        if abs(y - x) < 0.000001:
            break
        x = y

    return x


def build(self):
    state.root = Builder.load_file('main.kv')
    return state.root


def press(button, root):
    if not state.in_game:
        return


def square_root(a):
    x = a
    while True:
        if x == 0:
            return 0


def is_prime(n):
    if n < 2:
        return False


def factorize(n):
    factors = []

    for x in range(2, int(math.sqrt(n)) + 1):
        if n % x == 0:
            factors.append(x)
            factors.append(n / x)

    return factors


def chunker(lst, length):
    return (lst[pos:pos + length] for pos in xrange(0, len(lst)))


>> > def make_decrementor(n):
... return lambda x: n - x


def sqrt(x):
    """Approximates the square root of the number x.

    This function is provided for demonstration purposes,
    you should use the provided math.sqrt(x) instead.

    """
    return sqrt_helper(1.0, x)


def sqrt_helper(guess, x):
    """Helper function that actually performs the algorithm for sqrt(x)"""
    if good_enough(guess, x):
        return guess


def good_enough(guess, x):
    """Return true if close enough, otherwise false."""
    if math.fabs(guess ** 2 - x) < 0.001:
        return True


def improve_guess(guess, x):
    """Improves the guess by Heron's method

    That is, average the guess and the quotient of x and the guess.

    """
    return (guess + (x / guess)) / 2.0


def example_sqrt(x):
    """Prints example output in a string"""
    print("The square root of " + str(x) + " is " + str(sqrt(x)))
    return None


def square_root(number):
    left = 0
    right = number
    mid = left + (right - left) / 2.0
    while True:
        if mid ** 2 > number:
            right = mid
        if mid ** 2 < number:
            left = mid
        if abs(mid ** 2 - number) < 0.00001:
            break
        mid = left + (right - left) / 2.0
    return mid


def get_layer(cgorup):
    if("docker" not in cgorup):
        return "host"


def replace_container_id(path):
    return re.sub(glob_patterns.container_id, "*", path)


def glob_paths(path):
    path = replace_container_id(path)
    for (regex, sub_value) in glob_patterns.glob_patterns_regex.iteritems():
        path = re.sub(regex, sub_value, path)
    return path


def glob_container_paths(path, cmd):
    full_access_paths = glob_patterns.container_full_access_paths
    if cmd == "build":
        full_access_paths += glob_patterns.container_build_full_access_paths

    if (path.startswith(glob_patterns.container_root)):
        for container_path in full_access_paths:
            if re.match(glob_patterns.container_root +
                        "\*" + container_path + ".+", path):
                return glob_patterns.container_root + "*" + container_path + "**"


def open_permission_rule(args):
    args_list = args.split()
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(args_list[0])

    ''' FMODE_EXEC flag: File is opened for execution with sys_execve '''
    if(flags & 32):
        return ((replace_container_id(
            square_args[0]), EXEC_PERMISSION), square_args[-1])


def memory_map_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path = replace_container_id(square_args[0])
    return ((path, "m"), square_args[-1])


def write_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "w"), square_args[1])


def read_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "r"), square_args[-1])


def rw_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "rw"), square_args[-1])


def lock_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "k"), square_args[-1])


def rename_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    old_path = glob_paths(square_args[0])
    new_path = glob_paths(square_args[1])
    return ((old_path, "rw", new_path, "rw"), square_args[-1])


def pivot_root_link_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path1 = glob_paths(square_args[0])
    path2 = glob_paths(square_args[1])
    return ((path1, path2), square_args[-1])


def mount_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(square_args[3])
    ftype = None
    source = None
    options = []

    if(flags > 0):
        options = [
            apparmor_mnt_flag for (
                mnt_flag,
                apparmor_mnt_flag) in MOUNT_FLAGS_LIST if(
                mnt_flag & flags)]

        if(MS_REC & flags):
            if(MS_PRIVATE & flags):
                options.remove("make-private")
                options.append("make-rprivate")
            if(MS_BIND & flags):
                options.remove("bind")
                options.append("rbind")

    if((len(square_args[2]) > 0) and
       (square_args[2] != "bind") and
       (square_args[2] != "none") and
       (not (MS_REMOUNT & flags))):
        ftype = square_args[2]

    if((len(square_args[0]) > 0) and
       (not (MS_REMOUNT & flags))):
        source = glob_paths(square_args[0])
        if(source[0] == "/" and source[-1] != '/'):
            source = "%s/" % source

    target = glob_paths(square_args[1])
    if(target[-1] != '/'):
        target = "%s/" % target

    return ((ftype, options, source, target), square_args[-1])


def get_permission(line):
    args = line.split(" ", 2)
    probe_point = args[0]
    layer_id = get_layer(args[1])
    square_args = re.findall("\{(.*?)\}", args[2])
    executable_path = replace_container_id(square_args[0])
    if probe_point not in probe_point_dispatcher:
        return (None, None, None, None, None)


def square_root_continuous(x, epsilon=.01):
    step = epsilon ** 2
    num_guesses = 0
    ans = 0.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        ans += step
        num_guesses += 1
    print('Tried ' + str(num_guesses) + ' times')

    return(ans)


def square_root_bisect(x, epsilon=.01):
    num_guesses = 0
    low = 0.0
    high = float(x)
    ans = (low + high) / 2.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        num_guesses += 1
        if ans ** 2 > x:
            high = ans
        else:
            low = ans
        ans = (low + high) / 2.0
    print('Tried ' + str(num_guesses) + ' times')

    return(ans)


def average(x, y):
    return (x + y) / 2


def improve(guess, x):
    return average(guess, (x / guess))


def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001


def square_root_iter(guess, x):
    if good_enough(guess, x):
        return guess


def square_root(x):
    return square_root_iter(1.0, x)


def number_of_divisors(n):
    divisors = 0
    square_root = int(sqrt(n))
    for i in range(1, square_root + 1):
        if n % i == 0:
            divisors += 2

    if square_root * square_root == n:
        divisors -= 1

    return divisors


def triangular_number_with_n_divisors(n):

    triangular_number = 1

    natural_number = 1

    while number_of_divisors(triangular_number) < n:
        natural_number += 1
        triangular_number += natural_number

    return triangular_number


def solver(n=100, m=100):
    """ For the first n natural numbers, find the total of the digital sums
    of the first m decimal digits for all the irrational square roots.

    (solved 2014-11-26)
    """
    result = 0
    getcontext().prec = m + 2
    for number in range(n + 1):
        square_root = Decimal(number).sqrt()
        if square_root % 1:

            decimal_places = str(square_root).replace(".", "")[:m]
            result += sum(int(digit) for digit in decimal_places)
    return result


def digital_sum(n):
    return sum([int(i) for i in str(n).split('.')[-1]])


def gcd(a, b):
    if a == b:
        return a


def solve():
    B = 10 ** 12
    s = set()
    for a in range(2, 10 ** 4):
        a3 = a ** 3
        for b in range(1, a):
            b2 = b ** 2
            if b2 * (a3 + 1) >= B:
                break
            c = 1
            n = a3 * b * c * c + c * b2
            while n <= B:
                r = iSqrt(n)
                if r * r == n:
                    s.add(n)
                c += 1
                n = a3 * b * c * c + c * b2
    return sum(s)


def squareRootBi(x, epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)

    low = 0
    high = max(x, 1)
    guess = (low + high) / 2.0
    ctr = 1

    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess

        guess = (low + high) / 2.0
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'

    return guess


def testBi():
    print 'squareRootBi(4,0.0001) returns', squareRootBi(4, 0.0001)


def squareRootNR(x, epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)

    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1

    while abs(diff) > epsilon and ctr <= 100:
        print 'Error:', diff, 'guess:', guess

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR method. Num iterations:', ctr, 'Estimate:', guess
    return guess


def is_square(num):
    root = math.sqrt(num)
    return root == int(root)


def get_smallest_not_satisfying_golbach():
    primes = []

    for candidate in range(3, MAX_RANGE, 2):

        if helpers.is_prime(candidate):

            primes.append(candidate)
        else:

            if not any(is_square((candidate - prime) / 2) for prime in primes):
                return candidate


def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def average(x, y):
    return (x + y) / 2.0


def average_damp(f):
    return lambda x: average(x, f(x))


def is_close_enough(x, y):
    return abs(x - y) <= error_tolerance


def ith_root_lambda(n, i):
    return lambda x: n / (x ** (i - 1))


def square_root_01(n):
    return find_fixed_point(average_damp(lambda x: n / x),


def square_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 2)),


def cubic_root_01(n):
    return find_fixed_point(average_damp(lambda x: n / (x * x)),


def cubic_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 3)),


def the_golden_ratio():
    return find_fixed_point(average_damp(lambda x: 1 + 1 / x), 1.0)


def learning_rate(self):
    return self.init_lr * power(self._acc_grad_var, self.exponent)


def square_root(a):
    epsilon = 10e-15
    x = a / 2
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def get_num(min, max):
    result = 0
    for i in range(min, max + 1):
        if is_par_square(i):
            result += 1
    return result


def is_par_square(number):
    if is_par(str(number)) and is_square(number):
        if is_par(str(int(math.sqrt(number)))):
            return True


def is_par(number):
    reversed_number = ""
    if 1 == len(number):
        return True


def is_square(number):
    square_root = str(math.sqrt(number)).split('.')[1]
    if 1 == len(square_root) and '0' == square_root:
        return True


def update_alg_square(score):
    """Change the score by squaring."""
    return score * score


def update_alg_squarert(score):
    """Change the score by taking the square root."""
    return math.sqrt(score)


def newton_raphson_root(value, power, epsilon):
    """ function used to find the root of a given value through the Newton-Raphson method

    :param value: int, number for which we want to find the root
    :param power: int, power that turns the root into the given value
    :param epsilon: float, tolerance used when testing the root
    :return: float, the root of the given value
    """
    result = value / 2.0

    while abs(result ** power - value) >= epsilon:
        result += (value - result ** power) / (power * result ** (power - 1))
    return result


def check_auth(username, password):
    return username == 'admin' and password == 'secret'


def authenticate():
    message = {'message': "Authenticate."}
    resp = jsonify(message)

    resp.status_code = 401
    resp.headers['WWW-Authenticate'] = 'Basic realm="Example"'

    return resp


def decorated(*args, **kwargs):
    auth = request.authorization
    if not auth:
        return authenticate()


def api_hello():
    return redirect("http://www.google.com", code=302)


def approx_eq(x, y, tolerance=1e-14):
    return abs(x - y) < tolerance


def average(x, y):
    return (x + y) / 2


def sqrt_update(x):
    return average(x, a / x)


def sqrt_close(x):
    return approx_eq(x * x, a)


def newton_update(f, df):
    return lambda x: x - f(x) / df(x)


def df(x):
    return n * power(x, n - 1)


def curried_power(x):
    return lambda y: power(x, y)


def curried_nth_power(x):
    return lambda y: power(y, x)


def f(x, y):
    return g(x)(y)


def wrapped(x):
    print('-> ', fn, '(', x, ')')
    return fn(x)


def tracetest(fn):
    return 5


def ftest():
    return 26


def quadruple(x):
    return 4 * x


def newtons(n):
    n = float(n)
    x = n / 2
    i = 0
    while i < 10:
        y = (x + n / x) / 2
        x = y
        i += 1
    return y


def libmath(n):
    n = float(n)
    return math.sqrt(n)


def square_root(n):
    n = float(n)
    x = n / 2
    i = 0
    while i < 10:
        y = (x + n / x) / 2
        x = y
        i += 1
    return x


def square_root(number):
    if number < 0.0:
        return -1


def make_mid_point(start, end):
    return start + (end - start) / 2


def equal_lists(list_a, list_b):
    if(len(list_a) != len(list_b)):
        return False


def to_num(list):
    sum = 0
    for i in list:
        sum = sum * 10
        sum += i
    return sum


def to_list(num):
    result = []
    val = num
    while(val > 0):
        result = [val % 10] + result
        val = val / 10
    return result


def hypotenuse(a, b):
    sum = a ** 2 + b ** 2
    hypotenuse = math.sqrt(sum)
    return hypotenuse


def solve():
    return sum(list(map(digsum, range(2, 100))))


def digsum(a):
    sum = 0
    if round(sqrt(a)) ** 2 == a:
        return 0


def askForNumber():
    return int(raw_input("Enter square of x: "))


def compute(self):
    return RootMeanSquareError.compute_list(self.errors)


def compute_list(errors):
    """
    Calculates the mean average error for the predicted rating

    :param errors: a list
    :return: the mean average error after predicting all the overall ratings
    """
    num_ratings = 0.
    total_error = 0.

    for error in errors:
        if error is not None:
            total_error += error ** 2
            num_ratings += 1

    if num_ratings == 0:
        return None


def horo(channel, user, args):
    """Calculate square root. Usage: sqrt <number>"""

    result = sqrt(int(args[0]))

    return u'PRIVMSG {channel} :{result}'.format(user=user, result=result)


def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps
    return y


def square_root(a):
    if(a == 0 or a == 1):
        return a


def square_root(a):
    x = a / 2
    epsilon = 0.0000000001
    while True:
        y = (x + a / x) / 2
        if abs(x - y) < epsilon:
            return y


def eval_loop():
    x = ""
    result = 0
    while True:
        x = input("Give me math > ")
        if x == 'done':
            break
        result = eval(x)
        print(result)
    return result


def factorial(n):
    if n == 0:
        return 1


def estimate_pi():
    total = 0
    k = 0
    left_side = 2 * math.sqrt(2) / 9801
    while True:
        num = factorial(4 * k) * (1103 + 26390 * k)
        den = factorial(k) ** 4 * 396 ** (4 * k)
        term = left_side * num / den
        total += term
        if abs(term) < 1e-16:
            break
        k += 1
    return 1 / total


def server_static(filename):
    return static_file(filename, root='./static')


def index():
    return static_file('index.html', root='./static')


def api_square():
    global ncalls
    ncalls += 1
    n = request.json['data']
    return {'number': n * n,
            'comments': 'Using python. Called {} times'.format(ncalls)}


def api_square_shell():
    outstr = subprocess.check_output(['bash', './compute_square.sh', '5'])
    return json.loads(outstr)


def isFairAndSquare(num):
    square = math.sqrt(num)
    if square == int(square) and isFair(num) and isFair(int(square)):
        return 1


def isFair(num):
    if num in memo_ana:
        return memo_ana[num]


def solve(lower_limit, upper_limit):
    num_root = int(math.ceil(math.sqrt(lower_limit)))
    count = 0
    while num_root <= int(math.sqrt(upper_limit)):
        num = num_root ** 2
        if num in memo:
            count += memo[num]
        else:
            memo[num] = isFairAndSquare(num)
            count += memo[num]

        num_root += 1
    return count


def babylon(num):
    n = num
    r = 1
    accuracy = 0.000001
    while (n - r) > accuracy:
        n = (n + r) / 2
        r = num / n
    return n


def isSquare(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True


def is_square(n):
    root = int(n ** 0.5)
    return n == root * root


def get_pandigital_mapping(w, n):
    str_n = str(n)

    if len(str_n) != len(w):
        return None


def apply_mapping(mapping, w):
    used = set()

    n = 0
    for c in w:
        if c not in mapping:
            return ValueError(
                'Mapping does not contain a character in the word')


def pandigital_square_pair(w1, w2):
    if len(w1) != len(w2):
        return False


def sqrt(self, x):
    y0, y1 = 0, 1
    while int(y0) != int(y1):
        y0 = y1
        y1 = 1.0 / 2.0 * (y0 + x / y0)
    return int(y0)


def getInputs():
    number = eval(input("Enter the number to find its square root: "))
    print()

    string = "Enter the difference between the calculate and real square root: "
    diff = eval(input(string))
    print()
    return number, diff


def calcSqrt(number, diff):
    newguess = number / 2.0
    tries = 0
    oldguess = 1
    calc = 0
    while abs((newguess - oldguess)) > diff:
        oldguess = newguess
        newguess = (oldguess + number / oldguess) / 2.0
        tries = tries + 1
        calc = newguess
    actDiff = abs((math.sqrt(number) - calc))
    return calc, actDiff, tries


def sin_rms(a):
    """
    The root mean square of a sine wave.
    y = a sin(2 pi f t)
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(2)


def square_rms(a):
    """
    The root mean square of a square wave.
    y = a if ft < 0.5 V -a if ft > 0.5
    :param a: amplitude (peak value)
    :return: float
    """
    return a


def triangle_rms(a):
    """
    The root mean square of a triangle wave.
    y = |2 a ft - a|
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(3)


def eng_rms(rms_ac, rms_dc):
    """
    The root mean square of a non sine wave.
    y = |2 a ft - a|
    :param rms_ac: ac rms
    :param rms_dc: dc rms
    :return: float
    """
    return math.sqrt(math.pow(rms_dc, 2) + math.pow(rms_ac, 2))


def approx_equal(a, b, limit):
    if abs(a - b) < limit:
        return True


def square_root(a):
    x = a / 2.0
    epsilon = 0.001
    while True:
        print x
        y = (x + a / x) / 2
        if approx_equal(y, x, epsilon):
            break
        x = y
    return x


def square_root(number: int, n_step: int) -> float:
    r = 1

    for _ in range(n_step):
        d = number / r
        r = (r + d) / 2

    return r


def main() -> int:
    n = int(input())
    results = [''] * n

    for i in range(n):
        (number, steps) = map(int, input().split())
        results[i] = str(square_root(number, steps))

    print(' '.join(results))
    return 0


def find_root(a, eps):
    appx = a / 2.0
    while True:
        root = (appx + a / appx) / 2

        if abs(appx - root) < eps:
            break
        appx = root
    return root


def draw_square(canvas, color, size, position):
    """

    :param canvas:
    :param color:
    :param size:
    :param position:
    :return handle:

    Takes a Tkinter canvas, a color string, an integer size, and a tuple of
    x,y coordinates for the center of the rectangle.

    Returns the handle from the created rectangle.
    """
    upper_x = position[0] - size / 2
    upper_y = position[1] - size / 2

    lower_x = position[0] + size / 2
    lower_y = position[1] + size / 2

    return canvas.create_rectangle(upper_x,


def square(number=1):
    '''Return the square of the number.'''
    return number * number


def root(number=1):
    '''Return the square root of the number.'''
    return number ** 0.5


def cube(number=1):
    '''Return the cube of the number.'''
    return number * number * number


def power(number=1, power=1):
    '''Return the number raised to the power.'''
    return number ** power


def square_root(a, x):
    a = float(a)
    next_x = float(x + (a / x)) / 2
    global number_of_iterations
    number_of_iterations += 1

    if abs(next_x - sqrt(a)) < error:
        print "Number of iterations: %s" % number_of_iterations
        return float(next_x)


def is_sqrt_good_enough(x, guess, tolerance=0.0001):
    return abs(square(guess) - x) < tolerance


def sqrt_improve(x, guess):
    return average(guess, (x / guess))


def sqrt_iter(x, guess=1.0):
    return guess if is_sqrt_good_enough(
        x, guess) else sqrt_iter(x, sqrt_improve(x, guess))


def local_average(x, y):
    return (x + y) / 2


def local_good_enough(x, g, t=0.0001):
    return abs(square(g) - x) < t


def local_improve(x, g):
    return local_average(g, (x / g))


def printResults(number, diff, calc, actDiff, tries):
    print("For the square root of", number, "after", tries, "tries")
    print("The calculated square root is {:0.11f}".format(calc))
    print("The real square root is       {:0.11f}".format(math.sqrt(number)))
    print("The difference is             {:0.11f}".format(actDiff))
    print("The delta was                 {:0.11f}".format(diff))
    print()


if(__name__ == '__main__'): main()


"""Created on Mon Sep 21 10:08:02 2015
@author: CharlotteVDD
define a function sqrt(num), where num is a number and sqrt a funtion
that returns the square root of num.


def sqrt(n):
    n = n ** .5
    return(n)


def sqrt(x):
    '''compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def square(number):
    return number * number


def average(x, y):
    return (x + y) / 2


def closeEnough(guess):
    return (math.fabs((square(guess)) - number) < 0.001)


def improve(guess):
    return average(guess, (number / guess))


def sqrtHelper(guess):
    if closeEnough(guess):
        return guess


def new_g(g, s):
    g = ((g + (s / g)) / 2)
    return g


def findSumSpecialNum():
    mySum = 0

    sieve = computeSumSquareDivisor()
    print('Hi')
    for x in range(1, LIMIT):
        if isPerfectSquare(sieve[x]):
            mySum += x

    return mySum


def computeSumSquareDivisor():

    sieve = [1] * LIMIT

    sieve[0] = 0

    for x in range(2, LIMIT):
        currentNum = x
        square = x * x

        while currentNum < LIMIT:
            sieve[currentNum] += square
            currentNum += x

    return sieve


def isPerfectSquare(N):
    squareRoot = floor(sqrt(N))
    if squareRoot * squareRoot == N:
        return True


def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True


def sqrt(x):
    '''Computer square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x

    Raises:
        ValueError: if x is negative
    '''
    if x < 0:
        raise ValueError(
            'Cannot compute square root of negative number. {}'.format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1

    return guess


def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def sqrt(x):
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return y


def squareRoot(a, precision=0.001):
    x = 4.0
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < precision:
            break
        x = y

    return y


def square_root(a):
    x = 10
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < 0.000001:
            break
        x = y
    return x






def estimate_square_root_fancy(number, accuracy):
    sqrt = None

    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    elif float_equals(number, 1.0):
        sqrt = 1.0

    else:
        if number < 1.0:
            lower_bound = 0.0
            upper_bound = 1.0
        else:
            lower_bound, upper_bound = find_square_root_bounds(number)

        if float_equals(lower_bound * lower_bound, number):
            sqrt = lower_bound
        elif float_equals(upper_bound * upper_bound, number):
            sqrt = upper_bound
        else:

            while upper_bound - lower_bound > accuracy:
                midpoint = (upper_bound + lower_bound) / 2.0

                if float_equals(midpoint * midpoint, number):
                    lower_bound = midpoint
                    upper_bound = midpoint
                    break
                elif midpoint * midpoint < number:
                    lower_bound = midpoint
                else:
                    upper_bound = midpoint

            sqrt = lower_bound

    return sqrt


def estimate_square_root_simple(number, accuracy):
    """
    Bare-bones square root estimator

    Set guaranteed lower and upper bounds on the solution and binary search until
    we find something close enough
    """

    sqrt = None

    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')

    else:
        lower_bound = 0
        upper_bound = max(number, 1.0)

        while upper_bound - lower_bound > accuracy:
            midpoint = (upper_bound + lower_bound) / 2.0

            if midpoint * midpoint < number:
                lower_bound = midpoint
            else:
                upper_bound = midpoint

            sqrt = lower_bound

    return sqrt


def main(argv):
    if len(argv) < 2:
        sys.stderr.write("Usage: %s <number>" % (argv[0],))
        return 1


def square_root(a, x):
    y = (x + a / x) / 2
    return y


def math_squrt(a, x):
    m = math.sqrt(a)
    return m


def compute(self, actual, predicted):
    N, D = actual.shape
    error = 0
    for d in range(D):
        error += (np.sum((actual[:N, d] -
                          predicted[:N, d]) ** 2) / float(N)) ** 0.5
    error = error / float(D)
    return error


def average(a, b):
    return (a + b) / 2.0


def improve(guess, x):
    return average(guess, x / guess)


def good_enough(guess, x):
    d = abs(guess * guess - x)
    return (d < 0.001)


def square_root(guess, x):
    while(not good_enough(guess, x)):
        guess = improve(guess, x)
    return guess


def my_sqrt(x):
    r = square_root(1, x)
    return r


def approximate_log(n):
    if n < 1.1:
        return n - 1


def approximate_log2(n):
    return (n ** n - 1.0) / n


def cube(n):
    """
    Returns the cube of the number n
    """
    return n ** 3


def negate(n):
    """ Return negative n
    """
    return -n


def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    return math.factorial(n)




def sqrt1(x):
    i = 0
    while i * i != x:
        i = i + 1
    return i


def sqrt(x):
    l = 0
    h = x
    while l <= h:
        m = l + h / 2
        if m * m == x:
            return m


def sqrt(x):
    '''
    Compute square roots using the method of Heron of Alexandria.
    :param x: The number for which the square root is to be computed.
    :return: The square root of x.
    '''

    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def value_y(self, x):

    y = self.fun_1[0] * np.square(x) + self.fun_1[1] * x + self.fun_1[2]

    return y


def single_root(self):

    x = -(self.fun[2]) / self.fun[1]

    return np.array([x, self.value_y(x)])


def root_one(self):

    x = (-(self.fun[1]) + np.sqrt(self.part_one)) / (2 * self.fun[0])

    return np.array([x, self.value_y(x)])


def root_two(self):

    x = (-(self.fun[1]) - np.sqrt(self.part_one)) / (2 * self.fun[0])

    return np.array([x, self.value_y(x)])


def square(base, root):
    number = base
    for x in range(1, root):
        number = number + base
    return number


def sqroot(x):
    if x <= 0:
        print "Positive number only."
        return


def square_root(x, eps=10e-7):

    assert x >= 0
    y = math.sqrt(x)

    assert abs((y * y) - x) < eps
    return y


def exp_2(x):
    if x == 0:
        return 1


def log_2(x):
    if x == 1:
        return 0


def sq_rt(x):
    tmp = 1
    while tmp < x / 2:
        if tmp * tmp == x:
            return tmp


def sq_rt2(x):
    tmp = 1
    while x / tmp != tmp:
        tmp = tmp + 1
    return tmp


def square(x):
    return x * x


def inverse(f, g, x):
    return (f(g(x)) == x)


def approx_equal(a, b, limit):
    if abs(a - b) < limit:
        return True


def square_root(a):
    x = a / 2.0
    epsilon = 0.001
    while True:

        y = (x + a / x) / 2.0
        if approx_equal(y, x, epsilon):
            break
        x = y
    return x


def squareroot(n):
    x = n
    e = 0.0000001
    y = 1
    while (x - y > e):
        x = (x + y) / 2
        y = n / x
    return x


def PIECE___root_mean_square_error():
    """PIECE___root_mean_square_error:

    ROOT_MEAN_SQUARE_ERROR = sum of squared differences between items in PREDICTED_OUTPUTS multi-dimensional
    array and TARGET_OUTPUTS multi-dimensional array, divided by the number of cases, then square-rooted
    """

    forwards = {'root_mean_square_error':
                [lambda a0, a1: sqrt(((a1 - a0) ** 2).sum() / a0.shape[0]),
                 {'a0': 'target_outputs',
                  'a1': 'predicted_outputs'}]}

    backwards = {('DOVERD', 'root_mean_square_error', 'predicted_outputs'):
                 [lambda a0, a1, rmse: ((a1 - a0) / a0.shape[0]) / rmse,
                  {'a0': 'target_outputs',
                   'a1': 'predicted_outputs',
                   'rmse': 'root_mean_square_error'}]}

    return Piece(forwards, backwards)


def add(a, b):
    return a + b


def sub(a, b):
    return a - b


def square(a):
    return a * a


def root(a):
    return a ** .5


def square_root(x):
    count = 0
    ballpark_num = 1
    while round(ballpark_num ** 2 - user_input, 2) != 0:
        new_number = 0.5 * (ballpark_num + (x / ballpark_num))
        ballpark_num = new_number
        count += 1
        print("Count is {} number is {}".format(count, ballpark_num))
    return new_number


def parse_square(text):
    if text[0] == 'w' or text[0] == 'b':
        return [text[0], text[0], text[0], text[0]]


def square_to_text_inner(square):
    s = ''
    for elem in square:
        if isinstance(elem, list):
            s += 'p'
        else:
            s += elem

    for elem in square:
        if isinstance(elem, list):
            s += square_to_text_inner(elem)

    return s


def add_squares(sq1, sq2):
    result = []
    for i in range(4):
        if not isinstance(sq1[i], list) and not isinstance(sq2[i], list):
            if sq1[i] == 'b' or sq2[i] == 'b':
                result.append('b')
            else:
                result.append('w')
        else:
            if not isinstance(sq1[i], list):
                c = sq1[i]
                sq1[i] = [c, c, c, c]

            if not isinstance(sq2[i], list):
                c = sq2[i]
                sq2[i] = [c, c, c, c]

            r = add_squares(sq1[i], sq2[i])
            if r == ['w', 'w', 'w', 'w']:
                r = 'w'
            elif r == ['b', 'b', 'b', 'b']:
                r = 'b'

            result.append(r)

    return result


def compress_square(square):
    result = []

    for elem in square:
        if isinstance(elem, list):
            if elem == ['w', 'w', 'w', 'w']:
                result.append('w')
            elif elem == ['b', 'b', 'b', 'b']:
                result.append('b')
            else:
                result.append(compress_square(elem))
        else:
            result.append(elem)

    return result


def get_square_depth(square, level):
    max_level = level

    for elem in square:
        if isinstance(elem, list):
            max_level = max(max_level, get_square_depth(elem, level + 1))

    return max_level


def get_square_size(square):

    depth = get_square_depth(square, 1)
    return 2 ** depth


def bitlength(x):
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n


def isqrt(n):
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    if n == 0:
        return 0


def is_perfect_square(n):
    h = n & 0xF
    if h > 9:
        return -1


def partial_quotiens(x, y):
    partials = []
    while x != 1:
        partials.append(x // y)
        a = y
        b = x % y
        x = a
        y = b

    return partials


def indexed_convergent(sequence):
    i = len(sequence) - 1
    num = sequence[i]
    denom = 1
    while i > 0:
        i -= 1
        a = (sequence[i] * num) + denom
        b = num
        num = a
        denom = b

    return (num, denom)


def convergents(sequence):
    c = []
    for i in range(1, len(sequence)):
        c.append(indexed_convergent(sequence[0:i]))

    return c


def phiN(e, d, k):
    return ((e * d) - 1) / k


def wiener_attack(N, e):
    (p, q, d) = (0, 0, 0)
    conv = convergents(partial_quotiens(e, N))
    for frac in conv:
        (k, d) = frac
        if k == 0:
            continue
        y = -(N - phiN(e, d, k) + 1)
        discr = y * y - 4 * N
        if(discr >= 0):

            sqr_discr = is_perfect_square(discr)

            if sqr_discr != -1 and (-y + sqr_discr) % 2 == 0:
                p = ((-y + sqr_discr) / 2)
                q = ((-y - sqr_discr) / 2)
                return p, q, d


def newsqrt(a):
    x = a / 2
    e = 0.0005
    while True:
        y = (x + a / x) / 2
        if x == y and abs(y - x) < e:
            return y


def babylonian(a):
    r = a
    while (p > q):
        p = (p + q) / 2.0
        q = r / p
    return p


def __call__(self, *args):
    if not args in self.memo:
        self.memo[args] = self.f(*args)
    return self.memo[args]


from functools import reduce


def factorial(n):
    return reduce(operator.mul, range(2, n + 1), 1)


from functools import reduce


def choose(n, k):
    return reduce(operator.mul, range(n - k + 1, n + 1), 1) / factorial(k)


def num_divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num


def divisors(p):
    div = set()
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root + 1):
        if p % x == 0:
            div.add(p / x)
            div.add(x)
    if p > 1:
        div.remove(p)
    return div


def word_score(word):
    return sum((ord(x) - ord('A') + 1) for x in word)


def is_prime(x):
    if len(_primes) == 0:
        _primes.update(get_primes(_prime_limit))
    if x in _primes:
        return True


def gcd(a, b):
    if a > b:
        a, b = b, a
    while b != 0:
        a, b = b, a % b
    return a


def lcd(a, b):
    return a * b / gcd(a, b)


def reverse(seq, start, end):

    end -= 1
    if end <= start:
        return


def is_square(n):
    sq = int(math.sqrt(n))
    return sq * sq == n


def factors(n, first):
    global _fprimes
    if _fprimes[-1] < n:
        _fprimes = list(get_primes(n * 2))

    factors = []
    for p in _fprimes:
        while n % p == 0:
            factors.append(p)
            n /= p
        if n == 1:
            break
    return factors


def zipWith(f, a, b):
    return map(f, zip(a, b))


def fg(*a, **kw):
    return f(g(*a, **kw))


def inner(*a, **kw):
    print '> calling', f.func_name, 'with ', a, kw
    r = f(*a, **kw)
    print '> returning', f.func_name, r


def is_prime(n):
    square_root_of_potential_prime = sqrt(n)

    for i in range(2, int(square_root_of_potential_prime) + 1):
        if n % i == 0:
            return False


def generate_nth_prime(n):
    prime_count = 0
    current_number = 1

    while prime_count < n:
        current_number += 1

        if is_prime(current_number):
            prime_count += 1

    return current_number


def isqrt(n):
    x = n
    y = (x + n // x) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def count_digits_in_sqrt(num):
    return sum(map(int, str(isqrt(num * 10 ** (2 * (prec - 1))))))


def is_palindrome(num):
    dummy = int(num)
    rev = 0
    while(dummy != 0):
        r = dummy % 10
        rev = rev * 10 + r
        dummy = int(dummy / 10)
    if(num == rev):
        return 0


def is_perfect_square(is_square):
    root = math.sqrt(int(is_square))
    return int(root) ** 2 == int(is_square)


def newton_raphson_sqrt(number):
    epsilon = 0.01
    y = number
    guess = y / 2.0

    while abs(guess * guess - y) >= epsilon:
        guess = guess - (((guess ** 2) - y) / (2 * guess))

    return guess


def RMSE(estimation, truth):
    """Root Mean Square Error"""

    num_sample = len(estimation)

    sse = np.sum(np.square(truth - estimation))
    return np.sqrt(np.divide(sse, num_sample - 1.0))


def sqrt(w, eps=1.e-14, maxIter=100):
    x = 1.
    for i in range(maxIter):
        x_old = x
        x = (x + w / x) / 2
        if abs(x - x_old) / w < eps:
            return x


def square_root(a):
    x = a / 2.0
    y = x
    while True:

        y = (x + a / x) / 2.0

        if abs(y - x) < sys.float_info.epsilon:
            break

        x = y

    return x


def factorial(n):
    if n < 0:
        return None


def estimate_pi():
    tot = 0
    k = 0
    factor = (2 * math.sqrt(2)) / 9801

    while True:
        num = factorial(4 * k) * (1103 + (26390 * k))
        den = (factorial(k) ** 4) * (396 ** (4 * k))
        term = factor * (num / den)
        tot += term

        if abs(term) < 1e-15:
            break

        k += 1

    return 1 / tot


def square_root(a, x):
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < 0.0000001:
            return x


def found(n):
    n_string = str(n)
    for i in range(9):
        if int(n_string[i * 2]) != (i + 1):
            return False


def sqrt(a):
    if a == 0:
        return a


def sqrt(x, error):
    """Returns an approximation to the square root.
        Using Heron of Alexandria's algorithm."""
    guess = 1
    while my_abs(square(guess) - x) > error:
        guess = average(guess, x / guess)
    return guess


def find_sqrt_bin_search(n, error=0.001):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid


def power(x):
    return x ** 2


def square_root(x):
    return np.sqrt(x)


def sqrt(x):
    while True:
        print x
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return y


def squareRoot(x, maxPrecision, root):
    precision = maxPrecision
    low = 0.0
    high = x
    guess = (low + high) / 2
    while (precision > 0):
        if guess ** root > x:
            high = guess
        else:
            low = guess
        guess = (low + high) / 2
        precision -= 1
    return guess


def sq_rt(num):
    """Approximates square root of parameter to 2 decimal places"""
    neg = ""
    if num < 0:
        num = abs(num)
        neg = 'i'
    guess_1 = 1
    guess_2 = 0
    count = 0
    while round(guess_1, 2) != round(guess_2, 2):
        count += 1
        guess_2 = guess_1
        guess_1 = (guess_1 + num / guess_1) / 2
        print(
            "This loop has iterated",
            count,
            "times and the current guess is",
            str(guess_1) + ".")
    return (str(round(guess_1, 2)) + neg)


def squareRootConvergents():
    count = 1
    numberCount = 0
    x = 2 + fractions.Fraction(1, 2)
    while count < 999:
        y = 1 + 1 / x
        if len(str(y).split('/')[0]) > len(str(y).split('/')[1]):
            numberCount += 1
        x = 2 + 1 / x
        count += 1
    return numberCount




def update(x):
    return cube_root_update(x, a)


def close(x):
    return approx_eq(pow(x, 3), a)


def sqroot(x):
    """
    Finds the square root of the number passed in
    """
    return math.sqrt(x)


def euclidian_distance(a, b):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return sqrt(sum(pow(x - y, 2) for x, y in zip(a, b)))


def manathan_distance(a, b):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return sum(abs(x - y) for x, y in zip(a, b))


def __str__(self):
    return repr(self.value)


def root(self):
    """
    For a typical sudoku board, root = 3
    """
    return self.__root


def size(self):
    """
    The board size is the root value squared: 9 for a typical sudoku board
    """
    return self.__size


def all_moves(self):
    return set(range(1, self.__size + 1))


def get_int_in_range(self, value):
    try:
        intvalue = int(value)
        if intvalue < 0 or intvalue > self.__size:
            raise OutOfRangeException(intvalue)
        return intvalue


def dimensions(self):
    return self.__dimensions


def value(self):
    return self.__value


def move(self, value):
    intvalue = self.dimensions.get_int_in_range(value)
    if self.__value and intvalue:
        raise DeniedMoveException('The cell has already a value')

    if self.__value == intvalue:
        return


def is_empty(self):
    return 0 == self.__value


def allowed_moves(self):
    return self._allowed_moves


def is_allowed_move(self, value):
    return value in self.allowed_moves()


def num_cells(self):
    return self.__dimensions.size


def cell(self, index):
    return self.__cells[index - 1]


def cells(self):
    return self.__cells


def find_only_available_move(self):
    """
    Here we have 8 full cells - the nineth one gets a compulsory move
    Convert in CellSolver(group) class?
    """
    for c in self.cells:
        if not c.value:
            if len(c.allowed_moves()) == 1:
                return (c, list(c.allowed_moves())[0])


def find_forced_move(self):
    """
    Only one cell of the group can have one of the available moves for the group
    """
    for value in self.allowed_moves():
        cell = None
        for c in self.cells:
            if not c.value and c.is_allowed_move(value):
                if cell is None:
                    cell = c
                else:
                    cell = None
                    break
        if not cell is None:
            return (cell, value)


def find_exclusive_move(self):
    """
    ???
    """
    return (None, None)


def size(self):
    return self.dimensions.size


def num_cells(self):
    return self.dimensions.size ** 2


def __makeCellGroups(self):
    cgs = []
    for i in range(self.dimensions.size):
        cgs.append(CellGroup(self.dimensions))
    return cgs


def row(self, rowIndex):
    return self.__rows[rowIndex - 1]


def col(self, colIndex):
    return self.__cols[colIndex - 1]


def square(self, squareIndex):
    return self.__squares[squareIndex - 1]


def rows(self):
    return self.__rows


def cols(self):
    return self.__cols


def squares(self):
    return self.__squares


def finished(self):
    return 0 == self.__empty_cells


def all_groups(self):
    return self.__rows + self.__cols + self.__squares


def find_forced_move(self):
    for group in self.all_groups:
        (c, v) = group.find_forced_move()
        if not c is None:
            return (c, v)


def find_move(self):
    (c, v) = self.find_only_available_move()
    if c is not None:
        return (c, v)


def square_root(a):
    x = a + 0.01
    while True:
        epsilon = 0.000000000001
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            return y


def estimate_pi():
    k = 0
    s = 0
    a = 2 * math.sqrt(2) * 1103 / 9801
    while a > 1e-15:
        s += a
        k += 1
        a = (2 * math.sqrt(2) * math.factorial(4 * k) * (1103 + 26390 * k)
             ) / (9801 * (math.factorial(k) ** 4) * (396 ** (4 * k)))
    return 1 / s


def bisection(l, a, k):
    if l[math.floor(len(l) / 2):][0] < a:
        print(k)
        k = k + math.floor(len(l) / 2)
        print(k)
        bisection(l[math.floor(len(l) / 2):], a, k)
    elif l[math.floor(len(l) / 2):][0] == a:
        return k + 1


def divisor_count(n):
    """Count number of divisors. Used on problem 12, 179.
    """
    divcount = 0
    tmax = n ** 0.5
    for t in xrange(1, int(tmax + 1)):
        if n % t == 0:
            divcount += 2
    if t == tmax:
        divcount -= 1
    return divcount


def square_root(a, x):
    while True:
        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return x


def square_root(a):
    global epsilon
    print "epsilon", epsilon
    x = a / 2.0
    y = (x + a / x) / 2
    while True:
        if abs(y - x) <= epsilon:
            break
        x = y
        y = (x + a / x) / 2
    return x


def fibonacci_primitive_root(p):
    """
    Returns a fibonacci primitive root if p has one and None otherwise.
    Assumes p is a prime and that p is congruent to 1 or -1 modulo 5.
    """

    q = square_root(5, p)
    half = (p + 1) / 2

    q1 = half + half * q
    q2 = half - half * q

    q1 %= p
    q2 %= p

    if is_primitive_root(q1, p):
        return q1


def test_root(r, p):
    print "Testing p =", p, "root =", r
    subgroup = [(r ** k) % p for k in xrange(p - 1)]
    if len(set(subgroup)) != p - 1:
        print "Not a primitive root!"
        return


def square_root(x):
    """
    Binary method;
    """
    if x == 0:
        return 0


def square_root_2(x):
    """
    Status: accepted;

    Newton-Raphson method
    """
    if x == 0:
        return 0


def is_good_enough(guess, n):
    global error_tolerance
    return abs(square(guess) - n) < error_tolerance


def improve_guess(guess, n):
    return average(guess, n / guess)


def sqrt_iter(guess, n):
    if is_good_enough(guess, n):
        return guess


def newton_sqrt(n):
    ''' Computers Newton's square root approximation of n. '''
    return sqrt_iter(1, n)


def is_good_enough_inner(guess):
    return abs(square(guess) - n) < error_tolerance


def improve_guess_inner(guess, n):
    return average(guess, n / guess)


def sqrt_iter_inner(guess):
    if is_good_enough_inner(guess):
        return guess


def sqrt(x):
    """ Compute square roots using method of Heron of Alexndria.

    Args:
        x: The number of which the square root is to be computed.

    Returns: The square root fo x.

    Raises:
        ValueError: if x is negative
    """
    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def compute(dm, do):
    """ Computes rms """
    if dm is None and do is None:
        return {


def euler66(stopD=EULER66_STOP_D):

    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    potentDsList = [d for d in range(stopD) if not sqrt(d).is_integer()]

    potentialDToMinYSquareDict = {potentD: getMinXForDByContinuedFract(
        potentD) for potentD in potentDsList}
    return max(potentialDToMinYSquareDict.items(), key=itemgetter(1))


def getMinXForDByContinuedFract(d):
    dRootContinuedFract = getContinuedFract(
        decimal.Decimal(d).sqrt(),
        EULER66_MAX_FRACT_TO_REFER_TO_AS_ZERO,
        EULER66_MIN_FRACT_TO_REFER_TO_AS_ONE)
    for numOfRepeatsOfPeriodicTerms in count(1):
        potentXDivPotentYAsSimpleFract = getSimpleFractOfContinuedFract(
            dRootContinuedFract.intPart,
            (dRootContinuedFract.periodicTermsList * (
                numOfRepeatsOfPeriodicTerms))[:-1])
        potentX, potentY = (potentXDivPotentYAsSimpleFract.numerator,
                            potentXDivPotentYAsSimpleFract.denominator)
        if 1 == (potentX ** 2 - d * potentY ** 2):
            print('d: {0}, x: {1}, y: {2}'.format(d, potentX, potentY))
            return potentX


def getPotentialSolutionsToEuler66(stopD=EULER66_STOP_D):
    dList = [d for d in range(stopD) if not safeHasSquareRoot(d)]
    return filter(lambda d: getMinYSquareForD2(


def getHardMinXForD(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    print(1 / dRoot)

    potentY = decimal.Decimal(1)
    while True:
        '''
        print((1 / zeroLeftToDecPoint(dRoot * potentY)).to_integral(
            rounding=decimal.ROUND_FLOOR))
        '''
        potentY *= floor(1 / zeroLeftToDecPoint(dRoot * potentY))
        potentX = (potentY ** 2 * d + 1).sqrt()
        if potentX == floor(potentX):
            print(d, potentX)
            return potentX


def getHardMinXForD2(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator(dRoot):
        '''
        print(dRootMulPotentY, dRootMulPotentY.adjusted() + 1)
        print(dRootMulPotentY, dRootMulPotentY.as_tuple().digits[
            dRootMulPotentY.adjusted() + 1])
        '''
        if EULER66_D_ROOT_MUL_Y_MIN_FIRST_DIGIT_AFTER_DEC_POINT <= (
                dRootMulPotentY.as_tuple().digits[dRootMulPotentY.adjusted() + 1]):
            potentX = (d * potentY ** 2 + 1).sqrt()

            if potentX == floor(potentX):
                print(d, potentX)
                return potentX


def getHardMinYForD3(d):
    '''
    failed at 61 when used 120 bits for precision (succeeded at 53, 46)
    '''
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator2(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if mpmath.isint((d * potentY ** 2 + 1).sqrt()):
                print(d, potentY)
                print()
                return potentY


def getHardMinYForD4(d):
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator3(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if ((int(dRootMulPotentY) + 1) ** 2) == (d * potentY ** 2 + 1):
                print(d, potentY)
                print()
                return potentY


def zeroLeftToDecPoint(num):
    return num - floor(num)


def getMinYForD(d):
    for y in count(1):
        if safeHasSquareRoot3(d * y ** 2 + 1):
            print(d, y)
            return y


def getMinYSquareForD2(d, stopYSquare=1000000000000000000000000):
    for ySquare in takewhile(lambda ySquare: ySquare < stopYSquare,
                             squaresGenerator()):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD5(d):

    for ySquare in squaresGenerator():
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD6(d):
    for ySquare in euler66PotentialYSquaresGenerator(d):
        if safeHasSquareRoot6(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD7(d):

    ySquare = 1
    for diffToNextSquare in count(3, 2):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def getHardMinYSquareForD8(d):
    for ySquare in squaresGenerator():
        if isMaybeAPerfectSquare2(d * (ySquare % 100) + 1) and (
                safeHasSquareRoot(d * ySquare + 1)):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare


def isMaybeAPerfectSquare(num):
    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[


def isMaybeAPerfectSquare2(num):
    return ((num % 10) not in ONES_DIGITS_SQUARES_CANT_HAVE) and (


def getMinYForD3(d, stopY=None):
    if stopY is None:
        ysToTry = count(1)
    else:
        ysToTry = range(1, stopY)
    dRoot = d ** 0.5
    for y in ysToTry:

        if (ceil(dRoot * y) ** 2) == (d * y ** 2 + 1):
            print(d, ceil(dRoot * y))
            return y


def safeHasSquareRoot2(num):

    lowMaybeRoot = 0
    highMaybeRoot = num
    while lowMaybeRoot <= highMaybeRoot:
        midMaybeRoot = (lowMaybeRoot + highMaybeRoot) // 2
        midMaybeRootSquare = midMaybeRoot ** 2
        if midMaybeRootSquare == num:
            return True


def safeHasSquareRoot3(num):

    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[


def safeHasSquareRoot6(num):
    '''
    assuming the square was received from euler66PotentialYSquaresGenerator
    '''
    return ((num // 10 % 10) in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[


def safeHasSquareRoot4(num):
    if num > 1000000:
        numOnesDigit = num % 10
        if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
            numTensDigit = num // 10 % 10
            return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[


def safeHasSquareRoot5(num):

    numAsStr = str(num)
    return (numAsStr[-2:]
            in DIGITS_SQUARES_CAN_END_WITH) and safeHasSquareRoot(num)


def safeHasSquareRoot(num):
    return mpmath.isint(mpmath.sqrt(num))


def mult(a, b):
    global count

    if a > 2 and b > 2:
        count = count + 1
    return a * b


def square(x):
    return mult(x, x)


def counted_mod_exp(a, b, q):
    global count
    count = 0
    res = mod_exp(a, b, q)
    return (res, count)


def square_root(n, precision):
    low = 0.0
    high = n
    mid = (low + high) / 2.0

    while (abs(mid * mid - n) > precision):
        if (mid * mid) < n:
            low = mid
        elif (mid * mid) > n:
            high = mid
        mid = (low + high) / 2.0

    return mid


def sqrt(x):
    ans = 0
    if x >= 0:
        while ans * ans < x:
            ans = ans + 1
        if ans * ans != x:
            print x, 'is not a perfect square'
            return None


def f(x):
    x = x + 1
    return x


def solve(numLegs, numHeads):
    for numChicks in range(0, numHeads + 1):
        numPigs = numHeads - numChicks
        totLegs = 4 * numPigs + 2 * numChicks
        if totLegs == numLegs:
            return [numPigs, numChicks]


def isPalindrome(s):
    if len(s) <= 1:
        return True


def isPalindromel(s, indent):
    print indent, 'isPalindromel called with', s
    if len(s) <= 1:
        print indent, 'About to return True frome this case'


def fib(x):
    if x == 0 or x == 1:
        return 1


def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess

        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:', ctr, 'Estimate:', guess
    return guess


def squareRootNR(x, epsilon):
    """Assume x >= 0 and elsilon > 0
        Return y s.y. y*y is within epsilon of x"""
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    x = float(x)
    guess = x / 2.0
    guess = 0.001
    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
        assert ctr <= 100, 'Iteration count exceeded'
        print 'NR method. Num.. iterations:', ctr, 'Estimated:', guess
        return guess


def squareRootBi(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using bisection method
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0.0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr < 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'Bi method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess


def squareRootNR(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using Newton-Raphson method.
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    guess = float(x) / 2.0

    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr < 100:
        guess = guess - (guess ** 2 - x) / (2.0 * guess)
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'NR method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess


def is_square(n):
    if(n == 1):
        return True


def sqrt(num):
    "Returns the square root of a number"
    Answer = num ** 0.5
    return float(Answer)


def _nearest_whole_square_root(n):
    while _roots[-1][0] < n:
        next_root = _roots[-1][1] + 1
        square_number = next_root * next_root

        _square_numbers.add(square_number)

        _roots.append((square_number, next_root))

    for i in xrange(1, len(_roots)):
        if _roots[i][0] > n:
            return _roots[i - 1][1]


def _is_square_number(n):
    return n in _square_numbers


def reciprocal(self):
    new_c = (self.b * self.b - self.a) / -self.c
    new_b = -self.b

    whole_number = (self.nearest_whole_number + new_b) / new_c

    new_b -= whole_number * new_c

    return _SquareRootFraction(


def get_period(n):
    if _is_square_number(n):
        return 0


def get_number_of_odd_periods_up_to(n):
    return sum(1 for i in xrange(1, n + 1) if get_period(i) % 2 == 1)


def get_answer():
    return get_number_of_odd_periods_up_to(10000)


def PrintFunc(str):
    print str
    return


def square(Val):
    SquareRel = Val * Val
    print "Got Value and Square equal=", SquareRel
    return SquareRel


def ask_and_approx_roots():
    num_iterations = int(
        input("Please enter the number of iterations (an integer): "))
    square_root_to_approx = int(
        input("Please enter the square root to approximate (an integer): "))
    sq_root_guess = float(input("Please enter a guess for the square root: "))
    return heron_method(num_iterations, square_root_to_approx, sq_root_guess)


def __repr__(self):

    return 'GameStateNode({}, {})'.format(self.value, self.children)


def __eq__(self, other):
    ''' (GameStateNode, object) -> bool
    Return whether this GameStateNode is equivalent to other, i.e., they
    contain equivalent GameStates, and equivalent children.  The order of
    their children does not matter.
    >>> s1 = SubtractSquareState('p1', current_total = 6)
    >>> s2 = SubtractSquareState('p2', current_total = 5)
    >>> s3 = SubtractSquareState('p1', current_total = 2)
    >>> leaf1 = GameStateNode(s1)
    >>> leaf2 = GameStateNode(s2)
    >>> leaf3 = GameStateNode(s3)
    >>> leaf1.__eq__(leaf2)
    False
    >>> root1 = GameStateNode(s1)
    >>> root1.children = [s2, s3]
    >>> root2 = GameStateNode(s1)
    >>> root1.__eq__(root2)
    False
    >>> root2.children = [s2, s3]
    >>> root1.__eq__(root2)
    True
    '''

    return (type(self) == type(other) and


def node_count(root):
    ''' (GameStateNode) -> int

    Return the number of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    if root.value is None:
        return 0


def leaf_count(root):
    '''(GameStateNode) -> int

    Return the number of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    if root.children == []:
        return 1


def distinct_node_count(root):
    '''(GameStateNode) -> int

    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''

    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1
    else:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1
        for child in root.children:
            count += distinct_node_count(child)
    return count


def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int

    Return the number of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_leaf:
            s_distinct_leaf.add(root.value.__str__())
            count += 1
    else:
        for child in root.children:
            count += distinct_leaf_count(child)
    return count


def branching_stats(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''

    d = {0: 0}
    if not root.children:
        d[0] += 1
    else:
        arity = len(root.children)
        if arity in d:
            d[arity] += 1
        else:
            d[arity] = 1
        for child in root.children:
            merge_dict(d, branching_stats(child))
    return d


def merge_dict(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}

    Helper function

    Returns a merged dictionary from two dictionarys.
    '''
    d = d1
    for key in d2:
        if key in d:
            d[key] += d2[key]
        else:
            d[key] = d2[key]
    return d


def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]

    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    l = [0, 0, 0]
    if not root.children:
        if root.value.winner('p1'):
            l[0] += 1
        elif root.value.winner('p2'):
            l[1] += 1
        else:
            l[2] += 1
    else:
        for child in root.children:
            l = merge_list(l, outcome_counts(child))
    return l


def merge_list(l1, l2):
    ''' (list, list) -> list

    Helper function

    Returns a merged list from two lists
    Assumes that the lists have same lengths.
    '''
    l = l1
    for index in range(len(l2)):
        l[index] += l2[index]
    return l


def game_lengths(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    d = {}
    if not root.children:

        d[0] = 1
    else:
        for child in root.children:

            d = merge_dict2(d, game_lengths(child))
    return d


def merge_dict2(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}

    Helper function

    Returns a merged dictionary from two dictionarys, version 2.
    Adds d2 to d1, but with the keys in d2 incremented by 1.
    Assumes that the keys are Integers
    '''
    d = d1
    for key in d2:

        if (key + 1) in d:
            d[key + 1] += d2[key]
        else:
            d[key + 1] = d2[key]
    return d


def abbreviated(s):
    '''(GameState) -> str

    Return an abbreviated str representation of SubtractSquareState s.
    '''
    return "{}:{}".format(s.next_player, s.current_total)


def expand_root(square, precision):

    digits = []
    c = square
    p = 0
    x = 9
    y = 0
    while len(digits) < precision:
        while True:
            testnum = x * (20 * p + x)
            if testnum > c:
                x -= 1
            else:
                y = testnum
                break
        digits.append(x)
        p = p * 10 + x
        c = (c - y) * 100
        x = 9
        y = 0
    return sum(digits)


def constraint_square_root():

    return math.sqrt(a.x ** 2) == 10


def constraint_sum_over_500():
    return sum([a.x, a.y, b.x, b.y, c.x, c.y]) > 500


def square(lst):
    n = len(lst)
    temp = [0] * (n * 2 - 1)
    for i in range(0, n):
        for j in range(0, n):
            temp[i + j] += lst[i] * lst[j]
    for i in range(0, len(temp) - 1):
        if temp[-1 - i] > 9:
            temp[-2 - i] += temp[-1 - i] // 10
            temp[-1 - i] = temp[-1 - i] % 10
    return temp


def bigger(num, lst):
    if lst[0] >= num:
        return False


def root(num):
    x = 100
    temp = [math.floor(math.sqrt(num))]
    while len(temp) < x:
        temp.append(1)
        while temp[-1] < 10 and bigger(num, square(temp)):
            temp[-1] += 1
        temp[-1] -= 1
    return temp


def isSquare(num):
    r = math.floor(math.sqrt(num))
    if r * r - num == 0:
        return True


def newtonest(num):
    return num ** 0.5


def nth_root(value, n_root):

    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)


def average(a, b):
    return (a + b) / 2.0


def improve(guess, x):
    return average(guess, x / guess)


def good_enough(guess, x):
    d = abs(guess * guess - x)
    return (d < 0.000001)


def square_root(x):
    guess = 1
    while (not good_enough(guess, x)):
        guess = improve(guess, x)
    return guess


def solve():
    total = 0
    for n in range(2, NUM_COUNT + 1):
        if com.is_square(n):
            continue

        root = com.sqrt_expansion(n, DIGIT_COUNT)
        root = root.replace('.', '')
        total += sum([int(digit) for digit in root[:DIGIT_COUNT]])

    return total


def root_mean_square(x):
    """ Returns the root mean square (rms) given a list of values. """
    return math.sqrt(sum([i * i for i in x]) / len(x))


def get_period(root):
    history = []
    current_pair = Fraction(root, 0, 0, 1).disjoin_invert()
    history.append(current_pair)
    while True:

        current_pair = current_pair[1].rationalize().disjoin_invert()
        if current_pair in history:
            return len(history) - history.index(current_pair)


def count_odd_periods(max_root):
    count = 0
    for root in xrange(2, max_root + 1):
        if gmpy.is_square(root):
            continue
        period = get_period(root)
        if period % 2 == 1:
            count += 1
    return count


def rationalize(self):
    assert(self.denom_root != 0)
    assert(self.num_root == 0)
    new_denom_root = 0
    new_denom_int = (self.denom_root - self.denom_int ** 2) / self.num_int
    new_num_root = self.denom_root
    new_num_int = -self.denom_int
    return Fraction(new_num_root, new_num_int,


def disjoin(self):
    assert(self.denom_root == 0)
    assert(self.num_root != 0)
    int_part = int(
        (math.sqrt(
            self.num_root) +
            self.num_int) /
        self.denom_int)
    frac_part = Fraction(
        self.num_root,
        self.num_int -
        int_part *
        self.denom_int,
        0,
        self.denom_int)
    return (int_part, frac_part)


def invert(self):
    return Fraction(self.denom_root, self.denom_int,


def disjoin_invert(self):
    int_part, frac_part = self.disjoin()
    return (int_part, frac_part.invert())


def __eq__(self, other):
    return (


def __str__(self):
    return "(%d, %d, %d, %d)" % (self.num_root,


def __repr__(self):
    return str(self)


def square(numbers):
    return numbers ** 2


def sqrt_digit(n):
    k = n
    q = 0
    while len(str(q)) < 100:
        if q == 0:
            temp = q
        else:
            temp = q * 2
        i = 1
        while (temp * 10 + i) * i <= k:
            i += 1
        i = i - 1
        t = (temp * 10 + i) * i
        q = q * 10 + i
        k = (k - t) * 100
    return q


def sqrt(n):
    a = n
    b = 0
    while(b != a):
        b = a
        a = (n / a + a) / 2
    return a


def my_square_root(x):
    assert x >= 0
    y = math.sqrt(x)
    try:
        assert y * y == x
    except AssertionError as e:
        print x, y, y * y
        raise Exception
    return y


def has_int_root(n, V):
    A, C = V
    square = 1 + C * n
    sq_root = int(square ** 0.5 + 0.5)

    if sq_root ** 2 != square:
        return False


def triangle(n):
    '''return the nth triangle number'''
    return sum(range(1, n + 1))


def n_divisors(n):
    '''count unique divisors of n'''
    ret = 0

    for x in xrange(1, int(n ** 0.5) + 1):
        if n % x == 0:
            if x ** 2 != n:
                ret += 2
            else:
                ret += 1
    return ret


def search():

    top = 100
    while True:
        print top
        for x in range(top):
            t = triangle(x)
            if n_divisors(t) > 500:
                return t


def my_square_root(n, precision=None):
    if precision is None:
        precision = 5

    start = 0.01
    end = max(float(n), 1.0)
    max_e = 10.0 ** (-precision)
    while True:
        mid = start + (end - start) / 2.0
        e = n - (mid * mid)
        if abs(e) <= max_e:
            return mid




def sqrt(x):
    """
    give square root
    """
    if x >= 0:
        """
        if x is positive"""
        return x ** 0.5


def add(a, b):
    temp = a + b
    return temp


def f(x, y):
    return x ** 2 + x * y + y ** 2


def squareRootBi(x, epsilon):
    '''
    Assume x>=0 and epsilon > 0,
    Return y s.t. y*y is within epsilon of x.
    '''
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    low = 0

    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bi Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess


def squareRootNR(x, epsilon):
    '''
    Assume x >= 0 and epsilon > 0,
    Return y s.t. y**2 is within epsilon of x.
    '''
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess


def addthe2(x, y):
    return x + y


def cal(f, x):
    return f(x, 0.0001)


def square_root(a):

    x = a / 3.0
    epsilon = 0.000000000001

    while abs(a - (x ** 2)) > epsilon:
        x = (x + a / x) / 2
    return x


def test_sqrt(self, val):
    if (val ** 2 <= self.ulim) and (val ** 2 >= self.llim):
        return True


def is_lucky(x):
    s = str(x)
    for c in s:
        if c != "4" and c != "7":
            return False


def is_almost_lucky(x):
    if is_lucky(x):
        return True


def is_digit(self):
    try:
        float(self.text)
        return True


def is_simple_operation(self):
    if (self.text == '+' or self.text == '-' or
            self.text == u'' or self.text == u'' or
            self.text == u'^' or self.text == u'.'):
        return True


def is_ce(self):
    if self.text == 'CE':
        return True


def is_equal(self):
    if self.text == '=':
        return True


def is_square_root(self):
    if self.text == u'':
        return True


def is_sign(self):
    if self.text == '+/-':
        return True


def getSquareRoot(num):
    """
    Finds square root of a given number
    @param num: Number
    @type num: integer
    """
    isNegative = False
    if (num < 0):
        isNegative = True
        num = abs(num)

    guess = num / 2

    while (abs(guess * guess - num) > 0.001):
        print guess
        guess = (guess + num / guess) / 2

    if (isNegative):
        return str(guess) + " i"


def good_enough(guess, x):
    global difference
    difference.append(abs(square(guess) - x))
    return abs(square(guess) - x) < 0.001


def square_root_iter(guess, x):
    global iterations
    iterations += 1
    if good_enough(guess, x):
        return guess


def grades_sum(grades):
    total = 0
    for item in grades:
        total += item
    return total


def grades_average(grades):
    sum_of_grades = grades_sum(grades)
    average = sum_of_grades / len(grades)
    return average


def grades_variance(grades, average):
    sum_of_square = 0
    for item in grades:
        square_of_difference = (average - item) ** 2
        sum_of_square += square_of_difference
        variance = sum_of_square / len(grades)
    return variance


def grades_std_deviation(variance):
    std_deviation = variance ** 0.5
    return std_deviation


def square_root_convergents():
    num = 3
    den = 2
    result = 0
    for i in range(1, 1001):
        num += 2 * den
        den = num - den
        if len(str(num)) > len(str(den)):
            result += 1
    return result


def squareRoot(n, p):
    a = 5 * n
    b = 5
    limit = 10 ** (p + 1)
    while b < limit:
        if (a >= b):
            a -= b
            b += 10
        else:
            a *= 100
            b = (b - 5) * 10 + 5
    return b / 100


def sumDigits(n):
    r = 0
    while n:
        r, n = r + n % 10, n / 10
    return r


def sqrtFloat(n, p):
    from decimal import *
    getcontext().prec = p
    return Decimal(n).sqrt()


def perfectRoot(x):
    import math
    sqrt = int(math.sqrt(x))
    return sqrt * sqrt == x


def rmsle(target, prediction):
    squared_diff = np.power(np.log1p(prediction) - np.log1p(target), 2)
    return np.sqrt(squared_diff.mean())


def squareRootBi(x, epsilon):
    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"

    lowBound = 0
    highBound = max(1.0, x)
    guess = (lowBound + highBound) / 2.0
    counter = 1
    while abs(guess ** 2 - x) > epsilon and counter <= 1000:
        if guess ** 2 < x:
            lowBound = guess
        if guess ** 2 > x:
            highBound = guess

        guess = (lowBound + highBound) / 2
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: ", guess, " Count: ", counter
    return guess


def squareRootNR(x, epsilon):

    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"

    counter = 1
    x = float(x)
    guess = x / 2.0
    diff = guess ** 2 - x
    while abs(diff) > epsilon and counter <= 1000:
        guess = guess - (diff / (2.0 * guess))
        diff = guess ** 2 - x
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: ", guess, " Count: ", counter
    return guess


def is_square(n):
    root = int(n ** .5)
    return root * root == n


def root(x, n):
    return x ** (1 / n)


def is_prime(n):

    return n in primes


def is_triangular(n):
    """To tell whether n is a triangular number"""
    return n in triangular


def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    return n in tetrahedrals


def is_square(n):

    return n ** 0.5 % 1 == 0


def is_square_pyramidal(n):
    """To tell whether n is a tetrahedral number"""
    remainder = n
    subtractor_root = 0
    while remainder > 0:
        subtractor_root += 1
        remainder -= subtractor_root ** 2
    return remainder == 0


def is_pentagonal(n):
    """To tell whether n is a pentagonal number"""
    return (math.sqrt(n * 24 + 1) + 1) % 6 == 0


def is_prime_oblong(n):

    prime_oblong = False
    j = 0

    while j < len(primes):

        if n % primes[j] == 0 and n / primes[j] in primes:
            prime_oblong = True
            break
        j = j + 1

    return prime_oblong


def is_pointy(n):

    pointy = False

    j = 0
    while j < len(tetrahedrals):
        if n - tetrahedrals[j] in tetrahedrals and n != 2 * tetrahedrals[j]:
            pointy = True
            break
        j += 1

    return pointy


def main():
    num, den, cnt = 3, 2, 0

    for _ in range(1, 1001):
        if int(log10(num)) > int(log10(den)):
            cnt += 1

        num, den = num + 2 * den, num + den

    return cnt


def d(x):
    if (x == 0):
        return 0


def isAmicable(x):
    y = d(x)
    if x == d(y) and x != y:
        return 1


def is_perfect_square(integer):
    number_root = math.sqrt(integer) + 0.5
    if (int(number_root) ** 2) == integer:
        return False


def squareRootBi(x, epsilon):
    '''Assumes x >= 0, and epsilon > 0
       Return y
    '''
    low = 0
    high = x
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1

    print "Bi method. Num. iterations:", ctr, "Estimated: ", guess
    return guess


def divisors(p):
    divs = [1]
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(2, square_root):
        if p % x == 0:
            div1 = x
            div2 = p / x

            divs.append(div1)
            if div1 != div2:
                divs.append(div2)

    return divs


def __repr__(self):
    res = 'Table, zones: \n'
    for zone in self.zones_map.values():
        res += str(zone) + '\n'
    return res


def is_prime(n):
    """This determines if n is prime by dividing n by all numbers smaller than the square root of n"""
    i = 2
    prime = True

    if n == 1:
        prime = False

    while i <= int(n ** 0.5):
        if n % i == 0:
            prime = False
            break
        i = i + 1

    return prime


def is_triangular(n):
    """To tell whether n is a triangular number"""
    return (math.sqrt(n * 8 + 1) - 1) % 2 == 0


def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    m = 0
    f_m = 0
    tetrahedral = False
    while n - f_m > 0:
        m += 1
        f_m = (m ** 3 + 3 * m * m + 2 * m) / 6
        if f_m - n == 0:
            tetrahedral = True
            break
    return tetrahedral


def is_square(n):
    """Determines if n is square by taking the square root and evaluating if the result is an integer"""
    return n ** 0.5 % 1 == 0


def is_prime_oblong(n):
    """Determines if n is prime oblong by dividing by every number smaller
    than n and evaluating if that number and n are prime and distinct"""
    i = 2
    prime_oblong = False

    while i <= int(n ** 0.5):

        if n % i == 0 and is_prime(i) and is_prime(n / i) and n / i != i:
            prime_oblong = True

        i = i + 1

    return prime_oblong


def is_pointy(n):
    """To tell whether n is a pointy number"""
    i = 1
    pointy = False
    while i < n / 2:
        if is_tetrahedral(i) and is_tetrahedral(n - i):
            pointy = True
            break
        i += 1
    return pointy


def count_neighbourhoods(r):
    cnt = 0
    for i in range(int(math.ceil(math.sqrt(r)))):
        if is_square(r - i * i):
            cnt += 4
    return cnt


def newmark(oldmark):
    """Mr. Arkiletian's mark-boosting function"""

    return 10 * round(oldmark ** 0.5, 0)


def rmse(self, yPred, yTrue):
    """Finds the root mean square error """
    return np.sqrt(np.mean(np.power((yPred - yTrue), 2)))


def mae(self, yPred, yTrue):
    """Finds the mean absolute error"""
    return np.mean(np.fabs(yPred - yTrue))


def sqrt(x):

    i = 0
    if x >= 0:
        while i < x:
            if i * i == x:
                print i, "is the square root of the number", x
                return None


def find_sum(num):
    add = 0

    while num > 0:
        num, digit = divmod(num, 10)
        add += digit

    return add


def findSpecialComposite():
    listPreviousOddPrime = []

    x = 3
    while True:
        if isOddPrime(x, listPreviousOddPrime):
            listPreviousOddPrime.append(x)
        else:
            flagSpecial = False

            for oddPrime in listPreviousOddPrime:
                if isSquare((x - oddPrime) // 2):
                    flagSpecial = True
            if flagSpecial == False:
                return x


def isOddPrime(N, listPreviousOddPrime):
    if N <= 2:
        return False


def isSquare(N):
    floorSquareRoot = floor(sqrt(N))
    if floorSquareRoot * floorSquareRoot == N:
        return True


def rec_square_root(x, epsilon=0.01, low=None, high=None):

    if low is None:
        low = 0.0
    if high is None:
        high = x
    bisection = (low + high) / 2.0

    if abs(bisection ** 2 - x) < epsilon or bisection > x:
        return bisection


def isValidSquare(seq):
    """
Any Sequence can be treated as a square as long as
the square root of the number of elements is a positive integer"""
    NumberOfElements = len(seq)
    return sqrt(NumberOfElements).is_integer()


def Diagonal(seq, Diagonal="Left", X=4):
    diag = []
    LeN = len(seq)
    if Diagonal == "Left":
        pos = 0
        for i in xrange(0, LeN, LeN / X):
            diag.append(seq[pos + i])
            pos += 1
    elif Diagonal == "Right":
        pos = X
        for i in xrange(0, LeN, LeN / X):
            diag.append(seq[pos - i])
            pos -= 1

    return diag


def summation(n, term):
    return sum(term(k) for k in range(1, n + 1))


def invSquareSum(n):
    return summation(n, lambda k: 1 / (k * k))


def goldenUpdate(x):
    return 1 / x + 1


def squareCloseToSuccessor(x):
    return approxEq(x * x, x + 1)


def approxEq(x, y, epsilon=1e-15):
    return abs(x - y) < epsilon


def interpolate(x, y, f=0.5):
    return (1 - f) * x + f * y


def cubeRootUpdate(x):
    nonlocal iters
    iters += 1
    return interpolate(x, a / (x * x), f)


def cubeRootClose(x):
    return approxEq(x * x * x, a)


def myAdd(a, b):
    return a + b


def h(*moreArgs, **moreKwargs):
    nonlocal args
    nonlocal kwargs
    args += moreArgs
    kwargs.update(moreKwargs)
    return f(*args, **kwargs)


def digitalSumOfSquareNum(n, k):
    getcontext().prec = k
    digits = list(str(Decimal(n).sqrt()).replace('.', '')[:-2])
    digits = [int(i) for i in digits]
    return sum(digits)


def fracs(array):
    a = array
    f = frac(a[-2], 1, 1, a[-1])
    a = a[:-2]
    while a:
        f = frac(a[-1], 1, f[1], f[0])
        a = a[:-1]
    return tuple(f)


def exp(r):
    e = [1, 1, 2]
    while len(e) < r:
        if (e[-1] + e[-2]) % 2 == 0:
            e.append(e[-1] + e[-2] + e[-3])
        else:
            e.append(1)
    e[0] = 2
    return fracs(e)


def Root(n):
    x = n
    y = 0
    while(x != y):
        y = x
        x = (n / x + x) / 2
    return x


def sqrt(number):
    """This function uses division to converge to a square root"""

    guess = 2
    old = 0

    while (guess != old):
        old = guess
        quotient = number / guess
        guess = (quotient + guess) / 2

    return guess


def square_root(a, x):
    i = 10
    y = 0
    while i > 0:
        i = i - 1
        y = (x + a / x) / 2
        print i, y
        x = y

    return y


def main():
    while True:
        a = input('> ')

        if a == 'done':
            print 'Done!'
            return


def square_root(x):
    return math.sqrt(x)


def p(t):
    return t * 2


def power(x):
    return x ** 2


def __unicode__(self):
    return '%s %s' % (self.first_name, self.last_name)


def __unicode__(self):
    return "%s %s" % (self.first_name, self.last_name)


def is_square(x):
    root = (int)(math.sqrt(x))
    return x == root ** 2


def int_area(s, b):
    if b % 2 != 0:
        return False


def perim(s, b):
    return s * 2 + b


def build(self):
    """ build the Kivy app from the kv file """
    Window.size = (200, 100)
    self.title = "Square Number"
    self.root = Builder.load_file('squaring.kv')
    return self.root


def getRootSequence(r):
    """ See problem statement for details """
    a = -1 * math.floor(math.sqrt(r))
    b = 1

    sequence = []
    for i in range(500):
        d, r, a, b = helper(r, a, b)
        sequence.append(d)

    return sequence




def getPeriod(sequence):
    """ Returns the period of the repeating sequence """
    for period in range(1, len(sequence)):
        sequences = [
            tuple(
                sequence[
                    j *
                    period:j *
                    period +
                    period]) for j in range(
                len(sequence) /
                period)]
        if len(set(sequences)) == 1:
            return period


def isPerfectSquare(n):
    root = math.sqrt(n)
    return True if int(root + 0.5) ** 2 == n else False


def cube(x):
    return x * square(x)


def func(x):
    if not f._PRINTED:
        print("This function is deprecated. Use something else.")
        f._PRINTED = True
    out = f(x)
    return out


def sqrt(x):
    """Return sqare root of input"""
    square = math.sqrt(x)
    return square


def square_root(num, precission=0.001):
    x = num
    pow_two = x * x
    while abs(num - pow_two) > precission:
        pow_two = x * x
        x -= (pow_two - num) / (2.0 * x)

    return x


def square_root(self, number):
    left = 0
    right = number

    for a in range(100):
        middle = left + ((right - left) / 2)
        if middle ** 2 > number:
            right = middle
        else:
            left = middle

    return middle


def valueOf(com):
    result = (math.sqrt(com[0]) - com[3]) * com[1] / com[2]
    return math.floor(result * math.pow(10, 6))


def gcd(x, y):
    if x < y:
        temp = x
        x = y
        y = temp
    while y > 0:
        temp = x % y
        x = y
        y = temp

    return x


def oneOver(com):
    na = com[2]
    nb = com[1] * (com[0] - com[3] * com[3])
    nc = -com[3]
    d = gcd(na, nb)
    return [com[0], na // d, nb // d, nc]


def head(com):
    return int(valueOf(com) // math.pow(10, 6))


def trun(com, a):
    nc = com[3] + a * com[2] / com[1]
    return [com[0], com[1], com[2], nc]


def notation(num):
    root = math.sqrt(num)
    a = math.floor(root)
    if a == root:
        return [a, []]


def period(note):
    return len(note[1])


def digseq(num, i):
    note = notation(num)
    if i == 0:
        return note[0]


def convergent(num, n):
    if n == 1:
        return [notation(num)[0], 1]


def Dmim(d):
    i = 0
    while True:
        i += 1
        ab = convergent(d, i)
        x = ab[0]
        y = ab[1]
        if x * x - d * y * y == 1:
            return x


def square(num):
    root = math.sqrt(num)
    r = math.floor(root)
    if r == root:
        return True


def isSquare(n):
    return int(n ** 0.5) ** 2 == n


def diophantineX(d):

    for x, y in rootConvergentGenerator(d, True):
        ans = x ** 2 - d * y ** 2
        if ans == 1:
            return x


def challenge066():
    limit = 1000
    solutions = [[d, diophantineX(d)]
                 for d in xrange(1, limit + 1) if not isSquare(d)]
    return max(solutions, key=lambda x: x[1])[0]


def isSquare(n):
    r = math.sqrt(n)
    if r == int(r):
        return int(r)


def average(a, b):
    return (a + b) / 2.0


def good_enough():
    good = abs(guess * guess - x)
    return good < 0.001


def sqrt(A):
    if 2 > A:
        return A


def square_root(a):
    epsilon = 0.0000001
    if a < 0:
        return 'a must be larger than 0'


def return_name(str):


def pi_to_string():
    i_love_pi = 3.14
    return str(i_love_pi)


def hello_world():
    return "Hello World!"


def return_smallest(x, y):


def square_root(num):
    while ans * ans < x:
        ans = ans + 1
    return ans


def divisor(num):
    for i in range(1, num):
        if num % i == 0:
            return 'divisor ', i


def newton(k):

    if k < 0:
        raise ValueError("Cannot take the square root of a negative number")
    else:
        x = k / 2

        while abs(k - x ** 2) >= ((10) ** (-10)):

            x = (x + k / x) / 2

        return x


def square_root(n):
    ans = []
    p = 0
    c = n
    for i in range(100):
        x = 0
        while x * (20 * p + x) <= c:
            x += 1
        x = x - 1
        ans.append(x)
        c = (c - x * (20 * p + x)) * 100
        p = 10 * p + x

    return ans


def cheat():
    'decimal?'
    ans = 0
    dec = decimal.Decimal
    for n in range(1, 100):
        if not intlib.is_square(n):
            ans += sum(int(d) for d in str(dec(n) ** dec(.5))[:101]
                       if d != '.')
    return ans


def main():
    return sum(sum(square_root(n)) for n in range(1, 100)


def is_prime(n):
    """returns True if n is a prime
    """
    if n < 2:
        return False


def largest_prime(n):
    """Returns None if n is already a prime"""
    div = 2
    while div < n:
        if n % div == 0:
            current = n / div
            if is_prime(current) and n % current == 0:
                return current


def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    '''

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def square_root(self, num, guess=1.0):
    print str(guess)
    if '{:.2f}'.format(guess * guess) == '{:.2f}'.format(num):
        return guess


def square_root(a, x):
    while True:
        print x
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y - x) < epsilon:
            return y


def square_root(a):
    x = 3.0
    epsilon = 0.000001
    while True:
        y = (x + (a / x)) / 2
        if abs(y - x) < epsilon:
            return y


def test_square_root(a):
    function = square_root(a)
    builtin = math.sqrt(a)
    diff = abs(function - builtin)
    return '%d    %.8f    %.8f    %.11g' % (a, function, builtin, diff)


def func(x, y, z):
    return x + y + z


def squareRoot(number):
    if number < 0:
        raise NegativeNumberError(
            "Square root of negative number not permitted")
    return math.sqrt(number)


def sqrt(n, precision_digits=100):
    '''
    Calculate the square root of a integer with high precision.

    Uses digit-by-digit calculation found on:
    http://en.wikipedia.org/wiki/Methods_of_computing_square_roots

    Returns:
      The root with dot and the position of the dot.
    '''
    dot = 0
    count = 0
    root = 0
    current = 0
    while not (current == 0 and n == 0) and count < precision_digits:
        if n == 0:
            current *= 100
        else:
            tmp = n
            i = 0
            while tmp > 100:
                tmp /= 100
                i += 1
            n -= tmp * 100 ** i
            current = current * 100 + tmp
            dot += 1

        if root == 0:
            x = int(math.sqrt(current))
        else:
            x = current / (20 * root)

        while x * (20 * root + x) > current:
            x -= 1
        current -= x * (20 * root + x)
        root = root * 10 + x
        count += 1
    return root, dot


def sum_of_digits(n):
    sum = 0
    while n != 0:
        sum += n % 10
        n /= 10
    return sum


def is_square(n):
    if n < 1:
        return False


def cube(n):
    """
    Returns the cube of the number n
    """
    return n * n * n


def negate(n):
    """ Return negative n
    """
    return -n


def square_root(a):
    epsilon = 0.0000001
    x = a / 2
    while True:
        print(x)
        y = (x + a / x) / 2
        print(y)
        if abs(y - x) < epsilon:

            return y


def squareroot(number, precision=5):
    root = number / 2.0
    for i in range(20):
        nroot = (1 / 2.0) * (root + (number / root))

        if (root - nroot < 1.0 / 10 ** precision):
            break
        root = nroot
    return round(nroot, precision)


def is_square(number):
    root = int(round(math.sqrt(number)))
    return root ** 2 == number


def solve(N, P):
    decimal.getcontext().prec = P + 5
    return sum([sum(map(int, list(filter(lambda digit: digit != '.', list(str(decimal.Decimal(
        number).sqrt()))))[:P])) for number in range(1, N + 1) if not is_square(number)])


def sqrt(self, x):

    if x < 0:
        return None


def print_square_root(x):
    if x <= 0:
        print "Positive numbers only, please."
        return


def hasRoot(x):
    a = x // 2
    seen = set([a])
    while a * a != x:
        a = (a + (x // a)) // 2
        if a in seen:
            return a, False


def is_prime(number):
    if number == 1:
        return False


def get_nth_prime(n):
    prime_count = 0
    for x in itertools.count(1):
        if is_prime(x):
            prime_count += 1
            print("prime " + str(prime_count) + ": " + str(x))
        if prime_count == n:
            return x


def mapping(row, col):
    return [a + b for a in row for b in col]


def parse_grid(board):
    possibilities = dict((square, digits) for square in squares)
    for square, digit in grid_values(board).items():
        if digit in digits and not assign(possibilities, square, digit):
            return False


def grid_values(board):
    values = [c for c in board if c in digits or c in '0.']
    return dict(zip(squares, values))


def assign(possibilities, square, digit):
    other_possibilities = possibilities[square].replace(digit, '')
    if all(remove(possibilities, square, d2) for d2 in other_possibilities):
        return possibilities


def remove(possibilities, square, digit):
    if digit not in possibilities[square]:
        return possibilities


def search(possibilities):
    if possibilities is False:
        return False


def find_element(values):
    for e in values:
        if e:
            return e




def limite(n, p):
    return(int(math.log(n) / math.log(p)))


def difference_is_less_than(number_1, number_2, precision):
    print number_1, number_2, precision, abs(number_1 - number_2)
    return abs(number_1 - number_2) <= precision











def difference_is_less_than(number_1, number_2, precision):
    print number_1, number_2, precision, abs(number_1 - number_2)
    return abs(number_1 - number_2) <= precision


def square_root(self, number):
    return math.sqrt(number)


def log(self, number, base):
    return math.log(number, base)


def factorial(self, a):
    if a not in self.factorial_memo:
        self.factorial_memo[a] = self.factorial(a - 1) * a

    return self.factorial_memo[a]


def power(self, a, b):
    return a ** b


def mod(self, a, b):
    return a % b


def divide(self, a, b):
    return a / b


def multiply(self, a, b):
    return a * b


def sub(self, a, b):
    return a - b


def add(self, a, b):
    return a + b



def limite(n, p):
    return(int(math.log(n) / math.log(p)))





def find_element(values):
    for e in values:
        if e:
            return e



def search(possibilities):
    if possibilities is False:
        return False



def remove(possibilities, square, digit):
    if digit not in possibilities[square]:
        return possibilities



def assign(possibilities, square, digit):
    other_possibilities = possibilities[square].replace(digit, '')
    if all(remove(possibilities, square, d2) for d2 in other_possibilities):
        return possibilities



def grid_values(board):
    values = [c for c in board if c in digits or c in '0.']
    return dict(zip(squares, values))



def parse_grid(board):
    possibilities = dict((square, digits) for square in squares)
    for square, digit in grid_values(board).items():
        if digit in digits and not assign(possibilities, square, digit):
            return False



def mapping(row, col):
    return [a + b for a in row for b in col]



def get_nth_prime(n):
    prime_count = 0
    for x in itertools.count(1):
        if is_prime(x):
            prime_count += 1
            print("prime " + str(prime_count) + ": " + str(x))
        if prime_count == n:
            return x



def is_prime(number):
    if number == 1:
        return False



def hasRoot(x):
    a = x // 2
    seen = set([a])
    while a * a != x:
        a = (a + (x // a)) // 2
        if a in seen:
            return a, False



def print_square_root(x):
    if x <= 0:
        print "Positive numbers only, please."
        return


def sqrt(self, x):

    if x < 0:
        return None



def solve(N, P):
    decimal.getcontext().prec = P + 5
    return sum([sum(map(int, list(filter(lambda digit: digit != '.', list(str(decimal.Decimal(
        number).sqrt()))))[:P])) for number in range(1, N + 1) if not is_square(number)])



def is_square(number):
    root = int(round(math.sqrt(number)))
    return root ** 2 == number



def squareroot(number, precision=5):
    root = number / 2.0
    for i in range(20):
        nroot = (1 / 2.0) * (root + (number / root))

        if (root - nroot < 1.0 / 10 ** precision):
            break
        root = nroot
    return round(nroot, precision)



def square_root(a):
    epsilon = 0.0000001
    x = a / 2
    while True:
        print(x)
        y = (x + a / x) / 2
        print(y)
        if abs(y - x) < epsilon:

            return y


def __unicode__(self):
    return self.headline


def __unicode__(self):
    return u"%s %s" % (self.first_name, self.last_name)


def __unicode__(self):
    return u'%s %s' % (self.first_name, self.last_name)


def __unicode__(self):
    return "%s ** 2 == %s" % (self.root, self.square)



def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    return math.factorial(n)



def negate(n):
    """ Return negative n
    """
    return -n





def cube(n):
    """
    Returns the cube of the number n
    """
    return n * n * n



def is_square(n):
    if n < 1:
        return False



def sum_of_digits(n):
    sum = 0
    while n != 0:
        sum += n % 10
        n /= 10
    return sum



def sqrt(n, precision_digits=100):
    '''
    Calculate the square root of a integer with high precision.

    Uses digit-by-digit calculation found on:
    http://en.wikipedia.org/wiki/Methods_of_computing_square_roots

    Returns:
      The root with dot and the position of the dot.
    '''
    dot = 0
    count = 0
    root = 0
    current = 0
    while not (current == 0 and n == 0) and count < precision_digits:
        if n == 0:
            current *= 100
        else:
            tmp = n
            i = 0
            while tmp > 100:
                tmp /= 100
                i += 1
            n -= tmp * 100 ** i
            current = current * 100 + tmp
            dot += 1

        if root == 0:
            x = int(math.sqrt(current))
        else:
            x = current / (20 * root)

        while x * (20 * root + x) > current:
            x -= 1
        current -= x * (20 * root + x)
        root = root * 10 + x
        count += 1
    return root, dot



def squareRoot(number):
    if number < 0:
        raise NegativeNumberError(
            "Square root of negative number not permitted")
    return math.sqrt(number)


def func(x, y, z):
    return x + y + z



def test_square_root(a):
    function = square_root(a)
    builtin = math.sqrt(a)
    diff = abs(function - builtin)
    return '%d    %.8f    %.8f    %.11g' % (a, function, builtin, diff)



def square_root(a):
    x = 3.0
    epsilon = 0.000001
    while True:
        y = (x + (a / x)) / 2
        if abs(y - x) < epsilon:
            return y



def choose():
    func_choose = raw_input(
        "Choose function: square = 1, add = 2, root = 3 : ")
    if 1 == int(func_choose):
        return list_function(lst_a, square)



def root(x):
    try:
        return x ** 0.5



def add(x):
    '''(number) -> number
    Returns the number added with it self.
    >>> add(3)
    6
    >>> add(-1)
    -2
    '''
    return x + x



def square(x):
    '''(number) -> number
    Returns the square of a given number x.
    >>> square(3)
    9
    >>> square(-2)
    4
    >>> square(0)
    0
    '''
    return x ** 2





def square_root(a, x):
    while True:
        print x
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y - x) < epsilon:
            return y


def square_root(self, num, guess=1.0):
    print str(guess)
    if '{:.2f}'.format(guess * guess) == '{:.2f}'.format(num):
        return guess



def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    '''

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def largest_prime(n):
    """Returns None if n is already a prime"""
    div = 2
    while div < n:
        if n % div == 0:
            current = n / div
            if is_prime(current) and n % current == 0:
                return current



def is_prime(n):
    """returns True if n is a prime
    """
    if n < 2:
        return False



def get_largest_prime_factor(number):
    possible_factors = itertools.count(2)
    square_root_num = math.sqrt(number)

    for num in possible_factors:

        if num > square_root_num:
            break

        if num >= number:
            break

        while number / num % 1 == 0:
            if number / num != 1:
                number /= num

    return number



def isSqrt(a, b):
    '''
    Helper function to use in sqrt function to calculate number squared
    '''
    if a * a == b:
        return True



def sqrt(n):
    for number in range(0, n):
        if isSqrt(number, n):
            return number



def main():
    return sum(sum(square_root(n)) for n in range(1, 100)



def cheat():
    'decimal?'
    ans = 0
    dec = decimal.Decimal
    for n in range(1, 100):
        if not intlib.is_square(n):
            ans += sum(int(d) for d in str(dec(n) ** dec(.5))[:101]
                       if d != '.')
    return ans



def square_root(n):
    ans = []
    p = 0
    c = n
    for i in range(100):
        x = 0
        while x * (20 * p + x) <= c:
            x += 1
        x = x - 1
        ans.append(x)
        c = (c - x * (20 * p + x)) * 100
        p = 10 * p + x

    return ans


def path(self, *parts):
    return path.join(self.img_path, *parts)


def path(self, filename):
    return path.join(self.img_path, filename)



def newton(k):

    if k < 0:
        raise ValueError("Cannot take the square root of a negative number")
    else:
        x = k / 2

        while abs(k - x ** 2) >= ((10) ** (-10)):

            x = (x + k / x) / 2

        return x



def divisor(num):
    for i in range(1, num):
        if num % i == 0:
            return 'divisor ', i



def square_root(num):
    while ans * ans < x:
        ans = ans + 1
    return ans



def return_smallest(x, y):



def hello_world():
    return "Hello World!"



def pi_to_string():
    i_love_pi = 3.14
    return str(i_love_pi)



def return_name(str):



def square_root(a):
    epsilon = 0.0000001
    if a < 0:
        return 'a must be larger than 0'



def sqrt(A):
    if 2 > A:
        return A


def good_enough():
    good = abs(guess * guess - x)
    return good < 0.001


def average(a, b):
    return (a + b) / 2.0



def isSquare(n):
    r = math.sqrt(n)
    if r == int(r):
        return int(r)


def root_mean_square(self):
    """
    Find the root-dimension_means-square error for the given regression
    :return:
    """
    N = len(self.d_mat)

    guess_sum = 0
    for i in range(N):
        guess_sum += (self.t_vec[i][0] - self.predict(i)) ** 2

    return np.sqrt((1 / N) * guess_sum)



def challenge066():
    limit = 1000
    solutions = [[d, diophantineX(d)]
                 for d in xrange(1, limit + 1) if not isSquare(d)]
    return max(solutions, key=lambda x: x[1])[0]



def diophantineX(d):

    for x, y in rootConvergentGenerator(d, True):
        ans = x ** 2 - d * y ** 2
        if ans == 1:
            return x



def isSquare(n):
    return int(n ** 0.5) ** 2 == n



def power(question):
    m = re.match("^.* ([0-9]*) to the power of ([0-9]*)", question)
    if m:
        x = int(m.group(1))
        y = int(m.group(2))
        return str(int(math.pow(x, y)))



def __calc_fibonnaci(number):
    a, b = 0, 1
    for i in range(number):
        a, b = b, a + b
    return a



def fibonnaci(question):
    m = re.match("^what is the ([0-9]*).*", question)
    if m:
        number = int(m.group(1))
        return str(__calc_fibonnaci(number))



def which_are_primes(question):
    question = question[43:]
    question = question.replace(" ", "")
    number_list = question.split(",")
    number_list = list(map(int, number_list))
    result_list = []
    for number in number_list:
        if __is_prime(number):
            result_list.append(number)
    result_list = list(map(str, result_list))
    return ", ".join(result_list)



def __is_prime(n):
    n = int(n)
    if n <= 100:
        return n in primes_under_100



def float_equals(a, b, tolerance=0.00000001):
    return abs(a - b) < tolerance



def __is_third_square(number):
    number = int(number)
    float_root = (number ** (1.0 / 3.0))
    int_root = int(round(float_root))
    return float_equals(float_root, int_root)



def __is_square(number):
    number = int(number)
    root = math.sqrt(number)
    if (root % 1) > 0:
        return False



def square_cube(question):
    question = question[60:]
    number_list = question.replace(" ", "")
    number_list = number_list.split(",")
    list(map(int, number_list))
    return_values = []



def largest(question):
    question = question[47:]
    question = question.replace(" ", "")
    number_list = str.split(question, ",")
    number_list = list(map(int, number_list))
    max_val = max(number_list)
    return str(max_val)



def arithmetic(question):
    question = question[8:]
    question = question.replace(
        "plus", "+").replace("multiplied by", "*").replace("minus", "-")
    return str(eval(question))



def square(num):
    root = math.sqrt(num)
    r = math.floor(root)
    if r == root:
        return True



def Dmim(d):
    i = 0
    while True:
        i += 1
        ab = convergent(d, i)
        x = ab[0]
        y = ab[1]
        if x * x - d * y * y == 1:
            return x



def convergent(num, n):
    if n == 1:
        return [notation(num)[0], 1]



def digseq(num, i):
    note = notation(num)
    if i == 0:
        return note[0]



def period(note):
    return len(note[1])



def notation(num):
    root = math.sqrt(num)
    a = math.floor(root)
    if a == root:
        return [a, []]



def trun(com, a):
    nc = com[3] + a * com[2] / com[1]
    return [com[0], com[1], com[2], nc]



def head(com):
    return int(valueOf(com) // math.pow(10, 6))



def oneOver(com):
    na = com[2]
    nb = com[1] * (com[0] - com[3] * com[3])
    nc = -com[3]
    d = gcd(na, nb)
    return [com[0], na // d, nb // d, nc]



def gcd(x, y):
    if x < y:
        temp = x
        x = y
        y = temp
    while y > 0:
        temp = x % y
        x = y
        y = temp

    return x



def valueOf(com):
    result = (math.sqrt(com[0]) - com[3]) * com[1] / com[2]
    return math.floor(result * math.pow(10, 6))


def square_root(self, number):
    left = 0
    right = number

    for a in range(100):
        middle = left + ((right - left) / 2)
        if middle ** 2 > number:
            right = middle
        else:
            left = middle

    return middle


def build(self):
    """ build the Kivy app from the kv file """
    Window.size = (200, 100)
    self.title = "Square Number"
    self.root = Builder.load_file('squaring.kv')
    return self.root



def square_root(num, precission=0.001):
    x = num
    pow_two = x * x
    while abs(num - pow_two) > precission:
        pow_two = x * x
        x -= (pow_two - num) / (2.0 * x)

    return x



def sqrt(x):
    """Return sqare root of input"""
    square = math.sqrt(x)
    return square


def func(x):
    if not f._PRINTED:
        print("This function is deprecated. Use something else.")
        f._PRINTED = True
    out = f(x)
    return out



def cube(x):
    return x * square(x)



def square(x):
    return x * x



def squareRoot(a, precision=0.001):
    x = 4.0
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < precision:
            break
        x = y

    return y



def isPerfectSquare(n):
    root = math.sqrt(n)
    return True if int(root + 0.5) ** 2 == n else False



def getPeriod(sequence):
    """ Returns the period of the repeating sequence """
    for period in range(1, len(sequence)):
        sequences = [
            tuple(
                sequence[
                    j *
                    period:j *
                    period +
                    period]) for j in range(
                len(sequence) /
                period)]
        if len(set(sequences)) == 1:
            return period





def getRootSequence(r):
    """ See problem statement for details """
    a = -1 * math.floor(math.sqrt(r))
    b = 1

    sequence = []
    for i in range(500):
        d, r, a, b = helper(r, a, b)
        sequence.append(d)

    return sequence



def square_root(a):

    x = 0.75 * float(a)
    epsilon = 0.000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def perim(s, b):
    return s * 2 + b



def int_area(s, b):
    if b % 2 != 0:
        return False



def is_square(x):
    root = (int)(math.sqrt(x))
    return x == root ** 2


def __unicode__(self):
    return "%s %s" % (self.first_name, self.last_name)


def __unicode__(self):
    return '%s %s' % (self.first_name, self.last_name)


def dragged(self):
    return self.__dragged


def prev_state(self):
    return self.__prev_state


def state(self):
    return self.__state


def __call__(self):
    return "{0},{1}".format(self.x, self.y)


def drag(self, event):

    mouse_x = self.frame.winfo_pointerx() - self.frame.winfo_rootx()
    mouse_y = self.frame.winfo_pointery() - self.frame.winfo_rooty()
    event_grid = self.frame.grid_location(mouse_x, mouse_y)
    event_x, event_y = [int(i) for i in event_grid]

    if event_x < 0:
        event_x = 0
    elif event_x >= self.x:
        event_x = self.x - 1

    if event_y < 0:
        event_y = 0
    elif event_y >= self.y:
        event_y = self.y - 1

    event_square = self.squares["{0},{1}".format(event_x, event_y)]

    if self.drag_coord != -1:
        self.drag_mark(event_square, event_x, event_y)
        return None



def square_root(a):

    x = 3
    epsilon = 0.000000000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def square_root(x):
    return np.sqrt(x)



def power(x):
    """
    Returns the power of x

    Parameter
    ---------
    x : sequence

    Returns
    -------
    x ** 2

    """
    return x ** 2



def power(x):
    return x ** 2



def p(t):
    return t * 2



def square_root(x):
    return math.sqrt(x)



def square_root(a, x):
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < 0.0000001:
            return x



def main():
    while True:
        a = input('> ')

        if a == 'done':
            print 'Done!'
            return



def square_root(a, x):
    i = 10
    y = 0
    while i > 0:
        i = i - 1
        y = (x + a / x) / 2
        print i, y
        x = y

    return y



def sqrt(number):
    """This function uses division to converge to a square root"""

    guess = 2
    old = 0

    while (guess != old):
        old = guess
        quotient = number / guess
        guess = (quotient + guess) / 2

    return guess



def Root(n):
    x = n
    y = 0
    while(x != y):
        y = x
        x = (n / x + x) / 2
    return x



def exp(r):
    e = [1, 1, 2]
    while len(e) < r:
        if (e[-1] + e[-2]) % 2 == 0:
            e.append(e[-1] + e[-2] + e[-3])
        else:
            e.append(1)
    e[0] = 2
    return fracs(e)



def fracs(array):
    a = array
    f = frac(a[-2], 1, 1, a[-1])
    a = a[:-2]
    while a:
        f = frac(a[-1], 1, f[1], f[0])
        a = a[:-1]
    return tuple(f)



def digitalSumOfSquareNum(n, k):
    getcontext().prec = k
    digits = list(str(Decimal(n).sqrt()).replace('.', '')[:-2])
    digits = [int(i) for i in digits]
    return sum(digits)


def h(*moreArgs, **moreKwargs):
    nonlocal args
    nonlocal kwargs
    args += moreArgs
    kwargs.update(moreKwargs)
    return f(*args, **kwargs)



def myAdd(a, b):
    return a + b


def h(y):
    return f(x, y)


def cubeRootClose(x):
    return approxEq(x * x * x, a)


def cubeRootUpdate(x):
    nonlocal iters
    iters += 1
    return interpolate(x, a / (x * x), f)



def interpolate(x, y, f=0.5):
    return (1 - f) * x + f * y



def approxEq(x, y, epsilon=1e-15):
    return abs(x - y) < epsilon



def squareCloseToSuccessor(x):
    return approxEq(x * x, x + 1)



def goldenUpdate(x):
    return 1 / x + 1



def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess



def invSquareSum(n):
    return summation(n, lambda k: 1 / (k * k))



def summation(n, term):
    return sum(term(k) for k in range(1, n + 1))



def Diagonal(seq, Diagonal="Left", X=4):
    diag = []
    LeN = len(seq)
    if Diagonal == "Left":
        pos = 0
        for i in xrange(0, LeN, LeN / X):
            diag.append(seq[pos + i])
            pos += 1
    elif Diagonal == "Right":
        pos = X
        for i in xrange(0, LeN, LeN / X):
            diag.append(seq[pos - i])
            pos -= 1

    return diag



def isValidSquare(seq):
    """
Any Sequence can be treated as a square as long as
the square root of the number of elements is a positive integer"""
    NumberOfElements = len(seq)
    return sqrt(NumberOfElements).is_integer()



def rec_square_root(x, epsilon=0.01, low=None, high=None):

    if low is None:
        low = 0.0
    if high is None:
        high = x
    bisection = (low + high) / 2.0

    if abs(bisection ** 2 - x) < epsilon or bisection > x:
        return bisection



def example_function(x):
    """Compute the square root of x and return it."""



def isSquare(N):
    floorSquareRoot = floor(sqrt(N))
    if floorSquareRoot * floorSquareRoot == N:
        return True



def isOddPrime(N, listPreviousOddPrime):
    if N <= 2:
        return False



def findSpecialComposite():
    listPreviousOddPrime = []

    x = 3
    while True:
        if isOddPrime(x, listPreviousOddPrime):
            listPreviousOddPrime.append(x)
        else:
            flagSpecial = False

            for oddPrime in listPreviousOddPrime:
                if isSquare((x - oddPrime) // 2):
                    flagSpecial = True
            if flagSpecial == False:
                return x



def find_sum(num):
    add = 0

    while num > 0:
        num, digit = divmod(num, 10)
        add += digit

    return add



def sqrt(x):

    i = 0
    if x >= 0:
        while i < x:
            if i * i == x:
                print i, "is the square root of the number", x
                return None





def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')

    if n == 0:
        return 0



def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n



def totient(p, q):
    '''
    Calculates the totient of pq
    '''
    return (p - 1) * (q - 1)



def modInverse(e, n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e, n)[0] % n



def gcd(a, b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a, b = (b, a) if a < b else (a, b)
    while b:
        a, b = b, a % b
    return a




def mae(self, yPred, yTrue):
    """Finds the mean absolute error"""
    return np.mean(np.fabs(yPred - yTrue))


def rmse(self, yPred, yTrue):
    """Finds the root mean square error """
    return np.sqrt(np.mean(np.power((yPred - yTrue), 2)))



def newmark(oldmark):
    """Mr. Arkiletian's mark-boosting function"""

    return 10 * round(oldmark ** 0.5, 0)



def count_neighbourhoods(r):
    cnt = 0
    for i in range(int(math.ceil(math.sqrt(r)))):
        if is_square(r - i * i):
            cnt += 4
    return cnt



def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True



def sqrt(n):
    approx = n / 2.0
    better = (approx + n / approx) / 2.0
    while better != approx:
        approx = better
        better = (approx + n / approx) / 2.0
    return approx



def power(x):
    return x ** 2



def is_pointy(n):
    """To tell whether n is a pointy number"""
    i = 1
    pointy = False
    while i < n / 2:
        if is_tetrahedral(i) and is_tetrahedral(n - i):
            pointy = True
            break
        i += 1
    return pointy



def is_prime_oblong(n):
    """Determines if n is prime oblong by dividing by every number smaller
    than n and evaluating if that number and n are prime and distinct"""
    i = 2
    prime_oblong = False

    while i <= int(n ** 0.5):

        if n % i == 0 and is_prime(i) and is_prime(n / i) and n / i != i:
            prime_oblong = True

        i = i + 1

    return prime_oblong



def is_pentagonal(n):
    """To tell whether n is a pentagonal number"""
    return (math.sqrt(n * 24 + 1) + 1) % 6 == 0



def is_square_pyramidal(n):
    """To tell whether n is a tetrahedral number"""
    remainder = n
    subtractor_root = 0
    while remainder > 0:
        subtractor_root += 1
        remainder -= subtractor_root ** 2
    return remainder == 0



def is_square(n):
    """Determines if n is square by taking the square root and evaluating if the result is an integer"""
    return n ** 0.5 % 1 == 0



def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    m = 0
    f_m = 0
    tetrahedral = False
    while n - f_m > 0:
        m += 1
        f_m = (m ** 3 + 3 * m * m + 2 * m) / 6
        if f_m - n == 0:
            tetrahedral = True
            break
    return tetrahedral



def is_triangular(n):
    """To tell whether n is a triangular number"""
    return (math.sqrt(n * 8 + 1) - 1) % 2 == 0



def is_prime(n):
    """This determines if n is prime by dividing n by all numbers smaller than the square root of n"""
    i = 2
    prime = True

    if n == 1:
        prime = False

    while i <= int(n ** 0.5):
        if n % i == 0:
            prime = False
            break
        i = i + 1

    return prime



def getFunctionByKey(key):
    for func in function_list:
        if key == func.key:
            return func



def sqrt(x):
    return math.sqrt(x)


def __repr__(self):
    res = 'Table, zones: \n'
    for zone in self.zones_map.values():
        res += str(zone) + '\n'
    return res



def divisors(p):
    divs = [1]
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(2, square_root):
        if p % x == 0:
            div1 = x
            div2 = p / x

            divs.append(div1)
            if div1 != div2:
                divs.append(div2)

    return divs



def squareRootBi(x, epsilon):
    '''Assumes x >= 0, and epsilon > 0
       Return y
    '''
    low = 0
    high = x
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1

    print "Bi method. Num. iterations:", ctr, "Estimated: ", guess
    return guess



def is_perfect_square(integer):
    number_root = math.sqrt(integer) + 0.5
    if (int(number_root) ** 2) == integer:
        return False



def isAmicable(x):
    y = d(x)
    if x == d(y) and x != y:
        return 1



def d(x):
    if (x == 0):
        return 0



def main():
    num, den, cnt = 3, 2, 0

    for _ in range(1, 1001):
        if int(log10(num)) > int(log10(den)):
            cnt += 1

        num, den = num + 2 * den, num + den

    return cnt



def is_pointy(n):

    pointy = False

    j = 0
    while j < len(tetrahedrals):
        if n - tetrahedrals[j] in tetrahedrals and n != 2 * tetrahedrals[j]:
            pointy = True
            break
        j += 1

    return pointy



def is_prime_oblong(n):

    prime_oblong = False
    j = 0

    while j < len(primes):

        if n % primes[j] == 0 and n / primes[j] in primes:
            prime_oblong = True
            break
        j = j + 1

    return prime_oblong



def is_square(n):

    return n ** 0.5 % 1 == 0



def is_tetrahedral(n):
    """To tell whether n is a tetrahedral number"""
    return n in tetrahedrals



def is_triangular(n):
    """To tell whether n is a triangular number"""
    return n in triangular



def is_prime(n):

    return n in primes



def square_root(a, x):
    while True:
        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return x



def root(x, n):
    return x ** (1 / n)



def is_square(n):
    root = int(n ** .5)
    return root * root == n



def squareRootNR(x, epsilon):

    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"

    counter = 1
    x = float(x)
    guess = x / 2.0
    diff = guess ** 2 - x
    while abs(diff) > epsilon and counter <= 1000:
        guess = guess - (diff / (2.0 * guess))
        diff = guess ** 2 - x
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: ", guess, " Count: ", counter
    return guess



def squareRootBi(x, epsilon):
    assert x >= 0, "x must be greater than 0"
    assert epsilon > 0, "epsilon must be greater than 0"

    lowBound = 0
    highBound = max(1.0, x)
    guess = (lowBound + highBound) / 2.0
    counter = 1
    while abs(guess ** 2 - x) > epsilon and counter <= 1000:
        if guess ** 2 < x:
            lowBound = guess
        if guess ** 2 > x:
            highBound = guess

        guess = (lowBound + highBound) / 2
        counter += 1
    assert counter <= 1000, "Iteration exceeded"
    print "Square root of x is approximately: ", guess, " Count: ", counter
    return guess



def rmsle(target, prediction):
    squared_diff = np.power(np.log1p(prediction) - np.log1p(target), 2)
    return np.sqrt(squared_diff.mean())



def sqrt(n):
    '''function to determine the square root of a given numebr n'''

    error = 1
    oldGuess = n / 2
    newGuess = 0

    while (error > 1e-6):
        newGuess = ((n / oldGuess) + oldGuess) / 2
        error = abs(oldGuess - newGuess)
        oldGuess = newGuess

    return newGuess



def perfectRoot(x):
    import math
    sqrt = int(math.sqrt(x))
    return sqrt * sqrt == x



def sqrtFloat(n, p):
    from decimal import *
    getcontext().prec = p
    return Decimal(n).sqrt()



def sumDigits(n):
    r = 0
    while n:
        r, n = r + n % 10, n / 10
    return r



def squareRoot(n, p):
    a = 5 * n
    b = 5
    limit = 10 ** (p + 1)
    while b < limit:
        if (a >= b):
            a -= b
            b += 10
        else:
            a *= 100
            b = (b - 5) * 10 + 5
    return b / 100



def square_root_convergents():
    num = 3
    den = 2
    result = 0
    for i in range(1, 1001):
        num += 2 * den
        den = num - den
        if len(str(num)) > len(str(den)):
            result += 1
    return result



def grades_std_deviation(variance):
    std_deviation = variance ** 0.5
    return std_deviation



def grades_variance(grades, average):
    sum_of_square = 0
    for item in grades:
        square_of_difference = (average - item) ** 2
        sum_of_square += square_of_difference
        variance = sum_of_square / len(grades)
    return variance



def grades_average(grades):
    sum_of_grades = grades_sum(grades)
    average = sum_of_grades / len(grades)
    return average



def grades_sum(grades):
    total = 0
    for item in grades:
        total += item
    return total



def square_root(x):
    return square_root_iter(1.0, x)



def square_root_iter(guess, x):
    global iterations
    iterations += 1
    if good_enough(guess, x):
        return guess



def good_enough(guess, x):
    global difference
    difference.append(abs(square(guess) - x))
    return abs(square(guess) - x) < 0.001



def improve(guess, x):
    return average(guess, (x / guess))



def average(x, y):
    return (x + y) / 2



def square(x):
    return x * x



def getSquareRoot(num):
    """
    Finds square root of a given number
    @param num: Number
    @type num: integer
    """
    isNegative = False
    if (num < 0):
        isNegative = True
        num = abs(num)

    guess = num / 2

    while (abs(guess * guess - num) > 0.001):
        print guess
        guess = (guess + num / guess) / 2

    if (isNegative):
        return str(guess) + " i"


def is_sign(self):
    if self.text == '+/-':
        return True


def is_square_root(self):
    if self.text == u'':
        return True


def is_equal(self):
    if self.text == '=':
        return True


def is_ce(self):
    if self.text == 'CE':
        return True


def is_simple_operation(self):
    if (self.text == '+' or self.text == '-' or
            self.text == u'' or self.text == u'' or
            self.text == u'^' or self.text == u'.'):
        return True


def is_digit(self):
    try:
        float(self.text)
        return True



def generate_fixed_amount_of_primes(n):
    assert(n > 0)
    primes = [2, 3]
    current_number = primes[1]
    while (len(primes) < n):
        current_number += 2
        square_root = math.floor(math.sqrt(current_number))
        prime = True
        for p in primes:
            if p > square_root:
                break
            elif current_number % p == 0:
                prime = False
                break

        if prime:
            primes.append(current_number)
    return primes[:n]



def find_prime_by_index(i):
    return generate_fixed_amount_of_primes(i)[-1]



def problem7():
    return find_prime_by_index(10001)



def is_almost_lucky(x):
    if is_lucky(x):
        return True



def is_lucky(x):
    s = str(x)
    for c in s:
        if c != "4" and c != "7":
            return False


def test_sqrt(self, val):
    if (val ** 2 <= self.ulim) and (val ** 2 >= self.llim):
        return True



def square_root(a):

    x = a / 3.0
    epsilon = 0.000000000001

    while abs(a - (x ** 2)) > epsilon:
        x = (x + a / x) / 2
    return x



def cal(f, x):
    return f(x, 0.0001)



def addthe2(x, y):
    return x + y



def squareRootNR(x, epsilon):
    '''
    Assume x >= 0 and epsilon > 0,
    Return y s.t. y**2 is within epsilon of x.
    '''
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess



def squareRootBi(x, epsilon):
    '''
    Assume x>=0 and epsilon > 0,
    Return y s.t. y*y is within epsilon of x.
    '''
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must greater than ZERO, not' + str(epsilon)
    low = 0

    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bi Method.  Num. of Iteration:', ctr, ' Estimation:', guess
    return guess



def f(x, y):
    return x ** 2 + x * y + y ** 2



def add(a, b):
    temp = a + b
    return temp



def sqrt(x):
    """
    give square root
    """
    if x >= 0:
        """
        if x is positive"""
        return x ** 0.5





def my_square_root(n, precision=None):
    if precision is None:
        precision = 5

    start = 0.01
    end = max(float(n), 1.0)
    max_e = 10.0 ** (-precision)
    while True:
        mid = start + (end - start) / 2.0
        e = n - (mid * mid)
        if abs(e) <= max_e:
            return mid



def search():

    top = 100
    while True:
        print top
        for x in range(top):
            t = triangle(x)
            if n_divisors(t) > 500:
                return t



def n_divisors(n):
    '''count unique divisors of n'''
    ret = 0

    for x in xrange(1, int(n ** 0.5) + 1):
        if n % x == 0:
            if x ** 2 != n:
                ret += 2
            else:
                ret += 1
    return ret



def triangle(n):
    '''return the nth triangle number'''
    return sum(range(1, n + 1))



def has_int_root(n, V):
    A, C = V
    square = 1 + C * n
    sq_root = int(square ** 0.5 + 0.5)

    if sq_root ** 2 != square:
        return False



def my_square_root(x):
    assert x >= 0
    y = math.sqrt(x)
    try:
        assert y * y == x
    except AssertionError as e:
        print x, y, y * y
        raise Exception
    return y



def sqrt(n):
    a = n
    b = 0
    while(b != a):
        b = a
        a = (n / a + a) / 2
    return a



def sqrt_digit(n):
    k = n
    q = 0
    while len(str(q)) < 100:
        if q == 0:
            temp = q
        else:
            temp = q * 2
        i = 1
        while (temp * 10 + i) * i <= k:
            i += 1
        i = i - 1
        t = (temp * 10 + i) * i
        q = q * 10 + i
        k = (k - t) * 100
    return q



def square(numbers):
    return numbers ** 2


def __repr__(self):
    return str(self)


def __str__(self):
    return "(%d, %d, %d, %d)" % (self.num_root,


def __eq__(self, other):
    return (


def disjoin_invert(self):
    int_part, frac_part = self.disjoin()
    return (int_part, frac_part.invert())


def invert(self):
    return Fraction(self.denom_root, self.denom_int,


def disjoin(self):
    assert(self.denom_root == 0)
    assert(self.num_root != 0)
    int_part = int(
        (math.sqrt(
            self.num_root) +
            self.num_int) /
        self.denom_int)
    frac_part = Fraction(
        self.num_root,
        self.num_int -
        int_part *
        self.denom_int,
        0,
        self.denom_int)
    return (int_part, frac_part)


def rationalize(self):
    assert(self.denom_root != 0)
    assert(self.num_root == 0)
    new_denom_root = 0
    new_denom_int = (self.denom_root - self.denom_int ** 2) / self.num_int
    new_num_root = self.denom_root
    new_num_int = -self.denom_int
    return Fraction(new_num_root, new_num_int,



def count_odd_periods(max_root):
    count = 0
    for root in xrange(2, max_root + 1):
        if gmpy.is_square(root):
            continue
        period = get_period(root)
        if period % 2 == 1:
            count += 1
    return count



def get_period(root):
    history = []
    current_pair = Fraction(root, 0, 0, 1).disjoin_invert()
    history.append(current_pair)
    while True:

        current_pair = current_pair[1].rationalize().disjoin_invert()
        if current_pair in history:
            return len(history) - history.index(current_pair)



def root_mean_square(x):
    """ Returns the root mean square (rms) given a list of values. """
    return math.sqrt(sum([i * i for i in x]) / len(x))



def solve():
    total = 0
    for n in range(2, NUM_COUNT + 1):
        if com.is_square(n):
            continue

        root = com.sqrt_expansion(n, DIGIT_COUNT)
        root = root.replace('.', '')
        total += sum([int(digit) for digit in root[:DIGIT_COUNT]])

    return total



def square_root(x):
    guess = 1
    while (not good_enough(guess, x)):
        guess = improve(guess, x)
    return guess



def good_enough(guess, x):
    d = abs(guess * guess - x)
    return (d < 0.000001)



def improve(guess, x):
    return average(guess, x / guess)



def average(a, b):
    return (a + b) / 2.0



def nth_root(value, n_root):

    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)



def normB(b):
    sum_squares = 0
    for i in b:
        squares = eval(i) ** 2
        sum_squares += squares
    x = sum_squares ** 0.5

    return x



def normA(a):
    sum_squares = 0
    for i in a:
        squares = eval(i) ** 2
        sum_squares += squares
    x = sum_squares ** 0.5

    return x



def productvectors(a, b):
    iteration = 0
    product = 0
    for i in a:
        multiply = eval(i) * eval(b[iteration])
        product += multiply
        iteration += 1
    return product



def addvectors(a, b):
    iteration = 0
    new_list = []
    for i in a:
        add = eval(i) + eval(b[iteration])
        new_list.append(add)
        iteration += 1
    return new_list



def sqrt(x):
    '''Computer square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x

    Raises:
        ValueError: if x is negative
    '''
    if x < 0:
        raise ValueError(
            'Cannot compute square root of negative number. {}'.format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1

    return guess



def newtonest(num):
    return num ** 0.5



def isSquare(num):
    r = math.floor(math.sqrt(num))
    if r * r - num == 0:
        return True



def root(num):
    x = 100
    temp = [math.floor(math.sqrt(num))]
    while len(temp) < x:
        temp.append(1)
        while temp[-1] < 10 and bigger(num, square(temp)):
            temp[-1] += 1
        temp[-1] -= 1
    return temp



def bigger(num, lst):
    if lst[0] >= num:
        return False



def square(lst):
    n = len(lst)
    temp = [0] * (n * 2 - 1)
    for i in range(0, n):
        for j in range(0, n):
            temp[i + j] += lst[i] * lst[j]
    for i in range(0, len(temp) - 1):
        if temp[-1 - i] > 9:
            temp[-2 - i] += temp[-1 - i] // 10
            temp[-1 - i] = temp[-1 - i] % 10
    return temp


def constraint_sum_over_500():
    return sum([a.x, a.y, b.x, b.y, c.x, c.y]) > 500


def constraint_square_root():

    return math.sqrt(a.x ** 2) == 10



def expand_root(square, precision):

    digits = []
    c = square
    p = 0
    x = 9
    y = 0
    while len(digits) < precision:
        while True:
            testnum = x * (20 * p + x)
            if testnum > c:
                x -= 1
            else:
                y = testnum
                break
        digits.append(x)
        p = p * 10 + x
        c = (c - y) * 100
        x = 9
        y = 0
    return sum(digits)



def abbreviated(s):
    '''(GameState) -> str

    Return an abbreviated str representation of SubtractSquareState s.
    '''
    return "{}:{}".format(s.next_player, s.current_total)



def merge_dict2(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}

    Helper function

    Returns a merged dictionary from two dictionarys, version 2.
    Adds d2 to d1, but with the keys in d2 incremented by 1.
    Assumes that the keys are Integers
    '''
    d = d1
    for key in d2:

        if (key + 1) in d:
            d[key + 1] += d2[key]
        else:
            d[key + 1] = d2[key]
    return d



def game_lengths(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    d = {}
    if not root.children:

        d[0] = 1
    else:
        for child in root.children:

            d = merge_dict2(d, game_lengths(child))
    return d



def merge_list(l1, l2):
    ''' (list, list) -> list

    Helper function

    Returns a merged list from two lists
    Assumes that the lists have same lengths.
    '''
    l = l1
    for index in range(len(l2)):
        l[index] += l2[index]
    return l



def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]

    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    l = [0, 0, 0]
    if not root.children:
        if root.value.winner('p1'):
            l[0] += 1
        elif root.value.winner('p2'):
            l[1] += 1
        else:
            l[2] += 1
    else:
        for child in root.children:
            l = merge_list(l, outcome_counts(child))
    return l



def merge_dict(d1, d2):
    ''' (dict of {int: int}, dict of {int: int}) -> dict of {int: int}

    Helper function

    Returns a merged dictionary from two dictionarys.
    '''
    d = d1
    for key in d2:
        if key in d:
            d[key] += d2[key]
        else:
            d[key] = d2[key]
    return d



def branching_stats(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''

    d = {0: 0}
    if not root.children:
        d[0] += 1
    else:
        arity = len(root.children)
        if arity in d:
            d[arity] += 1
        else:
            d[arity] = 1
        for child in root.children:
            merge_dict(d, branching_stats(child))
    return d



def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int

    Return the number of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_leaf:
            s_distinct_leaf.add(root.value.__str__())
            count += 1
    else:
        for child in root.children:
            count += distinct_leaf_count(child)
    return count



def distinct_node_count(root):
    '''(GameStateNode) -> int

    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''

    count = 0
    if not root.children:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1
    else:
        if not root.value.__str__() in s_distinct_nodes:
            s_distinct_nodes.add(root.value.__str__())
            count += 1
        for child in root.children:
            count += distinct_node_count(child)
    return count



def leaf_count(root):
    '''(GameStateNode) -> int

    Return the number of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    if root.children == []:
        return 1



def node_count(root):
    ''' (GameStateNode) -> int

    Return the number of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    if root.value is None:
        return 0



def same_contents(L1, L2):
    ''' (list, list) -> bool

    Return True iff L1 and L2 have the same contents, although not necessarily
    in the same order.

    >>> same_contents([1, 4, 5, 2], [5, 2, 4, 1])
    True
    >>> same_contents([1, 2], [2, 1, 1])
    False
    '''
    return (len(L1) == len(L2) and


def __eq__(self, other):
    ''' (GameStateNode, object) -> bool
    Return whether this GameStateNode is equivalent to other, i.e., they
    contain equivalent GameStates, and equivalent children.  The order of
    their children does not matter.
    >>> s1 = SubtractSquareState('p1', current_total = 6)
    >>> s2 = SubtractSquareState('p2', current_total = 5)
    >>> s3 = SubtractSquareState('p1', current_total = 2)
    >>> leaf1 = GameStateNode(s1)
    >>> leaf2 = GameStateNode(s2)
    >>> leaf3 = GameStateNode(s3)
    >>> leaf1.__eq__(leaf2)
    False
    >>> root1 = GameStateNode(s1)
    >>> root1.children = [s2, s3]
    >>> root2 = GameStateNode(s1)
    >>> root1.__eq__(root2)
    False
    >>> root2.children = [s2, s3]
    >>> root1.__eq__(root2)
    True
    '''

    return (type(self) == type(other) and


def __repr__(self):

    return 'GameStateNode({}, {})'.format(self.value, self.children)



def ask_and_approx_roots():
    num_iterations = int(
        input("Please enter the number of iterations (an integer): "))
    square_root_to_approx = int(
        input("Please enter the square root to approximate (an integer): "))
    sq_root_guess = float(input("Please enter a guess for the square root: "))
    return heron_method(num_iterations, square_root_to_approx, sq_root_guess)



def square(Val):
    SquareRel = Val * Val
    print "Got Value and Square equal=", SquareRel
    return SquareRel



def PrintFunc(str):
    print str
    return



def get_answer():
    return get_number_of_odd_periods_up_to(10000)



def get_number_of_odd_periods_up_to(n):
    return sum(1 for i in xrange(1, n + 1) if get_period(i) % 2 == 1)



def get_period(n):
    if _is_square_number(n):
        return 0


def reciprocal(self):
    new_c = (self.b * self.b - self.a) / -self.c
    new_b = -self.b

    whole_number = (self.nearest_whole_number + new_b) / new_c

    new_b -= whole_number * new_c

    return _SquareRootFraction(



def _is_square_number(n):
    return n in _square_numbers



def _nearest_whole_square_root(n):
    while _roots[-1][0] < n:
        next_root = _roots[-1][1] + 1
        square_number = next_root * next_root

        _square_numbers.add(square_number)

        _roots.append((square_number, next_root))

    for i in xrange(1, len(_roots)):
        if _roots[i][0] > n:
            return _roots[i - 1][1]


def sqrtHelper(guess):
    if closeEnough(guess):
        return guess


def improve(guess):
    return average(guess, (number / guess))


def closeEnough(guess):
    return (math.fabs((square(guess)) - number) < 0.001)



def average(x, y):
    return (x + y) / 2



def square(number):
    return number * number



def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)



def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)



def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)



def minkowski_dist(x, y, p_value):
    return nth_root(sum(pow(abs(a - b), p_value) for a, b in zip(x, y)),



def nth_root(value, n_root):
    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)



def manhattan_dist(x, y):
    return sum(



def euclid_dist(x, y):
    return sqrt(sum(



def sqrt(num):
    "Returns the square root of a number"
    Answer = num ** 0.5
    return float(Answer)





def is_square(n):
    if(n == 1):
        return True



def squareRootNR(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using Newton-Raphson method.
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    guess = float(x) / 2.0

    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr < 100:
        guess = guess - (guess ** 2 - x) / (2.0 * guess)
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'NR method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess



def squareRootBi(x, epsilon):
    """
    Assume x >= 0, and epsilon > 0, Calculates the square root of x
    using bisection method
    :param x: a number >= 0
    :param epsilon: a number > 0, which indicates the accuracy of the result
    :return: square root of x (y s.t. y^2 == x)
    """
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0.0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr < 100:
        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr < 100, 'Iteration count exceeded.'
    print 'Bi method, Num. Iterations:', ctr, 'Estimate:', guess
    return guess



def smooth(data, alpha):
    return lfilter([alpha], [1.0, 1.0 - alpha], data)



def trajSpeed(traj):
    "Compute trajectory speed by taking square root of energy"
    e = trajEnergy(traj)
    return e ** .5



def trajEnergy(traj):
    "Compute trajectory energy by taking square of velocity vector length."
    vel = trajVelocity(traj)
    return np.sum(vel ** 2, 1)



def trajVelocity(traj):
    "Compute trajectory velocities"
    data = np.array(traj.pointData)
    return data[1:, :] - data[:-1, :]



def squareRootNR(x, epsilon):
    """Assume x >= 0 and elsilon > 0
        Return y s.y. y*y is within epsilon of x"""
    assert x >= 0, 'x must be non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    x = float(x)
    guess = x / 2.0
    guess = 0.001
    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
        assert ctr <= 100, 'Iteration count exceeded'
        print 'NR method. Num.. iterations:', ctr, 'Estimated:', guess
        return guess



def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess

        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:', ctr, 'Estimate:', guess
    return guess



def fib(x):
    if x == 0 or x == 1:
        return 1



def isPalindromel(s, indent):
    print indent, 'isPalindromel called with', s
    if len(s) <= 1:
        print indent, 'About to return True frome this case'



def isPalindrome(s):
    if len(s) <= 1:
        return True



def solve(numLegs, numHeads):
    for numChicks in range(0, numHeads + 1):
        numPigs = numHeads - numChicks
        totLegs = 4 * numPigs + 2 * numChicks
        if totLegs == numLegs:
            return [numPigs, numChicks]



def f(x):
    x = x + 1
    return x



def sqrt(x):
    ans = 0
    if x >= 0:
        while ans * ans < x:
            ans = ans + 1
        if ans * ans != x:
            print x, 'is not a perfect square'
            return None



def square_root(n, precision):
    low = 0.0
    high = n
    mid = (low + high) / 2.0

    while (abs(mid * mid - n) > precision):
        if (mid * mid) < n:
            low = mid
        elif (mid * mid) > n:
            high = mid
        mid = (low + high) / 2.0

    return mid


def get_close_clicked_signal(self):
    return self.__get_root_window().closeClicked


def get_add_curly_brackets_clicked_signal(self):
    return self.__get_root_window().addCurlyBracketsClicked


def get_add_square_brackets_clicked_signal(self):
    return self.__get_root_window().addSquareBracketsClicked


def get_add_round_brackets_clicked_signal(self):
    return self.__get_root_window().addRoundBracketsClicked


def get_add_language_clicked_signal(self):
    return self.__get_root_window().addLanguageClicked


def get_add_duration_clicked_signal(self):
    return self.__get_root_window().addDurationClicked


def get_add_directors_clicked_signal(self):
    return self.__get_root_window().addDirectorsClicked


def get_add_year_clicked_signal(self):
    return self.__get_root_window().addYearClicked


def get_add_original_title_clicked_signal(self):
    return self.__get_root_window().addOriginalTitleClicked


def get_add_title_clicked_signal(self):
    return self.__get_root_window().addTitleClicked


def get_remove_all_rules_clicked_signal(self):
    return self.__get_root_window().removeAllRulesClicked


def get_remove_rule_clicked_signal(self):
    return self.__get_root_window().removeRuleClicked


def get_rule_changed_signal(self):
    return self.__get_root_window().ruleChanged


def __set_property(self, property_name: str, property_value):
    return self.__get_root_window().setProperty(property_name, property_value)


def __get_property(self, property_name: str):
    return self.__get_root_window().property(property_name)


def __get_root_window(self):
    return self.__engine.rootObjects()[0]



def primitive_roots(q):
    """Brute force search for primitive roots of a prime q."""
    return [i for i in range(1, q) if is_primitive_root(i, q)]



def generator_permutation(g, q):
    return [mod_exp(g, i, q) for i in range(1, q)]



def mod_exp(a, b, q):
    if b == 0:
        return 1



def counted_mod_exp(a, b, q):
    global count
    count = 0
    res = mod_exp(a, b, q)
    return (res, count)



def square(x):
    return mult(x, x)



def mult(a, b):
    global count

    if a > 2 and b > 2:
        count = count + 1
    return a * b



def is_primitive_root(g, q):
    reached = []
    x = g
    while True:
        if x in reached:
            break
        reached.append(x)
        x = (x * g) % q
    return len(reached) == q - 1



def totient(n):
    """Brute force computation of Euler's totient (not for large n)."""
    return [i for i in range(n) if gcd(i, n) == 1]



def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a



def square(x):
    return x * x



def safeHasSquareRoot(num):
    return mpmath.isint(mpmath.sqrt(num))



def safeHasSquareRoot5(num):

    numAsStr = str(num)
    return (numAsStr[-2:]
            in DIGITS_SQUARES_CAN_END_WITH) and safeHasSquareRoot(num)



def safeHasSquareRoot4(num):
    if num > 1000000:
        numOnesDigit = num % 10
        if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
            numTensDigit = num // 10 % 10
            return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[



def safeHasSquareRoot6(num):
    '''
    assuming the square was received from euler66PotentialYSquaresGenerator
    '''
    return ((num // 10 % 10) in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[



def safeHasSquareRoot3(num):

    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return (numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[



def safeHasSquareRoot2(num):

    lowMaybeRoot = 0
    highMaybeRoot = num
    while lowMaybeRoot <= highMaybeRoot:
        midMaybeRoot = (lowMaybeRoot + highMaybeRoot) // 2
        midMaybeRootSquare = midMaybeRoot ** 2
        if midMaybeRootSquare == num:
            return True



def getMinYForD3(d, stopY=None):
    if stopY is None:
        ysToTry = count(1)
    else:
        ysToTry = range(1, stopY)
    dRoot = d ** 0.5
    for y in ysToTry:

        if (ceil(dRoot * y) ** 2) == (d * y ** 2 + 1):
            print(d, ceil(dRoot * y))
            return y



def isMaybeAPerfectSquare2(num):
    return ((num % 10) not in ONES_DIGITS_SQUARES_CANT_HAVE) and (



def isMaybeAPerfectSquare(num):
    numOnesDigit = num % 10
    if numOnesDigit not in ONES_DIGITS_SQUARES_CANT_HAVE:
        numTensDigit = num // 10 % 10
        return numTensDigit in ONES_DIGIT_TO_TENS_DIGITS_SQUARES_CAN_HAVE[



def getHardMinYSquareForD8(d):
    for ySquare in squaresGenerator():
        if isMaybeAPerfectSquare2(d * (ySquare % 100) + 1) and (
                safeHasSquareRoot(d * ySquare + 1)):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare



def getHardMinYSquareForD7(d):

    ySquare = 1
    for diffToNextSquare in count(3, 2):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare



def getHardMinYSquareForD6(d):
    for ySquare in euler66PotentialYSquaresGenerator(d):
        if safeHasSquareRoot6(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare



def getHardMinYSquareForD5(d):

    for ySquare in squaresGenerator():
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare



def getMinYSquareForD2(d, stopYSquare=1000000000000000000000000):
    for ySquare in takewhile(lambda ySquare: ySquare < stopYSquare,
                             squaresGenerator()):
        if safeHasSquareRoot3(d * ySquare + 1):
            print('d: {0}, ySquare: {1}'.format(d, ySquare))
            return ySquare



def getMinYForD(d):
    for y in count(1):
        if safeHasSquareRoot3(d * y ** 2 + 1):
            print(d, y)
            return y



def zeroLeftToDecPoint(num):
    return num - floor(num)



def getHardMinYForD4(d):
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator3(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if ((int(dRootMulPotentY) + 1) ** 2) == (d * potentY ** 2 + 1):
                print(d, potentY)
                print()
                return potentY



def getHardMinYForD3(d):
    '''
    failed at 61 when used 120 bits for precision (succeeded at 53, 46)
    '''
    print('trying {}'.format(d))
    mp.prec = EULER66_NEEDED_PRECISION_IN_BITS

    dRoot = mp.mpf(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator2(dRoot):
        if EULER66_D_ROOT_MUL_Y_MIN_VAL_AFTER_DEC_POINT < zeroLeftToDecPoint(
                dRootMulPotentY):
            print(potentY)
            if mpmath.isint((d * potentY ** 2 + 1).sqrt()):
                print(d, potentY)
                print()
                return potentY



def getHardMinXForD2(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    for potentY, dRootMulPotentY in multiplesGenerator(dRoot):
        '''
        print(dRootMulPotentY, dRootMulPotentY.adjusted() + 1)
        print(dRootMulPotentY, dRootMulPotentY.as_tuple().digits[
            dRootMulPotentY.adjusted() + 1])
        '''
        if EULER66_D_ROOT_MUL_Y_MIN_FIRST_DIGIT_AFTER_DEC_POINT <= (
                dRootMulPotentY.as_tuple().digits[dRootMulPotentY.adjusted() + 1]):
            potentX = (d * potentY ** 2 + 1).sqrt()

            if potentX == floor(potentX):
                print(d, potentX)
                return potentX



def getHardMinXForD(d):
    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    dRoot = decimal.Decimal(d).sqrt()

    print(1 / dRoot)

    potentY = decimal.Decimal(1)
    while True:
        '''
        print((1 / zeroLeftToDecPoint(dRoot * potentY)).to_integral(
            rounding=decimal.ROUND_FLOOR))
        '''
        potentY *= floor(1 / zeroLeftToDecPoint(dRoot * potentY))
        potentX = (potentY ** 2 * d + 1).sqrt()
        if potentX == floor(potentX):
            print(d, potentX)
            return potentX



def getPotentialSolutionsToEuler66(stopD=EULER66_STOP_D):
    dList = [d for d in range(stopD) if not safeHasSquareRoot(d)]
    return filter(lambda d: getMinYSquareForD2(



def getMinXForDByContinuedFract(d):
    dRootContinuedFract = getContinuedFract(
        decimal.Decimal(d).sqrt(),
        EULER66_MAX_FRACT_TO_REFER_TO_AS_ZERO,
        EULER66_MIN_FRACT_TO_REFER_TO_AS_ONE)
    for numOfRepeatsOfPeriodicTerms in count(1):
        potentXDivPotentYAsSimpleFract = getSimpleFractOfContinuedFract(
            dRootContinuedFract.intPart,
            (dRootContinuedFract.periodicTermsList * (
                numOfRepeatsOfPeriodicTerms))[:-1])
        potentX, potentY = (potentXDivPotentYAsSimpleFract.numerator,
                            potentXDivPotentYAsSimpleFract.denominator)
        if 1 == (potentX ** 2 - d * potentY ** 2):
            print('d: {0}, x: {1}, y: {2}'.format(d, potentX, potentY))
            return potentX



def euler66(stopD=EULER66_STOP_D):

    decimal.getcontext().prec = EULER66_NEEDED_PRECISION_IN_DIGITS
    potentDsList = [d for d in range(stopD) if not sqrt(d).is_integer()]

    potentialDToMinYSquareDict = {potentD: getMinXForDByContinuedFract(
        potentD) for potentD in potentDsList}
    return max(potentialDToMinYSquareDict.items(), key=itemgetter(1))



def compute(dm, do):
    """ Computes rms """
    if dm is None and do is None:
        return {



def sqrt(x):
    """ Compute square roots using method of Heron of Alexndria.

    Args:
        x: The number of which the square root is to be computed.

    Returns: The square root fo x.

    Raises:
        ValueError: if x is negative
    """
    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def sqrt(num) -> float:
    """Calculate the square root of the given number"""

    root = num / 2 if num > 0 else 1
    while abs((num / root) - root) > 0.000000001:
        root = average((root, num / root))
    return root



def average(seq):
    """Calculate the average value of a sequence of values"""
    return sum(seq) / len(seq)



def binomialCoeff(elements, combinations):
    """
    Calculate binomial coefficient for the given number of
    elements and combinations
    """
    fact = math.factorial
    return fact(elements) / fact(combinations) * fact(elements - combinations)



def isPrime(num):
    """Check if num is prime"""
    for idx in range(2, int(math.sqrt(num))):
        if not num % idx:
            return False



def sieve_of_atkin(limit):
    primes = []

    sieve = [False] * limit

    square_root_of_limit = int(math.sqrt(limit))

    for x in range(1, square_root_of_limit + 1):
        for y in range(1, square_root_of_limit + 1):
            n = (4 * x * x) + (y * y)

            if n <= limit and (n % 12 == 1 or n % 12 == 5):
                sieve[n] = not sieve[n]

            n = (3 * x * x) + (y * y)

            if n <= limit and n % 12 == 7:
                sieve[n] = not sieve[n]

            n = (3 * x * x) - (y * y)

            if x > y and n <= limit and n % 12 == 11:
                sieve[n] = not sieve[n]

    sieve[2] = True

    sieve[3] = True

    primes.append(2)

    primes.append(3)

    n = 5

    while n <= square_root_of_limit:
        if sieve[n]:
            i = n * n

            while i < limit:
                sieve[i] = False

                i += n * n

            primes.append(n)

        n += 2

    while n < limit:
        if sieve[n]:
            primes.append(n)

        n += 2

    return primes


def sqrt_iter_inner(guess):
    if is_good_enough_inner(guess):
        return guess


def improve_guess_inner(guess, n):
    return average(guess, n / guess)


def is_good_enough_inner(guess):
    return abs(square(guess) - n) < error_tolerance



def newton_sqrt(n):
    ''' Computers Newton's square root approximation of n. '''
    return sqrt_iter(1, n)



def sqrt_iter(guess, n):
    if is_good_enough(guess, n):
        return guess



def improve_guess(guess, n):
    return average(guess, n / guess)



def is_good_enough(guess, n):
    global error_tolerance
    return abs(square(guess) - n) < error_tolerance



def average(x, y):
    return (x + y) / 2.0



def square_root_2(x):
    """
    Status: accepted;

    Newton-Raphson method
    """
    if x == 0:
        return 0



def square_root(x):
    """
    Binary method;
    """
    if x == 0:
        return 0



def square_root(a):
    global epsilon
    print "epsilon", epsilon
    x = a / 2.0
    y = (x + a / x) / 2
    while True:
        if abs(y - x) <= epsilon:
            break
        x = y
        y = (x + a / x) / 2
    return x



def test_root(r, p):
    print "Testing p =", p, "root =", r
    subgroup = [(r ** k) % p for k in xrange(p - 1)]
    if len(set(subgroup)) != p - 1:
        print "Not a primitive root!"
        return



def fibonacci_primitive_root(p):
    """
    Returns a fibonacci primitive root if p has one and None otherwise.
    Assumes p is a prime and that p is congruent to 1 or -1 modulo 5.
    """

    q = square_root(5, p)
    half = (p + 1) / 2

    q1 = half + half * q
    q2 = half - half * q

    q1 %= p
    q2 %= p

    if is_primitive_root(q1, p):
        return q1



def checkPrime(x):
    prime = True

    if x % 2 == 0:
        return False



def squareRoot(x):
    root = int(floor(sqrt(x)))

    if root % 2 == 0:
        root += 1
    return root



def evt(evt_type, data=None, request=None):
    if not LOG_METRICS:
        return



def divisor_count(n):
    """Count number of divisors. Used on problem 12, 179.
    """
    divcount = 0
    tmax = n ** 0.5
    for t in xrange(1, int(tmax + 1)):
        if n % t == 0:
            divcount += 2
    if t == tmax:
        divcount -= 1
    return divcount



def main(argv):
    if len(argv) < 2:
        sys.stderr.write("Usage: %s <number>" % (argv[0],))
        return 1



def estimate_square_root_simple(number, accuracy):
    """
    Bare-bones square root estimator

    Set guaranteed lower and upper bounds on the solution and binary search until
    we find something close enough
    """

    sqrt = None

    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')

    else:
        lower_bound = 0
        upper_bound = max(number, 1.0)

        while upper_bound - lower_bound > accuracy:
            midpoint = (upper_bound + lower_bound) / 2.0

            if midpoint * midpoint < number:
                lower_bound = midpoint
            else:
                upper_bound = midpoint

            sqrt = lower_bound

    return sqrt



def estimate_square_root_fancy(number, accuracy):
    sqrt = None

    if float_equals(number, 0.0):
        sqrt = 0.0
    elif number < 0.0:
        raise Exception('Cannot calculate square root on a negative number')
    elif float_equals(number, 1.0):
        sqrt = 1.0

    else:
        if number < 1.0:
            lower_bound = 0.0
            upper_bound = 1.0
        else:
            lower_bound, upper_bound = find_square_root_bounds(number)

        if float_equals(lower_bound * lower_bound, number):
            sqrt = lower_bound
        elif float_equals(upper_bound * upper_bound, number):
            sqrt = upper_bound
        else:

            while upper_bound - lower_bound > accuracy:
                midpoint = (upper_bound + lower_bound) / 2.0

                if float_equals(midpoint * midpoint, number):
                    lower_bound = midpoint
                    upper_bound = midpoint
                    break
                elif midpoint * midpoint < number:
                    lower_bound = midpoint
                else:
                    upper_bound = midpoint

            sqrt = lower_bound

    return sqrt







def bisection(l, a, k):
    if l[math.floor(len(l) / 2):][0] < a:
        print(k)
        k = k + math.floor(len(l) / 2)
        print(k)
        bisection(l[math.floor(len(l) / 2):], a, k)
    elif l[math.floor(len(l) / 2):][0] == a:
        return k + 1



def estimate_pi():
    k = 0
    s = 0
    a = 2 * math.sqrt(2) * 1103 / 9801
    while a > 1e-15:
        s += a
        k += 1
        a = (2 * math.sqrt(2) * math.factorial(4 * k) * (1103 + 26390 * k)
             ) / (9801 * (math.factorial(k) ** 4) * (396 ** (4 * k)))
    return 1 / s



def square_root(a):
    x = a + 0.01
    while True:
        epsilon = 0.000000000001
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            return y




def find_move(self):
    (c, v) = self.find_only_available_move()
    if c is not None:
        return (c, v)


def find_forced_move(self):
    for group in self.all_groups:
        (c, v) = group.find_forced_move()
        if not c is None:
            return (c, v)


def all_groups(self):
    return self.__rows + self.__cols + self.__squares


def finished(self):
    return 0 == self.__empty_cells


def squares(self):
    return self.__squares


def cols(self):
    return self.__cols


def rows(self):
    return self.__rows


def square(self, squareIndex):
    return self.__squares[squareIndex - 1]


def col(self, colIndex):
    return self.__cols[colIndex - 1]


def row(self, rowIndex):
    return self.__rows[rowIndex - 1]


def __makeCellGroups(self):
    cgs = []
    for i in range(self.dimensions.size):
        cgs.append(CellGroup(self.dimensions))
    return cgs


def num_cells(self):
    return self.dimensions.size ** 2


def size(self):
    return self.dimensions.size


def allowed_moves(self):
    return self._allowed_moves


def find_exclusive_move(self):
    """
    ???
    """
    return (None, None)


def find_forced_move(self):
    """
    Only one cell of the group can have one of the available moves for the group
    """
    for value in self.allowed_moves():
        cell = None
        for c in self.cells:
            if not c.value and c.is_allowed_move(value):
                if cell is None:
                    cell = c
                else:
                    cell = None
                    break
        if not cell is None:
            return (cell, value)


def find_only_available_move(self):
    """
    Here we have 8 full cells - the nineth one gets a compulsory move
    Convert in CellSolver(group) class?
    """
    for c in self.cells:
        if not c.value:
            if len(c.allowed_moves()) == 1:
                return (c, list(c.allowed_moves())[0])


def dimensions(self):
    return self.__dimensions


def cells(self):
    return self.__cells


def cell(self, index):
    return self.__cells[index - 1]


def num_cells(self):
    return self.__dimensions.size


def is_allowed_move(self, value):
    return value in self.allowed_moves()


def is_empty(self):
    return 0 == self.__value


def move(self, value):
    intvalue = self.dimensions.get_int_in_range(value)
    if self.__value and intvalue:
        raise DeniedMoveException('The cell has already a value')

    if self.__value == intvalue:
        return


def value(self):
    return self.__value


def get_int_in_range(self, value):
    try:
        intvalue = int(value)
        if intvalue < 0 or intvalue > self.__size:
            raise OutOfRangeException(intvalue)
        return intvalue


def all_moves(self):
    return set(range(1, self.__size + 1))


def size(self):
    """
    The board size is the root value squared: 9 for a typical sudoku board
    """
    return self.__size


def root(self):
    """
    For a typical sudoku board, root = 3
    """
    return self.__root


def __str__(self):
    return repr(self.value)



def cosine_similarity(x, y):
    numerator = sum(a * b for a, b in zip(x, y))
    denominator = square_rooted(x) * square_rooted(y)
    return round(numerator / float(denominator), 3)



def square_rooted(x):
    return round(sqrt(sum([a * a for a in x])), 3)



def minkowski_distance(x, y, p_value):
    return nth_root(sum(pow(abs(a - b), p_value)
                        for a, b in zip(x, y)), p_value)



def nth_root(value, n_root):
    root_value = 1 / float(n_root)
    return round(Decimal(value) ** Decimal(root_value), 3)



def manathan_distance(a, b):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return sum(abs(x - y) for x, y in zip(a, b))



def euclidian_distance(a, b):
    ''' a and b are vector '''
    if len(a) != len(b):
        raise ValueError("a and b has not the same size ")

    return sqrt(sum(pow(x - y, 2) for x, y in zip(a, b)))



def sqroot(x):
    """
    Finds the square root of the number passed in
    """
    return math.sqrt(x)


def df(x):
    return n * power(x, n - 1)


def f(x):
    return power(x, n) - a



def power(x, n):
    """Return x * x * x * ... * x for x repeated n times."""
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product



def cube_root_newton(a):
    """Return the cube root of a.

    >>> cube_root_newton(27)
    3.0
    """
    return find_zero(lambda x: x * x * x - a, lambda x: 3 * x * x)


def df(x):
    return 2 * x


def f(x):
    return x * x - a


def update(x):
    return x - f(x) / df(x)


def near_zero(x):
    return approx_eq(f(x), 0)


def close(x):
    return approx_eq(pow(x, 3), a)


def update(x):
    return cube_root_update(x, a)



def cube_root_improve(a):
    """Return the cube root of a.

    >>> cube_root_improve(27)
    3.0
    """
    return improve(lambda x: cube_root_update(x, a),


def close(x):
    return approx_eq(x * x, a)


def update(x):
    return square_root_update(x, a)



def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance



def improve(update, close, guess=1, max_updates=100):
    """Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied."""
    k = 0
    while not close(guess) and k < max_updates:
        guess = update(guess)
        k = k + 1
    return guess



def improve(update, close, guess=1):
    """Iteratively improve guess with update until close(guess) is true."""
    while not close(guess):
        guess = update(guess)
    return guess



def cube_root_update(x, a):
    return (2 * x + a / (x * x)) / 3



def cube_root(a):
    """Return the cube root of a.

    >>> cube_root(27)
    3.0
    """
    x = 1
    while pow(x, 3) != a:
        x = cube_root_update(x, a)
    return x



def square_root_update(x, a):
    return (x + a / x) / 2



def square_root(a):
    """Return the square root of a.

    >>> square_root(9)
    3.0
    """
    x = 1
    while x * x != a:
        x = square_root_update(x, a)
    return x





def chunker(lst, length):
    return (lst[pos:pos + length] for pos in xrange(0, len(lst)))



def factorize(n):
    factors = []

    for x in range(2, int(math.sqrt(n)) + 1):
        if n % x == 0:
            factors.append(x)
            factors.append(n / x)

    return factors



def is_prime(n):
    if n < 2:
        return False



def squareRootConvergents():
    count = 1
    numberCount = 0
    x = 2 + fractions.Fraction(1, 2)
    while count < 999:
        y = 1 + 1 / x
        if len(str(y).split('/')[0]) > len(str(y).split('/')[1]):
            numberCount += 1
        x = 2 + 1 / x
        count += 1
    return numberCount



def sq_rt(num):
    """Approximates square root of parameter to 2 decimal places"""
    neg = ""
    if num < 0:
        num = abs(num)
        neg = 'i'
    guess_1 = 1
    guess_2 = 0
    count = 0
    while round(guess_1, 2) != round(guess_2, 2):
        count += 1
        guess_2 = guess_1
        guess_1 = (guess_1 + num / guess_1) / 2
        print(
            "This loop has iterated",
            count,
            "times and the current guess is",
            str(guess_1) + ".")
    return (str(round(guess_1, 2)) + neg)



def squareRoot(x, maxPrecision, root):
    precision = maxPrecision
    low = 0.0
    high = x
    guess = (low + high) / 2
    while (precision > 0):
        if guess ** root > x:
            high = guess
        else:
            low = guess
        guess = (low + high) / 2
        precision -= 1
    return guess



def sqrt(x):
    while True:
        print x
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return y



def square_root(x):
    return np.sqrt(x)



def power(x):
    return x ** 2



def find_sqrt_bin_search(n, error=0.001):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid



def sqrt(x, error):
    """Returns an approximation to the square root.
        Using Heron of Alexandria's algorithm."""
    guess = 1
    while my_abs(square(guess) - x) > error:
        guess = average(guess, x / guess)
    return guess



def my_abs(x):
    """Returns the absolute value of x."""
    if x < 0:
        return -x



def average(x, y):
    """Returns the average of two numbers."""
    return (x + y) / 2



def square(x):
    """Returns the square of a number."""
    return x * x



def sqrt(a):
    if a == 0:
        return a



def sqrt(x):
    """Return the square root of `x`.

    Examples
    --------
    >>> sqrt(4.0)
    2.0
    """
    return x * 0.5



def square(x):
    """Return the square of `x`.

    Parameters
    ----------
    x : int or float
        The input number.

    Returns
    -------
    x2 : same type as `x`
        The square of the input value.

    Examples
    --------
    >>> square(5)
    25
    """
    return x ** 2



def sqrt2(a, b):
    if abs(a - b * b) > .000000000000001:
        return sqrt2(a, (a / b + b) / 2)



def sqrt(n):
    if n > 0:
        return sqrt2(n, 1)



def fib2(a, b, c):
    if a != 1:
        return fib2(a - 1, c, b + c)



def fib(n):
    if n >= 0:
        return fib2(n, 0, 1)



def fact2(a, b):
    if a != 1:
        return fact2(a - 1, b * a)



def fact(n):
    if n >= 0:
        return fact2(n, 1)



def isPrime(candidate):
    """
    Determines if candidate is prime or not.
    """
    if ((candidate % 2) == 0):
        if (candidate == 2):
            return True



def found(n):
    n_string = str(n)
    for i in range(9):
        if int(n_string[i * 2]) != (i + 1):
            return False



def estimate_pi():
    tot = 0
    k = 0
    factor = (2 * math.sqrt(2)) / 9801

    while True:
        num = factorial(4 * k) * (1103 + (26390 * k))
        den = (factorial(k) ** 4) * (396 ** (4 * k))
        term = factor * (num / den)
        tot += term

        if abs(term) < 1e-15:
            break

        k += 1

    return 1 / tot



def factorial(n):
    if n < 0:
        return None



def square_root(a):
    x = a / 2.0
    y = x
    while True:

        y = (x + a / x) / 2.0

        if abs(y - x) < sys.float_info.epsilon:
            break

        x = y

    return x



def sqrt(w, eps=1.e-14, maxIter=100):
    x = 1.
    for i in range(maxIter):
        x_old = x
        x = (x + w / x) / 2
        if abs(x - x_old) / w < eps:
            return x



def RMSE(estimation, truth):
    """Root Mean Square Error"""

    num_sample = len(estimation)

    sse = np.sum(np.square(truth - estimation))
    return np.sqrt(np.divide(sse, num_sample - 1.0))



def newton_raphson_sqrt(number):
    epsilon = 0.01
    y = number
    guess = y / 2.0

    while abs(guess * guess - y) >= epsilon:
        guess = guess - (((guess ** 2) - y) / (2 * guess))

    return guess



def is_perfect_square(is_square):
    root = math.sqrt(int(is_square))
    return int(root) ** 2 == int(is_square)



def is_palindrome(num):
    dummy = int(num)
    rev = 0
    while(dummy != 0):
        r = dummy % 10
        rev = rev * 10 + r
        dummy = int(dummy / 10)
    if(num == rev):
        return 0



def is_prime(num):
    root = int(float(square_root(num)))
    for i in range(2, root + 1):
        if(num % i == 0):
            return 1



def square_root(num):
    initial_guess = 1
    while True:
        f_x = float(initial_guess * initial_guess - num)
        der_f_x = float(2 * initial_guess)
        new_guess = initial_guess - (f_x / der_f_x) * 1.0
        if(abs(initial_guess - new_guess) < 0.001 or abs(initial_guess - new_guess) == 0):
            break
        initial_guess = new_guess
    return "%.4f" % new_guess



def count_digits_in_sqrt(num):
    return sum(map(int, str(isqrt(num * 10 ** (2 * (prec - 1))))))



def isqrt(n):
    x = n
    y = (x + n // x) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x



def generate_nth_prime(n):
    prime_count = 0
    current_number = 1

    while prime_count < n:
        current_number += 1

        if is_prime(current_number):
            prime_count += 1

    return current_number



def is_prime(n):
    square_root_of_potential_prime = sqrt(n)

    for i in range(2, int(square_root_of_potential_prime) + 1):
        if n % i == 0:
            return False


def inner(*a, **kw):
    print '> calling', f.func_name, 'with ', a, kw
    r = f(*a, **kw)
    print '> returning', f.func_name, r


def fg(*a, **kw):
    return f(g(*a, **kw))



def zipWith(f, a, b):
    return map(f, zip(a, b))



def factors(n, first):
    global _fprimes
    if _fprimes[-1] < n:
        _fprimes = list(get_primes(n * 2))

    factors = []
    for p in _fprimes:
        while n % p == 0:
            factors.append(p)
            n /= p
        if n == 1:
            break
    return factors



def is_square(n):
    sq = int(math.sqrt(n))
    return sq * sq == n


def reverse(seq, start, end):

    end -= 1
    if end <= start:
        return



def lcd(a, b):
    return a * b / gcd(a, b)



def gcd(a, b):
    if a > b:
        a, b = b, a
    while b != 0:
        a, b = b, a % b
    return a



def is_prime(x):
    if len(_primes) == 0:
        _primes.update(get_primes(_prime_limit))
    if x in _primes:
        return True



def word_score(word):
    return sum((ord(x) - ord('A') + 1) for x in word)



def divisors(p):
    div = set()
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root + 1):
        if p % x == 0:
            div.add(p / x)
            div.add(x)
    if p > 1:
        div.remove(p)
    return div



def num_divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num



def triangular(p):
    return (p * (p + 1)) / 2


from functools import reduce


def choose(n, k):
    return reduce(operator.mul, range(n - k + 1, n + 1), 1) / factorial(k)


from functools import reduce


def factorial(n):
    return reduce(operator.mul, range(2, n + 1), 1)


def __call__(self, *args):
    if not args in self.memo:
        self.memo[args] = self.f(*args)
    return self.memo[args]



def babylonian(a):
    r = a
    while (p > q):
        p = (p + q) / 2.0
        q = r / p
    return p


def learning_rate(self):
    return self.init_lr * power(self._acc_grad_var, self.exponent)



def newsqrt(a):
    x = a / 2
    e = 0.0005
    while True:
        y = (x + a / x) / 2
        if x == y and abs(y - x) < e:
            return y



def wiener_attack(N, e):
    (p, q, d) = (0, 0, 0)
    conv = convergents(partial_quotiens(e, N))
    for frac in conv:
        (k, d) = frac
        if k == 0:
            continue
        y = -(N - phiN(e, d, k) + 1)
        discr = y * y - 4 * N
        if(discr >= 0):

            sqr_discr = is_perfect_square(discr)

            if sqr_discr != -1 and (-y + sqr_discr) % 2 == 0:
                p = ((-y + sqr_discr) / 2)
                q = ((-y - sqr_discr) / 2)
                return p, q, d



def phiN(e, d, k):
    return ((e * d) - 1) / k



def convergents(sequence):
    c = []
    for i in range(1, len(sequence)):
        c.append(indexed_convergent(sequence[0:i]))

    return c



def indexed_convergent(sequence):
    i = len(sequence) - 1
    num = sequence[i]
    denom = 1
    while i > 0:
        i -= 1
        a = (sequence[i] * num) + denom
        b = num
        num = a
        denom = b

    return (num, denom)



def partial_quotiens(x, y):
    partials = []
    while x != 1:
        partials.append(x // y)
        a = y
        b = x % y
        x = a
        y = b

    return partials



def is_perfect_square(n):
    h = n & 0xF
    if h > 9:
        return -1



def isqrt(n):
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    if n == 0:
        return 0



def bitlength(x):
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n



def get_square_size(square):

    depth = get_square_depth(square, 1)
    return 2 ** depth



def get_square_depth(square, level):
    max_level = level

    for elem in square:
        if isinstance(elem, list):
            max_level = max(max_level, get_square_depth(elem, level + 1))

    return max_level



def compress_square(square):
    result = []

    for elem in square:
        if isinstance(elem, list):
            if elem == ['w', 'w', 'w', 'w']:
                result.append('w')
            elif elem == ['b', 'b', 'b', 'b']:
                result.append('b')
            else:
                result.append(compress_square(elem))
        else:
            result.append(elem)

    return result



def add_squares(sq1, sq2):
    result = []
    for i in range(4):
        if not isinstance(sq1[i], list) and not isinstance(sq2[i], list):
            if sq1[i] == 'b' or sq2[i] == 'b':
                result.append('b')
            else:
                result.append('w')
        else:
            if not isinstance(sq1[i], list):
                c = sq1[i]
                sq1[i] = [c, c, c, c]

            if not isinstance(sq2[i], list):
                c = sq2[i]
                sq2[i] = [c, c, c, c]

            r = add_squares(sq1[i], sq2[i])
            if r == ['w', 'w', 'w', 'w']:
                r = 'w'
            elif r == ['b', 'b', 'b', 'b']:
                r = 'b'

            result.append(r)

    return result


def square_to_text_inner(square):
    s = ''
    for elem in square:
        if isinstance(elem, list):
            s += 'p'
        else:
            s += elem

    for elem in square:
        if isinstance(elem, list):
            s += square_to_text_inner(elem)

    return s



def parse_square(text):
    if text[0] == 'w' or text[0] == 'b':
        return [text[0], text[0], text[0], text[0]]



def square_root(x):
    count = 0
    ballpark_num = 1
    while round(ballpark_num ** 2 - user_input, 2) != 0:
        new_number = 0.5 * (ballpark_num + (x / ballpark_num))
        ballpark_num = new_number
        count += 1
        print("Count is {} number is {}".format(count, ballpark_num))
    return new_number



def root(a):
    return a ** .5



def square(a):
    return a * a



def sub(a, b):
    return a - b



def add(a, b):
    return a + b



def PIECE___root_mean_square_error():
    """PIECE___root_mean_square_error:

    ROOT_MEAN_SQUARE_ERROR = sum of squared differences between items in PREDICTED_OUTPUTS multi-dimensional
    array and TARGET_OUTPUTS multi-dimensional array, divided by the number of cases, then square-rooted
    """

    forwards = {'root_mean_square_error':
                [lambda a0, a1: sqrt(((a1 - a0) ** 2).sum() / a0.shape[0]),
                 {'a0': 'target_outputs',
                  'a1': 'predicted_outputs'}]}

    backwards = {('DOVERD', 'root_mean_square_error', 'predicted_outputs'):
                 [lambda a0, a1, rmse: ((a1 - a0) / a0.shape[0]) / rmse,
                  {'a0': 'target_outputs',
                   'a1': 'predicted_outputs',
                   'rmse': 'root_mean_square_error'}]}

    return Piece(forwards, backwards)



def squareroot(n):
    x = n
    e = 0.0000001
    y = 1
    while (x - y > e):
        x = (x + y) / 2
        y = n / x
    return x



def square_root(a):
    x = a / 2.0
    epsilon = 0.001
    while True:

        y = (x + a / x) / 2.0
        if approx_equal(y, x, epsilon):
            break
        x = y
    return x



def approx_equal(a, b, limit):
    if abs(a - b) < limit:
        return True



def inverse(f, g, x):
    return (f(g(x)) == x)



def square(x):
    return x * x



def sq_rt2(x):
    tmp = 1
    while x / tmp != tmp:
        tmp = tmp + 1
    return tmp



def sq_rt(x):
    tmp = 1
    while tmp < x / 2:
        if tmp * tmp == x:
            return tmp



def log_2(x):
    if x == 1:
        return 0



def exp_2(x):
    if x == 0:
        return 1



def square_root(x, eps=10e-7):

    assert x >= 0
    y = math.sqrt(x)

    assert abs((y * y) - x) < eps
    return y



def sqroot(x):
    if x <= 0:
        print "Positive number only."
        return



def square(base, root):
    number = base
    for x in range(1, root):
        number = number + base
    return number


def root_two(self):

    x = (-(self.fun[1]) - np.sqrt(self.part_one)) / (2 * self.fun[0])

    return np.array([x, self.value_y(x)])


def root_one(self):

    x = (-(self.fun[1]) + np.sqrt(self.part_one)) / (2 * self.fun[0])

    return np.array([x, self.value_y(x)])


def single_root(self):

    x = -(self.fun[2]) / self.fun[1]

    return np.array([x, self.value_y(x)])


def value_y(self, x):

    y = self.fun_1[0] * np.square(x) + self.fun_1[1] * x + self.fun_1[2]

    return y



def sqrt(x):
    '''
    Compute square roots using the method of Heron of Alexandria.
    :param x: The number for which the square root is to be computed.
    :return: The square root of x.
    '''

    if x < 0:
        raise ValueError("Cannot compute square root "
                         "of negative number {}".format(x))
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def sqrt(x):
    l = 0
    h = x
    while l <= h:
        m = l + h / 2
        if m * m == x:
            return m



def sqrt1(x):
    i = 0
    while i * i != x:
        i = i + 1
    return i





def to_list(num):
    result = []
    val = num
    while(val > 0):
        result = [val % 10] + result
        val = val / 10
    return result



def to_num(list):
    sum = 0
    for i in list:
        sum = sum * 10
        sum += i
    return sum



def is_square(n):
    root = float(n) ** .5
    root = int(root + .5)
    if root * root == n:
        return root



def equal_lists(list_a, list_b):
    if(len(list_a) != len(list_b)):
        return False



def negate(n):
    """ Return negative n
    """
    return -n



def cube(n):
    """
    Returns the cube of the number n
    """
    return n ** 3



def approximate_log2(n):
    return (n ** n - 1.0) / n



def approximate_log(n):
    if n < 1.1:
        return n - 1



def my_sqrt(x):
    r = square_root(1, x)
    return r



def square_root(guess, x):
    while(not good_enough(guess, x)):
        guess = improve(guess, x)
    return guess



def good_enough(guess, x):
    d = abs(guess * guess - x)
    return (d < 0.001)



def improve(guess, x):
    return average(guess, x / guess)



def average(a, b):
    return (a + b) / 2.0


def compute(self, actual, predicted):
    N, D = actual.shape
    error = 0
    for d in range(D):
        error += (np.sum((actual[:N, d] -
                          predicted[:N, d]) ** 2) / float(N)) ** 0.5
    error = error / float(D)
    return error



def math_squrt(a, x):
    m = math.sqrt(a)
    return m



def square_root(a, x):
    y = (x + a / x) / 2
    return y



def square_root(a):
    x = 10
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < 0.000001:
            break
        x = y
    return x



def sqrt(x):
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return y



def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def l2_norm_sqr(w):
    """
    Returns square of L2 norm of the given matrix (w).
    square of L2 norm of a matrix is simply the sum of square of elements of the matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return (w ** 2).sum()



def l2_norm(w):
    """
    Returns L2 norm of the given matrix (w).
    L2 norm of a matrix is simply square root of the sum of square of elements of the matrix.
    In an other word, it's length for a matrix.

    @input: w, a theano shared variable.
    @output: L2 norm of w
    """

    return T.sqrt((w ** 2).sum())



def l1_norm(w):
    """
    Returns L1 norm of the given matrix (w).
    L1 norm is simply sum of a matrix elements.

    @input: w, a theano shared variable.
    @output: L1 norm of w
    """

    return abs(w).sum()



def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True



def abbreviated(s):
    '''(GameState) -> str

    Return an abbreviated str representation of SubtractSquareState s.
    '''

    return "{}:{}".format(s.next_player, s.current_total)


def __eq__(self, other):
    ''' (GameStateNode, object) -> bool

    Return whether this GameStateNode is equivalent to other, i.e., they
    contain equivalent GameStates, and equivalent children.  The order of
    their children does not matter.

    >>> s1 = SubtractSquareState('p1', current_total = 6)
    >>> s2 = SubtractSquareState('p2', current_total = 5)
    >>> s3 = SubtractSquareState('p1', current_total = 2)
    >>> leaf1 = GameStateNode(s1)
    >>> leaf2 = GameStateNode(s2)
    >>> leaf3 = GameStateNode(s3)
    >>> leaf1.__eq__(leaf2)
    False
    >>> root1 = GameStateNode(s1)
    >>> root1.children = [s2, s3]
    >>> root2 = GameStateNode(s1)
    >>> root1.__eq__(root2)
    False
    >>> root2.children = [s2, s3]
    >>> root1.__eq__(root2)
    True
    '''

    return (type(self) == type(other) and



def isPerfectSquare(N):
    squareRoot = floor(sqrt(N))
    if squareRoot * squareRoot == N:
        return True



def computeSumSquareDivisor():

    sieve = [1] * LIMIT

    sieve[0] = 0

    for x in range(2, LIMIT):
        currentNum = x
        square = x * x

        while currentNum < LIMIT:
            sieve[currentNum] += square
            currentNum += x

    return sieve



def findSumSpecialNum():
    mySum = 0

    sieve = computeSumSquareDivisor()
    print('Hi')
    for x in range(1, LIMIT):
        if isPerfectSquare(sieve[x]):
            mySum += x

    return mySum



def new_g(g, s):
    g = ((g + (s / g)) / 2)
    return g



def sqrt(x):
    '''compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''
    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def sqrt(n):
    n = n ** .5
    return(n)



def printResults(number, diff, calc, actDiff, tries):
    print("For the square root of", number, "after", tries, "tries")
    print("The calculated square root is {:0.11f}".format(calc))
    print("The real square root is       {:0.11f}".format(math.sqrt(number)))
    print("The difference is             {:0.11f}".format(actDiff))
    print("The delta was                 {:0.11f}".format(diff))
    print()


if(__name__ == '__main__'): main()


"""Created on Mon Sep 21 10:08:02 2015
@author: CharlotteVDD
define a function sqrt(num), where num is a number and sqrt a funtion
that returns the square root of num.



def calcSqrt(number, diff):
    newguess = number / 2.0
    tries = 0
    oldguess = 1
    calc = 0
    while abs((newguess - oldguess)) > diff:
        oldguess = newguess
        newguess = (oldguess + number / oldguess) / 2.0
        tries = tries + 1
        calc = newguess
    actDiff = abs((math.sqrt(number) - calc))
    return calc, actDiff, tries



def getInputs():
    number = eval(input("Enter the number to find its square root: "))
    print()

    string = "Enter the difference between the calculate and real square root: "
    diff = eval(input(string))
    print()
    return number, diff


def local_improve(x, g):
    return local_average(g, (x / g))


def local_good_enough(x, g, t=0.0001):
    return abs(square(g) - x) < t


def local_average(x, y):
    return (x + y) / 2



def sqrt_iter(x, guess=1.0):
    return guess if is_sqrt_good_enough(
        x, guess) else sqrt_iter(x, sqrt_improve(x, guess))



def sqrt_improve(x, guess):
    return average(guess, (x / guess))



def is_sqrt_good_enough(x, guess, tolerance=0.0001):
    return abs(square(guess) - x) < tolerance



def cube(x):
    return x * x * x



def square_root(a, x):
    a = float(a)
    next_x = float(x + (a / x)) / 2
    global number_of_iterations
    number_of_iterations += 1

    if abs(next_x - sqrt(a)) < error:
        print "Number of iterations: %s" % number_of_iterations
        return float(next_x)



def solver():
    """ Find the unique positive integer whose square has the form
    1_2_3_4_5_6_7_8_9_0 where _ is a single digit

    We can find the maximum and minimum boundary of square roots
    that satisfy 1020304050607080900 < n ** 2 < 1929394959697989990

    Note that a square ending in "0" has to end in at least "00",
    therefore we can simplify the problem to fnding the bounds of
    10203040506070809 < n ** 2 < 19293949596979899 and then multiplying
    the square root by 10

    (solved 2014-11-29)
    """
    min_bound = int(10203040506070809 ** 0.5)
    max_bound = int(19293949596979899 ** 0.5) + 1

    for number in xrange(min_bound, max_bound):
        if str(number ** 2)[::2] == "123456789":
            return number * 10



def power(number=1, power=1):
    '''Return the number raised to the power.'''
    return number ** power



def cube(number=1):
    '''Return the cube of the number.'''
    return number * number * number



def root(number=1):
    '''Return the square root of the number.'''
    return number ** 0.5



def square(number=1):
    '''Return the square of the number.'''
    return number * number



def draw_square(canvas, color, size, position):
    """

    :param canvas:
    :param color:
    :param size:
    :param position:
    :return handle:

    Takes a Tkinter canvas, a color string, an integer size, and a tuple of
    x,y coordinates for the center of the rectangle.

    Returns the handle from the created rectangle.
    """
    upper_x = position[0] - size / 2
    upper_y = position[1] - size / 2

    lower_x = position[0] + size / 2
    lower_y = position[1] + size / 2

    return canvas.create_rectangle(upper_x,


def df(x):
    return 2 * x


def f(x):
    return x * x - a



def find_root(a, eps):
    appx = a / 2.0
    while True:
        root = (appx + a / appx) / 2

        if abs(appx - root) < eps:
            break
        appx = root
    return root



def main() -> int:
    n = int(input())
    results = [''] * n

    for i in range(n):
        (number, steps) = map(int, input().split())
        results[i] = str(square_root(number, steps))

    print(' '.join(results))
    return 0



def square_root(number: int, n_step: int) -> float:
    r = 1

    for _ in range(n_step):
        d = number / r
        r = (r + d) / 2

    return r



def square_root(a):
    x = a / 2.0
    epsilon = 0.001
    while True:
        print x
        y = (x + a / x) / 2
        if approx_equal(y, x, epsilon):
            break
        x = y
    return x


def approx_equal(a, b, limit):
    if abs(a - b) < limit:
        return True



def eng_rms(rms_ac, rms_dc):
    """
    The root mean square of a non sine wave.
    y = |2 a ft - a|
    :param rms_ac: ac rms
    :param rms_dc: dc rms
    :return: float
    """
    return math.sqrt(math.pow(rms_dc, 2) + math.pow(rms_ac, 2))



def triangle_rms(a):
    """
    The root mean square of a triangle wave.
    y = |2 a ft - a|
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(3)



def square_rms(a):
    """
    The root mean square of a square wave.
    y = a if ft < 0.5 V -a if ft > 0.5
    :param a: amplitude (peak value)
    :return: float
    """
    return a



def sin_rms(a):
    """
    The root mean square of a sine wave.
    y = a sin(2 pi f t)
    :param a: amplitude (peak value)
    :return: float
    """
    return a / math.sqrt(2)


def sqrt(self, x):
    y0, y1 = 0, 1
    while int(y0) != int(y1):
        y0 = y1
        y1 = 1.0 / 2.0 * (y0 + x / y0)
    return int(y0)



def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps
    return y



def pandigital_square_pair(w1, w2):
    if len(w1) != len(w2):
        return False



def apply_mapping(mapping, w):
    used = set()

    n = 0
    for c in w:
        if c not in mapping:
            return ValueError(
                'Mapping does not contain a character in the word')



def get_pandigital_mapping(w, n):
    str_n = str(n)

    if len(str_n) != len(w):
        return None



def is_square(n):
    root = int(n ** 0.5)
    return n == root * root



def isSquare(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True



def babylon(num):
    n = num
    r = 1
    accuracy = 0.000001
    while (n - r) > accuracy:
        n = (n + r) / 2
        r = num / n
    return n



def solve(lower_limit, upper_limit):
    num_root = int(math.ceil(math.sqrt(lower_limit)))
    count = 0
    while num_root <= int(math.sqrt(upper_limit)):
        num = num_root ** 2
        if num in memo:
            count += memo[num]
        else:
            memo[num] = isFairAndSquare(num)
            count += memo[num]

        num_root += 1
    return count



def isFair(num):
    if num in memo_ana:
        return memo_ana[num]



def isFairAndSquare(num):
    square = math.sqrt(num)
    if square == int(square) and isFair(num) and isFair(int(square)):
        return 1



def api_square_shell():
    outstr = subprocess.check_output(['bash', './compute_square.sh', '5'])
    return json.loads(outstr)



def api_square():
    global ncalls
    ncalls += 1
    n = request.json['data']
    return {'number': n * n,
            'comments': 'Using python. Called {} times'.format(ncalls)}



def index():
    return static_file('index.html', root='./static')



def server_static(filename):
    return static_file(filename, root='./static')



def estimate_pi():
    total = 0
    k = 0
    left_side = 2 * math.sqrt(2) / 9801
    while True:
        num = factorial(4 * k) * (1103 + 26390 * k)
        den = factorial(k) ** 4 * 396 ** (4 * k)
        term = left_side * num / den
        total += term
        if abs(term) < 1e-16:
            break
        k += 1
    return 1 / total



def factorial(n):
    if n == 0:
        return 1



def eval_loop():
    x = ""
    result = 0
    while True:
        x = input("Give me math > ")
        if x == 'done':
            break
        result = eval(x)
        print(result)
    return result



def square_root(a):
    x = a / 2
    epsilon = 0.0000000001
    while True:
        y = (x + a / x) / 2
        if abs(x - y) < epsilon:
            return y



def square_root(a):
    if(a == 0 or a == 1):
        return a



def square_root(x, eps=10e-7):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(y * y - x) < eps
    return y



def horo(channel, user, args):
    """Calculate square root. Usage: sqrt <number>"""

    result = sqrt(int(args[0]))

    return u'PRIVMSG {channel} :{result}'.format(user=user, result=result)


def compute_list(errors):
    """
    Calculates the mean average error for the predicted rating

    :param errors: a list
    :return: the mean average error after predicting all the overall ratings
    """
    num_ratings = 0.
    total_error = 0.

    for error in errors:
        if error is not None:
            total_error += error ** 2
            num_ratings += 1

    if num_ratings == 0:
        return None


def compute(self):
    return RootMeanSquareError.compute_list(self.errors)



def askForNumber():
    return int(raw_input("Enter square of x: "))



def digsum(a):
    sum = 0
    if round(sqrt(a)) ** 2 == a:
        return 0



def solve():
    return sum(list(map(digsum, range(2, 100))))


def simplifie(self):
    """
    Additionne les nombres rationnels et dcompose les racines carres.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([[3, 9]]).simplifie()
    '3*3'
    >>> SquareRoot(-2, [-2, 1], [3, 1], [-1, 7], 8).simplifie()
    SquareRoot([[6, None], [1, 1], [-1, 7]])
    >>> SquareRoot(-2, [-2, 1], [3, 45], [-1, 7], 8).simplifie()
    SquareRoot([[6, None], [-2, 1], [3, 45], [-1, 7]])
    >>> SquareRoot([-2,1],[3,45]).simplifie()
    '-2+SquareRoot([[3, 9]])*SquareRoot([[1, 5]])'

    :rtype: SquareRoot ou String
    """
    decomposable = self.EstDecomposable()
    reductible = self.EstReductible()
    if not decomposable and not reductible:
        return self


def Decompose(self):
    """
    Dcompose une unique racine carre de la forme a*sqrt(b^2*c) en a*sqrt(b^2)*sqrt(c)

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8]).Decompose()
    'SquareRoot([[5, 4]])*SquareRoot([[1, 2]])'

    :rtype: string
    """
    racine = self.racines[0]
    if racine[1] is None:
        return repr(racine[0])


def EstReductible(self):
    """
    Renvoie True si la somme de racines est rductible

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8], [1, 45]).EstReductible()
    False
    >>> SquareRoot([5, 8], [1, 8]).EstReductible()
    True

    :rtype: Boolean
    """
    lradicandes = []
    rationnel = False
    for e in self.racines:
        if e[1] is not None:
            if e[1] in lradicandes:
                return True


def EstDecomposable(self):
    """
    Renvoie True si une des racines est de la forme sqrt{a**2*b} avec a != 1

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([5, 8], [1, 7]).EstDecomposable()
    True
    >>> SquareRoot([5, 7], [1, 7]).EstDecomposable()
    False

    :rtype: Boolean
    """
    for e in self.racines:
        if e[1] is not None and (carrerise(e[1]) != e[1] or e[1] == 1):
            return True


def __floordiv__(self, other):
    """
    Division entire par un entier

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([10, 8], [15, 5])//5
    SquareRoot([[2, 8], [3, 5]])

    :rtype: SquareRoot
    """
    if isinstance(other, int):
        r = list(self.racines)
        for i in range(len(r)):
            r[i][0] = r[i][0] // other
        return SquareRoot(r)


def __rmul__(self, other):
    """
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> 5*SquareRoot([3,45],3)
    SquareRoot([[15, 45], [15, None]])

    :rtype: SquareRoot
    """
    return SquareRoot([other, None]) * self


def __mul__(self, other):
    """Multiplie un objet SquareRoot par un nombre.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([3,45],3)*SquareRoot([2,45],-1)
    SquareRoot([['6*45', None], [-3, 45], [6, 45], [-3, None]])
    """
    if not isinstance(other, SquareRoot):
        other = SquareRoot([other, None])
    reduction = False
    if self.EstReductible():
        self = self.simplifie()
        reduction = True
    if other.EstReductible():
        other = other.simplifie()
        reduction = True
    if reduction:
        return '%r*%r' % (self, other)


def __abs__(self):
    """ Renvoie la valeur absolue d'un objet SquareRoot

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> abs(SquareRoot([5, 5], [-2, 7]))
    SquareRoot([[5, 5], [-2, 7]])
    >>> abs(SquareRoot([-5, 5], [2, 7]))
    SquareRoot([[5, 5], [-2, 7]])

    :rtype: SquareRoot
    """
    t = 0
    for e in self.racines:
        if e[1] is None:
            t += e[0]
        else:
            t += e[0] * sqrt(e[1])
    if t > 0:
        return self


def __neg__(self):
    """*object*\ .\ **__neg__**\ ()

    ``p.__neg__()`` est quivalent  ``-p`` est quivalent  ``p = -p``

    Renvoie l'oppos d'un objet SquareRoot.

    :rtype: SquareRoot
    """
    if self.EstDecomposable() or self.EstReductible():
        return '-%r' % self.simplifie()


def __radd__(self, other):
    """
    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> 2+SquareRoot([3,45],3)
    SquareRoot([[5, None], [3, 45]])

    :rtype: SquareRoot
    """
    other = SquareRoot([other, None])
    other.racines.extend(self.racines)
    return SquareRoot(other.racines).simplifie()


def __add__(self, other):
    """Renvoie la somme d'un objet SquareRoot et d'un nombre.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot([3,45],3)+SquareRoot([2,45])
    SquareRoot([[3, None], [5, 45]])

    :rtype: SquareRoot
    """

    if not isinstance(other, SquareRoot):
        other = SquareRoot([other, None])
    self.racines.extend(other.racines)
    return SquareRoot(self.racines).simplifie()


def __getitem__(self, i):
    """*object*\ .\ **__getitem__**\ (*integer*)

    Renvoie le i me lment de l'objet SquareRoot.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> SquareRoot(3, [2, 2], [4, 5])[2]
    [4, 5]

    :rtype: list
    """
    return self.racines[i]


def __len__(self):
    """*object*\ .\ **__len__**\ ()

    Renvoie le nombre d'lments de l'objet SquareRoot.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> len(SquareRoot(3, [2, 2], [4, 5]))
    3

    :rtype: integer
    """
    return len(self.racines)


def __repr__(self):
    """Renvoie une chane de caractre reprsentant un :mod:`SquareRoot`
    valuable pour crer un :mod:`SquareRoot`.

    >>> from pyromaths.classes.SquareRoot import SquareRoot
    >>> repr(SquareRoot(-4, [-2, 1], [3, 45], [-1, 7], 8))
    'SquareRoot([[-4, None], [-2, 1], [3, 45], [-1, 7], [8, None]])'

    :rtype: String
    """
    return "SquareRoot(%s)" % self.racines


def print_coef(coef):
    """Gre le format du coef
    """
    if isinstance(coef, (float, int)):
        if coef > 0:
            return "+" + decimaux(coef)



def hypotenuse(a, b):
    sum = a ** 2 + b ** 2
    hypotenuse = math.sqrt(sum)
    return hypotenuse



def get_square_root(n):
    root = []
    period = []
    cache = []
    x, y = 0, 1
    while (x + 1) ** 2 <= n:
        x += 1
    root.append(x)
    if x ** 2 != n:
        while (x, y) not in cache:
            cache.append((x, y))
            k = 0
            d = (n - x ** 2) // y
            while ((k + 1) * d - x) ** 2 <= n:
                k += 1
            period.append(k)
            x, y = k * d - x, d
    root.append(period)
    return root



def make_mid_point(start, end):
    return start + (end - start) / 2



def square_root(number):
    if number < 0.0:
        return -1



def square_root(n):
    n = float(n)
    x = n / 2
    i = 0
    while i < 10:
        y = (x + n / x) / 2
        x = y
        i += 1
    return x



def libmath(n):
    n = float(n)
    return math.sqrt(n)



def newtons(n):
    n = float(n)
    x = n / 2
    i = 0
    while i < 10:
        y = (x + n / x) / 2
        x = y
        i += 1
    return y



def RMSE_T(a, b):
    return T.sqrt(T.sum(T.square(a - b), axis=1))



def RMSE(a, b):
    """
    Root Mean Square Error
    """
    return np.sqrt(np.sum(np.square(a - b), axis=1))



def inv_sigmoid_T(x):
    return T.log(x / (1. - x))



def inv_sigmoid(x):
    """
    inverse sigmoid
    """
    return np.log(x / (1. - x))



def sigmoid_T(x):
    return 0.5 * (1 + T.tanh(x / 2))



def sigmoid(x):

    return 0.5 * (1 + np.tanh(x / 2))



def wiener_attack(N, e):
    (p, q, d) = (0, 0, 0)
    conv = convergents(partial_quotiens(e, N))
    for frac in conv:
        (k, d) = frac
        if k == 0:
            continue
        y = -(N - phiN(e, d, k) + 1)
        discr = y * y - 4 * N
        if(discr >= 0):

            sqr_discr = is_perfect_square(discr)

            if sqr_discr != -1 and (-y + sqr_discr) % 2 == 0:
                p = ((-y + sqr_discr) / 2)
                q = ((-y - sqr_discr) / 2)
                return p, q, d



def phiN(e, d, k):
    return ((e * d) - 1) / k



def convergents(sequence):
    c = []
    for i in range(1, len(sequence)):
        c.append(indexed_convergent(sequence[0:i]))

    return c



def indexed_convergent(sequence):
    i = len(sequence) - 1
    num = sequence[i]
    denom = 1
    while i > 0:
        i -= 1
        a = (sequence[i] * num) + denom
        b = num
        num = a
        denom = b

    return (num, denom)



def partial_quotiens(x, y):
    partials = []
    while x != 1:
        partials.append(x // y)
        a = y
        b = x % y
        x = a
        y = b

    return partials



def is_perfect_square(n):
    h = n & 0xF
    if h > 9:
        return -1



def isqrt(n):
    if n < 0:
        raise ValueError('square root not defined for negative numbers')
    if n == 0:
        return 0



def bitlength(x):
    assert x >= 0
    n = 0
    while x > 0:
        n = n + 1
        x = x >> 1
    return n



def quadruple(x):
    return 4 * x



def ftest():
    return 26



def tracetest(fn):
    return 5


def wrapped(x):
    print('-> ', fn, '(', x, ')')
    return fn(x)


def f(x, y):
    return g(x)(y)



def curried_nth_power(x):
    return lambda y: power(y, x)



def curried_power(x):
    return lambda y: power(x, y)


def df(x):
    return n * power(x, n - 1)



def newton_update(f, df):
    return lambda x: x - f(x) / df(x)


def sqrt_close(x):
    return approx_eq(x * x, a)


def sqrt_update(x):
    return average(x, a / x)



def average(x, y):
    return (x + y) / 2



def approx_eq(x, y, tolerance=1e-14):
    return abs(x - y) < tolerance



def api_hello():
    return redirect("http://www.google.com", code=302)


def decorated(*args, **kwargs):
    auth = request.authorization
    if not auth:
        return authenticate()



def authenticate():
    message = {'message': "Authenticate."}
    resp = jsonify(message)

    resp.status_code = 401
    resp.headers['WWW-Authenticate'] = 'Basic realm="Example"'

    return resp



def check_auth(username, password):
    return username == 'admin' and password == 'secret'



def newton_raphson_root(value, power, epsilon):
    """ function used to find the root of a given value through the Newton-Raphson method

    :param value: int, number for which we want to find the root
    :param power: int, power that turns the root into the given value
    :param epsilon: float, tolerance used when testing the root
    :return: float, the root of the given value
    """
    result = value / 2.0

    while abs(result ** power - value) >= epsilon:
        result += (value - result ** power) / (power * result ** (power - 1))
    return result



def update_alg_squarert(score):
    """Change the score by taking the square root."""
    return math.sqrt(score)



def update_alg_square(score):
    """Change the score by squaring."""
    return score * score



def is_square(number):
    square_root = str(math.sqrt(number)).split('.')[1]
    if 1 == len(square_root) and '0' == square_root:
        return True



def is_par(number):
    reversed_number = ""
    if 1 == len(number):
        return True



def is_par_square(number):
    if is_par(str(number)) and is_square(number):
        if is_par(str(int(math.sqrt(number)))):
            return True



def get_num(min, max):
    result = 0
    for i in range(min, max + 1):
        if is_par_square(i):
            result += 1
    return result



def root(token):
    return float(token[1]) ** (1 / float(token[2]))



def mod(token):
    return float(token[1]) % float(token[2])



def power(token):
    base = float(token[1])
    for i in range(2, len(token)):
        base = base ** float(token[i])
    return base



def cube(token):
    return float(token[1]) ** 3



def square(token):
    return float(token[1]) * float(token[1])



def divide(token):
    quo = float(token[1])
    for i in range(2, len(token)):
        quo = quo / float(token[i])
    return quo



def multiply(token):
    product = 1
    for i in range(1, len(token)):
        product = product * float(token[i])
    return product



def subtract(token):
    tot = float(token[1])
    for i in range(2, len(token)):
        tot = tot - float(token[i])
    return tot



def add(token):
    tot = 0
    for i in range(1, len(token)):
        tot = tot + float(token[i])
    return tot



def square_root(a):
    epsilon = 10e-15
    x = a / 2
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def the_golden_ratio():
    return find_fixed_point(average_damp(lambda x: 1 + 1 / x), 1.0)



def cubic_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 3)),



def cubic_root_01(n):
    return find_fixed_point(average_damp(lambda x: n / (x * x)),



def square_root_03(n):
    return find_fixed_point(average_damp(ith_root_lambda(n, 2)),



def square_root_01(n):
    return find_fixed_point(average_damp(lambda x: n / x),



def ith_root_lambda(n, i):
    return lambda x: n / (x ** (i - 1))


def is_close_enough(x, y):
    return abs(x - y) <= error_tolerance



def average_damp(f):
    return lambda x: average(x, f(x))



def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    '''

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def newtonSqrt(n):
    '''Calculates the square root of n'''

    i = 0
    approx = n / 2
    better_approx = 0.5 * (approx + (n / approx))

    while better_approx != approx:

        approx = better_approx
        better_approx = 0.5 * (approx + (n / approx))
        i = i + 1
        print(better_approx, "number of iterations: ", i)

    return approx



def get_smallest_not_satisfying_golbach():
    primes = []

    for candidate in range(3, MAX_RANGE, 2):

        if helpers.is_prime(candidate):

            primes.append(candidate)
        else:

            if not any(is_square((candidate - prime) / 2) for prime in primes):
                return candidate



def is_square(num):
    root = math.sqrt(num)
    return root == int(root)



def squareRootNR(x, epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)

    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1

    while abs(diff) > epsilon and ctr <= 100:
        print 'Error:', diff, 'guess:', guess

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'
    print 'NR method. Num iterations:', ctr, 'Estimate:', guess
    return guess



def testBi():
    print 'squareRootBi(4,0.0001) returns', squareRootBi(4, 0.0001)



def squareRootBi(x, epsilon):
    '''Assumes x >= 0 and epsilon > 0
    Return y such that y*y is within epsilon of x'''

    assert x >= 0, 'x must be positive, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)

    low = 0
    high = max(x, 1)
    guess = (low + high) / 2.0
    ctr = 1

    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess

        guess = (low + high) / 2.0
        ctr += 1

    assert ctr <= 100, 'Iteration count exceeded'

    return guess



def solve():
    B = 10 ** 12
    s = set()
    for a in range(2, 10 ** 4):
        a3 = a ** 3
        for b in range(1, a):
            b2 = b ** 2
            if b2 * (a3 + 1) >= B:
                break
            c = 1
            n = a3 * b * c * c + c * b2
            while n <= B:
                r = iSqrt(n)
                if r * r == n:
                    s.add(n)
                c += 1
                n = a3 * b * c * c + c * b2
    return sum(s)



def iSqrt(n):
    """
    Integral square root (by Newton iterations)
    """
    x = 1
    xOld = 1
    while True:
        aux = (x + (n / x)) / 2
        if aux == x:
            return x



def gcd(a, b):
    if a == b:
        return a



def digital_sum(n):
    return sum([int(i) for i in str(n).split('.')[-1]])



def r8_pi_sqrt():

    value = 1.7724538509055160273

    return value



def solver(n=100, m=100):
    """ For the first n natural numbers, find the total of the digital sums
    of the first m decimal digits for all the irrational square roots.

    (solved 2014-11-26)
    """
    result = 0
    getcontext().prec = m + 2
    for number in range(n + 1):
        square_root = Decimal(number).sqrt()
        if square_root % 1:

            decimal_places = str(square_root).replace(".", "")[:m]
            result += sum(int(digit) for digit in decimal_places)
    return result



def triangular_number_with_n_divisors(n):

    triangular_number = 1

    natural_number = 1

    while number_of_divisors(triangular_number) < n:
        natural_number += 1
        triangular_number += natural_number

    return triangular_number



def number_of_divisors(n):
    divisors = 0
    square_root = int(sqrt(n))
    for i in range(1, square_root + 1):
        if n % i == 0:
            divisors += 2

    if square_root * square_root == n:
        divisors -= 1

    return divisors



def square_root_iter(guess, x):
    if good_enough(guess, x):
        return guess



def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001



def square_root_bisect(x, epsilon=.01):
    num_guesses = 0
    low = 0.0
    high = float(x)
    ans = (low + high) / 2.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        num_guesses += 1
        if ans ** 2 > x:
            high = ans
        else:
            low = ans
        ans = (low + high) / 2.0
    print('Tried ' + str(num_guesses) + ' times')

    return(ans)



def square_root_continuous(x, epsilon=.01):
    step = epsilon ** 2
    num_guesses = 0
    ans = 0.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        ans += step
        num_guesses += 1
    print('Tried ' + str(num_guesses) + ' times')

    return(ans)



def get_permission(line):
    args = line.split(" ", 2)
    probe_point = args[0]
    layer_id = get_layer(args[1])
    square_args = re.findall("\{(.*?)\}", args[2])
    executable_path = replace_container_id(square_args[0])
    if probe_point not in probe_point_dispatcher:
        return (None, None, None, None, None)



def mount_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(square_args[3])
    ftype = None
    source = None
    options = []

    if(flags > 0):
        options = [
            apparmor_mnt_flag for (
                mnt_flag,
                apparmor_mnt_flag) in MOUNT_FLAGS_LIST if(
                mnt_flag & flags)]

        if(MS_REC & flags):
            if(MS_PRIVATE & flags):
                options.remove("make-private")
                options.append("make-rprivate")
            if(MS_BIND & flags):
                options.remove("bind")
                options.append("rbind")

    if((len(square_args[2]) > 0) and
       (square_args[2] != "bind") and
       (square_args[2] != "none") and
       (not (MS_REMOUNT & flags))):
        ftype = square_args[2]

    if((len(square_args[0]) > 0) and
       (not (MS_REMOUNT & flags))):
        source = glob_paths(square_args[0])
        if(source[0] == "/" and source[-1] != '/'):
            source = "%s/" % source

    target = glob_paths(square_args[1])
    if(target[-1] != '/'):
        target = "%s/" % target

    return ((ftype, options, source, target), square_args[-1])



def pivot_root_link_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path1 = glob_paths(square_args[0])
    path2 = glob_paths(square_args[1])
    return ((path1, path2), square_args[-1])



def rename_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    old_path = glob_paths(square_args[0])
    new_path = glob_paths(square_args[1])
    return ((old_path, "rw", new_path, "rw"), square_args[-1])



def lock_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "k"), square_args[-1])



def rw_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "rw"), square_args[-1])



def read_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "r"), square_args[-1])



def write_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    return ((glob_paths(square_args[0]), "w"), square_args[1])



def memory_map_permission_rule(args):
    square_args = re.findall("\{(.*?)\}", args)
    path = replace_container_id(square_args[0])
    return ((path, "m"), square_args[-1])



def open_permission_rule(args):
    args_list = args.split()
    square_args = re.findall("\{(.*?)\}", args)
    flags = int(args_list[0])

    ''' FMODE_EXEC flag: File is opened for execution with sys_execve '''
    if(flags & 32):
        return ((replace_container_id(
            square_args[0]), EXEC_PERMISSION), square_args[-1])



def glob_container_paths(path, cmd):
    full_access_paths = glob_patterns.container_full_access_paths
    if cmd == "build":
        full_access_paths += glob_patterns.container_build_full_access_paths

    if (path.startswith(glob_patterns.container_root)):
        for container_path in full_access_paths:
            if re.match(glob_patterns.container_root +
                        "\*" + container_path + ".+", path):
                return glob_patterns.container_root + "*" + container_path + "**"



def glob_paths(path):
    path = replace_container_id(path)
    for (regex, sub_value) in glob_patterns.glob_patterns_regex.iteritems():
        path = re.sub(regex, sub_value, path)
    return path



def replace_container_id(path):
    return re.sub(glob_patterns.container_id, "*", path)



def get_layer(cgorup):
    if("docker" not in cgorup):
        return "host"



def square_root(number):
    left = 0
    right = number
    mid = left + (right - left) / 2.0
    while True:
        if mid ** 2 > number:
            right = mid
        if mid ** 2 < number:
            left = mid
        if abs(mid ** 2 - number) < 0.00001:
            break
        mid = left + (right - left) / 2.0
    return mid



def example_sqrt(x):
    """Prints example output in a string"""
    print("The square root of " + str(x) + " is " + str(sqrt(x)))
    return None



def improve_guess(guess, x):
    """Improves the guess by Heron's method

    That is, average the guess and the quotient of x and the guess.

    """
    return (guess + (x / guess)) / 2.0



def good_enough(guess, x):
    """Return true if close enough, otherwise false."""
    if math.fabs(guess ** 2 - x) < 0.001:
        return True



def sqrt_helper(guess, x):
    """Helper function that actually performs the algorithm for sqrt(x)"""
    if good_enough(guess, x):
        return guess



def sqrt(x):
    """Approximates the square root of the number x.

    This function is provided for demonstration purposes,
    you should use the provided math.sqrt(x) instead.

    """
    return sqrt_helper(1.0, x)



>> > def make_decrementor(n):
... return lambda x: n - x



def read(fn):

    return open(fn, 'r').read()



def square_root(a):
    x = a
    while True:
        if x == 0:
            return 0



def press(button, root):
    if not state.in_game:
        return


def build(self):
    state.root = Builder.load_file('main.kv')
    return state.root



def square_root(a):
    """Approximates the square root of input a to accuracy of 0.000001"""
    x = a / 2
    while True:
        print(x)
        y = (x + a / x) / 2
        if abs(y - x) < 0.000001:
            break
        x = y

    return x



def isPrime(n):
    if (n <= 1):
        return False



def problem(n):
    if (n < 1):
        raise ValueError("n must be a positive integer")
    elif (n == 1):
        return True



def compute(dm, do):
    """ Computes rms"""
    if dm is None and do is None:
        return {


def squareRootInt(self, x):
    if x <= 1:
        return x



def cube_root(a):
    return improve(lambda x: cube_root_update(x, a),


def close(x):
    return approx_eq(x * x, a)


def update(x):
    return square_root_update(x, a)



def approx_eq(x, y, tolerance=1e-15):
    return abs(x - y) < tolerance



def power(x, n):
    product, k = 1, 0
    while k < n:
        product, k = product * x, k + 1
    return product



def cube_root(a):
    return find_zero(lambda x: x * x - a,


def square_root_iter(guess):
    if good_enough(guess):
        return guess


def good_enough(guess):
    return abs(square(guess) - x) < 0.00001


def improve(guess):
    return average(guess, (x / guess))


def average(x, y):
    return (x + y) / 2


def square(y):
    return y * y



def lesser_than(a, b, yes, no):
    if a < b:
        return yes



def greater_than(a, b, yes, no):
    if a > b:
        return yes



def power(a, b):
    return math.pow(a, round(b))



def square_root(a):
    return math.sqrt(abs(a))



def divide(a, b):
    return a / b



def multiply(a, b):
    return a * b



def subtract(a, b):
    return a - b



def add(a, b):
    return a + b



def isPrime(n):
    squareRoot = round(math.sqrt(n))
    for i in xrange(2, int(squareRoot)):
        if n % i == 0:
            return False



def largestPrimeFactor(n):
    largest = 2
    sqrtN = int(round(math.sqrt(n)))
    for i in xrange(2, sqrtN):

        if n % i == 0 and isPrime(i) and i > largest:
            largest = i
            i = n / largest
    return largest



def average(x, y):
    return (x + y) / 2



def square_root_update(x, a):
    return average(x, a / x)



def my_sqrt(x):
    EPSILON = 1e-10
    done = False
    root = (x + 1) / 2

    while not done:
        root1 = (root + x / root) / 2
        done = abs(root - root1) < EPSILON
        root = root1

    return root


def _square_root(self, cr, uid, id, name, value, args, context=None):
    return self.write(


def _square(self, cr, uid, ids, field_name, arg, context=None):
    res = {}
    for record in self.browse(cr, uid, ids, context=context):
        b = record.num
        res[record.id] = b ** 2
        print res
    return res



def is_square(n):
    root = gmpy2.sqrt(n)
    return root % 1 == 0



def fermat_factor(n):
    assert n % 2 != 0

    a = gmpy2.ceil(gmpy2.sqrt(n))
    b2 = gmpy2.square(a) - n
    while not is_square(b2):
        a += 1
        b2 = gmpy2.square(a) - n

    factor1 = a + gmpy2.sqrt(b2)
    factor2 = a - gmpy2.sqrt(b2)
    return int(factor1), int(factor2)


def draw_level(
    self,
    root,
    root_size,
    directory_sizes,
    file_sizes,
    spacing=4,
    square_color=(200, 225, 255),
    font_color=(0, 0, 0),
    border_color=(0, 0, 0),
    ):

    min_square_size = (
        2 * spacing + 3 * self.font_size,
        3 * spacing + self.font_size)

    if root not in self.square_size:

        return



def square_root(number):
    max_item = generate_range(number)
    left = max_item - 1
    right = max_item + 1
    gap = 0.0000001

    return pseudo_bin_search(left, right, gap, number)



def generate_range(number):
    left = 0
    right = number
    gap = 1
    return pseudo_bin_search(left, right, gap, number)



def bin_search(arr, number):
    left = 0
    right = len(arr) - 1
    curr = left + (right - left) // 2

    while left < right:
        if arr[curr + 1] ** 2 >= number and arr[curr - 1] ** 2 <= number:
            return arr[curr]



def pseudo_bin_search(start, end, gap, number):
    left = start
    right = end
    curr = left + (right - left) / 2
    for i in range(120):

        doubled_curr = curr * curr
        if doubled_curr >= number and (curr - gap) * (curr - gap) <= number:
            return curr


def __unicode__(self):
    return self.title + " by " + self.author


def json(self):
    return jsonpickle.encode(self)


def sqrt(self, x):

    return int(x ** 0.5)



def odd_digits(n):
    return str(n)[0::2]



def attempt(n):
    sq = n * n
    return odd_digits(sq) == '1234567890'



def solve():
    lower = int(math.sqrt(1020304050607080900))
    upper = int(math.ceil(math.sqrt(1929394959697989990)))

    for x in xrange(lower - (lower % 100), upper + 100 - (upper % 100), 100):
        if attempt(x + 30):
            return x + 30



def iterSqRt(number):
    for counter in range(1, number):
        if counter ** 2 == number:
            return "square root of" + str(number) + "is" + str(counter)



def squareRootBi(x, epsilon):
    assert x >= 0, 'x must be non-negative,not' + str(x)
    assert epsilon > 0, 'epsilon must be postive,not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 0
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100,  'Iteration count exceeded'
    print 'Bi method. Num. iterations', ctr, 'Estimer', guess
    return guess


def default_factor():
    return ErrorUtil.ROOT_MEAN_SQUARE


def get_factor(name):
    if name == ErrorUtil.ROOT_MEAN_SQUARE:
        return ErrorUtil.REGISTERED_FUNCTIONS[name]


def registered_factors():
    return ErrorUtil.REGISTERED_FUNCTIONS.keys()



def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def sqrt_iter(guess, x, calls=0):
    if good_enough(guess, x):
        return guess


def good_enough(guess, x):
    return guess_change_is_small_fraction_of_guess(guess, x)


def guess_change_is_small_fraction_of_guess(guess, x):
    return math.fabs(improve(guess, x) - guess) < guess * 0.0001


def improve(guess, x):
    return avg(x / guess, guess)


def avg(*args):
    return float(reduce(lambda x, y: x + y, args)) / len(args)



def estimate_pi():
    const = (2 * math.sqrt(2)) / 9801
    k = 1
    sumeval = 1103
    x = sumeval
    while x >= 1e-15:
        x = (factorial(4 * k) * (1103 + 26390 * k)) / \
            ((factorial(k) ** 4) * (396 ** (4 * k)))
        sumeval += x
        k = k + 1
    return 1 / (const * sumeval)



def factorial(n):
    if n == 0:
        return 1



def tabs(x):
    return str(x) + 4 * ' '



def sqrt2(a):
    x = a / 4
    while True:
        y = (x + a / x) / 2
        if x == y:
            return x



def sqrt(n, error=0.1):
    lower = n < 1 and n or 1
    upper = n < 1 and 1 or n
    mid = lower + (upper - lower) / 2.0
    square = mid * mid
    while abs(square - n) > error:
        if square < n:
            lower = mid
        else:
            upper = mid
        mid = lower + (upper - lower) / 2.0
        square = mid * mid
    return mid



def square_root(target):
    guess = 0
    guesses = 0

    while (abs(guess * guess - target) > _tolerance and
           guess * guess < target):
        guess += 0.00001
        guesses += 1

    if abs(guess * guess - target) > _tolerance:
        raise(_NO_GOOD_SOLUTION_FOUND)

    if _debug:
        print(guesses)

    return(guess)


def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0



def sum_digs(n):
    s = 0
    while n > 0:
        s += n % 10
        n /= 10
    return s


def numSquares(self, n):
    """
    :type n: int
    :rtype: int
    """
    dict = {}
    return self.f(dict, n)


def f(self, dict, n):
    if n == 0:
        return 0


def _sqrt(n, lower, upper):
    mid = (lower + upper) / 2.0
    midsq = mid * mid

    if abs(midsq - n) < SquareRoot.epsilon:
        return mid


def sqrt(n):
    if n < 0:
        raise ValueError("sqrt can't be less than 0")

    upper = 1 if n < 1 else n
    lower = 0
    return SquareRoot._sqrt(n, lower, upper)



def sum_of_100_digits_of_irr_root(n):
    n_groups = make_groups_of_two(n)
    result = 0
    remainder = 0
    for group in n_groups:
        c = remainder * 100 + int(group)
        x = get_best_x(c, result)
        remainder = c - (20 * result + x) * x
        result = result * 10 + x
    return sum_of_digits(result)



def get_best_x(c, p):
    for x in range(0, 11):
        if (20 * p + x) * x > c:
            return x - 1



def sum_of_digits(n):
    total = 0
    while n != 0:
        total += n % 10
        n /= 10
    return total



def make_groups_of_two(n):
    str_n = str(n)
    if len(str_n) % 2 == 1:

        str_n = "0" + str_n
    groups = []
    i = 0
    while i < len(str_n):
        groups.append(str_n[i:i + 2])
        i += 2
    groups += ["00"] * (100 - len(groups))
    return groups


def good_enough(v1, v2):
    return abs(v1 - v2) < tolerance


def iterate(guess):
    next = improve(guess)
    if good_enough(guess, next):
        return next



def smooth(f, dx):
    return lambda x: average(x, (f(x - dx) + f(x) + f(x + dx)) / 3.0)


def iterate(arg, i):
    if i > n:
        return arg



def compose(f, g):
    return lambda x: f(g(x))



def double(f):
    return lambda x: f(f(x))



def cubic(a, b, c):
    return lambda x: cube(x) + a * x * x + b * x + c



def sqrt(x):
    return fixed_point_of_transform(
        lambda y: square(y) - x, newton_transform, 1.0)



def sqrt(x):
    return fixed_point_of_transform(lambda y: x / y, average_damp, 1.0)



def fixed_point_of_transform(g, transform, guess):
    return fixed_point(transform(g), guess)



def sqrt(x):
    return newtons_method(lambda y: square(y) - x, 1.0)



def newtons_method(g, guess):
    return fixed_point(newton_transform(g), guess)



def newton_transform(g):
    return lambda x: x - float(g(x)) / (deriv(g)(x))



def cube(x):
    return x * x * x



def deriv(g):
    return lambda x: float(g(x + dx) - g(x)) / dx



def cube_root(x):
    return fixed_point(average_damp(lambda y: float(x) / square(y)), 1.0)



def sqrt(x):
    return fixed_point(average_damp(lambda y: float(x) / y), 1.0)



def average_damp(f):
    return lambda x: average(float(x), f(x))



def golden_ratio():
    return fixed_point(lambda x: 1.0 + 1.0 / x, 1.0)



def sqrt(x):
    return fixed_point(lambda y: average(y, float(x) / y), 1.0)



def sqrt(x):
    return fixed_point(lambda y: float(x) / y, 1.0)


def tryit(guess):
    next = f(guess)
    if close_enough(guess, next):
        return next


def close_enough(v1, v2):
    return abs(v1 - v2) < tolerance



def half_interval_method(f, a, b):
    a_value = f(a)
    b_value = f(b)
    if negative(a_value) and positive(b_value):
        return search(f, a, b)



def search(f, neg_point, pos_point):
    midpoint = average(neg_point, pos_point)
    if close_enough(neg_point, pos_point):
        return midpoint



def negative(x):
    return not(positive(x))



def positive(x):
    return x >= 0.0



def close_enough(x, y):
    return abs(x - y) < 0.001



def f(g):
    return g(2)



def f(x, y):
    a = 1 + x * y
    b = 1 - y
    return x * square(a) + y * b + a * b



def f(x, y):
    return (lambda a, b: x * square(a) + y * b + a * b)(1 + x * y, 1 - y)


def f_helper(a, b):
    return x * square(a) + y * b + a * b



def plus4(x):
    return x + 4



def integral(f, a, b, dx):
    return sum(f, a + (dx / 2.0), lambda x: x + dx, b) * dx



def pi_sum(a, b):
    return sum(lambda x: 1.0 / (x * (x + 2.0)), a, lambda x: x + 4.0, b)



def filtered_accumulate(combiner, null_value, term, a, next, b, pred):
    if a > b:
        return null_value



def product(a, b):
    return accumulate_iter(lambda x, y: x * y, identity, a, inc, b, 1)



def sum(a, b):
    return accumulate_iter(lambda x, y: x + y, identity, a, inc, b, 0)



def accumulate_iter(combiner, term, a, next, b, acc):
    if a > b:
        return acc



def product(a, b):
    return accumulate(lambda x, y: x * y, 1, identity, a, inc, b)



def sum(a, b):
    return accumulate(lambda x, y: x + y, 0, identity, a, inc, b)



def accumulate(combiner, null_value, term, a, next, b):
    if a > b:
        return null_value



def product_iter(term, a, next, b, acc):
    if a > b:
        return acc



def factorial(n):
    return product(identity, 1, inc, n)



def product(term, a, next, b):
    if a > b:
        return 1



def sum_cubes(a, b):
    return sum_iter(cube, a, inc, b, 0)



def sum_iter(term, a, next, b, acc):
    if a > b:
        return acc


def sum_iter(term, start, next, stop, acc):
    if start > stop:
        return acc


def add_dx(x):
    return x + dx


def pi_next(x):
    return x + 4.0


def pi_term(x):
    return 1.0 / (x * (x + 2.0))



def sum_integers(a, b):
    return sum(identity, a, inc, b)



def identity(x):
    return x



def sum_cubes(a, b):
    return sum(cube, a, inc, b)



def inc(n):
    return n + 1



def sum(term, a, next, b):
    if a > b:
        return 0



def pi_sum(a, b):
    if a > b:
        return 0.0



def sum_cubes(a, b):
    if a > b:
        return 0



def sum_integers(a, b):
    if a > b:
        return 0



def carmichael(n):
    return fast_prime(n, 100) and not(prime(n))



def expmod(nbase, nexp, m):
    if nexp == 0:
        return 1



def expmod(nbase, nexp, m):
    return fast_expt(nbase, nexp) % m



def fast_prime(n, ntimes):
    if ntimes == 0:
        return True


def try_it(a):
    return expmod(a, n, n) == a



def prime(n):
    return n == smallest_divisor(n)



def smallest_divisor(n):
    return find_divisor(n, 2)



def find_divisor(n, test_divisor):
    if square(test_divisor) > n:
        return n



def divides(a, b):
    return (b % a) == 0



def gcd(a, b):
    if b == 0:
        return a



def fib_monster(n):
    return fib_iter(1, 0, 0, 1, n)



def fib_iter(a, b, p, q, count):
    if count == 0:
        return b



def multiply(a, b):
    if b == 0:
        return 0



def fast_expt(b, n):
    if n == 0:
        return 1



def even(n):
    return (n % 2) == 0



def expt(b, n):
    return expt_iter(b, n, 1)



def expt_iter(b, counter, product):
    if counter == 0:
        return product



def expt(b, n):
    if n == 0:
        return 1



def sine(angle):
    if not(abs(angle) > 0.1):
        return angle



def p(x):
    return 3.0 * x - 4.0 * cube(x)



def pascals_triangle(n, k):
    if n == 0:
        return 1



def f(n):
    return f_iter(2, 1, 0, n)



def f_iter(a, b, c, count):
    if count == 0:
        return c



def f(n):
    if n < 3:
        return n



def count_change(amount):
    return cc(amount, 5)



def cc(amount, kinds_of_coins):
    if amount == 0:
        return 1



def first_denomination(x):
    if x == 1:
        return 1



def fib(n):
    return fib_iter(1, 0, n)



def fib_iter(a, b, count):
    if count == 0:
        return b



def fib(n):
    if n == 0:
        return 0



def k(n):
    return 5 * n * n



def h(n):
    return a(2, n)



def g(n):
    return a(1, n)



def f(n):
    return a(0, n)



def a(x, y):
    if y == 0:
        return 0



def plus(a, b):
    if a == 0:
        return b



def dec(a):
    return a - 1



def inc(a):
    return a + 1


def iter(product, counter):
    if counter > n:
        return product



def factorial(n):
    return fact_iter(1, 1, n)



def fact_iter(product, counter, max_count):
    if counter > max_count:
        return product



def factorial(n):
    if n == 1:
        return 1


def sqrt_iter(guess):
    if good_enough(guess):
        return guess


def improve(guess):
    return average(guess, float(x) / guess)


def good_enough(guess):
    return abs(square(guess) - x) < 0.001


def sqrt_iter(guess, x):
    if good_enough(guess, x):
        return guess


def improve(guess, x):
    return average(guess, float(x) / guess)


def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001



def sqrt(x):
    return sqrt_iter(1.0, x)



def sqrt_iter(guess, x):
    if good_enough(guess, x):
        return guess



def improve(guess, x):
    return average(guess, float(x) / guess)



def good_enough(guess, x):
    return abs(square(guess) - x) < 0.001



def square_real(x):
    return math.exp(double(math.log(x)))



def double(x):
    return x + x



def cube_root_0(x):
    return cube_iter(27.0, 1.0, x)



def cube_iter(guess, prev, x):
    if good_enough_gp(guess, prev):
        return guess



def improve_cube(guess, x):
    return (2.0 * guess + float(x) / (guess * guess)) / 3.0



def sqrt_gp(x):
    return sqrt_iter_gp(4.0, 1.0, float(x))



def sqrt_iter_gp(guess, prev, x):
    if good_enough_gp(guess, prev):
        return guess



def good_enough_gp(guess, prev):
    return abs(guess - prev) / guess < 0.001



def sqrt_iter(guess, x):
   return new_if(



def new_if(predicate, then_clause, else_clause):
    if predicate:
        return then_clause



def sqrt(x):
    return sqrt_iter(1.0, float(x))



def average(x, y):
    return (x + y) / 2.0



def test(x, y):
    if x == 0:
        return 0



def p():
    return p()



def a_plus_abs_b(a, b):
    if b > 0:
        return a + b



def three_n(n1, n2, n3):
    if n1 > n2:
        if n1 > n3:
            if n2 > n3:
                return n1 * n1 + n2 * n2



def ge(x, y):
    return not(x < y)



def ge(x, y):
    return x > y or x == y



def abs(x):
    if x < 0:
        return -x



def abs(x):
    if x > 0:
        return x



def f(a):
    return sum_of_squares(a + 1, a * 2)



def sum_of_squares(x, y):
    return square(x) + square(y)



def concealed_square():
    """ solves problem 206"""
    pat = re.compile(r'1\d2\d3\d4\d5\d6\d7\d8\d9\d0')

    start = 1010101010
    while True:
        if len(pat.findall(str(start ** 2))):
            return start



def square_root(number):
    left = 0
    right = number

    while left < right:
        middle = left + ((right - left) / 2.0)
        squared = middle ** 2

        if number - squared < 0.00001 and number - squared > 0:
            return round(middle, ROUND)



def findQuadraticNonresidue(p):
    if p % 8 in [3, 5]:
        return 2



def tsSquareRoot(a, p):
    '''Calculates the square root mod p of a.'''
    jacobi = jacobi_symbol(a, p)
    if jacobi == -1:
        raise ValueError("No square root mod {0} exists.".format(p))
    s = p - 1
    e = 0
    while s % 2 == 0:
        e += 1
        s //= 2
    n = findQuadraticNonresidue(p)
    x = pow(a, ((s + 1) / 2), p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e
    while r > 0:

        m = 0
        bp = b
        while m < r:
            if bp == 1:
                break
            bp = (bp * bp) % p
            m += 1
        if m == 0:
            break

        g = pow(g, pow(2, (r - m - 1), p), p)
        x = (x * g) % p
        g = (g * g) % p
        b = (b * g) % p
        r = m
    return x



def isSquare(n):
    '''Checks for perfect squares by checking mod 64 to rule out 52/64 cases immediately.'''
    if n % isSquare.mod in isSquare.set:
        m = math.floor(math.sqrt(n))
        return m * m == n



def powersInMod(n):
    ''' Computes all the squares in the integers mod n.
    '''
    return set((x * x) % n for x in range(0, n // 2 + 1))



def squareRoot(expansions_count):
    if expansions_count == 1:
        return 2



def SquareRoot(n):
    result = n ** (1 / 2)
    return result



def accept_n_gt_zero(fnToCall):
    if n <= 0:
        print 'From inside Decorator: n <=0 before raising exception'

        return 0



def root_mean_square(features, values, w, f=None):
    size = len(features[0])
    if f is None:
        v = dot(features, w) - values
    else:
        v = f(dot(features, w)) - values
    return sqrt(dot(v, v) / size)



def Guess(x, k):
    """ a function to guess the remainder of the root to reveal whether
    decreasing error in the WHL algorithm is meaningful """

    n = closest_perfect_kth_root(x, k)
    a = np.random.uniform(0, 1)

    a += n

    return float(a)



def WHL_kth(x, k):
    """ main computing function derived by Kevin Webster, Blane Hollingsworth,
    and Ken Locey """

    n = closest_perfect_kth_root(x, k)
    i = 1
    a = 0
    while i <= k:
        b = scipy.special.binom(k, 1)
        a += (b * (n ** (k - i)))
        i += 1

    a = (x - n ** k) / a
    a += n

    return float(a)



def closest_perfect_kth_root(x, k):
    """ naive method by KJL """

    y = 2
    while y <= x:
        y = y ** k
        if y > x:
            return y ** (1 / k) - 1



def iroot(k, n):
    """ http://stackoverflow.com/questions/15978781/how-to-find-integer-nth-roots"""

    u, s = n, n + 1
    while u < s:
        s = u
        t = (k - 1) * s + n // pow(s, k - 1)
        u = t // k
    return s



def root_of_closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """

    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x



def square_root(a):
    eps = 1e-8
    x = 1.0
    y = 2.0
    cnt = 1
    while abs(y - x) > eps:
        x = y
        y = (x + a / x) / 2
        print 'iter', cnt, '\ty=', y
        cnt = cnt + 1
    return y



def Frog():
    print "Yay!"
    return



def Main():
    X = input("Enter a value for X ---")
    Y = input("Enter a value for Y ---")
    if (X >= Y):
        print "Subtraction happened"
        MyResult = Subtractor(X, Y)
    else:
        print "Addition happened"
        MyResult = Adder(X, Y)
    Result1 = math.sqrt(MyResult)
    print "the square root of ", MyResult, " is ", Result1
    return



def Subtractor(N1, N2):
    MyResult = N1 - N2
    return MyResult



def Adder(N1, N2):
    MyResult = N1 + N2
    return MyResult


def sqrt(self, x):
    if x < 0:
        return



def mySqrt(self, x):
    """
    :type x: int
    :rtype: int
    """

    if x == 0:
        return 0



def main(upper=100, precision=100):
    a = 0
    for i in range(1, upper + 1):
        if not (i ** 0.5).is_integer():
            for j in get_square_root(i, precision):
                a += int(j)
    return a



def get_square_root(n, precision=100):
    """
    Used the square root by subtraction method by Frazer Jarvis
    """
    a = 5 * n
    b = 5
    while len(str(b)) < precision + 2:
        if a >= b:
            a, b = a - b, b + 10
        elif a < b:
            a, b = a * 100, (b - 5) * 10 + 5
    return str(b)[:-2]



def de_decimal(n):
    n = str(n)
    n = "".join(n.split("."))
    return int(n)



def isSquare(a):
    '''isSquare(int) -> int --  Returns the square root of a if a is a square in the positive integers, None otherwise'''

    if 0 <= a <= 2 ** 50:
        sr = int(a ** (1 / 2.0))
        if sr ** 2 == a:
            return sr



def squareRoot(x):
    s = sqrt(x)
    return "\n\t{} = {}".format(x, s)



def exponentiation(x, y):
    s = x ** y
    return "\n\t{} ** {} = {}".format(x, y, s)



def multiplication(x, y):
    s = x * y
    return "\n\t{} * {} = {}".format(x, y, s)



def division(x, y):
    s = x / y
    return "\n\t{} / {} = {}".format(x, y, s)



def minus(x, y):
    s = x - y
    return "\n\t{} - {} = {}".format(x, y, s)



def add(x, y):
    s = x + y
    return "\n\t{} + {} = {}".format(x, y, s)



def estimate_pi():
    s = 0
    k = 0
    while True:
        time = 2 * math.sqrt(2) / 9810
        numer = math.factorial(4 * k) * (1103 + 26390 * k)
        denom = (math.factorial(k)) ** 4 * 396 ** (4 * k)
        if time * numer / denom < 1e-15:
            break
        s = s + time * numer / denom
        k = k + 1
    pi = 1 / s
    return pi



def eval_loop():
    while True:
        a = raw_input('Give me a sting to evaluate : \n')
        if a == 'done':
            break
        r = eval(a)
        print r
    return r



def square_root(a, x):
    """
    a : number to compute square root
    x : approximation guess
    """
    while True:

        y = (x + a / x) / 2
        if abs(y - x) < 0.000000001:
            break
        x = y
    return x



def print_n(s, n):
    while n > 0:
        print s
        n = n - 1
    return None



def sqrt(x):
    """Compute square root using the Heron of Alexandria method

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError('Cannot compute square root '
                         'of negative number {}'.format(x))

    guess = x
    i = 0

    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def solve_problem():

    max_range = 1000
    count = 0

    for i, square_root in enumerate(yield_square_root(max_range)):
        if check_if_numerator_larger_denominator(square_root):
            count += 1

    print("Condition fullfilled by:")
    print(count)

    return 0



def check_if_numerator_larger_denominator(number_as_fraction):
    numerator = len(str(number_as_fraction.numerator))
    denominator = len(str(number_as_fraction.denominator))
    return numerator > denominator



def square_root_two(layers):

    return Fraction(1 + Fraction(1, create_continued_fraction(layers)))



def create_continued_fraction(layers):
    if layers == 0:
        half = Fraction(1, 2)
        half = 2
        return half



def frac_iter(n, v=Fraction(1, 2)):
    '''Yield expression for n expansions'''
    while n > 0:
        yield Fraction(1, 1) + v
        v = Fraction(1, Fraction(2, 1) + v)
        n -= 1
    return



def squareRootNR(num, precise=3):
    ''' Returns closest square-root of a number,
        using Newton-Rapson approximation algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1



def squareRootBisect(num, precise=3):
    ''' Returns closest square-root of a number,
        using Bisection search algorithm.
        @num : The number for which square root is needed
        @precise: Precise upto number precise number of digits
    '''
    if num < 0:
        return -1



def rms(a):
    """
    Computes the root mean square of *a*, which is a numpy array. The
    result is a double constant.
    """
    return sqrt((a ** 2).mean())



def findSquareRoot(number):
    low = 0.0
    high = number
    epsilon = 0.00000000001
    guess = (low + high) / 2

    while abs(number - guess ** 2) > epsilon:
        print "high:  " + str(high) + "  low:  " + str(low) + "  guess:   " + str(guess)
        if guess ** 2 < number:
            low = guess
        elif guess ** 2 > number:
            high = guess
        elif guess ** 2 == number:
            return "found square root of" + \
                str(number) + 'would be' + str(guess)



def main(num, tolerance):
    first_guess = num / 2.0
    approx_root = square_root(num, first_guess)
    while True:
        new_guess = square_root(num, approx_root)
        if abs(new_guess - approx_root) < tolerance:
            return new_guess



def square_root(num, guess):
    print 'Current guess: %f' % guess
    return 0.5 * (guess + (num / guess))



def square_root(a, x, iteration=0):
    a = float(a)
    if abs(x - sqrt(a)) > 0.000001:
        next_x = ((x + (a / x)) / 2)
        iteration += 1
        return square_root(a, next_x, iteration)



def euler86():
    size = 0
    M = 1
    target = 1000000

    while True:
        for ab in range(2, 2 * M + 1):
            if is_square((ab) ** 2 + M ** 2):
                if ab < M:
                    size += ab / 2
                else:
                    size += (ab / 2 - (ab - M) + 1)
                if size > target:
                    return M



def is_square(n):
    root = int(n ** 0.5)
    return root * root == n


def sqrt(self, x, blind_steps=0, accepted_error=1):
    if x < 0:
        print 'error, cannot compute square root of negative number'
        return -1



def test_square_root():
    a = 1.0
    while a < 10:
        m = square_root(a, 3)
        n = math.sqrt(a)
        print(a, "\t", m, "\t", n, "\t", abs(n - m))
        a = a + 1.0

test_square_root()


"""
Implement int sqrt(int x).
Compute and return the square root of x.



def square_root_2(a, x):

    y = (x + a / x) / 2
    while True:
        x = y
        y = (x + a / x) / 2

        if abs(y - x) < 0.0000001:
            break
    return y



def square_root(a, x):
    """
    a: find the sqrt of a
    x: estimate
    """
    y = (x + a / x) / 2
    while abs(y - x) > 0.0000001:
        x = y
        y = (x + a / x) / 2

    return y



def isprime(n):
    if n < 2:
        return False


def manhattenDistance(currentNode):
    curRow = currentNode.getRow()
    curCol = currentNode.getCol()
    goalRow = goalNode.getRow()
    goalCol = goalNode.getCol()
    rowDiff = goalRow - curRow
    colDiff = goalCol - curCol
    return fabs(colDiff) + fabs(rowDiff)


def __eq__(self, other):
    if manhattenDistance(self.getPath()[
                         0]) + len(self.getPath()) == manhattenDistance(other.getPath()[0]) + len(other.getPath()):
        return True


def __lt__(self, other):
    if manhattenDistance(self.getPath()[
                         0]) + len(self.getPath()) < manhattenDistance(other.getPath()[0]) + len(other.getPath()):
        return True


def getPath(self):
    return self.visitedList


def getTurtle(self):
    return self.t


def __eq__(self, other):
    if self.row == other.row and self.col == other.col:
        return True


def __lt__(self, other):
    if manhattenDistance(self) < manhattenDistance(other):
        return True


def getRow(self):
    return self.row


def getCol(self):
    return self.col


def __str__(self):
    st = str(self.col) + ',' + str(self.row)
    return st


def size(self):
    return self.items.size()


def isEmpty(self):
    return self.items.size() == 0


def dequeue(self):
    return self.items.delMin()



def find_all_amicable_numbers(n):
    """finds all amicable numbers until n"""
    list_pairs = []
    for i in range(2, n + 1):
        if i not in list_pairs:
            pair = is_amicable_pair(i)
            if pair == i:
                continue
            if pair:
                list_pairs.append(i)
                list_pairs.append(pair)
    for item in list_pairs:
        if item > n:
            list_pairs.remove(item)
    return list_pairs



def is_amicable_pair(n):
    """tests if it is amicable pair, and returns the pair"""



def return_all_factors(n):



def example4():
    cls = SquareOfDigits()
    input0 = [
        "9785409507",
        "2055103694",
        "0861396761",
        "3073207669",
        "1233049493",
        "2300248968",
        "9769239548",
        "7984130001",
        "1670020095",
        "8894239889",
        "4053971072"]
    returns = 49
    result = cls.getMax(input0)
    return result == returns



def example3():
    cls = SquareOfDigits()
    input0 = ["1234567890"]
    returns = 1
    result = cls.getMax(input0)
    return result == returns



def example2():
    cls = SquareOfDigits()
    input0 = ["42101", "22100", "22101"]
    returns = 9
    result = cls.getMax(input0)
    return result == returns



def example1():
    cls = SquareOfDigits()
    input0 = ["1255", "3455"]
    returns = 4
    result = cls.getMax(input0)
    return result == returns



def example0():
    cls = SquareOfDigits()
    input0 = ["12", "34"]
    returns = 1
    result = cls.getMax(input0)
    return result == returns


def getMax(self, data):
    input_array = data

    find(largest(square, that(contains(same(digit, all, corner)))))

    return(number(cells(square)))



def squareRootNR(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""

    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    x = float(x)
    guess = x / 2.0

    diff = guess ** 2 - x
    ctr = 1
    while abs(diff) > epsilon and ctr <= 100:

        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr <= 100, ''
    print 'NR', ctr, '', guess
    return guess



def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""

    assert x >= 0, 'x' + str(x)
    assert epsilon > 0, '' + str(epsilon)
    low = 0
    high = max(x, 1.0)

    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr <= 100, ''
    print 'Bi', ctr, '', guess
    return guess



def euler57():
    """http://projecteuler.net/index.php?section=problems&id=57

    Investigate the expansion of the continued fraction for the square root of
    two."""
    generator = sqrt_two_expansion()
    return len(filter(lambda x: len(str(x.numerator)) > len(str(x.denominator)),



def is_square(number):
    root = math.sqrt(number)
    if int(root + 0.5) ** 2 == number:
        return True



def square_root(s):
    i = 1
    j = s
    while (abs(j - i) > 0.001):
        print i, j
        j = (i + j) / 2.0
        i = s * 1.0 / j
    return i



def diagRoots(matrix):
    ris = sp.zeros(shape=matrix.shape)
    bb, eb, dims, wb, i, j = findBlocks0(matrix)
    k = 0
    for i in range(0, j):
        ris[k:k + dims[i], k:k + dims[i]
            ] = blockRoot(matrix[k:k + dims[i], k:k + dims[i]])

        k += dims[i]

    return ris



def blockRoot(matrix):
    if (matrix.shape[0] == 2):
        a = csr3(gev(matrix)).real
        ris = sp.ndarray(shape=(2, 2))
        ris[0, 0] = a + (1 / (4 * a)) * (matrix[0, 0] - matrix[1, 1])
        ris[1, 1] = a - (1 / (4 * a)) * (matrix[0, 0] - matrix[1, 1])
        ris[0, 1] = (1 / (2 * a)) * matrix[0, 1]
        ris[1, 0] = (1 / (2 * a)) * matrix[1, 0]
    else:

        return sp.sqrt(matrix)



def csr3(complex_n):
    ang = sp.angle(complex_n)
    r = sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))
    if (sp.sin(ang / 2) >= 0):
        return sp.sqrt(r) * (complex(sp.cos(ang / 2), sp.sin(ang / 2)))



def csr2(complex_n):
    t = sp.sqrt((sp.absolute(complex_n.real) +
                 (sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag)))) / 2)
    if(complex_n.real >= 0):
        return complex(t, (complex_n.imag / (2 * t)))



def csr1(complex_n):
    CMP0 = (sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))) / 2
    CMP1 = (complex_n.real / 2)
    return complex(sp.sqrt(CMP0 + CMP1), sp.sign(complex_n.imag)
                   * (sp.sqrt(CMP0 - CMP1)))



def csr0(complex_n):
    s = sp.sqrt(sp.square(complex_n.real) + sp.square(complex_n.imag))
    angle = sp.angle(complex_n)
    return sp.sqrt(s) * (complex((sp.cos(angle * 0.5)), (sp.sin(angle * 0.5))))



def gev(matrix):
    x = (matrix[0, 0] + matrix[1, 1]) / 2
    y = sp.sqrt(-sp.square(matrix[0, 0] - matrix[1, 1]
                           ) - 4 * matrix[1, 0] * matrix[0, 1]) / 2
    return complex(x, y)



def square_root(x):
    return math.sqrt(x)



def square(x):
    return x ** 2



def root(x):
    epsilon = 0.01
    guess = x / 2.0
    while abs(guess * guess - x) >= epsilon:
        guess = guess - (((guess ** 2) - x) / (2 * guess))

    return guess



def square_root(n):
    s = int(math.sqrt(n))
    if s * s == n:
        return s



def is_anagram(a, b):
    return sorted(list(a)) == sorted(list(b))



def fibo(n):
    if n < 2:
        return n



def is_prime(n):
    if n % 2 == 0 and n > 2:
        return False



def prime(numbers):
    return filter(is_prime, numbers)



def equal_float(a, b):
    return abs(a - b) < 0.00001



def is_square_and_cube(number):
    square_root = number ** 0.5
    cube_root = number ** (1 / 3.0)
    return equal_float(square_root, int(square_root)
                       ) and equal_float(cube_root, int(cube_root))



def square_and_cube(numbers):
    return filter(is_square_and_cube, numbers)



def plus(numbers):
    total = 0
    for n in numbers:
        total += n
    return total



def largest(numbers):
    return max(numbers)



def api(args):
    q = args['q']
    if "largest" in q or "primes" in q:
        hash = q.split(':')[0]
        text = q.split(':')[1]
        numbers = q.split(':')[2]
        numbers = map(int, numbers.split(', '))
        if "largest" in q:
            return largest(numbers)



def index2():
    q = request.args.get('q')
    result = str(api(request.args))
    print q, '=>', result
    return result



def index():
    q = request.args.get('q')
    try:
        result = str(api(request.args))
        print q, '=>', result
        return result



def findsquare(a):
    epsilon = 0.0000001
    x = a / 2.0
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            return x



def squareRootBisection(x, precision):
    '''
    Calculate the square root of a float number through bisection method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None




def fourthPower(x):
    '''
    x: int or float.
    '''
    return square(square(x))


def square(x):
    '''
    x: int or float.
    '''
    result = 1
    result = x * x
    return result



def int_rac(n, guess):
    """Integer Square Root of an Integer"""
    x = [guess]

    while (x[-1] + n / x[-1]) / 2 != x[-1]:
        x.append((x[-1] + n / x[-1]) / 2)

    return len(x)



def areaOfCircle(r):
    '''Computes and returns the are of the circle with radius p'''



def squareRoot(x):
    return x ** .5



def g(x):
    return x ** 2



"""def f(x):
    return x + 3



def square_root(a):
    x = a / 2.0

    while True:
        y = (x + a / x) / 2

        if x == y:
            return x



def square_root(a, x):
    while True:
        y = (x + (a / x)) / 2
        epsilon = 0.0000001
        if abs(y - x) < epsilon:
            return y



def square_root(x):
    return numpy.sqrt(x)



def power(x, y=2):
    return x ** y



def squareRoot(x):
    epsilon = 0.0001
    guess = 1.0
    while(absoluteValue(guess * guess - x) >= epsilon):
        guess = (x / guess + guess) / 2.0
    return guess



def absoluteValue(x):
    if(x < 0):
        x = -x
    return x


def mySqrt(self, x):
    if x < 0:
        return None



def traceit(frame, event, arg):

    invariants.track(frame, event, arg)
    return traceit


def __repr__(self):

    s = ""
    for function, events in self.vars.iteritems():
        for event, vars in events.iteritems():
            s += event + " " + function + ":\n"

            for var, range in vars.iteritems():
                s += "    assert "
                if range.min == range.max:
                    s += var + " == " + repr(range.min)
                else:
                    s += repr(range.min) + " <= " + var + \
                        " <= " + repr(range.max)
                s += "\n"

    return s


def __repr__(self):
    return repr(self.min) + ".." + repr(self.max)



def square_root(x, eps=0.00001):
    assert x >= 0
    y = math.sqrt(x)
    assert abs(square(y) - x) <= eps
    return y



def debug(command, my_arg, my_locals):
    global stepping
    global breakpoints
    global watchpoints

    if command.find(' ') > 0:
        arg = command.split(' ')[1]
    else:
        arg = None

    if command.startswith('s'):
        stepping = True
        return True


def get_boundary(self, square):
    return square.get_bottommost_coordinate()


def get_boundary(self, square):
    return -square.get_topmost_coordinate()


def get_boundary(self, square):
    return -square.get_rightmost_coordinate()


def get_boundary(self, square):
    return square.get_leftmost_coordinate()


def get_boundary_coordinate(self):
    h = []
    index = 0
    heapq.heappush(
        h,
        (self.get_boundary(
            self.root_square),
            index,
            self.root_square))

    performance_counter = 0
    boundary_so_far = self.INF
    while performance_counter < 10 ** 5:
        performance_counter += 1
        boundary, dummy_index, square = heapq.heappop(h)
        if square.edge < 1e-15:
            continue
        if boundary < boundary_so_far:
            boundary_so_far = boundary
        left_square = square.build_left_square()
        right_square = square.build_right_square()
        heapq.heappush(
            h, (self.get_boundary(left_square), index + 1, left_square))
        heapq.heappush(
            h, (self.get_boundary(right_square), index + 2, right_square))
        index += 2
    return boundary_so_far


def get_bottommost_coordinate(self):
    coordinates = [
        self.y,
        self.y + self.edge * self.sin_theta,
        self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.y + self.edge * self.cos_theta,
    ]
    return sorted(coordinates)[0]


def get_topmost_coordinate(self):
    coordinates = [
        self.y,
        self.y + self.edge * self.sin_theta,
        self.y + self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.y + self.edge * self.cos_theta,
    ]
    return sorted(coordinates)[-1]


def get_rightmost_coordinate(self):
    coordinates = [
        self.x,
        self.x + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta,
    ]
    return sorted(coordinates)[-1]


def get_leftmost_coordinate(self):
    coordinates = [
        self.x,
        self.x + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta + self.edge * self.cos_theta,
        self.x - self.edge * self.sin_theta,
    ]
    return sorted(coordinates)[0]


def build_right_square(self):
    x = self.x - Decimal(1.48) * self.edge * self.sin_theta + \
        Decimal(0.64) * self.edge * self.cos_theta
    y = self.y + Decimal(0.64) * self.edge * self.sin_theta + \
        Decimal(1.48) * self.edge * self.cos_theta
    sin_theta = - self.cos_theta * \
        Decimal(0.8) + self.sin_theta * Decimal(0.6)
    cos_theta = self.sin_theta * \
        Decimal(0.8) + self.cos_theta * Decimal(0.6)
    edge = self.edge * Decimal(0.6)
    return Square(x, y, sin_theta, cos_theta, edge)


def build_left_square(self):
    x = self.x - self.edge * self.sin_theta
    y = self.y + self.edge * self.cos_theta
    sin_theta = self.sin_theta * \
        Decimal(0.8) + self.cos_theta * Decimal(0.6)
    cos_theta = self.cos_theta * \
        Decimal(0.8) - self.sin_theta * Decimal(0.6)
    edge = self.edge * Decimal(0.8)
    return Square(x, y, sin_theta, cos_theta, edge)


def __repr__(self):
    return self.__str__()


def __str__(self):
    return str((self.x, self.y, self.sin_theta, self.cos_theta, self.edge))



def square_root(n, l, m=0):
    if l == 0:
        return m



def head(a):
    for e in a:
        return e



def create_cntfrac(fraction):
    new_frac = [[fraction[0]]]
    for i in repeat(fraction[1:], 200 / len(fraction[1:])):
        new_frac.append(i)
    new_frac = flatten(new_frac)
    return new_frac



def sum_digits(numbers):
    """Return the sum of the first one hundred decimal digits
    for all the irrational square root."""
    numbers = list(str(numbers))
    numbers.remove(".")
    numbers = numbers[:100]
    return sum([int(x) for x in numbers])




def square_root_bisection(self, num):
    epsilon = 0.01
    num_guesses = 0
    low = 0.0
    high = num
    ans = (high + low) / 2.0

    while abs(ans ** 2 - num) >= epsilon:
        num_guesses += 1
        if ans ** 2 < num:
            low = ans
        else:
            high = ans
        ans = (high + low) / 2.0

    return ans



def factorial_new(n):
    '''Factorial using for loop
    '''
    result = 1
    if n < 0:
        return None



def square_root(n):
    '''Square root calculated using Netwton's method
    '''
    x = n / 2.0
    while True:
        y = (x + n / x) / 2

        if abs(y - x) < sfi.epsilon:
            break
        x = y

    return x



def squareRoot(num, epsilon):
    iteration = 0
    result = 0.0
    while abs(result ** 2 - num) > epsilon and result < num:
        result += epsilon ** 2
        iteration += 1
    print iteration
    return result



def prob(d, p):
    p = p // 4
    x = 0
    for n in range(p, d + 1):
        if f420(n, p) == p:

            x += n
    return x



def f420(n, p):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n / 2) ** 2
    s = sqrt
    i = 1
    t = int
    for x in range(1, w):
        y = s(r - x * x)

        if t(y) == y:

            i += 1

            if i > p:
                return 0



def f(n):
    w = (n // 2) - (1 if n % 2 == 0 else 0)
    r = (n / 2) ** 2
    s = sqrt
    i = 1
    for x in range(1, w):
        y = s(-x ** 2 + r)
        if int(y) == y:
            i += 1

    return i * 4



def square_root(a):
    x = a / 2.0
    epsilon = 0.000001
    while True:
        y = (x + (a / x)) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x


def compare(self, a, b, esp):
    diff = (a - b) / b
    if diff < -esp:
        return -1


def squareRoot(self, x, esp):
    if self.compare(x, 1.0, esp) < 0:
        l, r = x, 1.0
    else:
        l, r = 1.0, x
    while self.compare(l, r, esp) == -1:
        mid = l + 0.5 * (r - l)
        if self.compare(mid * mid, x, esp) == 0:
            return mid



def root_binary_search(s, e, n, p):

    while (s <= e):
        m = (s + e) // 2

        if (m ** p < n):
            s = m + 1
        elif (m ** p > n):
            e = m - 1
        else:
            return m



def find_search_range(n, p):

    l = 1

    while (l ** p < n):
        l *= 2

    s = l // 2
    e = l

    return [s, e]



def get_root(n, p):

    sj, ej = find_search_range(n, p)

    return root_binary_search(sj, ej, n, p)



def is_root(n, p):

    r = get_root(n, p)

    return [r ** p == n, r]



def pow_seven(n):

    p = 0
    d = n

    while d % 7 == 0:
        d //= 7
        p += 1

    if p > 0:
        t, e = is_root(d, 2 * p + 1)

        if t:
            return [True, p, e]



def is_goldbach(candidate):
    for p in primes:
        squares = square_generator()

        while True:
            square = squares.next()
            sum = p + (2 * square)
            if sum == candidate:
                return True



def is_prime(maybe_p):
    root = int(sqrt(maybe_p))
    for prime in primes:
        if prime > root:
            primes.append(maybe_p)
            return True



def is_prime(i):
    """ function to determine whether an integer is a prime number or not"""
    if i == 1:
        return False



def fib(n):
    a, b = 1, 1
    for i in range(1, n):
        a, b = a + b, a
    return a



def isSquare(n):
    root = int(math.sqrt(n))
    return root * root == n



def isNugget(n):
    return isSquare(5 * n * n + 2 * n + 1)



def primes_trial(n):
    primes = [2]
    for x in range(2, n + 1):
        if all(x % p for p in primes):
            primes.append(x)
    return primes



def square_root(x):

    return np.sqrt(x)


def jaccard_similarity(self, x, y):
    """ returns the jaccard similarity between two lists """


def square_rooted(self, x):
    """ return 3 rounded square rooted value """


def cosine_similarity(self, x, y):
    """ return cosine similarity between two lists """


def nth_root(self, value, n_root):
    """ returns the n_root of an value """


def minkowski_distance(self, x, y, p_value):
    """ return minkowski distance between two lists """


def manhattan_distance(self, x, y):
    """ return manhattan distance between two lists """


def euclidean_distance(self, x, y):
    """ return euclidean distance between two lists """


def _square(x):
    return x + 1



def getSquareRoot(num):
    sq = float(sqrt(num))

    return sq



def is_square(test):
    from math import sqrt
    root = sqrt(test)

    if int(root) == root:
        return True



def fft(signal):
    n = len(signal)
    if n == 1:
        return signal



def square(list):
    return map(lambda x: x ** 2.0, list)



def squareRoot(list):
    return map(lambda x: math.sqrt(x), list)



def normalize(v):
    vmag = magnitude(v)
    return [v[i] / vmag for i in range(len(v))]



def dot(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(u[i] * v[i] for i in range(len(u)))]
        print '\n', a, '\n'
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a



def sub(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [u[i] - v[i] for i in range(len(u))]
    else:
        utils.error('Vectors are of different length (utils_math: sub)')
    return a



def add(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(x) for x in zip(u, v)]
    else:
        utils.error('Vectors are of different length (utils_math: add)')
    return a



def magnitude(v):
    return math.sqrt(sum(v[i] * v[i] for i in range(len(v))))



def RootBab(num):
    n = num
    r = 1
    acc = 0.0000001
    while (n - r) > acc:
        n = (n + r) / 2
        r = num / n
    return n



def square_root(num):
    low = 0.0
    high = 1.0 + (num / 2.0)

    while low < high:
        mid = (low + high) / 2
        sqr = mid ** 2
        diff = abs(num - sqr)

        if diff <= EPSILON:
            return mid



def solution(n):

    sieve = {}
    for i in range(2, n + 1):
        sieve[i] = True

    square_root = int(math.sqrt(n))
    primes = []

    for i in range(2, square_root + 1):
        if sieve[i] == True:
            for j in range(i * i, n + 1, i):
                sieve[j] = False

    for index in sieve:
        if sieve[index] == True:
            print index
            primes.append(index)

    return sum(primes)



def get_root(n, m):

    root = [0] * m
    root[0] = isqrt(n)
    n -= root[0] ** 2
    if n == 0:
        return [root[0]]





def inverse(f):
    """Return the inverse function of f.

    >>> square_root = inverse(square)
    >>> square_root(16)
    4.0
    """
    return lambda y: approx_zero(lambda x: f(x) - y)



def critical(f):
    """Find a critical value of f, such as a minimum.

    >>> min = critical(lambda x: x*x + 4*x + 1)
    >>> round(min, 7)
    -3.0
    """
    return f(approx_zero(derive(f)))



def approx_zero(f):
    """Find a zero of f using approximate differentiation.

    >>> approx_zero(lambda x: x*x*x - 27)
    3.0
    """
    return find_zero(f, lambda x: slope(f, x))



def slope(f, x, a=1e-10):
    """Return the approximate slope of f at x.

    >>> f = lambda x: x * x - 16
    >>> slope_at_two = 4
    >>> abs(slope(f, 2) - slope_at_two) < 1e-3
    True
    """
    return (f(x + a) - f(x)) / a


def df(x):
    return n * pow(x, n - 1)


def f(x):
    return pow(x, n) - a



def largestPrimeFactor(N):
    result = FermatFactor(N)
    if (result is not None):
        if result[0] == 1 or result[1] == 1:
            return N



def FermatFactor(N):
    if N % 2 == 0:
        return None



def IsSquare(apositiveint):
    squareRoot = int(math.sqrt(apositiveint))
    return apositiveint == (squareRoot * squareRoot)



def squareRoot(num):
    root = num / 2

    while (abs(root - (num / root)) > t):
        r = 0.5 * (root + (num / root))

    return root



def abc(a):

    r = a / 2
    while (abs(r - (a / r)) > t):
        r = 0.5 * (r + (a / r))

    return r


def find_root(whim):
    guess = (whim + num / whim) / 2.0
    guess2 = guess ** 2
    if (abs(guess2 - num) < delta):
        return guess


def find_root(min, max):
    guess = (min + max) / 2.0
    guess2 = guess * guess
    if (abs(guess2 - num) < delta):
        return guess



def isPerfectRoot(n):
    return gmpy2.is_square(n)



def findSquareRoot(number):
    low = 0.0
    high = number
    epsilon = 0.01
    guess = (low + high) / 2

    while abs((number) - guess ** 2) > epsilon:
        if guess ** 2 < number:
            low = guess
        elif guess ** 2 > number:
            high = guess
        elif guess ** 2 == number:
            return "The square root of" + str(number) + "would be" + str(guess)



def solution():
    b = 15
    n = 21
    target = 1000000000000

    while n < target:
        btemp = 3 * b + 2 * n - 2
        ntemp = 4 * b + 3 * n - 3

        b = btemp
        n = ntemp
    return b



def isPrime(n):
    squareRoot = math.ceil(math.sqrt(n))
    for i in xrange(2, int(squareRoot) + 1):
        if n % i == 0:
            return False



def guess_x(p, c):

    x = 1
    while x * (20 * p + x) <= c:
        x += 1
    return x - 1



def square_root_digit_sum(c):

    p = 0
    i = 0

    rational = False

    while i < 100:
        i += 1

        x = guess_x(p, c)
        y = x * (20 * p + x)

        p = 10 * p + x

        c -= y
        c *= 100

        if c == 0:
            return 0



def euler():
    acc = 0

    for c in range(2, MAX):
        acc += square_root_digit_sum(c)
    return acc



def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.
    """

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def test1(debug_solve=False):
    """
        Test Newton iteration for the square root with different initial
        conditions.
        """
    from numpy import sqrt
    for x0 in [1., 2., 100.]:
        print " "
        x, iters = solve(fvals_sqrt, x0, debug=debug_solve)
        print "solve returns x = %22.15e after %i iterations " % (x, iters)



def fvals_sqrt(x):
    """
        Return f(x) and f'(x) for applying Newton to find a square root.
        """
    f = x ** 2 - 4.
    fp = 2. * x
    return f, fp



def solve(fvals, x0, debug=False):

    x = x0
    n_iter = 0
    tol = 1.e-14
    for h in range(100):

        """evaluate function and its derivative:
            """
        fx, fpx = fvals(x)

        if (abs(fx) < tol):
            break
        """update x
            """
        x = x - fx / fpx

    return x, h



def close_enough(u, v):
    """Takes two numbers and returns True if they differ by less than ERROR."""



def try_as_int(x):
    """Takes a number and returns it as an int if it is a whole number."""



def fixed_point(f, new):
    """Takes a function and a guess. Returns the fixed point of the function."""
    old = 0
    while not close_enough(old, new):
        old, new = new, f(new)
    return new



def deriv(f):
    """Takes a function and returns its derivative."""



def newton(f, guess):
    """Takes a function and a guess.
    Returns the fixed point of Newton's square root method."""
    df = deriv(f)
    return fixed_point(lambda x: x - (f(x) / df(x)), guess)




def check_result(function, number):
    result = function(number)
    if not isinstance(result, (int, float)):
        print("The result should be a float or an integer.")
        return False



def super_root(number):
    return 1



def p80():
    return sum(S(i) for i in range(2, 100))



def S(x):
    p, L = ContinuedFraction(x)
    return decimal(p, L)



def ContinuedFraction(x):
    y = x ** 0.5
    p = int(y)
    if p * p == x:
        return p, []



def H(m, n):
    k = HCF(m, n)
    return m // k, n // k



def HCF(a, b):
    if a < b:
        return HCF(b, a)



def decimal(p, l):
    if l == []:
        return 0



def sumdicemal(a, b):
    result, a = str(a // b), a % b
    while len(result) < 100:
        a = a * 10
        result += str(a // b)
        a = a % b
    return sum(int(i) for i in result)



def is_prime(n):
    '''Checks to see if n is prime'''
    root = n ** 0.5
    for i in primes:

        if n % i == 0:
            return False



def sqrt(x):
    if x == 0 or x == 1:
        return x



def flip(l):
    return [l[1], l[0]]



def addn(l, n):
    return [l[0] + n * l[1], l[1]]



def get_closest_number(low, high, number):
    difference_from_low_sauared = math.fabs((low ** 2) - number)
    difference_from_high_squared = math.fabs((high ** 2) - number)
    if difference_from_low_sauared > difference_from_high_squared:
        return high



def closest_square_root(number):
    if number == 1:
        return number



def square_root(a):
    new_root = a / 3.0
    old_root = 0.0
    while abs(old_root - new_root) > epsilon:
        old_root = new_root
        new_root = (new_root + a / new_root) / 2.0

    return new_root



def solve_problem():

    max_range = 1000
    count = 0

    for i in range(max_range):
        current_square_root = square_root_two(i)
        numerator = len(str(current_square_root.numerator))
        denominator = len(str(current_square_root.denominator))
        if numerator > denominator:
            count += 1

        if i % 10 == 0:
            print("progress: " + str(i / max_range * 100))

    print("Condition fulfilled by:")
    print(count)

    return 0


def iter(val):
    if isGood(val):
        return val


def improve(val):
    return (val + x / val) / 2


def isGood(val):
    return abs(val * val - x) / x < 0.00001



def sqrt(num):
    if num < 0:
        return ValueError



def empty():
    return []



def input():
    data = open('numbers').readlines()
    numbers = map(string.atoi, map(string.strip, data))
    chunk_size = (len(numbers) + numberOfProcessors - 1) / numberOfProcessors
    chunks = []
    for i in range(numberOfProcessors):
        chunks.append((i, numbers[i * chunk_size:(i + 1) * chunk_size]))
    return chunks



def digit_sum_sqrt(n):
    square_root = str(int(n ** 0.5))
    for i in range(1, 100):
        for j in range(10):
            if (int(square_root) * 10 + j) ** 2 > n * 10 ** (2 * i):
                square_root += str(j - 1)
                break
            if j == 9:
                square_root += str(j)

    s = sum(map(int, square_root))

    return s



def divisors(p):
    num = 0
    square_root = int(math.ceil(math.sqrt(p)))
    for x in xrange(1, square_root):
        if p % x == 0:
            num += 2
    if square_root * square_root == p:
        num += 1
    return num



def print_square_root():
    y = input("Enter a number: ")

    y = float(y)

    if y <= 0:
        print("Positive numbers only, please.")
        return



def primesByMaxValue(MAX):

    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    root_index = 3
    root = 7
    square = 49
    r = range(1, root_index)

    for n in range(41, MAX, 2):

        if square <= n:
            r.append(root_index)
            root_index += 1
            root = primes[root_index]
            square = root * root

        for i in r:
            p = primes[i]
            if n % p == 0:
                break
        else:
            primes.append(n)

    return primes


def root_value(wrapper):
    if isinstance(wrapper._value, _.chaining.ChainWrapper):
        return root_value(wrapper._value)


def interceptor(value):
    tracker['called'] = True
    return value.pop()


def mySqrt(self, x):

    n = max(1, 10 * (len(str(x)) / 2))

    while not (pow(int(n), 2) <= x and x < pow(int(n) + 1, 2)):
        n = (n + x / n) / 2

    return int(n)



def pe57a(n=1000):
    return calc(n)



def calc(n):
    nd13 = n // 13
    return (nd13 << 1) + ((n - nd13 * 13) >> 3)



def pe57(limit=1000):
    """
    Investigate the expansion of the continued fraction
    for the square root of two.
    """
    n, d = 3, 2
    cnt = 0
    for a in range(limit + 1):

        nn = n
        n += d << 1
        d += nn
        if len(str(n)) > len(str(d)):
            cnt += 1
    return cnt



def square_root(a):
    x = 1
    while x * x != a:
        print(x)
        x = square_root_update(x, a)
    return x



def square_root(x, eps):
    ''' (float, float) -> float
    Return the square root of x to within "the accuracy" of eps.
    '''
    counter = 0
    this_guess = 1.0
    next_guess = 0.5 * (this_guess + (x / this_guess))
    error = next_guess - this_guess
    while abs(error) > eps and counter <= 10:
        this_guess = next_guess
        next_guess = 0.5 * (this_guess + (x / this_guess))
        error = next_guess - this_guess
        counter += 1
    if counter <= 10:
        return next_guess



def sqrt(x):
    '''Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for which the square root is to be computed

    Returns: The square root of x

    Raises:
        ValueError: If x is negative
    '''

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess


def mySqrt(self, x):
    i, j = 0, x / 2 + 1
    while i <= j:
        mid = (i + j) / 2
        cur = mid ** 2
        if cur == x:
            return mid



def Run():
    Process(
        GetANumber(
            "Please enter a positive number, " +
            requestString("Enter your name")))
    return



def Process(N):
    print "The Number is " + str(N)
    print "The Square is " + str(N)
    print "The Square root is " + str(math.sqrt(N))
    return



def GetANumber(PromptMessage):
    Num = -1
    while (Num < 1):
        Num = requestNumber(PromptMessage)
        if (Num < 1):
            showError("Input can not be negative!")
    return Num



def create_parser():
    parser = argparse.ArgumentParser(description="Square or root of number")
    parser.add_argument(
        '-r',
        type=int,
        dest="ROOT",
        nargs=1,
        help="Root of number")
    parser.add_argument(
        '-s',
        type=int,
        dest="SQUARE",
        nargs=1,
        help="Square of number")
    return parser



def squareRoot(a):
    for number in range(1, a):
        if a ** 2 == a:
            return "square root of" + str(a) + "would be" + str(number)



def ig_mod(a, m):
    g, x, y = ig(a, m)
    if g != 1:
        return None



def ig(x, y):
    a, b, u, v = 0, 1, 1, 0
    while x != 0:
        q, r = y // x, y % x
        m, n = a - u * q, b - v * q
        y, x, a, b, u, v = x, r, u, v, m, n
    return y, a, b



def sqrt(x, eps=1e-6):
    r = x * 1.
    while abs(x - r * r) > eps:
        r = 0.5 * (r + x / r)
    return r



def exSqrRt(number):

    float(number)
    counter = 1.0

    while counter ** 2 == number:
        return str(counter) + 'is the square root of' + number



def squareRoot(a, b):
    for counter in range(1, squareRoot):
        if counter ** 2 == squareRoot:
            return 'square root of' + str(squareRoot) + " is " + str(counter)



def raiz(n):
    x = n
    y = 0
    while(x != y):
        y = x
        x = (n / x + x) / 2
    return x



def main():

    total = 0

    for num in range(2, 100):
        if num not in {4, 9, 16, 25, 36, 49, 64, 81}:
            root = isqrt(num * (10 ** 2) ** 99)
            total += sum([int(x) for x in str(root)])
    return total



def test_square_root(s1, s2):
    for i in range(s1, s2):
        a = i ** 0.5
        b = math.sqrt(i)
        if (a).is_integer():
            print ("%1.1f\t %1.1f \t\t\t%1.1f \t\t\t%1.1f" % (i, a, b, a - b))
        else:
            print ("%1.1f\t %13.11f\t%13.11f\t%16.13e" % (i, a, b, a - b))
    return True



def isqrt(x):
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    n = int(x)
    if n == 0:
        return 0



def square_of_square_root(value):
    import math
    root = value ** 2
    product = math.sqrt(root)
    return product



def square(value):
    product = value * value
    return product



def multiply(factor1, factor2):
    product = factor1 * factor2
    return product



def subtract(term1, term2):
    result = term1 - term2
    return result



def add(term1, term2):
    result = term1 + term2
    return result



def neighbors(square_config):
    open_spot = square_config.index(0)
    n_list = []
    for i in N_HASH[open_spot]:
        new_config = list(square_config)
        new_config[open_spot] = square_config[i]
        new_config[i] = 0
        n_list.append(new_config)

    return n_list



def heuristic(square_config):
    d = 0
    for i in range(len(square_config)):
        d += dist_to_dest(i, square_config)

    return d



def dist_to_dest(num, square_config):
    return DISTANCE_HASH[(num, square_config.index(num))]



def get_input(prompt):
    num = raw_input(prompt)
    return num



def sqrt(num):
    epsilon = 0.000001
    rt = num / 2
    while True:
        newrt = (rt + num / rt) / 2
        if abs(newrt - rt) < epsilon:
            return newrt



def is_perfect_square(n):
    root = math.sqrt(n)
    return root == int(root)



def squares(start=0):
    return itertools.imap(square, itertools.count(start))



def square(n):
    return n * n



def count_to(n):
    return range(1, n + 1)



def lcm(a, b):
    return a * b / gcd(a, b)



def gcd(a, b):
    while b:
        a, b = b, a % b
    return a



def numbers_with_digits(digits, radix=10):
    start = pow(radix, digits - 1)
    end = pow(radix, digits)
    return range(start, end)



def is_palindromic(n):
    n = str(n)
    return n[:] == n[::-1]



def last(xs):
    return list(xs)[-1]



def first(xs, predicate=lambda x: True):
    for x in xs:
        if predicate(x):
            return x



def product(xs):
    result = 1

    for x in xs:
        result = result * x

    return result



def n_primes(n):
    return itertools.islice(primes(), n)



def primes_less_than(n):
    return take_while_less_than(n, primes())



def any(predicate, xs):
    for x in xs:
        if predicate(x):
            return True



def evens(xs):
    return itertools.ifilter(is_even, xs)



def fibonacci_less_than(n):
    return take_while_less_than(n, fibonacci())


def less_than_or_equal_to_n(x):
    return x <= n


def less_than_n(x):
    return x < n



def is_even(n):
    return divisible_by(n, 2)



def divisible_by(dividend, divisor):
    return dividend % divisor == 0



def loadObjects(root, folder):
    print "\nLoading: " + folder
    n = 0
    objects = []
    for subdir, dirs, files in os.walk(root + folder):
        for file in files:
            objects += perception(os.path.join(subdir, file), show=False)
            print str(file) + ", " + str(len(objects[-1]))
            gc.collect()
    return objects



def square_root(a):
    epsilon = 0.00000000001
    x = float(a / 2.0)
    while True:

        if abs(x - 0) < epsilon:
            y = a / 2.0
        else:
            y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def get_sum(n):
    start = n.index(".") + 1
    return(sum(n[start:]))



def get_max_x(p, c):
    for x in range(1, 10):
        if x * (20 * p + x) > c:
            break
    return(x - 1)



def square_root(n, d=100):
    nstr = str(n)
    if len(nstr) % 2 == 1:
        nstr = '0' + nstr

    vals = [int(nstr[i:i + 2]) for i in range(0, len(nstr), 2)]
    ans = [-1 for i in range(d)]

    p = 0
    r = 0
    vcnt = 0
    vmax = len(vals)
    for i in range(d):
        if vcnt < vmax:
            c = 100 * r + vals[vcnt]
            vcnt += 1
        else:
            c = 100 * r
        x = get_max_x(p, c)
        y = x * (20 * p + x)
        r = c - y
        p = 10 * p + x
        ans[i] = x
    dec = len(vals)
    ans = ans[:dec] + ["."] + ans[dec:]
    return(ans)



def dot(x, y):
    """
    Compute the dot product of two equal length vectors, `x`, and `y`.
    """
    return sum(n * m for n, m in izip(x, y))



def sqrt(x):
    """
    Trivial square root implementation.
    """
    return x ** 0.5



def factorial(n):
    """Return n factorial
    The factorial of anything <= 1 is 1
    >>> factorial(4)
    24
    """
    "REPLACE THIS CODE WITH YOUR FACTORIAL METHOD"
    return math.factorial(n)



def negate(n):
    """ Return negative n
    """
    "REPLACE THIS CODE WITH YOUR NEGATE METHOD"
    return (-n)



def cube(n):
    """
    Returns the cube of the number n
    """
    "REPLACE THIS CODE WITH YOUR CUBE METHOD"
    return n ** 3



def is_prime(number):

    if number % 2 == 0:
        return False



def prime_factors(number):
    factors = []
    for n in xrange(2, number / 2):
        if number % n == 0 and is_prime(n):
            factors.append(n)
    return factors



def largest_prime_factor(number):
    result = prime_factors(number)
    if result:
        result[-1]
    return result



def generate_primes_upto_number(n):
    primes = [2, 3]
    n -= 1
    current_number = primes[1]
    while current_number < n:
        current_number += 2
        square_root = math.floor(math.sqrt(current_number))
        prime = True
        for p in primes:
            if p > square_root:
                break
            elif current_number % p == 0:
                prime = False
                break

        if prime:
            primes.append(current_number)
    return primes



def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a



def solve():
    r = 0
    for k in range(1, 101):
        r += getSum(k)
    return r



def getSum(n):
    x = iSqrt(n)
    if x * x == n:
        return 0



def is_square(n):
    root = int(math.sqrt(n))
    if root * root == n:
        return True



def strict_ceil(f):
    if int(math.ceil(f)) == f:
        return int(f + 1)



def strict_floor(f):
    if int(math.floor(f)) == f:
        return int(f - 1)



def golden_ratio():
    return find_fixed_point(lambda x: average(x, (x + 1) / x), 1)



def cubic_root(n):
    return find_fixed_point(average_damp(lambda x: n / (x * x)), 1)



def square_root(n):
    return find_fixed_point(lambda x: average(x, n / x), 1)



def find_fixed_point(function, guess):
    next_guess = function(guess)
    if is_small_enough(guess, next_guess):
        return next_guess



def is_small_enough(neg_point, pos_point):
    tolerance = abs(neg_point - pos_point) / 2.0
    return tolerance <= tolerance_range



def average_damp(function):
    return lambda x: average(x, function(x))



def average(x, y):
    return (x + y) / 2.0



def square(numbers):
    return [x * x for x in numbers]



def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria.

    Args:
        x: The number for witch the square root is to be computed.

    Returns:
        The square root of x.
    """
    if x < 0:
        raise ValueError(
            'Cannot compute square root of negative number {}'.format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def square(x):
    return x * x


def digital_sum(n, limit=100):
    return reduce(lambda x, y: x + int(y),


def root_decimal_expansion(n, limit=10):
    """
    http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
    """
    n = str(int(n))
    if len(n) % 2 == 1:
        n = '0' + n
    pairs = zip(n[::2], n[1::2])[::-1]
    c = 0
    p = 0
    while pairs or c:
        c *= 100
        if pairs:
            c += int(''.join(pairs.pop()))
        x = 0
        y = lambda x: x * (20 * p + x)
        while y(x + 1) <= c:
            x += 1
        c -= y(x)
        p = 10 * p + x
        if len(str(p)) >= limit:
            break
    return p



def sqrt(x):
    """ Calculate the square root of a perfect square"""
    if x >= 0:
        ans = 0
        while ans * ans < x:
            ans += 1
        if ans * ans == x:
            return ans



def square_root(n):
    result = n ** (1 / 2)
    return result


def wrapper(n, *args, **kwargs):
    if n <= 0:
        print 'From inside Decorator: n <=0 before raising exception'
        raise Exception("Exception raised: n must be > 0")
    else:
        print 'From inside Decorator: n > 0, before calling SquareRoot fn'
        return fnToCall(n, *args, **kwargs)



def squareRootNR(x, epsilon=0.0001220703125):
    """Find the square root of x using Newton/Raphson method"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    guess = 1
    diff = guess ** 2 - x
    ctr = 1
    while ctr < 100 and abs(diff) > epsilon:
        guess = guess - diff / (2.0 * guess)
        diff = guess ** 2 - x
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("NR Method. Steps:", ctr)
    return guess



def squareRootBi(x, epsilon=0.0001220703125):
    """Find the square root of x using successive approximation by bissection"""
    assert x >= 0, "x must be greater or equal to 0"
    assert epsilon > 0, "epsilon must be greater than 0"
    low = 0

    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while ctr < 100 and abs(guess ** 2 - x) > epsilon:

        if guess ** 2 > x:
            high = guess
        else:
            low = guess
        guess = (low + high) / 2.0
        ctr += 1
    assert ctr < 100, "shouldn't take more than 100 repetitions to get answer"
    print("Bi Method. Steps:", ctr)
    return guess



def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a / x) / 2
        print "x:" + str(x) + " y:" + str(y)
        if abs(y - x) < epsilon:
            return y



def random_walk(startingsq):
    sq = startingsq
    N = 0
    while True:
        N += 1
        sq = random.choice(moves(sq))

        if sq == startingsq:
            return N



def moves(square):
    N = dict((d for d in zip("abcdefgh", range(1, 9))))
    L = dict((d for d in zip(range(1, 9), "abcdefgh")))

    numbers = N[square[0]], int(square[1])

    m = []
    for two in (-2, +2):
        for one in (-1, +1):
            h = numbers[0] + two
            v = numbers[1] + one

            if 1 <= h <= 8 and 1 <= v <= 8:

                m.append((L[h], v))

            h = numbers[0] + one
            v = numbers[1] + two

            if 1 <= h <= 8 and 1 <= v <= 8:

                m.append((L[h], v))

    return ["%s%i" % (a, n) for a, n in set(m)]



def derivative(array):
    d = []
    for i in range(len(array) - 1):
        d.append(array[i + 1] - array[i])
    return d



def energy(array, size_chunk):
    list_energy = []
    for i in range(len(array) // size_chunk):
        l = array[i * size_chunk:i * size_chunk + size_chunk]
        list_energy.append(root_mean_square(l))
    l = []
    for i in range(len(list_energy) - 1):
        l.append(sum(list_energy[i:i + 2]) / 2)
    return l



def cepstrum(array):
    array *= np.hamming(len(array))
    complex_array = np.fft.fft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    complex_array = np.fft.ifft(array)
    array = abs(complex_array)
    array = array[:(len(array) // 2)]
    return array



def spectrum(array):
    array *= np.hamming(len(array))
    complex_array = np.fft.fft(array)
    complex_array = complex_array[:len(complex_array) // 2]
    array = list(map(abs, complex_array))
    return array



def normalized(array):
    return array / max(array)



def root_mean_square(array):
    return (np.mean(array ** 2)) ** 0.5



def __good_enough(guess, x):
    return math.fabs((guess ** 2 - x)) < PRECISION



def __average(x, y):
    return (x + y) / 2



def __improve(guess, x):
    return __average(guess, (x / guess))



def gen_primes(max, primes):

    for n in primes:
        if n > max:
            return



def is_prime(number, primes=None):
    if number < 2:
        return False



def square_root(a):
    x = a / 2.0
    epsilon = 0.00000001
    while True:
        y = (x + a / x) / 2.0
        if abs(x - y) <= epsilon:
            break
        x = y
    return x



def squareRoot(x, power, eps):
    if x < 0 and power % 2 == 0:
        return None


def get_period(n):
    root = int(sqrt(n))
    m, d, a = 0, 1, root
    seq = [(0, 1, root)]
    while True:
        m = d * a - m
        d = (n - m * m) / d
        if d == 0:
            return 0



def sqrt(x):
    if x < 0:
        return None



def sqrt(x):
    x = float(x)
    for i in range(10):
        newtonX = x - (((x * x) - 2) / (2 * x))
        if (math.fabs(newtonX - x)) < 10 ** -10:
            return newtonX



def is_prime(n):

    for i in range(0, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False



def fibonacci_term(n):
    square_root_of_five = sqrt(5)
    phi = (1 + square_root_of_five) / 2
    phi_2 = (1 - square_root_of_five) / 2
    return int((phi ** n - phi_2 ** n) / square_root_of_five)



def sqr_root(x):
    return x ** 0.5



def square(x):
    return x ** 2



def divide(x, y):
    return x / y



def multiply(x, y):
    return x * y



def power(x, y):
    return x ** y



def add(x, y):
    return x + y



def subtract(x, y):
    return x - y



def sequence(bound, starter_values):
    values = [i for i in starter_values]
    if values[-1] >= bound:
        return values



def checkSeq2(n):
    true = []
    for i in range(2, n + 1, 2):
        if isSquare((i - 2) * (3 * i - 2)):
            true.append(i)
    return true



def checkSeq1(n):
    true = []
    for i in range(2, n + 1, 2):
        if isSquare((i + 2) * (3 * i + 2)):
            true.append(i)
    return true



def isSquare(n):
    root = int(sqrt(n))
    if root ** 2 == n or (root + 1) ** 2 == n:
        return True


def sqrt(self, x):
    self.target = x
    return self.binary_search(0, x)


def binary_search(self, x, y):
    m = (x + y) / 2
    if x > y:
        return y



def is_prime_slower(num):
    if num <= 1:
        return False



def table():
    for i in range(1, 10):
        tabelle = []
        p = math.sqrt(i)

        q = square_root_method(i, i + 1)

        r = abs(p - q)

        tabelle.append([i, p, q, r])
        print(tabelle)
    return tabelle



def square_root_method(a, x):
    while True:

        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return y



def square_root2(x):
    """An approximation to the square root of X, using the secant method.
    >>> round(square_root2(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    return secant_solve(lambda y: y * y - x, 1, 0.5 * (x + 1), x * 1.0e-10)


def secant_update(xk, xk1):
    return (xk - func(xk) * (xk - xk1)


def close_enough(x, state):
    return abs(func(x)) < tolerance



def iter_solve2(guess, done, update, state=None):
    """Return the result of repeatedly applying UPDATE to GUESS
    and STATE, until DONE yields a true value when applied to
    GUESS and STATE.  UPDATE returns an updated guess and state."""



def cube_root(a):
    """Compute an approximation to the cube root of X.
    >>> round(cube_root(8), 10)
    2.0
    """
    return newton_solve(lambda x: x ** 3 - a, lambda x: 3 * x ** 2,



def square_root(a):
    """Compute an approximation to the square root of A.
    >>> round(square_root(9), 10)
    3.0
    """
    if a < 0:
        raise ValueError("square root of negative value")
    return newton_solve(lambda x: x * x - a, lambda x: 2 * x,


def newton_update(x):
    return x - func(x) / deriv(x)


def close_enough(x):
    return abs(func(x)) < tolerance



def square_root(x):
    """Compute an approximation to the square root of X.
    >>> round(square_root(9), 10)
    3.0
    """
    if x < 0:
        raise ValueError("square root of negative value")
    tol = abs(x) * 1.0e-10
    y = x * 0.5
    while abs(y * y - x) > tol:
        y -= (y * y - x) / (2.0 * y)
    return y



def iter_solve(guess, done, update, iteration_limit=32):
    """Return the result of repeatedly applying UPDATE,
    starting at GUESS, until DONE yields a true value
    when applied to the result.  Causes error if more than
    ITERATION_LIMIT applications of UPDATE are necessary."""

    while not done(guess):
        if iteration_limit <= 0:
            raise ValueError("failed to converge")
        guess, iteration_limit = update(guess), iteration_limit - 1
    return guess


def solution(guess, iteration_limit):
    if done(guess):
        return guess



def iter_solve(guess, done, update):
    """Return the result of repeatedly applying UPDATE,
    starting at GUESS, until DONE yields a true value
    when applied to the result.  UPDATE takes a guees
    and returns an updated guess."""


def solution(guess):
    if done(guess):
        return guess


def sqrt(self, x):
    return int(math.sqrt(x))



def root(number, exp):
    i = exp - 1
    if i > 0:
        root1 = squareroot(number)
        return root(root1, exp - 1)



def squareroot(number):
    difference = 1
    number_guess = float(number / 2)
    while difference > 0.01:
        square_root = number_guess - \
            ((number_guess * number_guess - number) / (2 * number_guess))
        difference = float(abs(number_guess - square_root))
        number_guess = square_root
    return round(square_root, 3)



def squareRootBi(x, epsilon):
    assert epsilon > 0, 'epsilon must be postive, not ' + str(epsilon)
    low = 0
    high = max(x, 1)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon:

        if guess ** 2 < x:
            low = guess
        else:
            high = guess
        guess = (low + high) / 2.0
        ctr += 1
        assert ctr <= 1000, 'iteration count exceeded'
    print 'iterations:', ctr, 'Estimate:', guess
    return guess



def square_root(a):
    x = a / 2.0
    epsilon = 0.000000000001
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def print_n(s, n):
    while n <= 0:
        return



def isPrime(candidate):
    prime = True
    squareRoot = math.floor(math.sqrt(candidate))
    numbers = range(2, squareRoot)
    divisors = list(filter(lambda x: candidate % x == 0, numbers))
    if len(divisors) != 0:
        prime = False

    return prime


def tw_square_root_gen(limit=100):
    i, r = 0, 1 + Fraction(1, 2)
    while i < limit:
        yield r
        r = 1 + 1 / (1 + r)
        i += 1

    s = 0
    for f in tw_square_root_gen(1001):
    if len(str(f.numerator)) > len(str(f.denominator)):
        s += 1
    return s


def decimal_part(expansion):
    if expansion <= 1:
        return Fraction(1, 2)



def get_input():
    root_of = input("Enter a number: ")
    try:
        float(root_of)
    except:
        print("Non-numeric input.".format(end=''))
        return get_input()



def newton_sq_rt(root_of):
    '''Finds square root to minimum precision of 0.01 using Newton's method
        of successive approximations'''

    apxroot = root_of / 2
    n = 0
    while abs(root_of - apxroot ** 2) > 0.01:
        if n == 0:
            print(
                "{} iteration,  guess is {}".format(
                    n + 1,
                    round(
                        apxroot,
                        2)))
        else:
            print(
                "{} iterations, guess is {}".format(
                    n + 1,
                    round(
                        apxroot,
                        2)))
        apxroot = (apxroot + root_of / apxroot) / 2
        n += 1
    return apxroot



def grid_values(grid):
    char_list = []
    for c in grid:
        if c in digits or c in '0.':
            char_list.append(c)
    result = dict(zip(square_list, char_list))
    return result



def cross_product(A, B):
    the_list = []
    for a in A:
        for b in B:
            the_list.append(a + b)
    return the_list



def sqroot(x):
    return sqrt(x)



def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None



def egcd(x, y):
    a, b, u, v = 0, 1, 1, 0
    while x != 0:
        q, r = y // x, y % x
        m, n = a - u * q, b - v * q
        y, x, a, b, u, v = x, r, u, v, m, n
    return y, a, b



def factorial(n):
    """Computes factorial of n."""
    if n == 0:
        return 1







def solution():
    return sum([digital_sum(root(x, 100))



def square(n):
    return n in [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]



def digital_sum(n):
    return sum([int(x) for x in str(n)])



def root(n, digits):
    base = str(n)
    root = str(int(sqrt(n)))
    offset = 0
    while len(root) < digits:
        offset += 2
        root += "9"
        for digit in "876543210":
            if bigger(root, base, offset):
                root = root[:-1] + digit
    return root



def bigger(root, base, offset):
    root = int(root)
    return (root * root) > (int(base) * (10 ** offset))



def cube_root(x):
    return cube_root_iter(1.0, x)



def is_good_enough(guess, x):
    return abs(cube(guess) - x) < 0.001



def improve(guess, x):
    return (x / square(guess) + (2 * guess)) / 3



def cube_root_iter(guess, x):
    if is_good_enough(guess, x):
        return guess



def WebsterLocey(x):
    y1 = closest_perfect_square(x)

    y2 = y1 + 1
    z1 = x - y1 ** 2
    z2 = y1 + y2
    a = y + z1 / z2

    return float(a)



def closest_perfect_square(n):
    """ http://stackoverflow.com/questions/15390807/integer-square-root-in-python """
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x



def initFairs(n):
    """ initialize an array of fairs up to our end point """
    print "In init fairs with n = " + str(n)
    fairList = []
    for i in xrange(1, n + 1):
        if isFair(str(i)):
            fairList.append((i, i * i))
    return fairList



def isSquare2(n, listFairs):

    return 0



def isSquare(n, listFairs):

    for i in listFairs:

        if n[0] == i[1]:
            return i[0]



def isFair2(s):
    return s == s[::-1]



def isFair(s):
    """ determine if n is a palindrome """
    if len(s) <= 1:
        return True



def square_root(a):
    x = a / 2
    epsilon = 0.00000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def is_square(n):
    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:
        return True



def f(x):
    return OctoCat



def count_divisors(number):
    """ Determines the number of divisors that the number
        specified has."""

    divisor_count = 0
    square_root = math.sqrt(number)

    counter = 1
    while counter <= square_root:
        if number % counter == 0:
            divisor_count += 2
        counter += 1

    if square_root * square_root is number:
        divisor_count -= 1

    return divisor_count



def int_sqrt(n):

    ans = int(n ** .5)
    if ((ans ** 2) == n):
        return ans



def even(n):
    if ((n % 2) == 0):
        return True



def odd(n):
    if ((n % 2) == 1):
        return True



def bhatta_distance(hist1, hist2, num):
    h1 = np.average(hist1)
    h2 = np.average(hist2)

    dis = 0
    for i in range(num):
        dis += sqrt(hist1[i] * hist2[i])
    if h1 != h1:
        dis = sqrt(1 - (1 / sqrt(h1 * h2 * num * num)) * dis)
    return dis



def ln(n):
    if n == 0 or n < 0:
        return "Math Domain Error"



def loge(n, li, ls):
    if fabs(li - ls) <= 0.000001:
        return (li + ls) / 2.0



def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))
    return intersection_cardinality / float(union_cardinality)



def manhattan_distance(x, y):
    return sum(abs(a - b) for a, b in zip(x, y))



def euclidean_distance(x, y):
    return sqrt(sum(pow(a - b, 2) for a, b in zip(x, y)))



def dis_to_sim(d):
    return 1 / (1 + d)



def to_float(a):
    for i in range(len(a)):
        a[i] = float(a[i])
    return a



def to_nomalized(a):
    return preprocessing.normalize(a)



def mod_exp(x, y, mod):
    if y == 0:
        return 1



def mod_mult(x, y, mod):
    return (x * y) % mod



def square_root(a, x):
    """returns the square root of the number using newton's method
       other parameter is a valid integer """
    for i in range(5):
        y = (x + a / x) / 2
        x = y
    return y


def sqrt(self, x):
    l = 0
    h = x + 1
    while l <= h:
        m = (l + h) / 2
        if m ** 2 <= x < (m + 1) ** 2:
            return m



def bmeth(x):
    a = x
    y = 0
    while(y != a):
        y = a
        a = (x / a + a) / 2
    return a

print("Babylonian Method")
print("This program calculates the square root of a number using the Babylonian Method")
num = int(input("Give me a positive integer: "))
bab = bmeth(num)
print("The square root of {} is {}".format(num, bab))

'''
Implement int sqrt(int x).
.
Compute and return the square root of x.



def square_root(a):
    '''
    Use x(n+1) = [x(n) + a/x(n)]/2 to calculate square root of a
    '''
    e = 1
    x = a / 2
    while e >= 0.0000001:
        y = (x + a / x) / 2
        e = abs(y - x)
        x = y
    return y


def lcm(a, b):
    return (a * b) // gcd(a, b)


from functools import reduce


def gcd(*numbers):
    """Return the greatest common divisor of the given integers"""
    from fractions import gcd
    return reduce(gcd, numbers)



def subsets(s):
    return map(set, powerset(s))



def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))



def factor_to_primes(n):
    primfac = []
    d = 2
    while d * d <= n:
        while (n % d) == 0:
            primfac.append(d)
            n /= d
        d += 1
    if n > 1:
        primfac.append(n)
    return Counter(primfac)



def factor(test):

    i = 2
    limit = test ** 0.5
    factors = []
    while i <= (limit):
        if (test % i) == 0:

            factors.append(i)

        if i == 2:
            i = i + 1
        else:
            i = i + 2
    return factors



def is_prime(test):
    factors = factor(test)
    if len(factors) == 0:
        return True



def run():
    return solve()



def solve(n=1000):
    cnt = 0
    for n in range(1, n + 1):
        f = converge_square_2(n)
        if len(str(f.numerator)) > len(str(f.denominator)):
            cnt += 1
    return cnt



def converge_square_2(n, x=1):
    if n <= 0:
        return x



def evalLoop():
    end = "done"
    n = raw_input()
    while n != end:
        print eval(n)
        n = raw_input()
    return eval(n)



def squareRoot(a):
    if a > 1:
        x = a - 1.0
    else:
        x = 1.0
    y = (x + (a / x)) / 2
    epsilon = 0.00000001
    while abs(y - x) >= epsilon:
        x = y
        y = (x + (a / x)) / 2
    return y



def perfect_square_root(s, maxbits=4096):
    root = babylonian_square_root(s, maxdepth=20, maxbits=maxbits)
    if root * root == s:
        return root



def is_perfect_square(s):
    x = babylonian_square_root(s)
    if x * x == s:
        return True



def getSquareRoot_recur(left, right, target, precision):
    print("called")
    candidate = (left + right) / 2

    if(target - candidate ** 2 == 0 or abs(target - candidate ** 2) < precision):
        return candidate



def getSquareRoot_Wrapper(target, precision):
    return getSquareRoot_recur(0, target, target, precision)







def cube_root(x):
    return fixed_point(average_damp(lambda y: x / square(y)), 1)



def average_damp(f):
    return lambda x: (x + f(x)) / 2



def check(n):
    square = str(n * n)
    return all(int(square[x * 2]) == x + 1 for x in range(9))



def check_perfect(n):
    return math.floor(math.sqrt(n)) ** 2 == n



def findFactors(n):
    x = []

    z = n
    x.append(z)
    x.append(1)
    y = z ** .5 + 1
    p = 2

    while p < y:

        if z % p == 0:

            x.append(p)
            x.append(z / p)
            p = p + 1
        else:
            p = p + 1
    x.sort()

    return x



def square_root(a):
    x = float(a / 2)
    while True:
        y = (x + a / x) / 2
        if y == x:
            break
        x = y
    return x



def generate_primes_up_to(n):
    primes_so_far = [2]

    for potential_prime in range(3, n + 1, 2):
        if is_prime(potential_prime, primes_so_far):
            primes_so_far.append(potential_prime)

    return primes_so_far



def is_prime(potential_prime, primes_so_far):
    square_root_of_prime = sqrt(potential_prime)

    for prime in primes_so_far:
        if prime > square_root_of_prime:
            return True



def power(x, n):
    """Return x * x * x * ... * x for x repeated n times.

    >>> power(2, 3)
    8
    >>> power(4, 5)
    1024
    >>> power(6, 0)
    1
    """
    product, num_xs = 1, 0
    while num_xs < n:
        product, num_xs = product * x, num_xs + 1
    return product



def nth_root(n, a):
    return find_zero_of_x_to_the_n_minus_a(n, a)



def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance



def root_mean_square_fluct(in1):
    """
    Calculates mean squre fluctuation or root-mean-square (RMS) error.

    Parameters
    -----------
    in1 : :class:`numpy.ndarray`
        (Nx1) Numpy array

    Returns
    -------
    rms : :class:`numpy.ndarray`
        Mean square fluctuation.

    Notes
    -----

    RMS: Square-root of arithmetic mean of squares of original values.

    For an unbiased estimator, the RMSE is the square root of the variance,
    known as the standard error.

    References
    -----------
    * http://mathworld.wolfram.com/Root-Mean-Square.html
    * http://en.wikipedia.org/wiki/Root_mean_square_error

    """
    rms = np.sqrt(square_fluct(in1).sum() / in1.size)
    return rms



def square_fluct(in1):
    """
    Calculates ``(in1 - <in1>)*(in1 - <in1>)``.

    ``<...>`` stands for the average over the whole vector.

    Parameters
    ----------
    in1: :class:`numpy.ndarray`
        (Nx1) NumPy array.

    Returns
    -------
    sq_fluct : :class:`numpy.ndarray`
    """

    sq_fluct = (in1 - in1.mean()) ** 2
    return sq_fluct



def getRootPeriod(a):
    l = help.conFraction(a)
    return len(l) - 1



def hasOddRootPeriod(a):
    return getRootPeriod(a) % 2 == 1


def transform_back(cls, y):
    return SquareRootTargetTransform.transform_back(y)


def transform(cls, y):
    y = np.clip(y, 0, 20)
    return SquareRootTargetTransform.transform(y)


def transform_back(cls, y):
    return np.array(y)


def transform(cls, y):
    return np.clip(y, 0, 20)


def transform_back(cls, y):
    return np.array([np.exp(yy) - 1 for yy in y])


def transform(cls, y):
    y = np.clip(y, 0, np.inf)
    return np.array([np.log(yy + 1) for yy in y])


def transform_back(cls, y):
    return np.array([yy ** 2 for yy in y])


def transform(cls, y):
    y = np.clip(y, 0, np.inf)
    return np.array([np.sqrt(yy) for yy in y])


def transform(cls, y):
    return np.array(y)



def factor(n):
    if n == 1:
        return [1]



def mySquareRoot(x):
    return math.sqrt(x)



def draw_square(canvas, color, width, height, center):
    '''Does: Draws a square.
    Arguments: The canvas to draw on, the fill and outline color,
    the width and height of the square, and the center as a tuple.
    Returns: The square that is drawn.'''

    x1 = center[0] - width / 2
    x2 = center[0] + width / 2
    y1 = center[1] - height / 2
    y2 = center[1] + height / 2
    square = canvas.create_rectangle(x1, y1, x2, y2, fill=color,
                                     outline=color)
    return square


def findGoalNode(self):
    root = self.make_node(self.start)
    self.push(root)

    while self.frontier:
        node = self.pop()

        if node.square == self.goal:
            return (root, node)


def pop(self):
    (score, node) = heapq.heappop(self.frontier)
    del self.frontier_seen[node]
    return node


def make_node(self, square, action=None, parent=None):
    if parent:
        path_cost = parent.path_cost + 1
    else:
        path_cost = 0
    h_cost = square.dist(self.goal)
    return Node(parent, action, square, path_cost, h_cost)



def display_tree(root):
    return help_display(0, root)



def help_display(indent, node):

    str = "%sNode %s\n" % (indent * "  ", node.display())
    for action in node.children.keys():
        child = node.children[action]

        str += help_display(indent + 1, child)
    return str


def display(self):
  return "[%s] (c: %d, p:%d, h:%d, order: %s)" % (


def __str__(self):
    return "Node for [%s]" % self.square


def show_path(self):
    if self.parent:
        path = self.parent.show_path()
        path.append(self.action)
    else:
        path = []
    return path


def add_child(self, node):
    if node.parent != self:
        return


def cost(self):
    return self.path_cost + self.h_cost


def display(self):
    out = ""
    for i in xrange(3):
        for j in xrange(3):
            val = self.data[i * 3 + j]
            if val:
                out += "%d" % val
            else:
                out += " "
        if i < 2:
            out += "\n"
    return out


def __str__(self):
    out = ""
    for i in xrange(3):
        for j in xrange(3):
            val = self.data[i * 3 + j]
            if val:
                out += "%d" % val
            else:
                out += "_"
        if i < 2:
            out += " "
    return out


def swap(self, dir):
    blank = self.find(None)
    if blank is None:
        return None


def dist(self, other):
    dist = 0
    for i in [None, 1, 2, 3, 4, 5, 6, 7, 8]:

        self_coords = self.find(i)
        other_coords = other.find(i)
        dist += self_coords.dist(other_coords)
    return dist


def lookup(self, coord):
    return self.data[coord.index()]


def find(self, num):
    index = None
    for i in xrange(len(self.data)):
        if self.data[i] == num:
            index = i
            break
    if index is None:
        return None


def __hash__(self):
    return hash(self.__key())


def __eq__(self, other):
    return self.__key() == other.__key()


def __key(self):
    return self.__str__()


def fromStr(str):
    data = []
    entries = str.split(" ")
    if len(entries) != 9:
        print "Invalid square format: %s" % str
        sys.exit(2)
    for entry in str.split(" "):
        if entry == '_':
            data.append(None)
        else:
            data.append(int(entry))
    return Square(data)


def move(self, dir):
    if dir == LEFT:
        if self.x == 0:
            return None


def dist(self, other):
  return max(


def index(self):
    return self.x + self.y * 3


def __str__(self):
    return "(%d, %d)" % (self.x, self.y)


def fromIndex(index):
    return Coord(index % 3, index / 3)



def display_dir(dir):
    if dir == LEFT:
        return "LEFT"



def is_good_enough(guess, x):
    return abs(improve(guess, x) - guess) < 0.0001



def average(x, y):
    return (x + y) / 2.0



def improve(guess, x):
    q = (x * 1.0) / guess
    return average(q, guess)



def square_root(x):
    guess = 1.0
    while not is_good_enough(guess, x):
        guess = improve(guess, x)
        print(guess)
    return guess



def read_filter_split(fn):
    s = open(fn, 'r').read()
    return [w for w in s.split() if w.isalnum()]



def square_root(a):
    """ calculates the square root of a number using Newton's algorithm

    a: a number
    """

    x = a / 4.0
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < 0.0000001:
            break
        x = y
    return x



def count_on_cross(a, b, c, d):
    counts = a + b + c + d - 3
    return counts



def count_in_right_triangle(s1, s2):
    n_in = 0
    for x in range(1, s1):

        for y in range(1, s2):
            if s1 * y < -s2 * x + s2 * s1:
                n_in += 1
    return n_in



def getContinuedFraction(N):
    a = [int(sqrt(N)), int(1.0 / (sqrt(N) - int(sqrt(N))))]
    pnm2 = a[0]
    pnm1 = a[1] * pnm2 + 1
    qnm2 = 1
    qnm1 = a[1]
    Pnm2 = 0
    Pnm1 = a[0]
    Qnm1 = N - a[0] * a[0]
    n = 2
    while True:
        Pn = a[n - 1] * Qnm1 - Pnm1
        Qn = (N - Pn * Pn) / Qnm1
        a.append(int((a[0] + Pn) / Qn))
        pn = a[n] * pnm1 + pnm2
        qn = a[n] * qnm1 + qnm2
        if a[n] == 2 * a[0]:
            if a[n] == a[n - 1]:
                return a[:2]



def squareRoot(x):
    epsilon = 0.001
    low = 0
    high = max(x, 1)
    bisection = (high + low) / 2.0

    while abs((bisection ** 2) - x) >= epsilon and bisection <= x:
        if (bisection ** 2) > x:
            high = bisection
        else:
            low = bisection
        bisection = (high + low) / 2
    return bisection



def diophantine(d):
    """Determines the minimum solution of x for the equation
    x**2 - Dy**2 = 1"""
    x = 2
    while True:
        num = x * x - 1
        if num % d == 0 and isSquare(num / d):
            return x



def isSquare(n):

    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:

        return True


def mySqrt(self, x):
    if x <= 1:
        return x



def solve():
    B = 10 ** 15
    k = iSqrt(B)
    m = 10 ** 9
    r = 0
    s = B
    for n in range(1, k + 1):
        s2 = B / (n + 1)
        a1 = n * (sumSquares(s, m) - sumSquares(s2, m))
        r += a1
        r = r % m
        a2 = n * n * s
        r += a2
        r = r % m
        s = s2
    return r



def sumSquares(n, m):
    r = n * (n + 1) * (2 * n + 1)
    r /= 6
    r = r % m
    return r



def count_prime_power_triples(threshold):
    primes = [p for p in ntheory.primerange(1, math.sqrt(threshold))]
    numbers = set()
    for fourth_root in primes:
        n4 = fourth_root ** 4
        if n4 >= threshold:
            break
        for cube_root in primes:
            n3 = cube_root ** 3
            if n4 + n3 >= threshold:
                break
            for square_root in primes:
                n2 = square_root ** 2
                s = n4 + n3 + n2
                if s >= threshold:
                    break

                numbers.add(s)
    return len(numbers)



def squareRoot(x, epsilon):
    low = 0.0
    high = max(1.0, x)

    ans = low + (high - low) / 2.0

    while abs(ans ** 2 - x) >= epsilon:
        if ans ** 2 < x:
            low = ans
        else:
            high = ans
        ans = low + (high - low) / 2.0
    return ans



def square_root(a):
    epsilon = 0.0000000000000001
    if a < 0:
        return 'a must be larger than 0'



def sqrt(x, error_threshold=1e-4):
    res = 1.0
    error = error_threshold + 1
    while error > error_threshold:
        next_ = 0.5 * (res + (x + 0.0) / (res + 0.0))
        error = abs(next_ - res)
        res = next_
    return res



def bisection(x):
    '''
    Bisection search to approximate square root
    '''
    epsilon = 0.01
    numGuesses = 0
    low = 0.0
    high = max(1.0, x)
    ans = (high + low) / 2.0
    while abs(ans ** 2 - x) >= epsilon:

        numGuesses += 1
        if ans ** 2 < x:
            low = ans
        else:
            high = ans
        ans = (high + low) / 2.0
    return ans, numGuesses



def exhaustive_enumeration(x):
    '''
    Approximating the square root using exhaustive enumeration
    '''
    epsilon = 0.01
    step = epsilon ** 2
    numGuesses = 0
    ans = 0.0
    while abs(ans ** 2 - x) >= epsilon and ans <= x:
        ans += step
        numGuesses += 1
    if abs(ans ** 2 - x) >= epsilon:
        print 'Failed on square root of', x
    else:
        print ans, 'is close to square root of', x
    return ans, numGuesses



def newton_raphson(y):
    '''
    Newton-Raphson for square root
    '''
    epsilon = 0.01
    ans = y / 2.0
    numGuesses = 0
    while abs(ans * ans - y) >= epsilon:
        numGuesses += 1
        ans = ans - (((ans ** 2) - y) / (2 * ans))
    return ans, numGuesses



def squareRootConvergentsOfE():
    numretor1, demenator1 = 8, 3
    numretor2, demenator2 = 11, 4
    out_put = 0
    p = 4
    for i in range(5, 101):
        if i % 3 == 0:
            numretor = numretor2 * p + numretor1
            demenator = demenator2 * p + demenator1
            p += 2
        else:
            numretor = numretor2 + numretor1
            demenator = demenator2 + demenator1
        numretor1, demenator1 = numretor2, demenator2
        numretor2, demenator2 = numretor, demenator

    return numberSum(numretor)





def squareRootNR(x, precision):
    '''
    Calculate the square root of a float number through Newton-Raphson method with given precision
    :param x: Float number
    :param precision: Square root precision
    :return: Square root of the float number
    '''
    if x < 0 or precision <= 0:
        return None



def findsquareroot(number):
    low = 0.0
    high = number
    epsilon = 0.001
    guess = (low + high) / 2

    while abs(guess ** 2 - number) > epsilon:
        print "guess:  " + str(guess ** 2)
        if guess ** 2 > number:
            high = guess
        elif guess ** 2 < number:
            low = guess
        elif guess ** 2 == number:
            return 'Found square root of' + str(number)



def iterSqRt(number):
    for counter in range(1, number):
        if counter ** 2 == number:
            return "square root of" + str(number) + 'is' + str(number)



def isWholeNumber(x, y):
    val = x ** 2 + y ** 2
    if is_square(val):
        return True


def sqrt_(x):
    return IntrinsicEmitter("sqrt", (x,), (T,), T)


def log_(x):
    return IntrinsicEmitter("log", (x,), (T,), T)


def pow_(x, y):
    return IntrinsicEmitter("pow", (x, y), (T,), T)


def exp_(x):
    return IntrinsicEmitter("exp", (x,), (T,), T)



def mySqrt():
    print()
    print ('***Square Root Calculator***')
    print()
    print ('Please enter your number of choice:')

    x = int(input())

    time.sleep(2)

    """Returns the square root of x if x is a perfect square.
Prints an error message and returns none if otherwise."""



def squareTri2(line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    n = len(numbers)
    s = biSquareTri(numbers[:n / 2], numbers[n / 2:], triRoot(n / 2))
    return s, beta



def squareItFromTri(line):
    numbers = map(int, line.split())
    beta, numbers = numbers[0], numbers[1:]
    return squareTri(numbers), beta



def biSquareTri(num1, num2, n):
    return ''.join([''.join([dd[triCo(num1, x, y), triCo(num2, x, y)]



def triCo(numbers, x, y):
    c = y * (y + 1) / 2 + x
    if x <= y and c < len(numbers):
        return numbers[c]



def squareTri(numbers):
    n = len(numbers)
    a = triRoot(n)
    numbers = ['% i ' % num for num in numbers]
    m = [numbers[y * (y + 1) / 2:(y + 1) * (y + 2) / 2] +
         (a - y - 1) * [' . '] for y in range(a)]
    s = ''.join([''.join(line) + '\n' for line in m])
    return s



def squareIt(line):

    numbers = map(int, line.split())
    n = len(numbers)
    a = triRoot(n)
    beta = numbers[0]
    m = [numbers[1:][y * a:(y + 1) * a] for y in range(a)]
    s = ''.join([''.join(['% i ' % num for num in line]) + '\n' for line in m])
    return s, "% i" % beta



def triRoot(n):
    a = -0.5 + sqrt(0.25 + 2 * n)
    if a != int(a):
        print "warnin:", n, " not triangular"
    return int(a)



def squareRoot(n):

    a = int(sqrt(n - 1))
    if a * a + 1 != n:
        print "length %s not square" % (n - 1)
    return a



def getFacettes(flines):
    began = False
    for line in flines:
        if 'end' in line:
            return



def getLinearity(line):
    return int(line.split()[1])



def isLinearity(line):
    return line.startswith('linearity')



def isNoComment(line):
    return not line.startswith('*')



def flatten1(m):
    return sum(m, [])



def cube_root(x, epsilon=0.0001):
    ans = 0

    while ans ** 3 < abs(x):
        ans += 1

    if ans ** 3 != abs(x):
        return None



def square_root(x, epsilon=0.0001):
    ans = x / 2.0

    while abs(ans ** 2 - x) > epsilon:
        ans = ans - (((ans ** 2) - x) / (2 * ans))

    if abs(ans ** 2 - x) > epsilon:
        return None



def square_root(a):
    x = a / (2.0 ** (len(str(a))))

    while True:
        y = (x + (a / x)) / 2.0
        if abs(y - x) <= 0.0000001:

            break
        else:
            x = y
            print x
        return x



def solve_diophantine(d):
    for x, y in convergents(square_root_cf(d)):
        if x * x - d * y * y == 1:
            return x, y



def square_root_cf(s):
    a0 = int(math.sqrt(s))
    yield a0
    if a0 * a0 == s:
        return



def next_prime(n):
    i = bisect.bisect(_primes, n + 1)
    if i < len(_primes):
        return _primes[i]



def is_prime(n):
    if _primes[-1] < n:
        next_prime(n)
    i = bisect.bisect(_primes, n)
    return _primes[i] is n



def equal(im1, im2):
    return ImageChops.difference(im1, im2).getbbox() is None



def rmsdiff(im1, im2):
    "Calculate the root-mean-square difference between two images"

    h = ImageChops.difference(im1, im2).histogram()

    return math.sqrt(reduce(operator.add,



def squareRootInt(x):
    '''
    Calculate the square root of a perfect square
    :param x: Positive integer
    :return: Square root of the integer (IF AND ONLY IF is a perfect square)
    '''

    if x < 0:
        return None



def super_root(number):
    divisor = 1
    hi = number + 0.001
    low = number - 0.001
    super_root = 1

    while True:
        current = super_root ** super_root
        if low < current < hi:
            return super_root



def rms(x):
    """Return the root mean square value of the array x."""
    return np.sqrt(np.sum(x ** 2) / len(x))



def fix_offset_and_normalize(data):
    """Removes dc offsets and normalizes data."""
    offset = remove_offset(data)
    return normalize(offset)



def normalize(data):
    """Normalizes data by dividing by the maximum value."""
    return data / np.max(data)



def remove_offset(data):
    """Makes the minimum value of data be zero."""
    return data - np.min(data)



def solution():
    n = 1
    triangle_number = 1
    num_divisors = 1
    prime_powers = []

    while num_divisors <= 500:
        n += 1
        triangle_number += n
        prime_powers = prime_factor_powers(triangle_number)
        product = 1
        for power in prime_powers:
            product *= power + 1
        num_divisors = product

    return n, triangle_number, num_divisors



def prime_factor_powers(num):
    square_root = int(math.sqrt(num)) + 1
    prime_factors = []

    for i in range(2, square_root):
        if num % i == 0:
            if is_prime(i):
                prime_factors.append(i)

    prime_factor_powers = []

    for prime_factor in prime_factors:
        dividend = num
        power = 0
        while dividend % prime_factor == 0:
            dividend /= prime_factor
            power += 1
        prime_factor_powers.append(power)

    return prime_factor_powers



def is_prime(num):

    for i in range(2, num):
        if num % i == 0:
            return False


def sqrt(self, x):
    start, end = 1, x
    while start + 1 < end:
        mid = start + (end - start) / 2
        if mid * mid <= x:
            start = mid
        else:
            end = mid
    if end * end <= x:
        return end





def max_by_value(d):
    max_key = None
    max_value = None
    for k in d:
        if not max_value or d[k] > max_value:
            max_key = k
            max_value = d[k]
    return max_key



def square_root_convergents(upper_limit):
    pell = [0, 1]
    H = [1, 1]

    res = 0
    for n in range(2, upper_limit + 1):
        pell.append(2 * pell[n - 1] + pell[n - 2])
        H.append(H[n - 1] + 2 * pell[n - 1])
        if len(str(H[n])) > len(str(pell[n])):
            res += 1

    return res


def answer(self):
    bigNumSum = 0
    for i in range(1, 1001):
        print("iteration:" + str(i))
        frac = self.getSquareRootIteration(i)
        if len(str(frac.numerator)) > len(str(frac.denominator)):
            bigNumSum += 1
    return bigNumSum


def getSquareRootIteration(self, iterations):
    if iterations == 1:
        return Fraction(3, 2)



def squareRootBi(x, epsilon):
    """Assume x >= 0 and epsilon > 0
       Return y s.t. y*y is within epsilon of x"""
    assert x >= 0, 'x must be not non-negative, not' + str(x)
    assert epsilon > 0, 'epsilon must be positive, not' + str(epsilon)
    low = 0
    high = max(x, 1.0)
    guess = (low + high) / 2.0
    ctr = 1
    while abs(guess ** 2 - x) > epsilon and ctr <= 100:

        if guess ** 2 < x:
            low = guess
            print 'guess**2 - x is less than epsilon : ', epsilon, ' and now low value is ', low
        else:
            high = guess
            print 'guess**2 - x is greater than epsilon : ', epsilon, ' and now high value is ', high
        guess = (low + high) / 2.0
        print guess
        ctr += 1
        print ctr
    assert ctr <= 100, 'Iteration count exceeded'
    print 'Bisection method. Num. Iterations:', ctr, 'Estimate:', guess
    return guess



def find_next_joint_number(nth_pentagonal=1):
    while not is_joint_number(pentagonal(nth_pentagonal)):
        nth_pentagonal += 1
    return pentagonal(nth_pentagonal)



def is_joint_number(num):
    return is_triangular(num) and is_hexagonal(num)



def is_hexagonal(hn):
    '''Leverages:
    The inverse of hexagonal: n = -1/4 + 1/4 * sqrt(1 + 8 * hn)
    Therefore, 1 + 8 * hn must be square for hn to be hexagonal.
    Also, since n must be an integer, the evaluated sqrt must:
        Have a modulus of 3 with 4
    '''
    special_factor = 1 + 8 * hn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 4 == 3:
            return True



def is_triangular(tn):
    '''Leverages:
    The inverse of triangular: n = -1/2 + 1/2 * sqrt(1 + 8 * tn)
    Therefore, 1 + 8 * pn must be square for tn to be triangular.
    Also, since n must be an integer, the evaluated sqrt must be odd
    '''
    special_factor = 1 + 8 * tn
    if is_square(special_factor):
        given_root = int(sqrt(special_factor))
        if given_root % 2 == 1:
            return True



def is_palindrome(n, base=10):
    return n == reverse_number(n, base)



def reverse_number(n, base=10):
    result = 0
    while n > 0:
        result = result * base + n % base
        n //= base
    return result



def numberofDivisors(num):
    nod, squareRoot = 0, int(sqrt(num))
    for i in range(1, squareRoot + 1):
        if(num % i == 0):
            nod += 2
    if((squareRoot * squareRoot) == num):
        nod = nod - 1
    return nod


def generate(self):
    modules = PomUtils.get_modules()

    contents = "
    for module in modules:
        contents += "square_maven_layout('{0}')\n".format(module)

    return contents



def is_perfect_square(n):
    root = n ** 0.5
    return root == int(root)



def mysqrt(n, x):
    if abs(n - x ** 2) < 0.0000000000001:
        return x



def solvePellEquation(D):
    x = -1
    y = -1
    a = [int(sqrt(D)), int(1.0 / (sqrt(D) - int(sqrt(D))))]
    pnm2 = a[0]
    pnm1 = a[1] * pnm2 + 1
    qnm2 = 1
    qnm1 = a[1]
    Pnm2 = 0
    Pnm1 = a[0]
    Qnm1 = D - a[0] * a[0]
    n = 2
    found = False
    while not found:
        Pn = a[n - 1] * Qnm1 - Pnm1
        Qn = (D - Pn * Pn) / Qnm1
        a.append(int((a[0] + Pn) / Qn))
        pn = a[n] * pnm1 + pnm2
        qn = a[n] * qnm1 + qnm2
        if a[n] == 2 * a[0]:
            if (n - 1) % 2 != 0:
                x = pnm1
                y = qnm1
            else:
                pnm2 = pnm1
                pnm1 = pn
                qnm2 = qnm1
                qnm1 = qn
                Pnm1 = Pn
                Qnm1 = Qn
                limit = 2 * n - 1
                while n < limit:
                    n = n + 1
                    Pn = a[n - 1] * Qnm1 - Pnm1
                    Qn = (D - Pn * Pn) / Qnm1
                    a.append(int((a[0] + Pn) / Qn))
                    pn = a[n] * pnm1 + pnm2
                    qn = a[n] * qnm1 + qnm2
                    pnm2 = pnm1
                    pnm1 = pn
                    qnm2 = qnm1
                    qnm1 = qn
                    Pnm1 = Pn
                    Qnm1 = Qn
                x = pn
                y = qn
            found = True
        pnm2 = pnm1
        pnm1 = pn
        qnm2 = qnm1
        qnm1 = qn
        Pnm1 = Pn
        Qnm1 = Qn
        n = n + 1
    return x, y



def mySqrt():
    n = int(input("O hai, please enter a number you'd like to take square root of it:"))
    if n > 0:
        approximation = 0.5 * n
        b = 0.5 * (approximation + n / approximation)
        while b != approximation:
            approximation = b
            b = 0.5 * (approximation + n / approximation)
    else:
        print("please enter a nonzero value")
    return approximation



def nmn(a, n):
    """
    Computes the nth root mean nth power of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a ** n).mean()) ** (1 / float(n))



def cmc(a):
    """
    Computes the cubic root mean cube of *a*, which is a numpy array.
    The result is a double constant.
    """
    return ((a ** 3).mean()) ** (1.0 / 3.0)



def op_inverse(x):
    return 1. / x



def op_cube_root(x):
    return x ** (1. / 3)



def op_root(x):
    return np.sqrt(x)



def op_cube(x):
    return x * x * x



def op_square(x):
    return x * x



def op_power10(x):
    return 10 ** x



def op_exp(x):
    return np.exp(x)



def op_power(x, y):
    return x ** y



def op_log10(x):
    return np.log10(x)



def op_ln(x):
    return np.log(x)



def my_square_root(a, x):
    e = 0.0001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < e:
            return y



def square_root(x):
    return sqrt(x)



def multiply(x, y):
    return x * y



def add(x, y):
    return x + y



def layout(m):
    s = str(m)
    return s + ' ' * (14 - len(s))



def square_root(a):
    a = float(a)
    x = 10.0
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < 0.000000000001:
            break
        x = y
    return x



def square_root(a):
    """Computes squar root of a
    """
    espilon = 0.1e-11
    x = a
    while True:
        y = (x + a / x) / 2.0
        if abs(y - x) < espilon:
            return y



def sqrt(x):
    '''Compute square roots using the method of Helon of Alexandria.

        Args:
            X: The number for which the square root is be computed

        Returns:
            The square root of x.

        Raises:
            ValueError: If x is Negative
    '''
    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess




def __eq__(self, other):
    if manhattenDistance(self.getPath()[0]) == manhattenDistance(
            other.getPath()[0]):
        return True


def __lt__(self, other):
    if manhattenDistance(self.getPath()[0]) < manhattenDistance(
            other.getPath()[0]):
        return True



def get_input_int():

    number = raw_input("Please give me a number \n")
    number = int(number)

    return number



def problem():
    """ Attempt to solve the problem """

    return 'N/A'



def square(n):
    """Returns the square of a number."""
    squared = n ** 2
    print "%d squared is %d." % (n, squared)
    return squared



def main():
    MIN = 1020304050607080900
    MAX = 1929394959697989990
    root = int(math.sqrt(MIN))
    while True:
        if root % 100 == 30 or root % 100 == 70:
            square = root * root

            if square % 1000 == 900:
                if is_concealed_number(square):
                    print "Rock on!"
                    print "square = %d, root = %d" % (square, root)
                    return



def is_concealed_number(n):
    matches = 0
    while n != 0:
        digit = n % 10
        if digit != DIGITS[10 - 1 - matches]:
            return False



def is_perfect_square(num):
    """
    Determines whether or not a number is a perfect square. Checks using its digital root first to
    rule out impossible choices. We know that for a number to be a square number, its digital root
    must be 1, 4, 7, or 9
    :param num: Int
    :return: Boolean
    """
    digital_root = get_digital_root(num)
    if digital_root not in REQUIRED_ROOT_LIST:
        return False



def generate_super_number(num):
    """
    Shuffles num in between 1234567890 to generate the special number to check.
    :param num: Int
    :return: Int
    """
    new_num = int('0'.join(list(str(num).zfill(8))) + '000')
    new_num += 1020304050607080900
    return int(new_num)



def get_digital_root(num):
    """
    Gets the digital sum of a number
    :param num: Int
    :return: Int
    """
    while len(str(num)) > 1:
        r = 0
        while num:
            r, num = r + num % 10, num / 10
        num = r

    return num



def solve():
    for num in range(START_NUM, END_NUM + 1):
        super_number = generate_super_number(num)
        print "Checking {0}, {1}".format(str(num).zfill(8), super_number)
        if is_perfect_square(super_number):
            return int(Decimal(super_number).sqrt())



def isSquareful(n):
    return firstSquareFactor(n) != 1



def firstSquareFactor(n):
    root = 2
    square = root * root
    while square <= n:
        if n % square == 0:
            return square



def firstPrimeFactor(n):
    if n < 2:
        return -1



def isPrime(n):
    return firstPrimeFactor(n) == n



def primeFactors(n):
    factors = []
    remaining = n
    while True:

        nextFactor = firstPrimeFactor(remaining)

        if nextFactor <= 0:
            return factors


from functools import reduce


def removeDuplicateFactors(n):
    factors = primeFactors(n)
    uniqueFactors = []
    for factor in factors:
        if factor not in uniqueFactors:
            uniqueFactors.append(factor)
    product = reduce(lambda x, y: x * y, uniqueFactors, 1)
    return product



def genGrid(rows, cols):
    initVal = 0
    grid = [[initVal for r in range(rows)] for c in range(cols)]
    setStartingVals(grid)
    for r, row in enumerate(grid):
        for c, val in enumerate(row):

            if val != initVal:
                continue

            upVal = 0
            if r != 0:
                upVal = grid[r - 1][c]

            leftVal = 0
            if c != 0:
                leftVal = grid[r][c - 1]

            sum = upVal + leftVal
            grid[r][c] = removeDuplicateFactors(sum)

    return grid



def sqrt(x):
    """Compute square roots using the method of Heron of Alexandria

    Args:
        x: The number for which the square root is to be computed.

    Returns:
        The square root of x.

    Raises:
        ValueError: If x is negative.
    """

    if x < 0:
        raise ValueError(
            "Cannot compute square root of negative number {}".format(x))

    guess = x
    i = 0
    while guess * guess != x and i < 20:
        guess = (guess + x / guess) / 2.0
        i += 1
    return guess



def sqrt(x):
    assert(x > 0), 'input error'
    if x < 2:
        return x



def square_root(x):
    y = x / 2
    count = 0
    while abs((y ** 2) - x) > 0.01:
        y = (y + x / y) / 2
        count += 1
        print("After iterating {} times, my guess is {}.".format(count, y))
    return y



def squareRoot(x):
    g = x / 2.0
    while True:
        g = (g + x / g) / 2.0
        if (abs(x - g ** 2) <= 0.001):
            break
    return g



def square_root(a, x):
    for i in a:
             y = (x + i / x) / 2
              return y




def f(event):
    self.game.rightClick(i, j)
    return f


def f(event=None):
    self.game.click(i, j)
    return f


def start(self):
    self.root.mainloop()
    return self.cause



def P046():
    primes = [_ for _ in sieve(10000)]
    found = True
    i = 1

    while (found):
        found = False
        i += 2
        j = 0

        while (i >= primes[j]):
            if is_twice_square(i - primes[j]):
                found = True
                break
            j += 1

    return i



def is_twice_square(num):
    square_root = sqrt(num / 2)
    return square_root == int(square_root)


def sqrt2(self, x):
    if x < 0:
        return -1


def sqrt(self, x):
    if x < 0:
        return -1



def sqrt2(x, debug=False):
    '''
    square root of a give number
    '''
    if x == 0:
        return 0



def newton(a, x):
    return (x + (a / x)) / 2.0



def sqrt(x, guess, error):
    """Recursive version."""
    if my_abs(square(guess) - x) < error:
        return guess



def square_root(a):
    x = a / 3.0
    epsilon = 0.000000000001
    while abs(a - (x ** 2)) > epsilon:
        x = (x + a / x) / 2
    return x



def highest_factor(num):
    square_root = int(math.sqrt(num))

    for i in reversed(range(2, square_root)):
        if num % i == 0:
            if is_prime(i):
                return i



def is_prime(num):

    for i in range(2, num / 2):
        if num % i == 0:
            return False



def probable_prime(prime, count):
    for k in range(1, 10000000):
        p = prime + k
        a = gmpy2.powmod(2, p - 1, p)

        if (a == 1):
            print "k = ", k
            count += 1

            if count == 4:
                return



def square_roots(base, prime):
    exponent = (prime + 1) / 4
    root_1 = (base ** exponent) % prime
    root_2 = prime - root_1

    print "\n"
    print "first root = %i \nsecond root = %i\n" % (root_1, root_2)
    return



def is_prime(exponent):
    for k in range(0, 10000000):
        p = 10 ** exponent + k
        a = gmpy2.powmod(2, p - 1, p)

        if (a == 1):
            print "k = ", k
            return



def square_root(a):
    epsilon = 0.0000001
    x = a / 2.0
    while True:
        print x
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            break
        x = y
    return x



def main():
    odd_period_count = 0
    max_period = 0
    max_period_argument = 0
    for n in xrange(10001):
        period = len(get_continued_fraction(n)[1])
        if period > max_period:
            max_period = period
            max_period_argument = n
        if period % 2 == 1:
            odd_period_count += 1
    return odd_period_count



def get_continued_fraction(square_root_argument):
    first_appearance = {}
    sequence = []
    square_root_floor = int(math.sqrt(square_root_argument))
    if square_root_floor ** 2 == square_root_argument:
        return [square_root_floor], []



def func(a, n):
    return (



def square_root(in_put, precision):
    """
    :param input: Takes an input number
    :param precision: Takes a precision to output
    :return: The square root of the input number
    """
    in_put = float(in_put)
    precision = 1 / (10 ** float(precision))

    if in_put < 0:
        raise Exception("The square root of a negative number is non-real")
    elif in_put == 0:
        return 0



def find_root(a, b):
    i = float(a)
    step = float(b)
    return step - ((step ** 2 - i) / (2 * step))









def square(x, delta):
    start = 1
    end = x
    if (x < 1):
        start = 0
    sq = float(end + start) / 2

    while(abs(sq * sq - x) > delta):
        if (sq * sq > x):
            end = sq
        else:
            start = sq
        sq = (end + start) / 2
    return sq



def solve66(max_D):
    largest = 0
    for D in range(max_D):
        if not primes.is_square(D):
            min_solution = minimal_solution(D)
            if min_solution > largest:
                print min_solution
                largest = min_solution
    return largest



def minimal_solution(D):

    root = int(math.sqrt(D)) + 1
    while True:
        left = root * root - 1
        if left % D == 0:
            if primes.is_square(left / D):
                return root



def findroot(anum):
    """
    Find square root of a number
    """
    try:
        time.sleep(10)
        return math.sqrt(anum)



def square(list):
    return [x ** 2.0 for x in list]



def squareRoot(list):
    return [math.sqrt(x) for x in list]



def dot(u, v):
    a = []
    if abs(len(u) - len(v)) < 1e-12:
        a = [sum(u[i] * v[i] for i in range(len(u)))]
        print('\n', a, '\n')
    else:
        utils.error('Vectors are of different length (utils_math: dot)')
    return a



def eval_loop():
    while True:
        r = raw_input('Mathematical expression = ')
        if r == 'done' or r == 'Done':
            break
        print eval(r)
    print 'Done!'
    return



def approx_sqrt(a, g):
    """ Returns the aproximation of the square root of the first parameter accurate to ten decimal places. The second parameter is your guess of what the square root is.
    """
    import math
    if g < 0:
        print 'The square root of a number is never negative. Guess a positive value'
        return



def is_palindromic(num):
    return str(num) == str(num)[::-1]



def square_root(n, start=None, end=None):
    if start is None:
        start = 1
    if end is None:
        end = n
    mid = (end + start) / 2
    print (start, end, mid)
    squared_n = mid * mid
    if squared_n == n:
        return mid



def square_root(a):
    x = a / 2
    epsilon = .000000001
    while True:
        y = (x + a / x) / 2
        if abs(y - x) < epsilon:
            return y



def do_problem_12_try2(max_factors):
    """method is too slow! -after several hours no result: up to triangle number: 63850650"""
    number_of_factors = 0
    n = 0

    while number_of_factors <= max_factors:
        n = n + 1
        number_of_factors = get_number_of_factors(
            Problem_001.sum_of_all_whole_numbers(n))

    dictionary = {}

    dictionary[Problem_001.sum_of_all_whole_numbers(n)] = return_all_factors(
        Problem_001.sum_of_all_whole_numbers(n))



def get_number_of_factors(n):
    square_root = numpy.sqrt(n)
    number_of_factors = 0
    if n % square_root == 0:
        number_of_factors = -1

    for i in range(1, int(square_root) + 1):
        if n % i == 0:
            number_of_factors += 2
    return number_of_factors



def parseSquare(input):
    square = Square()
    if input == 'DW':
        square.wordBonus = 2
    elif input == 'TW':
        square.wordBonus = 3
    elif input == 'DL':
        square.letterBonus = 2
    elif input == 'TL':
        square.letterBonus = 3
    else:
        square.tile = input

    return square



def extendRowRight(inputList):
    input = inputList[0]
    square = parseSquare(input)

    if len(inputList[1::]) > 0:
        square.nextSquare = extendRowRight(inputList[1::])
        return square



def createRowLinkedList(inputList):
    parseSquare(inputList)

    rowHead = extendRowRight(inputList)

    return rowHead



def std(y_1, y_2):
    """Calculate square root of dispersion."""
    return math.sqrt(disp(y_1, y_2))



def disp(y_1, y_2):
    """Calculate sum of differences between f[] and y[] values."""
    total = 0
    for i in range(min(len(y_1),
                       len(y_2))):
        total += (y_1[i] - y_2[i]) ** 2

    return total



def avg(vals):
    """Calculate average of values in list."""
    return sum(vals) / float(len(vals))



def Sqrt(x, e):
    if x == 0:
        return 0


def accept(self, visitor):
    return visitor.visitEquation(self)


def accept(self, visitor):
    return visitor.visitNumber(self)


def accept(self, visitor):
    return visitor.visitPlus(self)


def accept(self, visitor):
    return visitor.visitMul(self)


def accept(self, visitor):
    return visitor.visitPower(self)


def accept(self, visitor):
    return visitor.visitSquareRoot(self)


def visitEquation(self, eq):
    return "{} = {}".format(eq.left.accept(self), eq.right.accept(self))


def visitSquareRoot(self, sqrt):
    return "sqrt_n({}, {})".format(


def visitPower(self, power):
    return "pow({}, {})".format(


def visitMul(self, mul):
    return "({} * {})".format(mul.left.accept(self),


def visitPlus(self, plus):
    return "({} + {})".format(plus.left.accept(self),


def visitNumber(self, number):
    return "{}".format(number.value)


def visitEquation(self, eq):
    return


def visitSquareRoot(self, sqrt):
    return sqrt_n(sqrt.value.accept(self), sqrt.sqrtpower.accept(self))


def visitPower(self, power):
    return pow(power.value.accept(self), power.power.accept(self))


def visitMul(self, mul):
    return mul.left.accept(self) * mul.right.accept(self)


def visitPlus(self, plus):
    return plus.left.accept(self) + plus.right.accept(self)


def visitNumber(self, number):
    return int(number.value.value)



def sqrt_n(value, exponent):
    return pow(value, 1.0 / exponent)



def is_palindrom(n):
    return str(n)[::-1] == str(n)



def is_anagram(a, b):
    """
    Check if a is an anagram of b
    """
    return set(str(a)) == set(str(b))



def calc_twice_area(a, b, c, d):
    area = 0
    area += a * b
    area += a * d
    area += d * c
    area += b * c

    return area



def count_side(a, b):
    n_pt = 0

    for x in range(0, a + 1):
        for y in range(0, b + 1):
            if y * a == -b * x + a * b:
                n_pt += 1
    return n_pt


def countNodes(self, root):
    if root is None:
        return 0



def squareCypher(s):
    from math import sqrt
    s = s.replace(' ', '')

    root = sqrt(len(s))
    cols = int(root) + 1 if root % 1 else int(root)

    result = ''
    for i in range(cols):
        for j in range(cols):
            index = j * cols + i
            if index < len(s):
                result += s[index]

        result += ' '

    return result



def squareroot(a, b):
    a1 = a * a
    b1 = b * b
    c = a1 + b1
    result = math.sqrt(c)
    print("Result of square root of a %d and b %d is %c", a, b, result)
    if result.is_integer() == False:
        return 0



def get_primes(n):
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    sieve = numpy.ones(n / 3 + (n % 6 == 2), dtype=numpy.bool)
    for i in xrange(1, int(n ** 0.5) / 3 + 1):
        if sieve[i]:
            k = 3 * i + 1 | 1
            sieve[k * k / 3::2 * k] = False
            sieve[k * (k - 2 * (i & 1) + 4) / 3::2 * k] = False
    return numpy.r_[2, 3, ((3 * numpy.nonzero(sieve)[0][1:] + 1) | 1)]



def factors(num):
    """Finds all the factors of a given number and returns them as a list."""



def square_root(N, accuracy=0.000001, guess=1.0):

    while abs(N - guess ** 2) > accuracy:
        quotient = N / guess
        guess = (guess + quotient) / 2.0
    return guess



def solve():
    start = iSqrt(19293949596979899)
    start /= 10
    n = start
    while n > 0:
        if check(10 * n + 3):
            return 100 * n + 30



def check(x):
    n = x * x
    for x in pattern:
        if n % 10 != x:
            return False



def solve():
    min_root = 1010101010
    max_root = 1389026620
    for root in range(min_root, max_root + 1, 10):
        square = root * root
        if matches_template(square):
            return root



def matches_template(nr):
  nr_str = str(nr)
  return (len(nr_str) == 19 and



def game_descriptions(root):
    ''' (GameStateNode) -> list of str

    Return a list containing a str describing each complete game that is
    possible from the game stored at root.

    Assume root is the root of a game state tree specifically for the game
    Subtract Square.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_descriptions(root)
    ['p1:6 -> p2:2 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:1 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:0 = p1 wins!', 'p1:6 -> p2:5 -> p1:4 -> p2:3 -> p1:2 -> p2:1 -> p1:0 = p2 wins!']
    '''
    descriptions = []
    games = _games(root)
    for game in games:
        abbreviateds = [abbreviated(node.value) for node in game]
        description = " -> ".join(abbreviateds)
        if game[-1].value.winner("p1"):
            description += " = p1 wins!"
        elif game[-1].value.winner("p2"):
            description += " = p2 wins!"
        else:
            description += " = tie!"
        descriptions.append(description)
    return descriptions



def game_lengths(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of game lengths in the
    tree rooted at root. Each key is a length of game >= 1, and its value is
    the number of games that are that long. The length of a game is the
    number of moves in the game.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> game_lengths(root) == {6: 1, 3: 3}
    True
    '''
    result = {}
    games = _games(root)
    for game in games:
        lenght = len(game) - 1
        result[lenght] = result.get(lenght, 0) + 1
    return result



def _games(root, games=[], t=[]):
    '''(GameStateNode, games, t) -> list of list

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_games(root))
    4
    '''
    t = t + [root]
    if root.value.over:
        games = games + [t]
    for node in root.children:
        games = _games(node, games, t)
    return games



def outcome_counts(root):
    ''' (GameStateNode) -> [int, int, int]

    Return a list containing the number of leaf nodes containing a state in
    which player 'p1' is the winner, the number in which player 'p2' is, and
    the number in which the outcome of the game is a tie.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> outcome_counts(root)
    [3, 1, 0]
    '''
    leafs = _leafs(root)
    p1 = p2 = tie = 0
    for leaf in leafs:
        if leaf.value.winner("p1"):
            p1 += 1
        elif leaf.value.winner("p2"):
            p2 += 1
        else:
            tie += 1
    return [p1, p2, tie]



def branching_stats(root):
    ''' (GameStateNode) -> {int: int}

    Return a dict that represents the distribution of branching factors in
    the tree rooted at root. Each key is a branching factor >= 0, and its
    value is the number of nodes with that branching factor.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> branching_stats(root) == {0: 4, 1: 6, 2: 3}
    True
    '''
    result = {}
    nodes = _nodes(root)
    for i in range(len(nodes)):
        count = 0
        for node in nodes:
            if len(node.children) == i:
                count += 1
        if count > 0:
            result[i] = count
    return result



def distinct_leaf_count(root):
    '''
    (GameStateNode) -> int

    Return the number of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_leaf_count(root)
    2
    '''
    return len(_distinct_leafs(root))



def _distinct_leafs(root):
    '''(GameStateNode) -> set

    Return the set of leaves representing distinct game states in the
    tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_leafs(root))
    2
    '''
    leafs = set()
    if root.value.over:
        leafs.add(str(root))
    for node in root.children:
        leafs |= _distinct_leafs(node)
    return leafs



def distinct_node_count(root):
    '''(GameStateNode) -> int

    Return the number of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> distinct_node_count(root)
    10
    '''
    return len(_distinct_nodes(root))



def _distinct_nodes(root):
    '''(GameStateNode) -> set

    Return the set of nodes representing distinct game states in the
    tree rooted at root.  Two game states are distinct if they are not __eq__.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_distinct_nodes(root))
    10
    '''
    nodes = set()
    nodes.add(str(root))
    for node in root.children:
        nodes |= _distinct_nodes(node)
    return nodes



def leaf_count(root):
    '''(GameStateNode) -> int

    Return the number of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> leaf_count(root)
    4
    '''
    return len(_leafs(root))



def _leafs(root):
    '''(GameStateNode) -> list

    Return the list of leaves in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_leafs(root))
    4
    '''
    leafs = []
    if root.value.over:
        leafs.append(root)
    for node in root.children:
        leafs += _leafs(node)
    return leafs



def node_count(root):
    ''' (GameStateNode) -> int

    Return the number of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> node_count(root)
    13
    '''
    return len(_nodes(root))



def _nodes(root):
    ''' (GameStateNode) -> list

    Return the list of nodes in the tree rooted at root.

    >>> s = SubtractSquareState('p1', current_total = 6)
    >>> root = GameStateNode(s)
    >>> root.grow()
    >>> len(_nodes(root))
    13
    '''
    nodes = [root]
    for node in root.children:
        nodes += _nodes(node)
    return nodes


def __str__(self):
    ''' (GameStateNode) -> str

    Return a convenient string representation of GameStateNode(self).

    >>> s = SubtractSquareState('p1', current_total = 17)
    >>> node = GameStateNode(s)
    >>> print(node)
    Current total: 17; next player: p1
    '''
    return self.value.__str__()



def SquareHelper(n, x):
    if n == 0:
        return 0



def Square(x):
    return SquareHelper(abs(x), abs(x))


def update_chessboard(self, data):
    data = data[::-1]
    in_table = 'prnbqkx-RNBQKPX'
    out_table = 'prnbqkx tmvwloX'
    tran_table = maketrans(in_table, out_table)
    pieces = converted_data = list(data.translate(tran_table, ' <12>'))
    col = False, True
    colour_square = ((col[0], col[1]) * 4 + (col[1], col[0]) * 4) * 4
    file_board = [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 4),
                  ('f', 5), ('g', 6), ('h', 7), ]
    rank_board = [('8', 7), ('7', 6), ('6', 5), ('5', 4), ('4', 3), ('3', 2),
                  ('2', 1), ('1', 0), ]
    pieces = ''
    for x, y in zip(colour_square, converted_data):
        if x and y != chr(32):
            pieces = pieces + (y.upper())
        elif x and y == chr(32):
            pieces = pieces + ('+')
        else:
            pieces = pieces + y

    square = list(
        [(7 * self.square_size - x[1] * self.square_size,
          y[1] * self.square_size,
          x[0] + y[0],
          pieces[(y[1] * 8) + x[1]],)
         for y in rank_board for x in file_board]
    )
    self.chessboard.delete(ALL)
    for x in square:
        self.output = self.chessboard.create_text(x[0] + self.square_size / 2,
                                                  x[1] +
                                                  self.square_size / 2,
                                                  fill='black', font=('Chess Cases',
                                                                      self.font_size,
                                                                      'normal'))
        self.chessboard.itemconfig(self.output, text=x[3])
    self.chessboard.update_idletasks()
    return



def sqrt(square):
    print '** taking square root of {:.2f}'.format(square)
    return math.sqrt(square)



def sum_(*args):
    return sum(args)



def square(x):
    return x ** 2



def square_root(a):
    a = float(a)
    x = a / 2
    while True:
        y = (x + a / x) / 2
        if x == y:
            break
        x = y
    return x



def squareroot(number):
    estimate = number / 2
    epsilon = 0.000000000001

    while True:

        root = 0.5 * (estimate + number / estimate)
        if abs(root - estimate) < epsilon:
            return root



def extended_euclid(a, b):
    """Returns (s, t) where as + bt = gcd(a, b)"""
    if b == 0:
        return (1, 0)



def euclid(a, b):
    if b == 0:
        return a



def ask_for_number():
    """Asks user for a positive number"""
    number = 0
    while True:
        if number > 0:
            return number



def square_root(N):
    guess = 1.0
    while abs(N - guess ** 2) > 0.000000000000001:
        quotient = N / guess
        guess = (guess + quotient) / 2.0
    return guess



def get_roots(a, b, c, discr):
    """
    Main solver

    >>> get_roots(1, -4, 4, 0)
    [2, 2]
    >>> get_roots(50, -225, 253, 25)
    [2, 2]

    :type a int
    :type b int
    :type c int
    :type discr int
    """
    doub_a = a << 1
    sqrt_discr = bisect(discr)
    t1 = - b - sqrt_discr
    t2 = - b + sqrt_discr
    root_l = t1 / doub_a
    root_r = t2 / doub_a

    roots = rounding_correction(
        lambda x: a * x ** 2 + b * x + c, [root_l, root_r])
    return roots


def error(x):
    return abs(func(x))



def bisect(square, left_end=0, right_end=None):
    """
    Square root realisation using bisection method.
    Usage:
    bisect(square, left_end, right_end)
    where square - number from which root is extracted,
    and left_end, right_end are the ends of segment where we're looking for root, optional parameters

    >>> bisect(18)
    4
    >>> bisect(9)
    3
    >>> bisect(100, 0, 50)
    10

    :type square int
    :type left_end int
    :type right_end int
    """

    if square < 0:
        raise ValueError('Cannot extract root of negative number')
    if right_end is None:
        right_end = square
    if right_end - left_end <= 1:
        return rounding_correction(lambda x: x * x - square, [right_end])



def r8_sqrt_i4(i):

    from math import sqrt

    value = sqrt(float(i))

    return value



def wait_5_secs(params):
    time.sleep(5)
    return {"value": 1}



def one_plus_inverse(params):
    if params["n"] == 0:
        return {"value": None}



def root_fun(params):
    """
    Find the root of the scalar input
    """
    return {"value": math.sqrt(params["n"])}



def square_fun(params):
    """
    Square the scalar input
    """
    return {"value": params["n"] ** 2}
